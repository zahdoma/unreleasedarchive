#!/usr/bin/env node
import require$$0$3 from "node:events";

import require$$1$1, { spawn } from "node:child_process";

import require$$2$1 from "node:path";

import require$$3 from "node:fs";

import process$2 from "node:process";

import path, { join, dirname, resolve, relative } from "path";

import fs, { rmSync, readdirSync, statSync } from "fs";

import Stream$1 from "stream";

import require$$2$2, { homedir } from "os";

import os from "node:os";

import * as childProcess from "child_process";

import { execSync, spawn as spawn$1 } from "child_process";

import tty from "node:tty";

import require$$0$4, { Buffer as Buffer$1 } from "buffer";

import * as nc from "node:crypto";

import require$$0$6 from "util";

import http from "http";

import https from "https";

import crypto$1 from "crypto";

import Url from "url";

import zlib from "zlib";

import require$$0$5 from "events";

import require$$3$1 from "net";

import require$$4 from "tls";

import "node:url";

import * as readline$1 from "node:readline";

import { AsyncLocalStorage, AsyncResource } from "node:async_hooks";

import require$$0$7 from "tty";

const MIN_NODE_VERSION = "22.0.0";

function checkVersion(currentVersion, requiredVersion) {
    const [major, minor] = currentVersion.split(".").map(Number), [reqMajor, reqMinor] = requiredVersion.split(".").map(Number);
    return major > reqMajor || major === reqMajor && minor >= reqMinor;
}

function assertRuntimeVersion() {
    "undefined" != typeof Bun || checkVersion(process.versions.node, MIN_NODE_VERSION) || (console.error(`This tool requires Node.js v${MIN_NODE_VERSION} or higher.`, `You are using v${process.versions.node}.`), 
    process.exit(1));
}

var commonjsGlobal = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};

function getDefaultExportFromCjs(x) {
    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x.default : x;
}

function getAugmentedNamespace(n) {
    if (n.__esModule) return n;
    var f = n.default;
    if ("function" == typeof f) {
        var a = function a() {
            return this instanceof a ? Reflect.construct(f, arguments, this.constructor) : f.apply(this, arguments);
        };
        a.prototype = f.prototype;
    } else a = {};
    return Object.defineProperty(a, "__esModule", {
        value: !0
    }), Object.keys(n).forEach((function(k) {
        var d = Object.getOwnPropertyDescriptor(n, k);
        Object.defineProperty(a, k, d.get ? d : {
            enumerable: !0,
            get: function() {
                return n[k];
            }
        });
    })), a;
}

var picocolors$1 = {
    exports: {}
}, hasRequiredPicocolors;

function requirePicocolors() {
    if (hasRequiredPicocolors) return picocolors$1.exports;
    hasRequiredPicocolors = 1;
    let p = process || {}, argv = p.argv || [], env = p.env || {}, isColorSupported = !(env.NO_COLOR || argv.includes("--no-color")) && (!!env.FORCE_COLOR || argv.includes("--color") || "win32" === p.platform || (p.stdout || {}).isTTY && "dumb" !== env.TERM || !!env.CI), formatter = (open, close, replace = open) => input => {
        let string = "" + input, index = string.indexOf(close, open.length);
        return ~index ? open + replaceClose(string, close, replace, index) + close : open + string + close;
    }, replaceClose = (string, close, replace, index) => {
        let result = "", cursor = 0;
        do {
            result += string.substring(cursor, index) + replace, cursor = index + close.length, 
            index = string.indexOf(close, cursor);
        } while (~index);
        return result + string.substring(cursor);
    }, createColors = (enabled = isColorSupported) => {
        let f = enabled ? formatter : () => String;
        return {
            isColorSupported: enabled,
            reset: f("[0m", "[0m"),
            bold: f("[1m", "[22m", "[22m[1m"),
            dim: f("[2m", "[22m", "[22m[2m"),
            italic: f("[3m", "[23m"),
            underline: f("[4m", "[24m"),
            inverse: f("[7m", "[27m"),
            hidden: f("[8m", "[28m"),
            strikethrough: f("[9m", "[29m"),
            black: f("[30m", "[39m"),
            red: f("[31m", "[39m"),
            green: f("[32m", "[39m"),
            yellow: f("[33m", "[39m"),
            blue: f("[34m", "[39m"),
            magenta: f("[35m", "[39m"),
            cyan: f("[36m", "[39m"),
            white: f("[37m", "[39m"),
            gray: f("[90m", "[39m"),
            bgBlack: f("[40m", "[49m"),
            bgRed: f("[41m", "[49m"),
            bgGreen: f("[42m", "[49m"),
            bgYellow: f("[43m", "[49m"),
            bgBlue: f("[44m", "[49m"),
            bgMagenta: f("[45m", "[49m"),
            bgCyan: f("[46m", "[49m"),
            bgWhite: f("[47m", "[49m"),
            blackBright: f("[90m", "[39m"),
            redBright: f("[91m", "[39m"),
            greenBright: f("[92m", "[39m"),
            yellowBright: f("[93m", "[39m"),
            blueBright: f("[94m", "[39m"),
            magentaBright: f("[95m", "[39m"),
            cyanBright: f("[96m", "[39m"),
            whiteBright: f("[97m", "[39m"),
            bgBlackBright: f("[100m", "[49m"),
            bgRedBright: f("[101m", "[49m"),
            bgGreenBright: f("[102m", "[49m"),
            bgYellowBright: f("[103m", "[49m"),
            bgBlueBright: f("[104m", "[49m"),
            bgMagentaBright: f("[105m", "[49m"),
            bgCyanBright: f("[106m", "[49m"),
            bgWhiteBright: f("[107m", "[49m")
        };
    };
    return picocolors$1.exports = createColors(), picocolors$1.exports.createColors = createColors, 
    picocolors$1.exports;
}

var picocolorsExports = requirePicocolors(), picocolors = getDefaultExportFromCjs(picocolorsExports);

function titleMessage(msg) {
    console.log(picocolors.inverse(` ${msg} `));
}

function warnMessage(msg, highlight = !1) {
    console.log(picocolors.yellow(msg));
}

function cancelMessage(msg = "Operation canceled") {
    console.log(msg), process.exit();
}

function warningOutro(msg = "Operation canceled") {
    warnMessage(msg), process.exit();
}

function successOutro(msg = "Operation successful") {
    console.log(picocolors.bgGreen(` ${msg} `), "\n"), process.exit(0);
}

function errorOutro(msg, title = null) {
    title ? (console.log(picocolors.bgRed(` ${title} `)), console.log(msg, "\n")) : console.log(picocolors.bgRed(` ${msg} `), "\n"), 
    process.exit(1);
}

function errorMessage(err, title = "An error occurred") {
    let message = "Unknown error";
    "string" == typeof err ? message = err : err instanceof Error && (message = err.message), 
    errorOutro(message, title);
}

var extraTypings = {
    exports: {}
}, commander = {}, argument = {}, error$1 = {}, hasRequiredError, hasRequiredArgument;

function requireError() {
    if (hasRequiredError) return error$1;
    hasRequiredError = 1;
    class CommanderError extends Error {
        constructor(exitCode, code, message) {
            super(message), Error.captureStackTrace(this, this.constructor), this.name = this.constructor.name, 
            this.code = code, this.exitCode = exitCode, this.nestedError = void 0;
        }
    }
    return error$1.CommanderError = CommanderError, error$1.InvalidArgumentError = class extends CommanderError {
        constructor(message) {
            super(1, "commander.invalidArgument", message), Error.captureStackTrace(this, this.constructor), 
            this.name = this.constructor.name;
        }
    }, error$1;
}

function requireArgument() {
    if (hasRequiredArgument) return argument;
    hasRequiredArgument = 1;
    const {InvalidArgumentError: InvalidArgumentError} = requireError();
    return argument.Argument = class {
        constructor(name, description) {
            switch (this.description = description || "", this.variadic = !1, this.parseArg = void 0, 
            this.defaultValue = void 0, this.defaultValueDescription = void 0, this.argChoices = void 0, 
            name[0]) {
              case "<":
                this.required = !0, this._name = name.slice(1, -1);
                break;

              case "[":
                this.required = !1, this._name = name.slice(1, -1);
                break;

              default:
                this.required = !0, this._name = name;
            }
            this._name.length > 3 && "..." === this._name.slice(-3) && (this.variadic = !0, 
            this._name = this._name.slice(0, -3));
        }
        name() {
            return this._name;
        }
        _concatValue(value, previous) {
            return previous !== this.defaultValue && Array.isArray(previous) ? previous.concat(value) : [ value ];
        }
        default(value, description) {
            return this.defaultValue = value, this.defaultValueDescription = description, this;
        }
        argParser(fn) {
            return this.parseArg = fn, this;
        }
        choices(values) {
            return this.argChoices = values.slice(), this.parseArg = (arg, previous) => {
                if (!this.argChoices.includes(arg)) throw new InvalidArgumentError(`Allowed choices are ${this.argChoices.join(", ")}.`);
                return this.variadic ? this._concatValue(arg, previous) : arg;
            }, this;
        }
        argRequired() {
            return this.required = !0, this;
        }
        argOptional() {
            return this.required = !1, this;
        }
    }, argument.humanReadableArgName = function(arg) {
        const nameOutput = arg.name() + (!0 === arg.variadic ? "..." : "");
        return arg.required ? "<" + nameOutput + ">" : "[" + nameOutput + "]";
    }, argument;
}

var command$1 = {}, help = {}, hasRequiredHelp;

function requireHelp() {
    if (hasRequiredHelp) return help;
    hasRequiredHelp = 1;
    const {humanReadableArgName: humanReadableArgName} = requireArgument();
    return help.Help = class {
        constructor() {
            this.helpWidth = void 0, this.sortSubcommands = !1, this.sortOptions = !1, this.showGlobalOptions = !1;
        }
        visibleCommands(cmd) {
            const visibleCommands = cmd.commands.filter((cmd => !cmd._hidden)), helpCommand = cmd._getHelpCommand();
            return helpCommand && !helpCommand._hidden && visibleCommands.push(helpCommand), 
            this.sortSubcommands && visibleCommands.sort(((a, b) => a.name().localeCompare(b.name()))), 
            visibleCommands;
        }
        compareOptions(a, b) {
            const getSortKey = option => option.short ? option.short.replace(/^-/, "") : option.long.replace(/^--/, "");
            return getSortKey(a).localeCompare(getSortKey(b));
        }
        visibleOptions(cmd) {
            const visibleOptions = cmd.options.filter((option => !option.hidden)), helpOption = cmd._getHelpOption();
            if (helpOption && !helpOption.hidden) {
                const removeShort = helpOption.short && cmd._findOption(helpOption.short), removeLong = helpOption.long && cmd._findOption(helpOption.long);
                removeShort || removeLong ? helpOption.long && !removeLong ? visibleOptions.push(cmd.createOption(helpOption.long, helpOption.description)) : helpOption.short && !removeShort && visibleOptions.push(cmd.createOption(helpOption.short, helpOption.description)) : visibleOptions.push(helpOption);
            }
            return this.sortOptions && visibleOptions.sort(this.compareOptions), visibleOptions;
        }
        visibleGlobalOptions(cmd) {
            if (!this.showGlobalOptions) return [];
            const globalOptions = [];
            for (let ancestorCmd = cmd.parent; ancestorCmd; ancestorCmd = ancestorCmd.parent) {
                const visibleOptions = ancestorCmd.options.filter((option => !option.hidden));
                globalOptions.push(...visibleOptions);
            }
            return this.sortOptions && globalOptions.sort(this.compareOptions), globalOptions;
        }
        visibleArguments(cmd) {
            return cmd._argsDescription && cmd.registeredArguments.forEach((argument => {
                argument.description = argument.description || cmd._argsDescription[argument.name()] || "";
            })), cmd.registeredArguments.find((argument => argument.description)) ? cmd.registeredArguments : [];
        }
        subcommandTerm(cmd) {
            const args = cmd.registeredArguments.map((arg => humanReadableArgName(arg))).join(" ");
            return cmd._name + (cmd._aliases[0] ? "|" + cmd._aliases[0] : "") + (cmd.options.length ? " [options]" : "") + (args ? " " + args : "");
        }
        optionTerm(option) {
            return option.flags;
        }
        argumentTerm(argument) {
            return argument.name();
        }
        longestSubcommandTermLength(cmd, helper) {
            return helper.visibleCommands(cmd).reduce(((max, command) => Math.max(max, helper.subcommandTerm(command).length)), 0);
        }
        longestOptionTermLength(cmd, helper) {
            return helper.visibleOptions(cmd).reduce(((max, option) => Math.max(max, helper.optionTerm(option).length)), 0);
        }
        longestGlobalOptionTermLength(cmd, helper) {
            return helper.visibleGlobalOptions(cmd).reduce(((max, option) => Math.max(max, helper.optionTerm(option).length)), 0);
        }
        longestArgumentTermLength(cmd, helper) {
            return helper.visibleArguments(cmd).reduce(((max, argument) => Math.max(max, helper.argumentTerm(argument).length)), 0);
        }
        commandUsage(cmd) {
            let cmdName = cmd._name;
            cmd._aliases[0] && (cmdName = cmdName + "|" + cmd._aliases[0]);
            let ancestorCmdNames = "";
            for (let ancestorCmd = cmd.parent; ancestorCmd; ancestorCmd = ancestorCmd.parent) ancestorCmdNames = ancestorCmd.name() + " " + ancestorCmdNames;
            return ancestorCmdNames + cmdName + " " + cmd.usage();
        }
        commandDescription(cmd) {
            return cmd.description();
        }
        subcommandDescription(cmd) {
            return cmd.summary() || cmd.description();
        }
        optionDescription(option) {
            const extraInfo = [];
            if (option.argChoices && extraInfo.push(`choices: ${option.argChoices.map((choice => JSON.stringify(choice))).join(", ")}`), 
            void 0 !== option.defaultValue) {
                (option.required || option.optional || option.isBoolean() && "boolean" == typeof option.defaultValue) && extraInfo.push(`default: ${option.defaultValueDescription || JSON.stringify(option.defaultValue)}`);
            }
            return void 0 !== option.presetArg && option.optional && extraInfo.push(`preset: ${JSON.stringify(option.presetArg)}`), 
            void 0 !== option.envVar && extraInfo.push(`env: ${option.envVar}`), extraInfo.length > 0 ? `${option.description} (${extraInfo.join(", ")})` : option.description;
        }
        argumentDescription(argument) {
            const extraInfo = [];
            if (argument.argChoices && extraInfo.push(`choices: ${argument.argChoices.map((choice => JSON.stringify(choice))).join(", ")}`), 
            void 0 !== argument.defaultValue && extraInfo.push(`default: ${argument.defaultValueDescription || JSON.stringify(argument.defaultValue)}`), 
            extraInfo.length > 0) {
                const extraDescripton = `(${extraInfo.join(", ")})`;
                return argument.description ? `${argument.description} ${extraDescripton}` : extraDescripton;
            }
            return argument.description;
        }
        formatHelp(cmd, helper) {
            const termWidth = helper.padWidth(cmd, helper), helpWidth = helper.helpWidth || 80;
            function formatItem(term, description) {
                if (description) {
                    const fullText = `${term.padEnd(termWidth + 2)}${description}`;
                    return helper.wrap(fullText, helpWidth - 2, termWidth + 2);
                }
                return term;
            }
            function formatList(textArray) {
                return textArray.join("\n").replace(/^/gm, " ".repeat(2));
            }
            let output = [ `Usage: ${helper.commandUsage(cmd)}`, "" ];
            const commandDescription = helper.commandDescription(cmd);
            commandDescription.length > 0 && (output = output.concat([ helper.wrap(commandDescription, helpWidth, 0), "" ]));
            const argumentList = helper.visibleArguments(cmd).map((argument => formatItem(helper.argumentTerm(argument), helper.argumentDescription(argument))));
            argumentList.length > 0 && (output = output.concat([ "Arguments:", formatList(argumentList), "" ]));
            const optionList = helper.visibleOptions(cmd).map((option => formatItem(helper.optionTerm(option), helper.optionDescription(option))));
            if (optionList.length > 0 && (output = output.concat([ "Options:", formatList(optionList), "" ])), 
            this.showGlobalOptions) {
                const globalOptionList = helper.visibleGlobalOptions(cmd).map((option => formatItem(helper.optionTerm(option), helper.optionDescription(option))));
                globalOptionList.length > 0 && (output = output.concat([ "Global Options:", formatList(globalOptionList), "" ]));
            }
            const commandList = helper.visibleCommands(cmd).map((cmd => formatItem(helper.subcommandTerm(cmd), helper.subcommandDescription(cmd))));
            return commandList.length > 0 && (output = output.concat([ "Commands:", formatList(commandList), "" ])), 
            output.join("\n");
        }
        padWidth(cmd, helper) {
            return Math.max(helper.longestOptionTermLength(cmd, helper), helper.longestGlobalOptionTermLength(cmd, helper), helper.longestSubcommandTermLength(cmd, helper), helper.longestArgumentTermLength(cmd, helper));
        }
        wrap(str, width, indent, minColumnWidth = 40) {
            const manualIndent = new RegExp("[\\n][ \\f\\t\\v   -   　\ufeff]+");
            if (str.match(manualIndent)) return str;
            const columnWidth = width - indent;
            if (columnWidth < minColumnWidth) return str;
            const leadingStr = str.slice(0, indent), columnText = str.slice(indent).replace("\r\n", "\n"), indentString = " ".repeat(indent), regex = new RegExp(`\n|.{1,${columnWidth - 1}}([\\s​]|$)|[^\\s​]+?([\\s​]|$)`, "g");
            return leadingStr + (columnText.match(regex) || []).map(((line, i) => "\n" === line ? "" : (i > 0 ? indentString : "") + line.trimEnd())).join("\n");
        }
    }, help;
}

var option = {}, hasRequiredOption;

function requireOption() {
    if (hasRequiredOption) return option;
    hasRequiredOption = 1;
    const {InvalidArgumentError: InvalidArgumentError} = requireError();
    return option.Option = class {
        constructor(flags, description) {
            this.flags = flags, this.description = description || "", this.required = flags.includes("<"), 
            this.optional = flags.includes("["), this.variadic = /\w\.\.\.[>\]]$/.test(flags), 
            this.mandatory = !1;
            const optionFlags = function(flags) {
                let shortFlag, longFlag;
                const flagParts = flags.split(/[ |,]+/);
                flagParts.length > 1 && !/^[[<]/.test(flagParts[1]) && (shortFlag = flagParts.shift());
                longFlag = flagParts.shift(), !shortFlag && /^-[^-]$/.test(longFlag) && (shortFlag = longFlag, 
                longFlag = void 0);
                return {
                    shortFlag: shortFlag,
                    longFlag: longFlag
                };
            }(flags);
            this.short = optionFlags.shortFlag, this.long = optionFlags.longFlag, this.negate = !1, 
            this.long && (this.negate = this.long.startsWith("--no-")), this.defaultValue = void 0, 
            this.defaultValueDescription = void 0, this.presetArg = void 0, this.envVar = void 0, 
            this.parseArg = void 0, this.hidden = !1, this.argChoices = void 0, this.conflictsWith = [], 
            this.implied = void 0;
        }
        default(value, description) {
            return this.defaultValue = value, this.defaultValueDescription = description, this;
        }
        preset(arg) {
            return this.presetArg = arg, this;
        }
        conflicts(names) {
            return this.conflictsWith = this.conflictsWith.concat(names), this;
        }
        implies(impliedOptionValues) {
            let newImplied = impliedOptionValues;
            return "string" == typeof impliedOptionValues && (newImplied = {
                [impliedOptionValues]: !0
            }), this.implied = Object.assign(this.implied || {}, newImplied), this;
        }
        env(name) {
            return this.envVar = name, this;
        }
        argParser(fn) {
            return this.parseArg = fn, this;
        }
        makeOptionMandatory(mandatory = !0) {
            return this.mandatory = !!mandatory, this;
        }
        hideHelp(hide = !0) {
            return this.hidden = !!hide, this;
        }
        _concatValue(value, previous) {
            return previous !== this.defaultValue && Array.isArray(previous) ? previous.concat(value) : [ value ];
        }
        choices(values) {
            return this.argChoices = values.slice(), this.parseArg = (arg, previous) => {
                if (!this.argChoices.includes(arg)) throw new InvalidArgumentError(`Allowed choices are ${this.argChoices.join(", ")}.`);
                return this.variadic ? this._concatValue(arg, previous) : arg;
            }, this;
        }
        name() {
            return this.long ? this.long.replace(/^--/, "") : this.short.replace(/^-/, "");
        }
        attributeName() {
            return this.name().replace(/^no-/, "").split("-").reduce(((str, word) => str + word[0].toUpperCase() + word.slice(1)));
        }
        is(arg) {
            return this.short === arg || this.long === arg;
        }
        isBoolean() {
            return !this.required && !this.optional && !this.negate;
        }
    }, option.DualOptions = class {
        constructor(options) {
            this.positiveOptions = new Map, this.negativeOptions = new Map, this.dualOptions = new Set, 
            options.forEach((option => {
                option.negate ? this.negativeOptions.set(option.attributeName(), option) : this.positiveOptions.set(option.attributeName(), option);
            })), this.negativeOptions.forEach(((value, key) => {
                this.positiveOptions.has(key) && this.dualOptions.add(key);
            }));
        }
        valueFromOption(value, option) {
            const optionKey = option.attributeName();
            if (!this.dualOptions.has(optionKey)) return !0;
            const preset = this.negativeOptions.get(optionKey).presetArg, negativeValue = void 0 !== preset && preset;
            return option.negate === (negativeValue === value);
        }
    }, option;
}

var suggestSimilar = {}, hasRequiredSuggestSimilar, hasRequiredCommand, hasRequiredCommander, hasRequiredExtraTypings;

function requireSuggestSimilar() {
    if (hasRequiredSuggestSimilar) return suggestSimilar;
    hasRequiredSuggestSimilar = 1;
    return suggestSimilar.suggestSimilar = function(word, candidates) {
        if (!candidates || 0 === candidates.length) return "";
        candidates = Array.from(new Set(candidates));
        const searchingOptions = word.startsWith("--");
        searchingOptions && (word = word.slice(2), candidates = candidates.map((candidate => candidate.slice(2))));
        let similar = [], bestDistance = 3;
        return candidates.forEach((candidate => {
            if (candidate.length <= 1) return;
            const distance = function(a, b) {
                if (Math.abs(a.length - b.length) > 3) return Math.max(a.length, b.length);
                const d = [];
                for (let i = 0; i <= a.length; i++) d[i] = [ i ];
                for (let j = 0; j <= b.length; j++) d[0][j] = j;
                for (let j = 1; j <= b.length; j++) for (let i = 1; i <= a.length; i++) {
                    let cost = 1;
                    cost = a[i - 1] === b[j - 1] ? 0 : 1, d[i][j] = Math.min(d[i - 1][j] + 1, d[i][j - 1] + 1, d[i - 1][j - 1] + cost), 
                    i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1] && (d[i][j] = Math.min(d[i][j], d[i - 2][j - 2] + 1));
                }
                return d[a.length][b.length];
            }(word, candidate), length = Math.max(word.length, candidate.length);
            (length - distance) / length > .4 && (distance < bestDistance ? (bestDistance = distance, 
            similar = [ candidate ]) : distance === bestDistance && similar.push(candidate));
        })), similar.sort(((a, b) => a.localeCompare(b))), searchingOptions && (similar = similar.map((candidate => `--${candidate}`))), 
        similar.length > 1 ? `\n(Did you mean one of ${similar.join(", ")}?)` : 1 === similar.length ? `\n(Did you mean ${similar[0]}?)` : "";
    }, suggestSimilar;
}

function requireCommand() {
    if (hasRequiredCommand) return command$1;
    hasRequiredCommand = 1;
    const EventEmitter = require$$0$3.EventEmitter, childProcess = require$$1$1, path = require$$2$1, fs = require$$3, process = process$2, {Argument: Argument, humanReadableArgName: humanReadableArgName} = requireArgument(), {CommanderError: CommanderError} = requireError(), {Help: Help} = requireHelp(), {Option: Option, DualOptions: DualOptions} = requireOption(), {suggestSimilar: suggestSimilar} = requireSuggestSimilar();
    class Command extends EventEmitter {
        constructor(name) {
            super(), this.commands = [], this.options = [], this.parent = null, this._allowUnknownOption = !1, 
            this._allowExcessArguments = !0, this.registeredArguments = [], this._args = this.registeredArguments, 
            this.args = [], this.rawArgs = [], this.processedArgs = [], this._scriptPath = null, 
            this._name = name || "", this._optionValues = {}, this._optionValueSources = {}, 
            this._storeOptionsAsProperties = !1, this._actionHandler = null, this._executableHandler = !1, 
            this._executableFile = null, this._executableDir = null, this._defaultCommandName = null, 
            this._exitCallback = null, this._aliases = [], this._combineFlagAndOptionalValue = !0, 
            this._description = "", this._summary = "", this._argsDescription = void 0, this._enablePositionalOptions = !1, 
            this._passThroughOptions = !1, this._lifeCycleHooks = {}, this._showHelpAfterError = !1, 
            this._showSuggestionAfterError = !0, this._outputConfiguration = {
                writeOut: str => process.stdout.write(str),
                writeErr: str => process.stderr.write(str),
                getOutHelpWidth: () => process.stdout.isTTY ? process.stdout.columns : void 0,
                getErrHelpWidth: () => process.stderr.isTTY ? process.stderr.columns : void 0,
                outputError: (str, write) => write(str)
            }, this._hidden = !1, this._helpOption = void 0, this._addImplicitHelpCommand = void 0, 
            this._helpCommand = void 0, this._helpConfiguration = {};
        }
        copyInheritedSettings(sourceCommand) {
            return this._outputConfiguration = sourceCommand._outputConfiguration, this._helpOption = sourceCommand._helpOption, 
            this._helpCommand = sourceCommand._helpCommand, this._helpConfiguration = sourceCommand._helpConfiguration, 
            this._exitCallback = sourceCommand._exitCallback, this._storeOptionsAsProperties = sourceCommand._storeOptionsAsProperties, 
            this._combineFlagAndOptionalValue = sourceCommand._combineFlagAndOptionalValue, 
            this._allowExcessArguments = sourceCommand._allowExcessArguments, this._enablePositionalOptions = sourceCommand._enablePositionalOptions, 
            this._showHelpAfterError = sourceCommand._showHelpAfterError, this._showSuggestionAfterError = sourceCommand._showSuggestionAfterError, 
            this;
        }
        _getCommandAndAncestors() {
            const result = [];
            for (let command = this; command; command = command.parent) result.push(command);
            return result;
        }
        command(nameAndArgs, actionOptsOrExecDesc, execOpts) {
            let desc = actionOptsOrExecDesc, opts = execOpts;
            "object" == typeof desc && null !== desc && (opts = desc, desc = null), opts = opts || {};
            const [, name, args] = nameAndArgs.match(/([^ ]+) *(.*)/), cmd = this.createCommand(name);
            return desc && (cmd.description(desc), cmd._executableHandler = !0), opts.isDefault && (this._defaultCommandName = cmd._name), 
            cmd._hidden = !(!opts.noHelp && !opts.hidden), cmd._executableFile = opts.executableFile || null, 
            args && cmd.arguments(args), this._registerCommand(cmd), cmd.parent = this, cmd.copyInheritedSettings(this), 
            desc ? this : cmd;
        }
        createCommand(name) {
            return new Command(name);
        }
        createHelp() {
            return Object.assign(new Help, this.configureHelp());
        }
        configureHelp(configuration) {
            return void 0 === configuration ? this._helpConfiguration : (this._helpConfiguration = configuration, 
            this);
        }
        configureOutput(configuration) {
            return void 0 === configuration ? this._outputConfiguration : (Object.assign(this._outputConfiguration, configuration), 
            this);
        }
        showHelpAfterError(displayHelp = !0) {
            return "string" != typeof displayHelp && (displayHelp = !!displayHelp), this._showHelpAfterError = displayHelp, 
            this;
        }
        showSuggestionAfterError(displaySuggestion = !0) {
            return this._showSuggestionAfterError = !!displaySuggestion, this;
        }
        addCommand(cmd, opts) {
            if (!cmd._name) throw new Error("Command passed to .addCommand() must have a name\n- specify the name in Command constructor or using .name()");
            return (opts = opts || {}).isDefault && (this._defaultCommandName = cmd._name), 
            (opts.noHelp || opts.hidden) && (cmd._hidden = !0), this._registerCommand(cmd), 
            cmd.parent = this, cmd._checkForBrokenPassThrough(), this;
        }
        createArgument(name, description) {
            return new Argument(name, description);
        }
        argument(name, description, fn, defaultValue) {
            const argument = this.createArgument(name, description);
            return "function" == typeof fn ? argument.default(defaultValue).argParser(fn) : argument.default(fn), 
            this.addArgument(argument), this;
        }
        arguments(names) {
            return names.trim().split(/ +/).forEach((detail => {
                this.argument(detail);
            })), this;
        }
        addArgument(argument) {
            const previousArgument = this.registeredArguments.slice(-1)[0];
            if (previousArgument && previousArgument.variadic) throw new Error(`only the last argument can be variadic '${previousArgument.name()}'`);
            if (argument.required && void 0 !== argument.defaultValue && void 0 === argument.parseArg) throw new Error(`a default value for a required argument is never used: '${argument.name()}'`);
            return this.registeredArguments.push(argument), this;
        }
        helpCommand(enableOrNameAndArgs, description) {
            if ("boolean" == typeof enableOrNameAndArgs) return this._addImplicitHelpCommand = enableOrNameAndArgs, 
            this;
            enableOrNameAndArgs = enableOrNameAndArgs ?? "help [command]";
            const [, helpName, helpArgs] = enableOrNameAndArgs.match(/([^ ]+) *(.*)/), helpDescription = description ?? "display help for command", helpCommand = this.createCommand(helpName);
            return helpCommand.helpOption(!1), helpArgs && helpCommand.arguments(helpArgs), 
            helpDescription && helpCommand.description(helpDescription), this._addImplicitHelpCommand = !0, 
            this._helpCommand = helpCommand, this;
        }
        addHelpCommand(helpCommand, deprecatedDescription) {
            return "object" != typeof helpCommand ? (this.helpCommand(helpCommand, deprecatedDescription), 
            this) : (this._addImplicitHelpCommand = !0, this._helpCommand = helpCommand, this);
        }
        _getHelpCommand() {
            return this._addImplicitHelpCommand ?? (this.commands.length && !this._actionHandler && !this._findCommand("help")) ? (void 0 === this._helpCommand && this.helpCommand(void 0, void 0), 
            this._helpCommand) : null;
        }
        hook(event, listener) {
            const allowedValues = [ "preSubcommand", "preAction", "postAction" ];
            if (!allowedValues.includes(event)) throw new Error(`Unexpected value for event passed to hook : '${event}'.\nExpecting one of '${allowedValues.join("', '")}'`);
            return this._lifeCycleHooks[event] ? this._lifeCycleHooks[event].push(listener) : this._lifeCycleHooks[event] = [ listener ], 
            this;
        }
        exitOverride(fn) {
            return this._exitCallback = fn || (err => {
                if ("commander.executeSubCommandAsync" !== err.code) throw err;
            }), this;
        }
        _exit(exitCode, code, message) {
            this._exitCallback && this._exitCallback(new CommanderError(exitCode, code, message)), 
            process.exit(exitCode);
        }
        action(fn) {
            return this._actionHandler = args => {
                const expectedArgsCount = this.registeredArguments.length, actionArgs = args.slice(0, expectedArgsCount);
                return this._storeOptionsAsProperties ? actionArgs[expectedArgsCount] = this : actionArgs[expectedArgsCount] = this.opts(), 
                actionArgs.push(this), fn.apply(this, actionArgs);
            }, this;
        }
        createOption(flags, description) {
            return new Option(flags, description);
        }
        _callParseArg(target, value, previous, invalidArgumentMessage) {
            try {
                return target.parseArg(value, previous);
            } catch (err) {
                if ("commander.invalidArgument" === err.code) {
                    const message = `${invalidArgumentMessage} ${err.message}`;
                    this.error(message, {
                        exitCode: err.exitCode,
                        code: err.code
                    });
                }
                throw err;
            }
        }
        _registerOption(option) {
            const matchingOption = option.short && this._findOption(option.short) || option.long && this._findOption(option.long);
            if (matchingOption) {
                const matchingFlag = option.long && this._findOption(option.long) ? option.long : option.short;
                throw new Error(`Cannot add option '${option.flags}'${this._name && ` to command '${this._name}'`} due to conflicting flag '${matchingFlag}'\n-  already used by option '${matchingOption.flags}'`);
            }
            this.options.push(option);
        }
        _registerCommand(command) {
            const knownBy = cmd => [ cmd.name() ].concat(cmd.aliases()), alreadyUsed = knownBy(command).find((name => this._findCommand(name)));
            if (alreadyUsed) {
                const existingCmd = knownBy(this._findCommand(alreadyUsed)).join("|"), newCmd = knownBy(command).join("|");
                throw new Error(`cannot add command '${newCmd}' as already have command '${existingCmd}'`);
            }
            this.commands.push(command);
        }
        addOption(option) {
            this._registerOption(option);
            const oname = option.name(), name = option.attributeName();
            if (option.negate) {
                const positiveLongFlag = option.long.replace(/^--no-/, "--");
                this._findOption(positiveLongFlag) || this.setOptionValueWithSource(name, void 0 === option.defaultValue || option.defaultValue, "default");
            } else void 0 !== option.defaultValue && this.setOptionValueWithSource(name, option.defaultValue, "default");
            const handleOptionValue = (val, invalidValueMessage, valueSource) => {
                null == val && void 0 !== option.presetArg && (val = option.presetArg);
                const oldValue = this.getOptionValue(name);
                null !== val && option.parseArg ? val = this._callParseArg(option, val, oldValue, invalidValueMessage) : null !== val && option.variadic && (val = option._concatValue(val, oldValue)), 
                null == val && (val = !option.negate && (!(!option.isBoolean() && !option.optional) || "")), 
                this.setOptionValueWithSource(name, val, valueSource);
            };
            return this.on("option:" + oname, (val => {
                const invalidValueMessage = `error: option '${option.flags}' argument '${val}' is invalid.`;
                handleOptionValue(val, invalidValueMessage, "cli");
            })), option.envVar && this.on("optionEnv:" + oname, (val => {
                const invalidValueMessage = `error: option '${option.flags}' value '${val}' from env '${option.envVar}' is invalid.`;
                handleOptionValue(val, invalidValueMessage, "env");
            })), this;
        }
        _optionEx(config, flags, description, fn, defaultValue) {
            if ("object" == typeof flags && flags instanceof Option) throw new Error("To add an Option object use addOption() instead of option() or requiredOption()");
            const option = this.createOption(flags, description);
            if (option.makeOptionMandatory(!!config.mandatory), "function" == typeof fn) option.default(defaultValue).argParser(fn); else if (fn instanceof RegExp) {
                const regex = fn;
                fn = (val, def) => {
                    const m = regex.exec(val);
                    return m ? m[0] : def;
                }, option.default(defaultValue).argParser(fn);
            } else option.default(fn);
            return this.addOption(option);
        }
        option(flags, description, parseArg, defaultValue) {
            return this._optionEx({}, flags, description, parseArg, defaultValue);
        }
        requiredOption(flags, description, parseArg, defaultValue) {
            return this._optionEx({
                mandatory: !0
            }, flags, description, parseArg, defaultValue);
        }
        combineFlagAndOptionalValue(combine = !0) {
            return this._combineFlagAndOptionalValue = !!combine, this;
        }
        allowUnknownOption(allowUnknown = !0) {
            return this._allowUnknownOption = !!allowUnknown, this;
        }
        allowExcessArguments(allowExcess = !0) {
            return this._allowExcessArguments = !!allowExcess, this;
        }
        enablePositionalOptions(positional = !0) {
            return this._enablePositionalOptions = !!positional, this;
        }
        passThroughOptions(passThrough = !0) {
            return this._passThroughOptions = !!passThrough, this._checkForBrokenPassThrough(), 
            this;
        }
        _checkForBrokenPassThrough() {
            if (this.parent && this._passThroughOptions && !this.parent._enablePositionalOptions) throw new Error(`passThroughOptions cannot be used for '${this._name}' without turning on enablePositionalOptions for parent command(s)`);
        }
        storeOptionsAsProperties(storeAsProperties = !0) {
            if (this.options.length) throw new Error("call .storeOptionsAsProperties() before adding options");
            if (Object.keys(this._optionValues).length) throw new Error("call .storeOptionsAsProperties() before setting option values");
            return this._storeOptionsAsProperties = !!storeAsProperties, this;
        }
        getOptionValue(key) {
            return this._storeOptionsAsProperties ? this[key] : this._optionValues[key];
        }
        setOptionValue(key, value) {
            return this.setOptionValueWithSource(key, value, void 0);
        }
        setOptionValueWithSource(key, value, source) {
            return this._storeOptionsAsProperties ? this[key] = value : this._optionValues[key] = value, 
            this._optionValueSources[key] = source, this;
        }
        getOptionValueSource(key) {
            return this._optionValueSources[key];
        }
        getOptionValueSourceWithGlobals(key) {
            let source;
            return this._getCommandAndAncestors().forEach((cmd => {
                void 0 !== cmd.getOptionValueSource(key) && (source = cmd.getOptionValueSource(key));
            })), source;
        }
        _prepareUserArgs(argv, parseOptions) {
            if (void 0 !== argv && !Array.isArray(argv)) throw new Error("first parameter to parse must be array or undefined");
            if (parseOptions = parseOptions || {}, void 0 === argv && void 0 === parseOptions.from) {
                process.versions?.electron && (parseOptions.from = "electron");
                const execArgv = process.execArgv ?? [];
                (execArgv.includes("-e") || execArgv.includes("--eval") || execArgv.includes("-p") || execArgv.includes("--print")) && (parseOptions.from = "eval");
            }
            let userArgs;
            switch (void 0 === argv && (argv = process.argv), this.rawArgs = argv.slice(), parseOptions.from) {
              case void 0:
              case "node":
                this._scriptPath = argv[1], userArgs = argv.slice(2);
                break;

              case "electron":
                process.defaultApp ? (this._scriptPath = argv[1], userArgs = argv.slice(2)) : userArgs = argv.slice(1);
                break;

              case "user":
                userArgs = argv.slice(0);
                break;

              case "eval":
                userArgs = argv.slice(1);
                break;

              default:
                throw new Error(`unexpected parse option { from: '${parseOptions.from}' }`);
            }
            return !this._name && this._scriptPath && this.nameFromFilename(this._scriptPath), 
            this._name = this._name || "program", userArgs;
        }
        parse(argv, parseOptions) {
            const userArgs = this._prepareUserArgs(argv, parseOptions);
            return this._parseCommand([], userArgs), this;
        }
        async parseAsync(argv, parseOptions) {
            const userArgs = this._prepareUserArgs(argv, parseOptions);
            return await this._parseCommand([], userArgs), this;
        }
        _executeSubCommand(subcommand, args) {
            args = args.slice();
            let launchWithNode = !1;
            const sourceExt = [ ".js", ".ts", ".tsx", ".mjs", ".cjs" ];
            function findFile(baseDir, baseName) {
                const localBin = path.resolve(baseDir, baseName);
                if (fs.existsSync(localBin)) return localBin;
                if (sourceExt.includes(path.extname(baseName))) return;
                const foundExt = sourceExt.find((ext => fs.existsSync(`${localBin}${ext}`)));
                return foundExt ? `${localBin}${foundExt}` : void 0;
            }
            this._checkForMissingMandatoryOptions(), this._checkForConflictingOptions();
            let proc, executableFile = subcommand._executableFile || `${this._name}-${subcommand._name}`, executableDir = this._executableDir || "";
            if (this._scriptPath) {
                let resolvedScriptPath;
                try {
                    resolvedScriptPath = fs.realpathSync(this._scriptPath);
                } catch (err) {
                    resolvedScriptPath = this._scriptPath;
                }
                executableDir = path.resolve(path.dirname(resolvedScriptPath), executableDir);
            }
            if (executableDir) {
                let localFile = findFile(executableDir, executableFile);
                if (!localFile && !subcommand._executableFile && this._scriptPath) {
                    const legacyName = path.basename(this._scriptPath, path.extname(this._scriptPath));
                    legacyName !== this._name && (localFile = findFile(executableDir, `${legacyName}-${subcommand._name}`));
                }
                executableFile = localFile || executableFile;
            }
            if (launchWithNode = sourceExt.includes(path.extname(executableFile)), "win32" !== process.platform ? launchWithNode ? (args.unshift(executableFile), 
            args = incrementNodeInspectorPort(process.execArgv).concat(args), proc = childProcess.spawn(process.argv[0], args, {
                stdio: "inherit"
            })) : proc = childProcess.spawn(executableFile, args, {
                stdio: "inherit"
            }) : (args.unshift(executableFile), args = incrementNodeInspectorPort(process.execArgv).concat(args), 
            proc = childProcess.spawn(process.execPath, args, {
                stdio: "inherit"
            })), !proc.killed) {
                [ "SIGUSR1", "SIGUSR2", "SIGTERM", "SIGINT", "SIGHUP" ].forEach((signal => {
                    process.on(signal, (() => {
                        !1 === proc.killed && null === proc.exitCode && proc.kill(signal);
                    }));
                }));
            }
            const exitCallback = this._exitCallback;
            proc.on("close", (code => {
                code = code ?? 1, exitCallback ? exitCallback(new CommanderError(code, "commander.executeSubCommandAsync", "(close)")) : process.exit(code);
            })), proc.on("error", (err => {
                if ("ENOENT" === err.code) {
                    const executableDirMessage = executableDir ? `searched for local subcommand relative to directory '${executableDir}'` : "no directory for search for local subcommand, use .executableDir() to supply a custom directory", executableMissing = `'${executableFile}' does not exist\n - if '${subcommand._name}' is not meant to be an executable command, remove description parameter from '.command()' and use '.description()' instead\n - if the default executable name is not suitable, use the executableFile option to supply a custom name or path\n - ${executableDirMessage}`;
                    throw new Error(executableMissing);
                }
                if ("EACCES" === err.code) throw new Error(`'${executableFile}' not executable`);
                if (exitCallback) {
                    const wrappedError = new CommanderError(1, "commander.executeSubCommandAsync", "(error)");
                    wrappedError.nestedError = err, exitCallback(wrappedError);
                } else process.exit(1);
            })), this.runningCommand = proc;
        }
        _dispatchSubcommand(commandName, operands, unknown) {
            const subCommand = this._findCommand(commandName);
            let promiseChain;
            return subCommand || this.help({
                error: !0
            }), promiseChain = this._chainOrCallSubCommandHook(promiseChain, subCommand, "preSubcommand"), 
            promiseChain = this._chainOrCall(promiseChain, (() => {
                if (!subCommand._executableHandler) return subCommand._parseCommand(operands, unknown);
                this._executeSubCommand(subCommand, operands.concat(unknown));
            })), promiseChain;
        }
        _dispatchHelpCommand(subcommandName) {
            subcommandName || this.help();
            const subCommand = this._findCommand(subcommandName);
            return subCommand && !subCommand._executableHandler && subCommand.help(), this._dispatchSubcommand(subcommandName, [], [ this._getHelpOption()?.long ?? this._getHelpOption()?.short ?? "--help" ]);
        }
        _checkNumberOfArguments() {
            this.registeredArguments.forEach(((arg, i) => {
                arg.required && null == this.args[i] && this.missingArgument(arg.name());
            })), this.registeredArguments.length > 0 && this.registeredArguments[this.registeredArguments.length - 1].variadic || this.args.length > this.registeredArguments.length && this._excessArguments(this.args);
        }
        _processArguments() {
            const myParseArg = (argument, value, previous) => {
                let parsedValue = value;
                if (null !== value && argument.parseArg) {
                    const invalidValueMessage = `error: command-argument value '${value}' is invalid for argument '${argument.name()}'.`;
                    parsedValue = this._callParseArg(argument, value, previous, invalidValueMessage);
                }
                return parsedValue;
            };
            this._checkNumberOfArguments();
            const processedArgs = [];
            this.registeredArguments.forEach(((declaredArg, index) => {
                let value = declaredArg.defaultValue;
                declaredArg.variadic ? index < this.args.length ? (value = this.args.slice(index), 
                declaredArg.parseArg && (value = value.reduce(((processed, v) => myParseArg(declaredArg, v, processed)), declaredArg.defaultValue))) : void 0 === value && (value = []) : index < this.args.length && (value = this.args[index], 
                declaredArg.parseArg && (value = myParseArg(declaredArg, value, declaredArg.defaultValue))), 
                processedArgs[index] = value;
            })), this.processedArgs = processedArgs;
        }
        _chainOrCall(promise, fn) {
            return promise && promise.then && "function" == typeof promise.then ? promise.then((() => fn())) : fn();
        }
        _chainOrCallHooks(promise, event) {
            let result = promise;
            const hooks = [];
            return this._getCommandAndAncestors().reverse().filter((cmd => void 0 !== cmd._lifeCycleHooks[event])).forEach((hookedCommand => {
                hookedCommand._lifeCycleHooks[event].forEach((callback => {
                    hooks.push({
                        hookedCommand: hookedCommand,
                        callback: callback
                    });
                }));
            })), "postAction" === event && hooks.reverse(), hooks.forEach((hookDetail => {
                result = this._chainOrCall(result, (() => hookDetail.callback(hookDetail.hookedCommand, this)));
            })), result;
        }
        _chainOrCallSubCommandHook(promise, subCommand, event) {
            let result = promise;
            return void 0 !== this._lifeCycleHooks[event] && this._lifeCycleHooks[event].forEach((hook => {
                result = this._chainOrCall(result, (() => hook(this, subCommand)));
            })), result;
        }
        _parseCommand(operands, unknown) {
            const parsed = this.parseOptions(unknown);
            if (this._parseOptionsEnv(), this._parseOptionsImplied(), operands = operands.concat(parsed.operands), 
            unknown = parsed.unknown, this.args = operands.concat(unknown), operands && this._findCommand(operands[0])) return this._dispatchSubcommand(operands[0], operands.slice(1), unknown);
            if (this._getHelpCommand() && operands[0] === this._getHelpCommand().name()) return this._dispatchHelpCommand(operands[1]);
            if (this._defaultCommandName) return this._outputHelpIfRequested(unknown), this._dispatchSubcommand(this._defaultCommandName, operands, unknown);
            !this.commands.length || 0 !== this.args.length || this._actionHandler || this._defaultCommandName || this.help({
                error: !0
            }), this._outputHelpIfRequested(parsed.unknown), this._checkForMissingMandatoryOptions(), 
            this._checkForConflictingOptions();
            const checkForUnknownOptions = () => {
                parsed.unknown.length > 0 && this.unknownOption(parsed.unknown[0]);
            }, commandEvent = `command:${this.name()}`;
            if (this._actionHandler) {
                let promiseChain;
                return checkForUnknownOptions(), this._processArguments(), promiseChain = this._chainOrCallHooks(promiseChain, "preAction"), 
                promiseChain = this._chainOrCall(promiseChain, (() => this._actionHandler(this.processedArgs))), 
                this.parent && (promiseChain = this._chainOrCall(promiseChain, (() => {
                    this.parent.emit(commandEvent, operands, unknown);
                }))), promiseChain = this._chainOrCallHooks(promiseChain, "postAction"), promiseChain;
            }
            if (this.parent && this.parent.listenerCount(commandEvent)) checkForUnknownOptions(), 
            this._processArguments(), this.parent.emit(commandEvent, operands, unknown); else if (operands.length) {
                if (this._findCommand("*")) return this._dispatchSubcommand("*", operands, unknown);
                this.listenerCount("command:*") ? this.emit("command:*", operands, unknown) : this.commands.length ? this.unknownCommand() : (checkForUnknownOptions(), 
                this._processArguments());
            } else this.commands.length ? (checkForUnknownOptions(), this.help({
                error: !0
            })) : (checkForUnknownOptions(), this._processArguments());
        }
        _findCommand(name) {
            if (name) return this.commands.find((cmd => cmd._name === name || cmd._aliases.includes(name)));
        }
        _findOption(arg) {
            return this.options.find((option => option.is(arg)));
        }
        _checkForMissingMandatoryOptions() {
            this._getCommandAndAncestors().forEach((cmd => {
                cmd.options.forEach((anOption => {
                    anOption.mandatory && void 0 === cmd.getOptionValue(anOption.attributeName()) && cmd.missingMandatoryOptionValue(anOption);
                }));
            }));
        }
        _checkForConflictingLocalOptions() {
            const definedNonDefaultOptions = this.options.filter((option => {
                const optionKey = option.attributeName();
                return void 0 !== this.getOptionValue(optionKey) && "default" !== this.getOptionValueSource(optionKey);
            })), optionsWithConflicting = definedNonDefaultOptions.filter((option => option.conflictsWith.length > 0));
            optionsWithConflicting.forEach((option => {
                const conflictingAndDefined = definedNonDefaultOptions.find((defined => option.conflictsWith.includes(defined.attributeName())));
                conflictingAndDefined && this._conflictingOption(option, conflictingAndDefined);
            }));
        }
        _checkForConflictingOptions() {
            this._getCommandAndAncestors().forEach((cmd => {
                cmd._checkForConflictingLocalOptions();
            }));
        }
        parseOptions(argv) {
            const operands = [], unknown = [];
            let dest = operands;
            const args = argv.slice();
            function maybeOption(arg) {
                return arg.length > 1 && "-" === arg[0];
            }
            let activeVariadicOption = null;
            for (;args.length; ) {
                const arg = args.shift();
                if ("--" === arg) {
                    dest === unknown && dest.push(arg), dest.push(...args);
                    break;
                }
                if (!activeVariadicOption || maybeOption(arg)) {
                    if (activeVariadicOption = null, maybeOption(arg)) {
                        const option = this._findOption(arg);
                        if (option) {
                            if (option.required) {
                                const value = args.shift();
                                void 0 === value && this.optionMissingArgument(option), this.emit(`option:${option.name()}`, value);
                            } else if (option.optional) {
                                let value = null;
                                args.length > 0 && !maybeOption(args[0]) && (value = args.shift()), this.emit(`option:${option.name()}`, value);
                            } else this.emit(`option:${option.name()}`);
                            activeVariadicOption = option.variadic ? option : null;
                            continue;
                        }
                    }
                    if (arg.length > 2 && "-" === arg[0] && "-" !== arg[1]) {
                        const option = this._findOption(`-${arg[1]}`);
                        if (option) {
                            option.required || option.optional && this._combineFlagAndOptionalValue ? this.emit(`option:${option.name()}`, arg.slice(2)) : (this.emit(`option:${option.name()}`), 
                            args.unshift(`-${arg.slice(2)}`));
                            continue;
                        }
                    }
                    if (/^--[^=]+=/.test(arg)) {
                        const index = arg.indexOf("="), option = this._findOption(arg.slice(0, index));
                        if (option && (option.required || option.optional)) {
                            this.emit(`option:${option.name()}`, arg.slice(index + 1));
                            continue;
                        }
                    }
                    if (maybeOption(arg) && (dest = unknown), (this._enablePositionalOptions || this._passThroughOptions) && 0 === operands.length && 0 === unknown.length) {
                        if (this._findCommand(arg)) {
                            operands.push(arg), args.length > 0 && unknown.push(...args);
                            break;
                        }
                        if (this._getHelpCommand() && arg === this._getHelpCommand().name()) {
                            operands.push(arg), args.length > 0 && operands.push(...args);
                            break;
                        }
                        if (this._defaultCommandName) {
                            unknown.push(arg), args.length > 0 && unknown.push(...args);
                            break;
                        }
                    }
                    if (this._passThroughOptions) {
                        dest.push(arg), args.length > 0 && dest.push(...args);
                        break;
                    }
                    dest.push(arg);
                } else this.emit(`option:${activeVariadicOption.name()}`, arg);
            }
            return {
                operands: operands,
                unknown: unknown
            };
        }
        opts() {
            if (this._storeOptionsAsProperties) {
                const result = {}, len = this.options.length;
                for (let i = 0; i < len; i++) {
                    const key = this.options[i].attributeName();
                    result[key] = key === this._versionOptionName ? this._version : this[key];
                }
                return result;
            }
            return this._optionValues;
        }
        optsWithGlobals() {
            return this._getCommandAndAncestors().reduce(((combinedOptions, cmd) => Object.assign(combinedOptions, cmd.opts())), {});
        }
        error(message, errorOptions) {
            this._outputConfiguration.outputError(`${message}\n`, this._outputConfiguration.writeErr), 
            "string" == typeof this._showHelpAfterError ? this._outputConfiguration.writeErr(`${this._showHelpAfterError}\n`) : this._showHelpAfterError && (this._outputConfiguration.writeErr("\n"), 
            this.outputHelp({
                error: !0
            }));
            const config = errorOptions || {}, exitCode = config.exitCode || 1, code = config.code || "commander.error";
            this._exit(exitCode, code, message);
        }
        _parseOptionsEnv() {
            this.options.forEach((option => {
                if (option.envVar && option.envVar in process.env) {
                    const optionKey = option.attributeName();
                    (void 0 === this.getOptionValue(optionKey) || [ "default", "config", "env" ].includes(this.getOptionValueSource(optionKey))) && (option.required || option.optional ? this.emit(`optionEnv:${option.name()}`, process.env[option.envVar]) : this.emit(`optionEnv:${option.name()}`));
                }
            }));
        }
        _parseOptionsImplied() {
            const dualHelper = new DualOptions(this.options), hasCustomOptionValue = optionKey => void 0 !== this.getOptionValue(optionKey) && ![ "default", "implied" ].includes(this.getOptionValueSource(optionKey));
            this.options.filter((option => void 0 !== option.implied && hasCustomOptionValue(option.attributeName()) && dualHelper.valueFromOption(this.getOptionValue(option.attributeName()), option))).forEach((option => {
                Object.keys(option.implied).filter((impliedKey => !hasCustomOptionValue(impliedKey))).forEach((impliedKey => {
                    this.setOptionValueWithSource(impliedKey, option.implied[impliedKey], "implied");
                }));
            }));
        }
        missingArgument(name) {
            const message = `error: missing required argument '${name}'`;
            this.error(message, {
                code: "commander.missingArgument"
            });
        }
        optionMissingArgument(option) {
            const message = `error: option '${option.flags}' argument missing`;
            this.error(message, {
                code: "commander.optionMissingArgument"
            });
        }
        missingMandatoryOptionValue(option) {
            const message = `error: required option '${option.flags}' not specified`;
            this.error(message, {
                code: "commander.missingMandatoryOptionValue"
            });
        }
        _conflictingOption(option, conflictingOption) {
            const findBestOptionFromValue = option => {
                const optionKey = option.attributeName(), optionValue = this.getOptionValue(optionKey), negativeOption = this.options.find((target => target.negate && optionKey === target.attributeName())), positiveOption = this.options.find((target => !target.negate && optionKey === target.attributeName()));
                return negativeOption && (void 0 === negativeOption.presetArg && !1 === optionValue || void 0 !== negativeOption.presetArg && optionValue === negativeOption.presetArg) ? negativeOption : positiveOption || option;
            }, getErrorMessage = option => {
                const bestOption = findBestOptionFromValue(option), optionKey = bestOption.attributeName();
                return "env" === this.getOptionValueSource(optionKey) ? `environment variable '${bestOption.envVar}'` : `option '${bestOption.flags}'`;
            }, message = `error: ${getErrorMessage(option)} cannot be used with ${getErrorMessage(conflictingOption)}`;
            this.error(message, {
                code: "commander.conflictingOption"
            });
        }
        unknownOption(flag) {
            if (this._allowUnknownOption) return;
            let suggestion = "";
            if (flag.startsWith("--") && this._showSuggestionAfterError) {
                let candidateFlags = [], command = this;
                do {
                    const moreFlags = command.createHelp().visibleOptions(command).filter((option => option.long)).map((option => option.long));
                    candidateFlags = candidateFlags.concat(moreFlags), command = command.parent;
                } while (command && !command._enablePositionalOptions);
                suggestion = suggestSimilar(flag, candidateFlags);
            }
            const message = `error: unknown option '${flag}'${suggestion}`;
            this.error(message, {
                code: "commander.unknownOption"
            });
        }
        _excessArguments(receivedArgs) {
            if (this._allowExcessArguments) return;
            const expected = this.registeredArguments.length, s = 1 === expected ? "" : "s", message = `error: too many arguments${this.parent ? ` for '${this.name()}'` : ""}. Expected ${expected} argument${s} but got ${receivedArgs.length}.`;
            this.error(message, {
                code: "commander.excessArguments"
            });
        }
        unknownCommand() {
            const unknownName = this.args[0];
            let suggestion = "";
            if (this._showSuggestionAfterError) {
                const candidateNames = [];
                this.createHelp().visibleCommands(this).forEach((command => {
                    candidateNames.push(command.name()), command.alias() && candidateNames.push(command.alias());
                })), suggestion = suggestSimilar(unknownName, candidateNames);
            }
            const message = `error: unknown command '${unknownName}'${suggestion}`;
            this.error(message, {
                code: "commander.unknownCommand"
            });
        }
        version(str, flags, description) {
            if (void 0 === str) return this._version;
            this._version = str, flags = flags || "-V, --version", description = description || "output the version number";
            const versionOption = this.createOption(flags, description);
            return this._versionOptionName = versionOption.attributeName(), this._registerOption(versionOption), 
            this.on("option:" + versionOption.name(), (() => {
                this._outputConfiguration.writeOut(`${str}\n`), this._exit(0, "commander.version", str);
            })), this;
        }
        description(str, argsDescription) {
            return void 0 === str && void 0 === argsDescription ? this._description : (this._description = str, 
            argsDescription && (this._argsDescription = argsDescription), this);
        }
        summary(str) {
            return void 0 === str ? this._summary : (this._summary = str, this);
        }
        alias(alias) {
            if (void 0 === alias) return this._aliases[0];
            let command = this;
            if (0 !== this.commands.length && this.commands[this.commands.length - 1]._executableHandler && (command = this.commands[this.commands.length - 1]), 
            alias === command._name) throw new Error("Command alias can't be the same as its name");
            const matchingCommand = this.parent?._findCommand(alias);
            if (matchingCommand) {
                const existingCmd = [ matchingCommand.name() ].concat(matchingCommand.aliases()).join("|");
                throw new Error(`cannot add alias '${alias}' to command '${this.name()}' as already have command '${existingCmd}'`);
            }
            return command._aliases.push(alias), this;
        }
        aliases(aliases) {
            return void 0 === aliases ? this._aliases : (aliases.forEach((alias => this.alias(alias))), 
            this);
        }
        usage(str) {
            if (void 0 === str) {
                if (this._usage) return this._usage;
                const args = this.registeredArguments.map((arg => humanReadableArgName(arg)));
                return [].concat(this.options.length || null !== this._helpOption ? "[options]" : [], this.commands.length ? "[command]" : [], this.registeredArguments.length ? args : []).join(" ");
            }
            return this._usage = str, this;
        }
        name(str) {
            return void 0 === str ? this._name : (this._name = str, this);
        }
        nameFromFilename(filename) {
            return this._name = path.basename(filename, path.extname(filename)), this;
        }
        executableDir(path) {
            return void 0 === path ? this._executableDir : (this._executableDir = path, this);
        }
        helpInformation(contextOptions) {
            const helper = this.createHelp();
            return void 0 === helper.helpWidth && (helper.helpWidth = contextOptions && contextOptions.error ? this._outputConfiguration.getErrHelpWidth() : this._outputConfiguration.getOutHelpWidth()), 
            helper.formatHelp(this, helper);
        }
        _getHelpContext(contextOptions) {
            const context = {
                error: !!(contextOptions = contextOptions || {}).error
            };
            let write;
            return write = context.error ? arg => this._outputConfiguration.writeErr(arg) : arg => this._outputConfiguration.writeOut(arg), 
            context.write = contextOptions.write || write, context.command = this, context;
        }
        outputHelp(contextOptions) {
            let deprecatedCallback;
            "function" == typeof contextOptions && (deprecatedCallback = contextOptions, contextOptions = void 0);
            const context = this._getHelpContext(contextOptions);
            this._getCommandAndAncestors().reverse().forEach((command => command.emit("beforeAllHelp", context))), 
            this.emit("beforeHelp", context);
            let helpInformation = this.helpInformation(context);
            if (deprecatedCallback && (helpInformation = deprecatedCallback(helpInformation), 
            "string" != typeof helpInformation && !Buffer.isBuffer(helpInformation))) throw new Error("outputHelp callback must return a string or a Buffer");
            context.write(helpInformation), this._getHelpOption()?.long && this.emit(this._getHelpOption().long), 
            this.emit("afterHelp", context), this._getCommandAndAncestors().forEach((command => command.emit("afterAllHelp", context)));
        }
        helpOption(flags, description) {
            return "boolean" == typeof flags ? (this._helpOption = flags ? this._helpOption ?? void 0 : null, 
            this) : (flags = flags ?? "-h, --help", description = description ?? "display help for command", 
            this._helpOption = this.createOption(flags, description), this);
        }
        _getHelpOption() {
            return void 0 === this._helpOption && this.helpOption(void 0, void 0), this._helpOption;
        }
        addHelpOption(option) {
            return this._helpOption = option, this;
        }
        help(contextOptions) {
            this.outputHelp(contextOptions);
            let exitCode = process.exitCode || 0;
            0 === exitCode && contextOptions && "function" != typeof contextOptions && contextOptions.error && (exitCode = 1), 
            this._exit(exitCode, "commander.help", "(outputHelp)");
        }
        addHelpText(position, text) {
            const allowedValues = [ "beforeAll", "before", "after", "afterAll" ];
            if (!allowedValues.includes(position)) throw new Error(`Unexpected value for position to addHelpText.\nExpecting one of '${allowedValues.join("', '")}'`);
            const helpEvent = `${position}Help`;
            return this.on(helpEvent, (context => {
                let helpStr;
                helpStr = "function" == typeof text ? text({
                    error: context.error,
                    command: context.command
                }) : text, helpStr && context.write(`${helpStr}\n`);
            })), this;
        }
        _outputHelpIfRequested(args) {
            const helpOption = this._getHelpOption();
            helpOption && args.find((arg => helpOption.is(arg))) && (this.outputHelp(), this._exit(0, "commander.helpDisplayed", "(outputHelp)"));
        }
    }
    function incrementNodeInspectorPort(args) {
        return args.map((arg => {
            if (!arg.startsWith("--inspect")) return arg;
            let debugOption, match, debugHost = "127.0.0.1", debugPort = "9229";
            return null !== (match = arg.match(/^(--inspect(-brk)?)$/)) ? debugOption = match[1] : null !== (match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+)$/)) ? (debugOption = match[1], 
            /^\d+$/.test(match[3]) ? debugPort = match[3] : debugHost = match[3]) : null !== (match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+):(\d+)$/)) && (debugOption = match[1], 
            debugHost = match[3], debugPort = match[4]), debugOption && "0" !== debugPort ? `${debugOption}=${debugHost}:${parseInt(debugPort) + 1}` : arg;
        }));
    }
    return command$1.Command = Command, command$1;
}

function requireCommander() {
    if (hasRequiredCommander) return commander;
    hasRequiredCommander = 1;
    const {Argument: Argument} = requireArgument(), {Command: Command} = requireCommand(), {CommanderError: CommanderError, InvalidArgumentError: InvalidArgumentError} = requireError(), {Help: Help} = requireHelp(), {Option: Option} = requireOption();
    return commander.program = new Command, commander.createCommand = name => new Command(name), 
    commander.createOption = (flags, description) => new Option(flags, description), 
    commander.createArgument = (name, description) => new Argument(name, description), 
    commander.Command = Command, commander.Option = Option, commander.Argument = Argument, 
    commander.Help = Help, commander.CommanderError = CommanderError, commander.InvalidArgumentError = InvalidArgumentError, 
    commander.InvalidOptionArgumentError = InvalidArgumentError, commander;
}

function requireExtraTypings() {
    return hasRequiredExtraTypings || (hasRequiredExtraTypings = 1, function(module, exports) {
        const commander = requireCommander();
        (exports = module.exports = {}).program = new commander.Command, exports.Argument = commander.Argument, 
        exports.Command = commander.Command, exports.CommanderError = commander.CommanderError, 
        exports.Help = commander.Help, exports.InvalidArgumentError = commander.InvalidArgumentError, 
        exports.InvalidOptionArgumentError = commander.InvalidArgumentError, exports.Option = commander.Option, 
        exports.createCommand = name => new commander.Command(name), exports.createOption = (flags, description) => new commander.Option(flags, description), 
        exports.createArgument = (name, description) => new commander.Argument(name, description);
    }(extraTypings, extraTypings.exports)), extraTypings.exports;
}

var extraTypingsExports = requireExtraTypings(), extraTypingsCommander = getDefaultExportFromCjs(extraTypingsExports);

const {program: program, createCommand: createCommand, createArgument: createArgument, createOption: createOption, CommanderError: CommanderError, InvalidArgumentError: InvalidArgumentError, InvalidOptionArgumentError: InvalidOptionArgumentError, Command: Command, Argument: Argument, Option: Option, Help: Help} = extraTypingsCommander;

var toml = {}, parse$2 = {
    exports: {}
}, tomlParser = {
    exports: {}
}, parser$1, hasRequiredParser$1, createDatetime, hasRequiredCreateDatetime, formatNum, hasRequiredFormatNum, createDatetimeFloat, hasRequiredCreateDatetimeFloat, createDate, hasRequiredCreateDate, createTime, hasRequiredCreateTime, hasRequiredTomlParser, parsePrettyError, hasRequiredParsePrettyError, parseString_1, hasRequiredParseString, parseAsync_1, hasRequiredParseAsync, parseStream_1, hasRequiredParseStream, hasRequiredParse;

function requireParser$1() {
    if (hasRequiredParser$1) return parser$1;
    hasRequiredParser$1 = 1;
    class ParserError extends Error {
        constructor(msg, filename, linenumber) {
            super("[ParserError] " + msg, filename, linenumber), this.name = "ParserError", 
            this.code = "ParserError", Error.captureStackTrace && Error.captureStackTrace(this, ParserError);
        }
    }
    class State {
        constructor(parser) {
            this.parser = parser, this.buf = "", this.returned = null, this.result = null, this.resultTable = null, 
            this.resultArr = null;
        }
    }
    class Parser {
        constructor() {
            this.pos = 0, this.col = 0, this.line = 0, this.obj = {}, this.ctx = this.obj, this.stack = [], 
            this._buf = "", this.char = null, this.ii = 0, this.state = new State(this.parseStart);
        }
        parse(str) {
            if (0 === str.length || null == str.length) return;
            let getNext;
            for (this._buf = String(str), this.ii = -1, this.char = -1; !1 === getNext || this.nextChar(); ) getNext = this.runOne();
            this._buf = null;
        }
        nextChar() {
            return 10 === this.char && (++this.line, this.col = -1), ++this.ii, this.char = this._buf.codePointAt(this.ii), 
            ++this.pos, ++this.col, this.haveBuffer();
        }
        haveBuffer() {
            return this.ii < this._buf.length;
        }
        runOne() {
            return this.state.parser.call(this, this.state.returned);
        }
        finish() {
            let last;
            this.char = 1114112;
            do {
                last = this.state.parser, this.runOne();
            } while (this.state.parser !== last);
            return this.ctx = null, this.state = null, this._buf = null, this.obj;
        }
        next(fn) {
            if ("function" != typeof fn) throw new ParserError("Tried to set state to non-existent state: " + JSON.stringify(fn));
            this.state.parser = fn;
        }
        goto(fn) {
            return this.next(fn), this.runOne();
        }
        call(fn, returnWith) {
            returnWith && this.next(returnWith), this.stack.push(this.state), this.state = new State(fn);
        }
        callNow(fn, returnWith) {
            return this.call(fn, returnWith), this.runOne();
        }
        return(value) {
            if (0 === this.stack.length) throw this.error(new ParserError("Stack underflow"));
            void 0 === value && (value = this.state.buf), this.state = this.stack.pop(), this.state.returned = value;
        }
        returnNow(value) {
            return this.return(value), this.runOne();
        }
        consume() {
            if (1114112 === this.char) throw this.error(new ParserError("Unexpected end-of-buffer"));
            this.state.buf += this._buf[this.ii];
        }
        error(err) {
            return err.line = this.line, err.col = this.col, err.pos = this.pos, err;
        }
        parseStart() {
            throw new ParserError("Must declare a parseStart method");
        }
    }
    return Parser.END = 1114112, Parser.Error = ParserError, parser$1 = Parser;
}

function requireCreateDatetime() {
    return hasRequiredCreateDatetime ? createDatetime : (hasRequiredCreateDatetime = 1, 
    createDatetime = value => {
        const date = new Date(value);
        if (isNaN(date)) throw new TypeError("Invalid Datetime");
        return date;
    });
}

function requireFormatNum() {
    return hasRequiredFormatNum || (hasRequiredFormatNum = 1, formatNum = (d, num) => {
        for (num = String(num); num.length < d; ) num = "0" + num;
        return num;
    }), formatNum;
}

function requireCreateDatetimeFloat() {
    if (hasRequiredCreateDatetimeFloat) return createDatetimeFloat;
    hasRequiredCreateDatetimeFloat = 1;
    const f = requireFormatNum();
    class FloatingDateTime extends Date {
        constructor(value) {
            super(value + "Z"), this.isFloating = !0;
        }
        toISOString() {
            return `${`${this.getUTCFullYear()}-${f(2, this.getUTCMonth() + 1)}-${f(2, this.getUTCDate())}`}T${`${f(2, this.getUTCHours())}:${f(2, this.getUTCMinutes())}:${f(2, this.getUTCSeconds())}.${f(3, this.getUTCMilliseconds())}`}`;
        }
    }
    return createDatetimeFloat = value => {
        const date = new FloatingDateTime(value);
        if (isNaN(date)) throw new TypeError("Invalid Datetime");
        return date;
    };
}

function requireCreateDate() {
    if (hasRequiredCreateDate) return createDate;
    hasRequiredCreateDate = 1;
    const f = requireFormatNum(), DateTime = commonjsGlobal.Date;
    class Date extends DateTime {
        constructor(value) {
            super(value), this.isDate = !0;
        }
        toISOString() {
            return `${this.getUTCFullYear()}-${f(2, this.getUTCMonth() + 1)}-${f(2, this.getUTCDate())}`;
        }
    }
    return createDate = value => {
        const date = new Date(value);
        if (isNaN(date)) throw new TypeError("Invalid Datetime");
        return date;
    };
}

function requireCreateTime() {
    if (hasRequiredCreateTime) return createTime;
    hasRequiredCreateTime = 1;
    const f = requireFormatNum();
    class Time extends Date {
        constructor(value) {
            super(`0000-01-01T${value}Z`), this.isTime = !0;
        }
        toISOString() {
            return `${f(2, this.getUTCHours())}:${f(2, this.getUTCMinutes())}:${f(2, this.getUTCSeconds())}.${f(3, this.getUTCMilliseconds())}`;
        }
    }
    return createTime = value => {
        const date = new Time(value);
        if (isNaN(date)) throw new TypeError("Invalid Datetime");
        return date;
    };
}

function requireTomlParser() {
    if (hasRequiredTomlParser) return tomlParser.exports;
    hasRequiredTomlParser = 1, tomlParser.exports = makeParserClass(requireParser$1()), 
    tomlParser.exports.makeParserClass = makeParserClass;
    class TomlError extends Error {
        constructor(msg) {
            super(msg), this.name = "TomlError", Error.captureStackTrace && Error.captureStackTrace(this, TomlError), 
            this.fromTOML = !0, this.wrapped = null;
        }
    }
    TomlError.wrap = err => {
        const terr = new TomlError(err.message);
        return terr.code = err.code, terr.wrapped = err, terr;
    }, tomlParser.exports.TomlError = TomlError;
    const createDateTime = requireCreateDatetime(), createDateTimeFloat = requireCreateDatetimeFloat(), createDate = requireCreateDate(), createTime = requireCreateTime(), CTRL_I = 9, CTRL_J = 10, CTRL_M = 13, CTRL_CHAR_BOUNDARY = 31, CHAR_SP = 32, CHAR_QUOT = 34, CHAR_NUM = 35, CHAR_APOS = 39, CHAR_PLUS = 43, CHAR_COMMA = 44, CHAR_HYPHEN = 45, CHAR_PERIOD = 46, CHAR_0 = 48, CHAR_1 = 49, CHAR_7 = 55, CHAR_9 = 57, CHAR_COLON = 58, CHAR_EQUALS = 61, CHAR_A = 65, CHAR_E = 69, CHAR_F = 70, CHAR_T = 84, CHAR_U = 85, CHAR_Z = 90, CHAR_LOWBAR = 95, CHAR_a = 97, CHAR_b = 98, CHAR_e = 101, CHAR_f = 102, CHAR_i = 105, CHAR_l = 108, CHAR_n = 110, CHAR_o = 111, CHAR_r = 114, CHAR_s = 115, CHAR_t = 116, CHAR_u = 117, CHAR_x = 120, CHAR_z = 122, CHAR_LCUB = 123, CHAR_RCUB = 125, CHAR_LSQB = 91, CHAR_BSOL = 92, CHAR_RSQB = 93, CHAR_DEL = 127, SURROGATE_FIRST = 55296, SURROGATE_LAST = 57343, escapes = {
        [CHAR_b]: "\b",
        [CHAR_t]: "\t",
        [CHAR_n]: "\n",
        [CHAR_f]: "\f",
        [CHAR_r]: "\r",
        [CHAR_QUOT]: '"',
        [CHAR_BSOL]: "\\"
    };
    function isDigit(cp) {
        return cp >= CHAR_0 && cp <= CHAR_9;
    }
    function isHexit(cp) {
        return cp >= CHAR_A && cp <= CHAR_F || cp >= CHAR_a && cp <= CHAR_f || cp >= CHAR_0 && cp <= CHAR_9;
    }
    function isBit(cp) {
        return cp === CHAR_1 || cp === CHAR_0;
    }
    function isOctit(cp) {
        return cp >= CHAR_0 && cp <= CHAR_7;
    }
    function isAlphaNumQuoteHyphen(cp) {
        return cp >= CHAR_A && cp <= CHAR_Z || cp >= CHAR_a && cp <= CHAR_z || cp >= CHAR_0 && cp <= CHAR_9 || cp === CHAR_APOS || cp === CHAR_QUOT || cp === CHAR_LOWBAR || cp === CHAR_HYPHEN;
    }
    function isAlphaNumHyphen(cp) {
        return cp >= CHAR_A && cp <= CHAR_Z || cp >= CHAR_a && cp <= CHAR_z || cp >= CHAR_0 && cp <= CHAR_9 || cp === CHAR_LOWBAR || cp === CHAR_HYPHEN;
    }
    const _type = Symbol("type"), _declared = Symbol("declared"), hasOwnProperty = Object.prototype.hasOwnProperty, defineProperty = Object.defineProperty, descriptor = {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        value: void 0
    };
    function hasKey(obj, key) {
        return !!hasOwnProperty.call(obj, key) || ("__proto__" === key && defineProperty(obj, "__proto__", descriptor), 
        !1);
    }
    const INLINE_TABLE = Symbol("inline-table");
    function InlineTable() {
        return Object.defineProperties({}, {
            [_type]: {
                value: INLINE_TABLE
            }
        });
    }
    function isInlineTable(obj) {
        return null !== obj && "object" == typeof obj && obj[_type] === INLINE_TABLE;
    }
    const TABLE = Symbol("table");
    function Table() {
        return Object.defineProperties({}, {
            [_type]: {
                value: TABLE
            },
            [_declared]: {
                value: !1,
                writable: !0
            }
        });
    }
    function isTable(obj) {
        return null !== obj && "object" == typeof obj && obj[_type] === TABLE;
    }
    const _contentType = Symbol("content-type"), INLINE_LIST = Symbol("inline-list");
    function InlineList(type) {
        return Object.defineProperties([], {
            [_type]: {
                value: INLINE_LIST
            },
            [_contentType]: {
                value: type
            }
        });
    }
    function isInlineList(obj) {
        return null !== obj && "object" == typeof obj && obj[_type] === INLINE_LIST;
    }
    const LIST = Symbol("list");
    function List() {
        return Object.defineProperties([], {
            [_type]: {
                value: LIST
            }
        });
    }
    function isList(obj) {
        return null !== obj && "object" == typeof obj && obj[_type] === LIST;
    }
    let _custom;
    try {
        const utilInspect = eval("require('util').inspect");
        _custom = utilInspect.custom;
    } catch (_) {}
    const _inspect = _custom || "inspect";
    class BoxedBigInt {
        constructor(value) {
            try {
                this.value = commonjsGlobal.BigInt.asIntN(64, value);
            } catch (_) {
                this.value = null;
            }
            Object.defineProperty(this, _type, {
                value: INTEGER
            });
        }
        isNaN() {
            return null === this.value;
        }
        toString() {
            return String(this.value);
        }
        [_inspect]() {
            return `[BigInt: ${this.toString()}]}`;
        }
        valueOf() {
            return this.value;
        }
    }
    const INTEGER = Symbol("integer");
    function Integer(value) {
        let num = Number(value);
        return Object.is(num, -0) && (num = 0), commonjsGlobal.BigInt && !Number.isSafeInteger(num) ? new BoxedBigInt(value) : Object.defineProperties(new Number(num), {
            isNaN: {
                value: function() {
                    return isNaN(this);
                }
            },
            [_type]: {
                value: INTEGER
            },
            [_inspect]: {
                value: () => `[Integer: ${value}]`
            }
        });
    }
    function isInteger(obj) {
        return null !== obj && "object" == typeof obj && obj[_type] === INTEGER;
    }
    const FLOAT = Symbol("float");
    function Float(value) {
        return Object.defineProperties(new Number(value), {
            [_type]: {
                value: FLOAT
            },
            [_inspect]: {
                value: () => `[Float: ${value}]`
            }
        });
    }
    function isFloat(obj) {
        return null !== obj && "object" == typeof obj && obj[_type] === FLOAT;
    }
    function tomlType(value) {
        const type = typeof value;
        if ("object" === type) {
            if (null === value) return "null";
            if (value instanceof Date) return "datetime";
            if (_type in value) switch (value[_type]) {
              case INLINE_TABLE:
                return "inline-table";

              case INLINE_LIST:
                return "inline-list";

              case TABLE:
                return "table";

              case LIST:
                return "list";

              case FLOAT:
                return "float";

              case INTEGER:
                return "integer";
            }
        }
        return type;
    }
    function makeParserClass(Parser) {
        return class extends Parser {
            constructor() {
                super(), this.ctx = this.obj = Table();
            }
            atEndOfWord() {
                return this.char === CHAR_NUM || this.char === CTRL_I || this.char === CHAR_SP || this.atEndOfLine();
            }
            atEndOfLine() {
                return this.char === Parser.END || this.char === CTRL_J || this.char === CTRL_M;
            }
            parseStart() {
                if (this.char === Parser.END) return null;
                if (this.char === CHAR_LSQB) return this.call(this.parseTableOrList);
                if (this.char === CHAR_NUM) return this.call(this.parseComment);
                if (this.char === CTRL_J || this.char === CHAR_SP || this.char === CTRL_I || this.char === CTRL_M) return null;
                if (isAlphaNumQuoteHyphen(this.char)) return this.callNow(this.parseAssignStatement);
                throw this.error(new TomlError(`Unknown character "${this.char}"`));
            }
            parseWhitespaceToEOL() {
                if (this.char === CHAR_SP || this.char === CTRL_I || this.char === CTRL_M) return null;
                if (this.char === CHAR_NUM) return this.goto(this.parseComment);
                if (this.char === Parser.END || this.char === CTRL_J) return this.return();
                throw this.error(new TomlError("Unexpected character, expected only whitespace or comments till end of line"));
            }
            parseAssignStatement() {
                return this.callNow(this.parseAssign, this.recordAssignStatement);
            }
            recordAssignStatement(kv) {
                let target = this.ctx, finalKey = kv.key.pop();
                for (let kw of kv.key) {
                    if (hasKey(target, kw) && (!isTable(target[kw]) || target[kw][_declared])) throw this.error(new TomlError("Can't redefine existing key"));
                    target = target[kw] = target[kw] || Table();
                }
                if (hasKey(target, finalKey)) throw this.error(new TomlError("Can't redefine existing key"));
                return isInteger(kv.value) || isFloat(kv.value) ? target[finalKey] = kv.value.valueOf() : target[finalKey] = kv.value, 
                this.goto(this.parseWhitespaceToEOL);
            }
            parseAssign() {
                return this.callNow(this.parseKeyword, this.recordAssignKeyword);
            }
            recordAssignKeyword(key) {
                return this.state.resultTable ? this.state.resultTable.push(key) : this.state.resultTable = [ key ], 
                this.goto(this.parseAssignKeywordPreDot);
            }
            parseAssignKeywordPreDot() {
                return this.char === CHAR_PERIOD ? this.next(this.parseAssignKeywordPostDot) : this.char !== CHAR_SP && this.char !== CTRL_I ? this.goto(this.parseAssignEqual) : void 0;
            }
            parseAssignKeywordPostDot() {
                if (this.char !== CHAR_SP && this.char !== CTRL_I) return this.callNow(this.parseKeyword, this.recordAssignKeyword);
            }
            parseAssignEqual() {
                if (this.char === CHAR_EQUALS) return this.next(this.parseAssignPreValue);
                throw this.error(new TomlError('Invalid character, expected "="'));
            }
            parseAssignPreValue() {
                return this.char === CHAR_SP || this.char === CTRL_I ? null : this.callNow(this.parseValue, this.recordAssignValue);
            }
            recordAssignValue(value) {
                return this.returnNow({
                    key: this.state.resultTable,
                    value: value
                });
            }
            parseComment() {
                do {
                    if (this.char === Parser.END || this.char === CTRL_J) return this.return();
                } while (this.nextChar());
            }
            parseTableOrList() {
                if (this.char !== CHAR_LSQB) return this.goto(this.parseTable);
                this.next(this.parseList);
            }
            parseTable() {
                return this.ctx = this.obj, this.goto(this.parseTableNext);
            }
            parseTableNext() {
                return this.char === CHAR_SP || this.char === CTRL_I ? null : this.callNow(this.parseKeyword, this.parseTableMore);
            }
            parseTableMore(keyword) {
                if (this.char === CHAR_SP || this.char === CTRL_I) return null;
                if (this.char === CHAR_RSQB) {
                    if (hasKey(this.ctx, keyword) && (!isTable(this.ctx[keyword]) || this.ctx[keyword][_declared])) throw this.error(new TomlError("Can't redefine existing key"));
                    return this.ctx = this.ctx[keyword] = this.ctx[keyword] || Table(), this.ctx[_declared] = !0, 
                    this.next(this.parseWhitespaceToEOL);
                }
                if (this.char === CHAR_PERIOD) {
                    if (hasKey(this.ctx, keyword)) if (isTable(this.ctx[keyword])) this.ctx = this.ctx[keyword]; else {
                        if (!isList(this.ctx[keyword])) throw this.error(new TomlError("Can't redefine existing key"));
                        this.ctx = this.ctx[keyword][this.ctx[keyword].length - 1];
                    } else this.ctx = this.ctx[keyword] = Table();
                    return this.next(this.parseTableNext);
                }
                throw this.error(new TomlError("Unexpected character, expected whitespace, . or ]"));
            }
            parseList() {
                return this.ctx = this.obj, this.goto(this.parseListNext);
            }
            parseListNext() {
                return this.char === CHAR_SP || this.char === CTRL_I ? null : this.callNow(this.parseKeyword, this.parseListMore);
            }
            parseListMore(keyword) {
                if (this.char === CHAR_SP || this.char === CTRL_I) return null;
                if (this.char === CHAR_RSQB) {
                    if (hasKey(this.ctx, keyword) || (this.ctx[keyword] = List()), isInlineList(this.ctx[keyword])) throw this.error(new TomlError("Can't extend an inline array"));
                    if (!isList(this.ctx[keyword])) throw this.error(new TomlError("Can't redefine an existing key"));
                    {
                        const next = Table();
                        this.ctx[keyword].push(next), this.ctx = next;
                    }
                    return this.next(this.parseListEnd);
                }
                if (this.char === CHAR_PERIOD) {
                    if (hasKey(this.ctx, keyword)) {
                        if (isInlineList(this.ctx[keyword])) throw this.error(new TomlError("Can't extend an inline array"));
                        if (isInlineTable(this.ctx[keyword])) throw this.error(new TomlError("Can't extend an inline table"));
                        if (isList(this.ctx[keyword])) this.ctx = this.ctx[keyword][this.ctx[keyword].length - 1]; else {
                            if (!isTable(this.ctx[keyword])) throw this.error(new TomlError("Can't redefine an existing key"));
                            this.ctx = this.ctx[keyword];
                        }
                    } else this.ctx = this.ctx[keyword] = Table();
                    return this.next(this.parseListNext);
                }
                throw this.error(new TomlError("Unexpected character, expected whitespace, . or ]"));
            }
            parseListEnd(keyword) {
                if (this.char === CHAR_RSQB) return this.next(this.parseWhitespaceToEOL);
                throw this.error(new TomlError("Unexpected character, expected whitespace, . or ]"));
            }
            parseValue() {
                if (this.char === Parser.END) throw this.error(new TomlError("Key without value"));
                if (this.char === CHAR_QUOT) return this.next(this.parseDoubleString);
                if (this.char === CHAR_APOS) return this.next(this.parseSingleString);
                if (this.char === CHAR_HYPHEN || this.char === CHAR_PLUS) return this.goto(this.parseNumberSign);
                if (this.char === CHAR_i) return this.next(this.parseInf);
                if (this.char === CHAR_n) return this.next(this.parseNan);
                if (isDigit(this.char)) return this.goto(this.parseNumberOrDateTime);
                if (this.char === CHAR_t || this.char === CHAR_f) return this.goto(this.parseBoolean);
                if (this.char === CHAR_LSQB) return this.call(this.parseInlineList, this.recordValue);
                if (this.char === CHAR_LCUB) return this.call(this.parseInlineTable, this.recordValue);
                throw this.error(new TomlError("Unexpected character, expecting string, number, datetime, boolean, inline array or inline table"));
            }
            recordValue(value) {
                return this.returnNow(value);
            }
            parseInf() {
                if (this.char === CHAR_n) return this.next(this.parseInf2);
                throw this.error(new TomlError('Unexpected character, expected "inf", "+inf" or "-inf"'));
            }
            parseInf2() {
                if (this.char === CHAR_f) return "-" === this.state.buf ? this.return(-1 / 0) : this.return(1 / 0);
                throw this.error(new TomlError('Unexpected character, expected "inf", "+inf" or "-inf"'));
            }
            parseNan() {
                if (this.char === CHAR_a) return this.next(this.parseNan2);
                throw this.error(new TomlError('Unexpected character, expected "nan"'));
            }
            parseNan2() {
                if (this.char === CHAR_n) return this.return(NaN);
                throw this.error(new TomlError('Unexpected character, expected "nan"'));
            }
            parseKeyword() {
                return this.char === CHAR_QUOT ? this.next(this.parseBasicString) : this.char === CHAR_APOS ? this.next(this.parseLiteralString) : this.goto(this.parseBareKey);
            }
            parseBareKey() {
                do {
                    if (this.char === Parser.END) throw this.error(new TomlError("Key ended without value"));
                    if (!isAlphaNumHyphen(this.char)) {
                        if (0 === this.state.buf.length) throw this.error(new TomlError("Empty bare keys are not allowed"));
                        return this.returnNow();
                    }
                    this.consume();
                } while (this.nextChar());
            }
            parseSingleString() {
                return this.char === CHAR_APOS ? this.next(this.parseLiteralMultiStringMaybe) : this.goto(this.parseLiteralString);
            }
            parseLiteralString() {
                do {
                    if (this.char === CHAR_APOS) return this.return();
                    if (this.atEndOfLine()) throw this.error(new TomlError("Unterminated string"));
                    if (this.char === CHAR_DEL || this.char <= CTRL_CHAR_BOUNDARY && this.char !== CTRL_I) throw this.errorControlCharInString();
                    this.consume();
                } while (this.nextChar());
            }
            parseLiteralMultiStringMaybe() {
                return this.char === CHAR_APOS ? this.next(this.parseLiteralMultiString) : this.returnNow();
            }
            parseLiteralMultiString() {
                return this.char === CTRL_M ? null : this.char === CTRL_J ? this.next(this.parseLiteralMultiStringContent) : this.goto(this.parseLiteralMultiStringContent);
            }
            parseLiteralMultiStringContent() {
                do {
                    if (this.char === CHAR_APOS) return this.next(this.parseLiteralMultiEnd);
                    if (this.char === Parser.END) throw this.error(new TomlError("Unterminated multi-line string"));
                    if (this.char === CHAR_DEL || this.char <= CTRL_CHAR_BOUNDARY && this.char !== CTRL_I && this.char !== CTRL_J && this.char !== CTRL_M) throw this.errorControlCharInString();
                    this.consume();
                } while (this.nextChar());
            }
            parseLiteralMultiEnd() {
                return this.char === CHAR_APOS ? this.next(this.parseLiteralMultiEnd2) : (this.state.buf += "'", 
                this.goto(this.parseLiteralMultiStringContent));
            }
            parseLiteralMultiEnd2() {
                return this.char === CHAR_APOS ? this.return() : (this.state.buf += "''", this.goto(this.parseLiteralMultiStringContent));
            }
            parseDoubleString() {
                return this.char === CHAR_QUOT ? this.next(this.parseMultiStringMaybe) : this.goto(this.parseBasicString);
            }
            parseBasicString() {
                do {
                    if (this.char === CHAR_BSOL) return this.call(this.parseEscape, this.recordEscapeReplacement);
                    if (this.char === CHAR_QUOT) return this.return();
                    if (this.atEndOfLine()) throw this.error(new TomlError("Unterminated string"));
                    if (this.char === CHAR_DEL || this.char <= CTRL_CHAR_BOUNDARY && this.char !== CTRL_I) throw this.errorControlCharInString();
                    this.consume();
                } while (this.nextChar());
            }
            recordEscapeReplacement(replacement) {
                return this.state.buf += replacement, this.goto(this.parseBasicString);
            }
            parseMultiStringMaybe() {
                return this.char === CHAR_QUOT ? this.next(this.parseMultiString) : this.returnNow();
            }
            parseMultiString() {
                return this.char === CTRL_M ? null : this.char === CTRL_J ? this.next(this.parseMultiStringContent) : this.goto(this.parseMultiStringContent);
            }
            parseMultiStringContent() {
                do {
                    if (this.char === CHAR_BSOL) return this.call(this.parseMultiEscape, this.recordMultiEscapeReplacement);
                    if (this.char === CHAR_QUOT) return this.next(this.parseMultiEnd);
                    if (this.char === Parser.END) throw this.error(new TomlError("Unterminated multi-line string"));
                    if (this.char === CHAR_DEL || this.char <= CTRL_CHAR_BOUNDARY && this.char !== CTRL_I && this.char !== CTRL_J && this.char !== CTRL_M) throw this.errorControlCharInString();
                    this.consume();
                } while (this.nextChar());
            }
            errorControlCharInString() {
                let displayCode = "\\u00";
                return this.char < 16 && (displayCode += "0"), displayCode += this.char.toString(16), 
                this.error(new TomlError(`Control characters (codes < 0x1f and 0x7f) are not allowed in strings, use ${displayCode} instead`));
            }
            recordMultiEscapeReplacement(replacement) {
                return this.state.buf += replacement, this.goto(this.parseMultiStringContent);
            }
            parseMultiEnd() {
                return this.char === CHAR_QUOT ? this.next(this.parseMultiEnd2) : (this.state.buf += '"', 
                this.goto(this.parseMultiStringContent));
            }
            parseMultiEnd2() {
                return this.char === CHAR_QUOT ? this.return() : (this.state.buf += '""', this.goto(this.parseMultiStringContent));
            }
            parseMultiEscape() {
                return this.char === CTRL_M || this.char === CTRL_J ? this.next(this.parseMultiTrim) : this.char === CHAR_SP || this.char === CTRL_I ? this.next(this.parsePreMultiTrim) : this.goto(this.parseEscape);
            }
            parsePreMultiTrim() {
                if (this.char === CHAR_SP || this.char === CTRL_I) return null;
                if (this.char === CTRL_M || this.char === CTRL_J) return this.next(this.parseMultiTrim);
                throw this.error(new TomlError("Can't escape whitespace"));
            }
            parseMultiTrim() {
                return this.char === CTRL_J || this.char === CHAR_SP || this.char === CTRL_I || this.char === CTRL_M ? null : this.returnNow();
            }
            parseEscape() {
                if (this.char in escapes) return this.return(escapes[this.char]);
                if (this.char === CHAR_u) return this.call(this.parseSmallUnicode, this.parseUnicodeReturn);
                if (this.char === CHAR_U) return this.call(this.parseLargeUnicode, this.parseUnicodeReturn);
                throw this.error(new TomlError("Unknown escape character: " + this.char));
            }
            parseUnicodeReturn(char) {
                try {
                    const codePoint = parseInt(char, 16);
                    if (codePoint >= SURROGATE_FIRST && codePoint <= SURROGATE_LAST) throw this.error(new TomlError("Invalid unicode, character in range 0xD800 - 0xDFFF is reserved"));
                    return this.returnNow(String.fromCodePoint(codePoint));
                } catch (err) {
                    throw this.error(TomlError.wrap(err));
                }
            }
            parseSmallUnicode() {
                if (!isHexit(this.char)) throw this.error(new TomlError("Invalid character in unicode sequence, expected hex"));
                if (this.consume(), this.state.buf.length >= 4) return this.return();
            }
            parseLargeUnicode() {
                if (!isHexit(this.char)) throw this.error(new TomlError("Invalid character in unicode sequence, expected hex"));
                if (this.consume(), this.state.buf.length >= 8) return this.return();
            }
            parseNumberSign() {
                return this.consume(), this.next(this.parseMaybeSignedInfOrNan);
            }
            parseMaybeSignedInfOrNan() {
                return this.char === CHAR_i ? this.next(this.parseInf) : this.char === CHAR_n ? this.next(this.parseNan) : this.callNow(this.parseNoUnder, this.parseNumberIntegerStart);
            }
            parseNumberIntegerStart() {
                return this.char === CHAR_0 ? (this.consume(), this.next(this.parseNumberIntegerExponentOrDecimal)) : this.goto(this.parseNumberInteger);
            }
            parseNumberIntegerExponentOrDecimal() {
                return this.char === CHAR_PERIOD ? (this.consume(), this.call(this.parseNoUnder, this.parseNumberFloat)) : this.char === CHAR_E || this.char === CHAR_e ? (this.consume(), 
                this.next(this.parseNumberExponentSign)) : this.returnNow(Integer(this.state.buf));
            }
            parseNumberInteger() {
                if (!isDigit(this.char)) {
                    if (this.char === CHAR_LOWBAR) return this.call(this.parseNoUnder);
                    if (this.char === CHAR_E || this.char === CHAR_e) return this.consume(), this.next(this.parseNumberExponentSign);
                    if (this.char === CHAR_PERIOD) return this.consume(), this.call(this.parseNoUnder, this.parseNumberFloat);
                    {
                        const result = Integer(this.state.buf);
                        if (result.isNaN()) throw this.error(new TomlError("Invalid number"));
                        return this.returnNow(result);
                    }
                }
                this.consume();
            }
            parseNoUnder() {
                if (this.char === CHAR_LOWBAR || this.char === CHAR_PERIOD || this.char === CHAR_E || this.char === CHAR_e) throw this.error(new TomlError("Unexpected character, expected digit"));
                if (this.atEndOfWord()) throw this.error(new TomlError("Incomplete number"));
                return this.returnNow();
            }
            parseNoUnderHexOctBinLiteral() {
                if (this.char === CHAR_LOWBAR || this.char === CHAR_PERIOD) throw this.error(new TomlError("Unexpected character, expected digit"));
                if (this.atEndOfWord()) throw this.error(new TomlError("Incomplete number"));
                return this.returnNow();
            }
            parseNumberFloat() {
                return this.char === CHAR_LOWBAR ? this.call(this.parseNoUnder, this.parseNumberFloat) : isDigit(this.char) ? void this.consume() : this.char === CHAR_E || this.char === CHAR_e ? (this.consume(), 
                this.next(this.parseNumberExponentSign)) : this.returnNow(Float(this.state.buf));
            }
            parseNumberExponentSign() {
                if (isDigit(this.char)) return this.goto(this.parseNumberExponent);
                if (this.char !== CHAR_HYPHEN && this.char !== CHAR_PLUS) throw this.error(new TomlError("Unexpected character, expected -, + or digit"));
                this.consume(), this.call(this.parseNoUnder, this.parseNumberExponent);
            }
            parseNumberExponent() {
                if (!isDigit(this.char)) return this.char === CHAR_LOWBAR ? this.call(this.parseNoUnder) : this.returnNow(Float(this.state.buf));
                this.consume();
            }
            parseNumberOrDateTime() {
                return this.char === CHAR_0 ? (this.consume(), this.next(this.parseNumberBaseOrDateTime)) : this.goto(this.parseNumberOrDateTimeOnly);
            }
            parseNumberOrDateTimeOnly() {
                return this.char === CHAR_LOWBAR ? this.call(this.parseNoUnder, this.parseNumberInteger) : isDigit(this.char) ? (this.consume(), 
                void (this.state.buf.length > 4 && this.next(this.parseNumberInteger))) : this.char === CHAR_E || this.char === CHAR_e ? (this.consume(), 
                this.next(this.parseNumberExponentSign)) : this.char === CHAR_PERIOD ? (this.consume(), 
                this.call(this.parseNoUnder, this.parseNumberFloat)) : this.char === CHAR_HYPHEN ? this.goto(this.parseDateTime) : this.char === CHAR_COLON ? this.goto(this.parseOnlyTimeHour) : this.returnNow(Integer(this.state.buf));
            }
            parseDateTimeOnly() {
                if (this.state.buf.length < 4) {
                    if (isDigit(this.char)) return this.consume();
                    if (this.char === CHAR_COLON) return this.goto(this.parseOnlyTimeHour);
                    throw this.error(new TomlError("Expected digit while parsing year part of a date"));
                }
                if (this.char === CHAR_HYPHEN) return this.goto(this.parseDateTime);
                throw this.error(new TomlError("Expected hyphen (-) while parsing year part of date"));
            }
            parseNumberBaseOrDateTime() {
                return this.char === CHAR_b ? (this.consume(), this.call(this.parseNoUnderHexOctBinLiteral, this.parseIntegerBin)) : this.char === CHAR_o ? (this.consume(), 
                this.call(this.parseNoUnderHexOctBinLiteral, this.parseIntegerOct)) : this.char === CHAR_x ? (this.consume(), 
                this.call(this.parseNoUnderHexOctBinLiteral, this.parseIntegerHex)) : this.char === CHAR_PERIOD ? this.goto(this.parseNumberInteger) : isDigit(this.char) ? this.goto(this.parseDateTimeOnly) : this.returnNow(Integer(this.state.buf));
            }
            parseIntegerHex() {
                if (!isHexit(this.char)) {
                    if (this.char === CHAR_LOWBAR) return this.call(this.parseNoUnderHexOctBinLiteral);
                    {
                        const result = Integer(this.state.buf);
                        if (result.isNaN()) throw this.error(new TomlError("Invalid number"));
                        return this.returnNow(result);
                    }
                }
                this.consume();
            }
            parseIntegerOct() {
                if (!isOctit(this.char)) {
                    if (this.char === CHAR_LOWBAR) return this.call(this.parseNoUnderHexOctBinLiteral);
                    {
                        const result = Integer(this.state.buf);
                        if (result.isNaN()) throw this.error(new TomlError("Invalid number"));
                        return this.returnNow(result);
                    }
                }
                this.consume();
            }
            parseIntegerBin() {
                if (!isBit(this.char)) {
                    if (this.char === CHAR_LOWBAR) return this.call(this.parseNoUnderHexOctBinLiteral);
                    {
                        const result = Integer(this.state.buf);
                        if (result.isNaN()) throw this.error(new TomlError("Invalid number"));
                        return this.returnNow(result);
                    }
                }
                this.consume();
            }
            parseDateTime() {
                if (this.state.buf.length < 4) throw this.error(new TomlError("Years less than 1000 must be zero padded to four characters"));
                return this.state.result = this.state.buf, this.state.buf = "", this.next(this.parseDateMonth);
            }
            parseDateMonth() {
                if (this.char === CHAR_HYPHEN) {
                    if (this.state.buf.length < 2) throw this.error(new TomlError("Months less than 10 must be zero padded to two characters"));
                    return this.state.result += "-" + this.state.buf, this.state.buf = "", this.next(this.parseDateDay);
                }
                if (!isDigit(this.char)) throw this.error(new TomlError("Incomplete datetime"));
                this.consume();
            }
            parseDateDay() {
                if (this.char === CHAR_T || this.char === CHAR_SP) {
                    if (this.state.buf.length < 2) throw this.error(new TomlError("Days less than 10 must be zero padded to two characters"));
                    return this.state.result += "-" + this.state.buf, this.state.buf = "", this.next(this.parseStartTimeHour);
                }
                if (this.atEndOfWord()) return this.returnNow(createDate(this.state.result + "-" + this.state.buf));
                if (!isDigit(this.char)) throw this.error(new TomlError("Incomplete datetime"));
                this.consume();
            }
            parseStartTimeHour() {
                return this.atEndOfWord() ? this.returnNow(createDate(this.state.result)) : this.goto(this.parseTimeHour);
            }
            parseTimeHour() {
                if (this.char === CHAR_COLON) {
                    if (this.state.buf.length < 2) throw this.error(new TomlError("Hours less than 10 must be zero padded to two characters"));
                    return this.state.result += "T" + this.state.buf, this.state.buf = "", this.next(this.parseTimeMin);
                }
                if (!isDigit(this.char)) throw this.error(new TomlError("Incomplete datetime"));
                this.consume();
            }
            parseTimeMin() {
                if (!(this.state.buf.length < 2 && isDigit(this.char))) {
                    if (2 === this.state.buf.length && this.char === CHAR_COLON) return this.state.result += ":" + this.state.buf, 
                    this.state.buf = "", this.next(this.parseTimeSec);
                    throw this.error(new TomlError("Incomplete datetime"));
                }
                this.consume();
            }
            parseTimeSec() {
                if (!isDigit(this.char)) throw this.error(new TomlError("Incomplete datetime"));
                if (this.consume(), 2 === this.state.buf.length) return this.state.result += ":" + this.state.buf, 
                this.state.buf = "", this.next(this.parseTimeZoneOrFraction);
            }
            parseOnlyTimeHour() {
                if (this.char === CHAR_COLON) {
                    if (this.state.buf.length < 2) throw this.error(new TomlError("Hours less than 10 must be zero padded to two characters"));
                    return this.state.result = this.state.buf, this.state.buf = "", this.next(this.parseOnlyTimeMin);
                }
                throw this.error(new TomlError("Incomplete time"));
            }
            parseOnlyTimeMin() {
                if (!(this.state.buf.length < 2 && isDigit(this.char))) {
                    if (2 === this.state.buf.length && this.char === CHAR_COLON) return this.state.result += ":" + this.state.buf, 
                    this.state.buf = "", this.next(this.parseOnlyTimeSec);
                    throw this.error(new TomlError("Incomplete time"));
                }
                this.consume();
            }
            parseOnlyTimeSec() {
                if (!isDigit(this.char)) throw this.error(new TomlError("Incomplete time"));
                if (this.consume(), 2 === this.state.buf.length) return this.next(this.parseOnlyTimeFractionMaybe);
            }
            parseOnlyTimeFractionMaybe() {
                if (this.state.result += ":" + this.state.buf, this.char !== CHAR_PERIOD) return this.return(createTime(this.state.result));
                this.state.buf = "", this.next(this.parseOnlyTimeFraction);
            }
            parseOnlyTimeFraction() {
                if (!isDigit(this.char)) {
                    if (this.atEndOfWord()) {
                        if (0 === this.state.buf.length) throw this.error(new TomlError("Expected digit in milliseconds"));
                        return this.returnNow(createTime(this.state.result + "." + this.state.buf));
                    }
                    throw this.error(new TomlError("Unexpected character in datetime, expected period (.), minus (-), plus (+) or Z"));
                }
                this.consume();
            }
            parseTimeZoneOrFraction() {
                if (this.char === CHAR_PERIOD) this.consume(), this.next(this.parseDateTimeFraction); else {
                    if (this.char !== CHAR_HYPHEN && this.char !== CHAR_PLUS) {
                        if (this.char === CHAR_Z) return this.consume(), this.return(createDateTime(this.state.result + this.state.buf));
                        if (this.atEndOfWord()) return this.returnNow(createDateTimeFloat(this.state.result + this.state.buf));
                        throw this.error(new TomlError("Unexpected character in datetime, expected period (.), minus (-), plus (+) or Z"));
                    }
                    this.consume(), this.next(this.parseTimeZoneHour);
                }
            }
            parseDateTimeFraction() {
                if (isDigit(this.char)) this.consume(); else {
                    if (1 === this.state.buf.length) throw this.error(new TomlError("Expected digit in milliseconds"));
                    if (this.char !== CHAR_HYPHEN && this.char !== CHAR_PLUS) {
                        if (this.char === CHAR_Z) return this.consume(), this.return(createDateTime(this.state.result + this.state.buf));
                        if (this.atEndOfWord()) return this.returnNow(createDateTimeFloat(this.state.result + this.state.buf));
                        throw this.error(new TomlError("Unexpected character in datetime, expected period (.), minus (-), plus (+) or Z"));
                    }
                    this.consume(), this.next(this.parseTimeZoneHour);
                }
            }
            parseTimeZoneHour() {
                if (!isDigit(this.char)) throw this.error(new TomlError("Unexpected character in datetime, expected digit"));
                if (this.consume(), /\d\d$/.test(this.state.buf)) return this.next(this.parseTimeZoneSep);
            }
            parseTimeZoneSep() {
                if (this.char !== CHAR_COLON) throw this.error(new TomlError("Unexpected character in datetime, expected colon"));
                this.consume(), this.next(this.parseTimeZoneMin);
            }
            parseTimeZoneMin() {
                if (!isDigit(this.char)) throw this.error(new TomlError("Unexpected character in datetime, expected digit"));
                if (this.consume(), /\d\d$/.test(this.state.buf)) return this.return(createDateTime(this.state.result + this.state.buf));
            }
            parseBoolean() {
                return this.char === CHAR_t ? (this.consume(), this.next(this.parseTrue_r)) : this.char === CHAR_f ? (this.consume(), 
                this.next(this.parseFalse_a)) : void 0;
            }
            parseTrue_r() {
                if (this.char === CHAR_r) return this.consume(), this.next(this.parseTrue_u);
                throw this.error(new TomlError("Invalid boolean, expected true or false"));
            }
            parseTrue_u() {
                if (this.char === CHAR_u) return this.consume(), this.next(this.parseTrue_e);
                throw this.error(new TomlError("Invalid boolean, expected true or false"));
            }
            parseTrue_e() {
                if (this.char === CHAR_e) return this.return(!0);
                throw this.error(new TomlError("Invalid boolean, expected true or false"));
            }
            parseFalse_a() {
                if (this.char === CHAR_a) return this.consume(), this.next(this.parseFalse_l);
                throw this.error(new TomlError("Invalid boolean, expected true or false"));
            }
            parseFalse_l() {
                if (this.char === CHAR_l) return this.consume(), this.next(this.parseFalse_s);
                throw this.error(new TomlError("Invalid boolean, expected true or false"));
            }
            parseFalse_s() {
                if (this.char === CHAR_s) return this.consume(), this.next(this.parseFalse_e);
                throw this.error(new TomlError("Invalid boolean, expected true or false"));
            }
            parseFalse_e() {
                if (this.char === CHAR_e) return this.return(!1);
                throw this.error(new TomlError("Invalid boolean, expected true or false"));
            }
            parseInlineList() {
                if (this.char === CHAR_SP || this.char === CTRL_I || this.char === CTRL_M || this.char === CTRL_J) return null;
                if (this.char === Parser.END) throw this.error(new TomlError("Unterminated inline array"));
                return this.char === CHAR_NUM ? this.call(this.parseComment) : this.char === CHAR_RSQB ? this.return(this.state.resultArr || InlineList()) : this.callNow(this.parseValue, this.recordInlineListValue);
            }
            recordInlineListValue(value) {
                if (this.state.resultArr) {
                    const listType = this.state.resultArr[_contentType], valueType = tomlType(value);
                    if (listType !== valueType) throw this.error(new TomlError(`Inline lists must be a single type, not a mix of ${listType} and ${valueType}`));
                } else this.state.resultArr = InlineList(tomlType(value));
                return isFloat(value) || isInteger(value) ? this.state.resultArr.push(value.valueOf()) : this.state.resultArr.push(value), 
                this.goto(this.parseInlineListNext);
            }
            parseInlineListNext() {
                if (this.char === CHAR_SP || this.char === CTRL_I || this.char === CTRL_M || this.char === CTRL_J) return null;
                if (this.char === CHAR_NUM) return this.call(this.parseComment);
                if (this.char === CHAR_COMMA) return this.next(this.parseInlineList);
                if (this.char === CHAR_RSQB) return this.goto(this.parseInlineList);
                throw this.error(new TomlError("Invalid character, expected whitespace, comma (,) or close bracket (])"));
            }
            parseInlineTable() {
                if (this.char === CHAR_SP || this.char === CTRL_I) return null;
                if (this.char === Parser.END || this.char === CHAR_NUM || this.char === CTRL_J || this.char === CTRL_M) throw this.error(new TomlError("Unterminated inline array"));
                return this.char === CHAR_RCUB ? this.return(this.state.resultTable || InlineTable()) : (this.state.resultTable || (this.state.resultTable = InlineTable()), 
                this.callNow(this.parseAssign, this.recordInlineTableValue));
            }
            recordInlineTableValue(kv) {
                let target = this.state.resultTable, finalKey = kv.key.pop();
                for (let kw of kv.key) {
                    if (hasKey(target, kw) && (!isTable(target[kw]) || target[kw][_declared])) throw this.error(new TomlError("Can't redefine existing key"));
                    target = target[kw] = target[kw] || Table();
                }
                if (hasKey(target, finalKey)) throw this.error(new TomlError("Can't redefine existing key"));
                return isInteger(kv.value) || isFloat(kv.value) ? target[finalKey] = kv.value.valueOf() : target[finalKey] = kv.value, 
                this.goto(this.parseInlineTableNext);
            }
            parseInlineTableNext() {
                if (this.char === CHAR_SP || this.char === CTRL_I) return null;
                if (this.char === Parser.END || this.char === CHAR_NUM || this.char === CTRL_J || this.char === CTRL_M) throw this.error(new TomlError("Unterminated inline array"));
                if (this.char === CHAR_COMMA) return this.next(this.parseInlineTable);
                if (this.char === CHAR_RCUB) return this.goto(this.parseInlineTable);
                throw this.error(new TomlError("Invalid character, expected whitespace, comma (,) or close bracket (])"));
            }
        };
    }
    return tomlParser.exports;
}

function requireParsePrettyError() {
    if (hasRequiredParsePrettyError) return parsePrettyError;
    return hasRequiredParsePrettyError = 1, parsePrettyError = function(err, buf) {
        if (null == err.pos || null == err.line) return err;
        let msg = err.message;
        if (msg += ` at row ${err.line + 1}, col ${err.col + 1}, pos ${err.pos}:\n`, buf && buf.split) {
            const lines = buf.split(/\n/), lineNumWidth = String(Math.min(lines.length, err.line + 3)).length;
            let linePadding = " ";
            for (;linePadding.length < lineNumWidth; ) linePadding += " ";
            for (let ii = Math.max(0, err.line - 1); ii < Math.min(lines.length, err.line + 2); ++ii) {
                let lineNum = String(ii + 1);
                if (lineNum.length < lineNumWidth && (lineNum = " " + lineNum), err.line === ii) {
                    msg += lineNum + "> " + lines[ii] + "\n", msg += linePadding + "  ";
                    for (let hh = 0; hh < err.col; ++hh) msg += " ";
                    msg += "^\n";
                } else msg += lineNum + ": " + lines[ii] + "\n";
            }
        }
        return err.message = msg + "\n", err;
    }, parsePrettyError;
}

function requireParseString() {
    if (hasRequiredParseString) return parseString_1;
    hasRequiredParseString = 1, parseString_1 = function(str) {
        commonjsGlobal.Buffer && commonjsGlobal.Buffer.isBuffer(str) && (str = str.toString("utf8"));
        const parser = new TOMLParser;
        try {
            return parser.parse(str), parser.finish();
        } catch (err) {
            throw prettyError(err, str);
        }
    };
    const TOMLParser = requireTomlParser(), prettyError = requireParsePrettyError();
    return parseString_1;
}

function requireParseAsync() {
    if (hasRequiredParseAsync) return parseAsync_1;
    hasRequiredParseAsync = 1, parseAsync_1 = function(str, opts) {
        opts || (opts = {});
        const blocksize = opts.blocksize || 40960, parser = new TOMLParser;
        return new Promise(((resolve, reject) => {
            setImmediate(parseAsyncNext, 0, blocksize, resolve, reject);
        }));
        function parseAsyncNext(index, blocksize, resolve, reject) {
            if (index >= str.length) try {
                return resolve(parser.finish());
            } catch (err) {
                return reject(prettyError(err, str));
            }
            try {
                parser.parse(str.slice(index, index + blocksize)), setImmediate(parseAsyncNext, index + blocksize, blocksize, resolve, reject);
            } catch (err) {
                reject(prettyError(err, str));
            }
        }
    };
    const TOMLParser = requireTomlParser(), prettyError = requireParsePrettyError();
    return parseAsync_1;
}

function requireParseStream() {
    if (hasRequiredParseStream) return parseStream_1;
    hasRequiredParseStream = 1, parseStream_1 = function(stm) {
        return stm ? function(stm) {
            const parser = new TOMLParser;
            return stm.setEncoding("utf8"), new Promise(((resolve, reject) => {
                let readable, ended = !1, errored = !1;
                function finish() {
                    if (ended = !0, !readable) try {
                        resolve(parser.finish());
                    } catch (err) {
                        reject(err);
                    }
                }
                function error(err) {
                    errored = !0, reject(err);
                }
                function readNext() {
                    let data;
                    for (readable = !0; null !== (data = stm.read()); ) try {
                        parser.parse(data);
                    } catch (err) {
                        return error(err);
                    }
                    if (readable = !1, ended) return finish();
                    errored || stm.once("readable", readNext);
                }
                stm.once("end", finish), stm.once("error", error), readNext();
            }));
        }(stm) : function() {
            const parser = new TOMLParser;
            return new stream.Transform({
                objectMode: !0,
                transform(chunk, encoding, cb) {
                    try {
                        parser.parse(chunk.toString(encoding));
                    } catch (err) {
                        this.emit("error", err);
                    }
                    cb();
                },
                flush(cb) {
                    try {
                        this.push(parser.finish());
                    } catch (err) {
                        this.emit("error", err);
                    }
                    cb();
                }
            });
        }();
    };
    const stream = Stream$1, TOMLParser = requireTomlParser();
    return parseStream_1;
}

function requireParse() {
    return hasRequiredParse || (hasRequiredParse = 1, parse$2.exports = requireParseString(), 
    parse$2.exports.async = requireParseAsync(), parse$2.exports.stream = requireParseStream(), 
    parse$2.exports.prettyError = requireParsePrettyError()), parse$2.exports;
}

var stringify$2 = {
    exports: {}
}, hasRequiredStringify$1, hasRequiredToml;

function requireStringify$1() {
    if (hasRequiredStringify$1) return stringify$2.exports;
    function typeError(type) {
        return new Error("Can only stringify objects, not " + type);
    }
    function getInlineKeys(obj) {
        return Object.keys(obj).filter((key => isInline(obj[key])));
    }
    function toJSON(obj) {
        let nobj = Array.isArray(obj) ? [] : Object.prototype.hasOwnProperty.call(obj, "__proto__") ? {
            ["__proto__"]: void 0
        } : {};
        for (let prop of Object.keys(obj)) obj[prop] && "function" == typeof obj[prop].toJSON && !("toISOString" in obj[prop]) ? nobj[prop] = obj[prop].toJSON() : nobj[prop] = obj[prop];
        return nobj;
    }
    function stringifyObject(prefix, indent, obj) {
        var inlineKeys, complexKeys;
        inlineKeys = getInlineKeys(obj = toJSON(obj)), complexKeys = function(obj) {
            return Object.keys(obj).filter((key => !isInline(obj[key])));
        }(obj);
        var result = [], inlineIndent = indent || "";
        inlineKeys.forEach((key => {
            var type = tomlType(obj[key]);
            "undefined" !== type && "null" !== type && result.push(inlineIndent + stringifyKey(key) + " = " + stringifyAnyInline(obj[key], !0));
        })), result.length > 0 && result.push("");
        var complexIndent = prefix && inlineKeys.length > 0 ? indent + "  " : "";
        return complexKeys.forEach((key => {
            result.push(function(prefix, indent, key, value) {
                var valueType = tomlType(value);
                if ("array" === valueType) return function(prefix, indent, key, values) {
                    validateArray(values = toJSON(values));
                    var firstValueType = tomlType(values[0]);
                    if ("table" !== firstValueType) throw typeError(firstValueType);
                    var fullKey = prefix + stringifyKey(key), result = "";
                    return values.forEach((table => {
                        result.length > 0 && (result += "\n"), result += indent + "[[" + fullKey + "]]\n", 
                        result += stringifyObject(fullKey + ".", indent, table);
                    })), result;
                }(prefix, indent, key, value);
                if ("table" === valueType) return function(prefix, indent, key, value) {
                    var fullKey = prefix + stringifyKey(key), result = "";
                    getInlineKeys(value).length > 0 && (result += indent + "[" + fullKey + "]\n");
                    return result + stringifyObject(fullKey + ".", indent, value);
                }(prefix, indent, key, value);
                throw typeError(valueType);
            }(prefix, complexIndent, key, obj[key]));
        })), result.join("\n");
    }
    function isInline(value) {
        switch (tomlType(value)) {
          case "undefined":
          case "null":
          case "integer":
          case "nan":
          case "float":
          case "boolean":
          case "string":
          case "datetime":
            return !0;

          case "array":
            return 0 === value.length || "table" !== tomlType(value[0]);

          case "table":
            return 0 === Object.keys(value).length;

          default:
            return !1;
        }
    }
    function tomlType(value) {
        return void 0 === value ? "undefined" : null === value ? "null" : "bigint" == typeof value || Number.isInteger(value) && !Object.is(value, -0) ? "integer" : "number" == typeof value ? "float" : "boolean" == typeof value ? "boolean" : "string" == typeof value ? "string" : "toISOString" in value ? isNaN(value) ? "undefined" : "datetime" : Array.isArray(value) ? "array" : "table";
    }
    function stringifyKey(key) {
        var keyStr = String(key);
        return /^[-A-Za-z0-9_]+$/.test(keyStr) ? keyStr : stringifyBasicString(keyStr);
    }
    function stringifyBasicString(str) {
        return '"' + escapeString(str).replace(/"/g, '\\"') + '"';
    }
    function escapeString(str) {
        return str.replace(/\\/g, "\\\\").replace(/[\b]/g, "\\b").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\f/g, "\\f").replace(/\r/g, "\\r").replace(/([\u0000-\u001f\u007f])/, (c => "\\u" + function(num, str) {
            for (;str.length < num; ) str = "0" + str;
            return str;
        }(4, c.codePointAt(0).toString(16))));
    }
    function stringifyAnyInline(value, multilineOk) {
        let type = tomlType(value);
        return "string" === type && (multilineOk && /\n/.test(value) ? type = "string-multiline" : !/[\b\t\n\f\r']/.test(value) && /"/.test(value) && (type = "string-literal")), 
        stringifyInline(value, type);
    }
    function stringifyInline(value, type) {
        switch (type || (type = tomlType(value)), type) {
          case "string-multiline":
            return function(str) {
                let escaped = str.split(/\n/).map((str => escapeString(str).replace(/"(?="")/g, '\\"'))).join("\n");
                return '"' === escaped.slice(-1) && (escaped += "\\\n"), '"""\n' + escaped + '"""';
            }(value);

          case "string":
            return stringifyBasicString(value);

          case "string-literal":
            return "'" + value + "'";

          case "integer":
            return stringifyInteger(value);

          case "float":
            return function(value) {
                if (value === 1 / 0) return "inf";
                if (value === -1 / 0) return "-inf";
                if (Object.is(value, NaN)) return "nan";
                if (Object.is(value, -0)) return "-0.0";
                var chunks = String(value).split("."), int = chunks[0], dec = chunks[1] || 0;
                return stringifyInteger(int) + "." + dec;
            }(value);

          case "boolean":
            return function(value) {
                return String(value);
            }(value);

          case "datetime":
            return function(value) {
                return value.toISOString();
            }(value);

          case "array":
            return function(values) {
                const type = validateArray(values = toJSON(values));
                var result = "[", stringified = values.map((_ => stringifyInline(_, type)));
                stringified.join(", ").length > 60 || /\n/.test(stringified) ? result += "\n  " + stringified.join(",\n  ") + "\n" : result += " " + stringified.join(", ") + (stringified.length > 0 ? " " : "");
                return result + "]";
            }(value.filter((_ => "null" !== tomlType(_) && "undefined" !== tomlType(_) && "nan" !== tomlType(_))));

          case "table":
            return function(value) {
                value = toJSON(value);
                var result = [];
                return Object.keys(value).forEach((key => {
                    result.push(stringifyKey(key) + " = " + stringifyAnyInline(value[key], !1));
                })), "{ " + result.join(", ") + (result.length > 0 ? " " : "") + "}";
            }(value);

          default:
            throw typeError(type);
        }
    }
    function stringifyInteger(value) {
        return String(value).replace(/\B(?=(\d{3})+(?!\d))/g, "_");
    }
    function validateArray(values) {
        const type = function(values) {
            var contentType = tomlType(values[0]);
            return values.every((_ => tomlType(_) === contentType)) ? contentType : values.every((_ => function(type) {
                return "float" === type || "integer" === type;
            }(tomlType(_)))) ? "float" : "mixed";
        }(values);
        if ("mixed" === type) throw new Error("Array values can't have mixed types");
        return type;
    }
    return hasRequiredStringify$1 = 1, stringify$2.exports = function(obj) {
        if (null === obj) throw typeError("null");
        if (void 0 === obj) throw typeError("undefined");
        if ("object" != typeof obj) throw typeError(typeof obj);
        "function" == typeof obj.toJSON && (obj = obj.toJSON());
        if (null == obj) return null;
        const type = tomlType(obj);
        if ("table" !== type) throw typeError(type);
        return stringifyObject("", "", obj);
    }, stringify$2.exports.value = stringifyInline, stringify$2.exports;
}

function requireToml() {
    return hasRequiredToml || (hasRequiredToml = 1, toml.parse = requireParse(), toml.stringify = requireStringify$1()), 
    toml;
}

var tomlExports = requireToml(), dist = {}, composer = {}, directives = {}, identity = {}, hasRequiredIdentity;

function requireIdentity() {
    if (hasRequiredIdentity) return identity;
    hasRequiredIdentity = 1;
    const ALIAS = Symbol.for("yaml.alias"), DOC = Symbol.for("yaml.document"), MAP = Symbol.for("yaml.map"), PAIR = Symbol.for("yaml.pair"), SCALAR = Symbol.for("yaml.scalar"), SEQ = Symbol.for("yaml.seq"), NODE_TYPE = Symbol.for("yaml.node.type"), isScalar = node => !!node && "object" == typeof node && node[NODE_TYPE] === SCALAR;
    function isCollection(node) {
        if (node && "object" == typeof node) switch (node[NODE_TYPE]) {
          case MAP:
          case SEQ:
            return !0;
        }
        return !1;
    }
    return identity.ALIAS = ALIAS, identity.DOC = DOC, identity.MAP = MAP, identity.NODE_TYPE = NODE_TYPE, 
    identity.PAIR = PAIR, identity.SCALAR = SCALAR, identity.SEQ = SEQ, identity.hasAnchor = node => (isScalar(node) || isCollection(node)) && !!node.anchor, 
    identity.isAlias = node => !!node && "object" == typeof node && node[NODE_TYPE] === ALIAS, 
    identity.isCollection = isCollection, identity.isDocument = node => !!node && "object" == typeof node && node[NODE_TYPE] === DOC, 
    identity.isMap = node => !!node && "object" == typeof node && node[NODE_TYPE] === MAP, 
    identity.isNode = function(node) {
        if (node && "object" == typeof node) switch (node[NODE_TYPE]) {
          case ALIAS:
          case MAP:
          case SCALAR:
          case SEQ:
            return !0;
        }
        return !1;
    }, identity.isPair = node => !!node && "object" == typeof node && node[NODE_TYPE] === PAIR, 
    identity.isScalar = isScalar, identity.isSeq = node => !!node && "object" == typeof node && node[NODE_TYPE] === SEQ, 
    identity;
}

var visit = {}, hasRequiredVisit, hasRequiredDirectives;

function requireVisit() {
    if (hasRequiredVisit) return visit;
    hasRequiredVisit = 1;
    var identity = requireIdentity();
    const BREAK = Symbol("break visit"), SKIP = Symbol("skip children"), REMOVE = Symbol("remove node");
    function visit$1(node, visitor) {
        const visitor_ = initVisitor(visitor);
        if (identity.isDocument(node)) {
            visit_(null, node.contents, visitor_, Object.freeze([ node ])) === REMOVE && (node.contents = null);
        } else visit_(null, node, visitor_, Object.freeze([]));
    }
    function visit_(key, node, visitor, path) {
        const ctrl = callVisitor(key, node, visitor, path);
        if (identity.isNode(ctrl) || identity.isPair(ctrl)) return replaceNode(key, path, ctrl), 
        visit_(key, ctrl, visitor, path);
        if ("symbol" != typeof ctrl) if (identity.isCollection(node)) {
            path = Object.freeze(path.concat(node));
            for (let i = 0; i < node.items.length; ++i) {
                const ci = visit_(i, node.items[i], visitor, path);
                if ("number" == typeof ci) i = ci - 1; else {
                    if (ci === BREAK) return BREAK;
                    ci === REMOVE && (node.items.splice(i, 1), i -= 1);
                }
            }
        } else if (identity.isPair(node)) {
            path = Object.freeze(path.concat(node));
            const ck = visit_("key", node.key, visitor, path);
            if (ck === BREAK) return BREAK;
            ck === REMOVE && (node.key = null);
            const cv = visit_("value", node.value, visitor, path);
            if (cv === BREAK) return BREAK;
            cv === REMOVE && (node.value = null);
        }
        return ctrl;
    }
    async function visitAsync(node, visitor) {
        const visitor_ = initVisitor(visitor);
        if (identity.isDocument(node)) {
            await visitAsync_(null, node.contents, visitor_, Object.freeze([ node ])) === REMOVE && (node.contents = null);
        } else await visitAsync_(null, node, visitor_, Object.freeze([]));
    }
    async function visitAsync_(key, node, visitor, path) {
        const ctrl = await callVisitor(key, node, visitor, path);
        if (identity.isNode(ctrl) || identity.isPair(ctrl)) return replaceNode(key, path, ctrl), 
        visitAsync_(key, ctrl, visitor, path);
        if ("symbol" != typeof ctrl) if (identity.isCollection(node)) {
            path = Object.freeze(path.concat(node));
            for (let i = 0; i < node.items.length; ++i) {
                const ci = await visitAsync_(i, node.items[i], visitor, path);
                if ("number" == typeof ci) i = ci - 1; else {
                    if (ci === BREAK) return BREAK;
                    ci === REMOVE && (node.items.splice(i, 1), i -= 1);
                }
            }
        } else if (identity.isPair(node)) {
            path = Object.freeze(path.concat(node));
            const ck = await visitAsync_("key", node.key, visitor, path);
            if (ck === BREAK) return BREAK;
            ck === REMOVE && (node.key = null);
            const cv = await visitAsync_("value", node.value, visitor, path);
            if (cv === BREAK) return BREAK;
            cv === REMOVE && (node.value = null);
        }
        return ctrl;
    }
    function initVisitor(visitor) {
        return "object" == typeof visitor && (visitor.Collection || visitor.Node || visitor.Value) ? Object.assign({
            Alias: visitor.Node,
            Map: visitor.Node,
            Scalar: visitor.Node,
            Seq: visitor.Node
        }, visitor.Value && {
            Map: visitor.Value,
            Scalar: visitor.Value,
            Seq: visitor.Value
        }, visitor.Collection && {
            Map: visitor.Collection,
            Seq: visitor.Collection
        }, visitor) : visitor;
    }
    function callVisitor(key, node, visitor, path) {
        return "function" == typeof visitor ? visitor(key, node, path) : identity.isMap(node) ? visitor.Map?.(key, node, path) : identity.isSeq(node) ? visitor.Seq?.(key, node, path) : identity.isPair(node) ? visitor.Pair?.(key, node, path) : identity.isScalar(node) ? visitor.Scalar?.(key, node, path) : identity.isAlias(node) ? visitor.Alias?.(key, node, path) : void 0;
    }
    function replaceNode(key, path, node) {
        const parent = path[path.length - 1];
        if (identity.isCollection(parent)) parent.items[key] = node; else if (identity.isPair(parent)) "key" === key ? parent.key = node : parent.value = node; else {
            if (!identity.isDocument(parent)) {
                const pt = identity.isAlias(parent) ? "alias" : "scalar";
                throw new Error(`Cannot replace node with ${pt} parent`);
            }
            parent.contents = node;
        }
    }
    return visit$1.BREAK = BREAK, visit$1.SKIP = SKIP, visit$1.REMOVE = REMOVE, visitAsync.BREAK = BREAK, 
    visitAsync.SKIP = SKIP, visitAsync.REMOVE = REMOVE, visit.visit = visit$1, visit.visitAsync = visitAsync, 
    visit;
}

function requireDirectives() {
    if (hasRequiredDirectives) return directives;
    hasRequiredDirectives = 1;
    var identity = requireIdentity(), visit = requireVisit();
    const escapeChars = {
        "!": "%21",
        ",": "%2C",
        "[": "%5B",
        "]": "%5D",
        "{": "%7B",
        "}": "%7D"
    };
    class Directives {
        constructor(yaml, tags) {
            this.docStart = null, this.docEnd = !1, this.yaml = Object.assign({}, Directives.defaultYaml, yaml), 
            this.tags = Object.assign({}, Directives.defaultTags, tags);
        }
        clone() {
            const copy = new Directives(this.yaml, this.tags);
            return copy.docStart = this.docStart, copy;
        }
        atDocument() {
            const res = new Directives(this.yaml, this.tags);
            switch (this.yaml.version) {
              case "1.1":
                this.atNextDocument = !0;
                break;

              case "1.2":
                this.atNextDocument = !1, this.yaml = {
                    explicit: Directives.defaultYaml.explicit,
                    version: "1.2"
                }, this.tags = Object.assign({}, Directives.defaultTags);
            }
            return res;
        }
        add(line, onError) {
            this.atNextDocument && (this.yaml = {
                explicit: Directives.defaultYaml.explicit,
                version: "1.1"
            }, this.tags = Object.assign({}, Directives.defaultTags), this.atNextDocument = !1);
            const parts = line.trim().split(/[ \t]+/), name = parts.shift();
            switch (name) {
              case "%TAG":
                {
                    if (2 !== parts.length && (onError(0, "%TAG directive should contain exactly two parts"), 
                    parts.length < 2)) return !1;
                    const [handle, prefix] = parts;
                    return this.tags[handle] = prefix, !0;
                }

              case "%YAML":
                {
                    if (this.yaml.explicit = !0, 1 !== parts.length) return onError(0, "%YAML directive should contain exactly one part"), 
                    !1;
                    const [version] = parts;
                    if ("1.1" === version || "1.2" === version) return this.yaml.version = version, 
                    !0;
                    return onError(6, `Unsupported YAML version ${version}`, /^\d+\.\d+$/.test(version)), 
                    !1;
                }

              default:
                return onError(0, `Unknown directive ${name}`, !0), !1;
            }
        }
        tagName(source, onError) {
            if ("!" === source) return "!";
            if ("!" !== source[0]) return onError(`Not a valid tag: ${source}`), null;
            if ("<" === source[1]) {
                const verbatim = source.slice(2, -1);
                return "!" === verbatim || "!!" === verbatim ? (onError(`Verbatim tags aren't resolved, so ${source} is invalid.`), 
                null) : (">" !== source[source.length - 1] && onError("Verbatim tags must end with a >"), 
                verbatim);
            }
            const [, handle, suffix] = source.match(/^(.*!)([^!]*)$/s);
            suffix || onError(`The ${source} tag has no suffix`);
            const prefix = this.tags[handle];
            if (prefix) try {
                return prefix + decodeURIComponent(suffix);
            } catch (error) {
                return onError(String(error)), null;
            }
            return "!" === handle ? source : (onError(`Could not resolve tag: ${source}`), null);
        }
        tagString(tag) {
            for (const [handle, prefix] of Object.entries(this.tags)) if (tag.startsWith(prefix)) return handle + tag.substring(prefix.length).replace(/[!,[\]{}]/g, (ch => escapeChars[ch]));
            return "!" === tag[0] ? tag : `!<${tag}>`;
        }
        toString(doc) {
            const lines = this.yaml.explicit ? [ `%YAML ${this.yaml.version || "1.2"}` ] : [], tagEntries = Object.entries(this.tags);
            let tagNames;
            if (doc && tagEntries.length > 0 && identity.isNode(doc.contents)) {
                const tags = {};
                visit.visit(doc.contents, ((_key, node) => {
                    identity.isNode(node) && node.tag && (tags[node.tag] = !0);
                })), tagNames = Object.keys(tags);
            } else tagNames = [];
            for (const [handle, prefix] of tagEntries) "!!" === handle && "tag:yaml.org,2002:" === prefix || doc && !tagNames.some((tn => tn.startsWith(prefix))) || lines.push(`%TAG ${handle} ${prefix}`);
            return lines.join("\n");
        }
    }
    return Directives.defaultYaml = {
        explicit: !1,
        version: "1.2"
    }, Directives.defaultTags = {
        "!!": "tag:yaml.org,2002:"
    }, directives.Directives = Directives, directives;
}

var Document = {}, Alias = {}, anchors = {}, hasRequiredAnchors;

function requireAnchors() {
    if (hasRequiredAnchors) return anchors;
    hasRequiredAnchors = 1;
    var identity = requireIdentity(), visit = requireVisit();
    function anchorNames(root) {
        const anchors = new Set;
        return visit.visit(root, {
            Value(_key, node) {
                node.anchor && anchors.add(node.anchor);
            }
        }), anchors;
    }
    function findNewAnchor(prefix, exclude) {
        for (let i = 1; ;++i) {
            const name = `${prefix}${i}`;
            if (!exclude.has(name)) return name;
        }
    }
    return anchors.anchorIsValid = function(anchor) {
        if (/[\x00-\x19\s,[\]{}]/.test(anchor)) {
            const sa = JSON.stringify(anchor);
            throw new Error(`Anchor must not contain whitespace or control characters: ${sa}`);
        }
        return !0;
    }, anchors.anchorNames = anchorNames, anchors.createNodeAnchors = function(doc, prefix) {
        const aliasObjects = [], sourceObjects = new Map;
        let prevAnchors = null;
        return {
            onAnchor: source => {
                aliasObjects.push(source), prevAnchors || (prevAnchors = anchorNames(doc));
                const anchor = findNewAnchor(prefix, prevAnchors);
                return prevAnchors.add(anchor), anchor;
            },
            setAnchors: () => {
                for (const source of aliasObjects) {
                    const ref = sourceObjects.get(source);
                    if ("object" != typeof ref || !ref.anchor || !identity.isScalar(ref.node) && !identity.isCollection(ref.node)) {
                        const error = new Error("Failed to resolve repeated object (this should not happen)");
                        throw error.source = source, error;
                    }
                    ref.node.anchor = ref.anchor;
                }
            },
            sourceObjects: sourceObjects
        };
    }, anchors.findNewAnchor = findNewAnchor, anchors;
}

var Node = {}, applyReviver = {}, hasRequiredApplyReviver;

function requireApplyReviver() {
    if (hasRequiredApplyReviver) return applyReviver;
    return hasRequiredApplyReviver = 1, applyReviver.applyReviver = function applyReviver$1(reviver, obj, key, val) {
        if (val && "object" == typeof val) if (Array.isArray(val)) for (let i = 0, len = val.length; i < len; ++i) {
            const v0 = val[i], v1 = applyReviver$1(reviver, val, String(i), v0);
            void 0 === v1 ? delete val[i] : v1 !== v0 && (val[i] = v1);
        } else if (val instanceof Map) for (const k of Array.from(val.keys())) {
            const v0 = val.get(k), v1 = applyReviver$1(reviver, val, k, v0);
            void 0 === v1 ? val.delete(k) : v1 !== v0 && val.set(k, v1);
        } else if (val instanceof Set) for (const v0 of Array.from(val)) {
            const v1 = applyReviver$1(reviver, val, v0, v0);
            void 0 === v1 ? val.delete(v0) : v1 !== v0 && (val.delete(v0), val.add(v1));
        } else for (const [k, v0] of Object.entries(val)) {
            const v1 = applyReviver$1(reviver, val, k, v0);
            void 0 === v1 ? delete val[k] : v1 !== v0 && (val[k] = v1);
        }
        return reviver.call(obj, key, val);
    }, applyReviver;
}

var toJS = {}, hasRequiredToJS, hasRequiredNode$1, hasRequiredAlias;

function requireToJS() {
    if (hasRequiredToJS) return toJS;
    hasRequiredToJS = 1;
    var identity = requireIdentity();
    return toJS.toJS = function toJS$1(value, arg, ctx) {
        if (Array.isArray(value)) return value.map(((v, i) => toJS$1(v, String(i), ctx)));
        if (value && "function" == typeof value.toJSON) {
            if (!ctx || !identity.hasAnchor(value)) return value.toJSON(arg, ctx);
            const data = {
                aliasCount: 0,
                count: 1,
                res: void 0
            };
            ctx.anchors.set(value, data), ctx.onCreate = res => {
                data.res = res, delete ctx.onCreate;
            };
            const res = value.toJSON(arg, ctx);
            return ctx.onCreate && ctx.onCreate(res), res;
        }
        return "bigint" != typeof value || ctx?.keep ? value : Number(value);
    }, toJS;
}

function requireNode$1() {
    if (hasRequiredNode$1) return Node;
    hasRequiredNode$1 = 1;
    var applyReviver = requireApplyReviver(), identity = requireIdentity(), toJS = requireToJS();
    return Node.NodeBase = class {
        constructor(type) {
            Object.defineProperty(this, identity.NODE_TYPE, {
                value: type
            });
        }
        clone() {
            const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
            return this.range && (copy.range = this.range.slice()), copy;
        }
        toJS(doc, {mapAsMap: mapAsMap, maxAliasCount: maxAliasCount, onAnchor: onAnchor, reviver: reviver} = {}) {
            if (!identity.isDocument(doc)) throw new TypeError("A document argument is required");
            const ctx = {
                anchors: new Map,
                doc: doc,
                keep: !0,
                mapAsMap: !0 === mapAsMap,
                mapKeyWarned: !1,
                maxAliasCount: "number" == typeof maxAliasCount ? maxAliasCount : 100
            }, res = toJS.toJS(this, "", ctx);
            if ("function" == typeof onAnchor) for (const {count: count, res: res} of ctx.anchors.values()) onAnchor(res, count);
            return "function" == typeof reviver ? applyReviver.applyReviver(reviver, {
                "": res
            }, "", res) : res;
        }
    }, Node;
}

function requireAlias() {
    if (hasRequiredAlias) return Alias;
    hasRequiredAlias = 1;
    var anchors = requireAnchors(), visit = requireVisit(), identity = requireIdentity(), Node = requireNode$1(), toJS = requireToJS();
    let Alias$1 = class extends Node.NodeBase {
        constructor(source) {
            super(identity.ALIAS), this.source = source, Object.defineProperty(this, "tag", {
                set() {
                    throw new Error("Alias nodes cannot have tags");
                }
            });
        }
        resolve(doc) {
            let found;
            return visit.visit(doc, {
                Node: (_key, node) => {
                    if (node === this) return visit.visit.BREAK;
                    node.anchor === this.source && (found = node);
                }
            }), found;
        }
        toJSON(_arg, ctx) {
            if (!ctx) return {
                source: this.source
            };
            const {anchors: anchors, doc: doc, maxAliasCount: maxAliasCount} = ctx, source = this.resolve(doc);
            if (!source) {
                const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
                throw new ReferenceError(msg);
            }
            let data = anchors.get(source);
            if (data || (toJS.toJS(source, null, ctx), data = anchors.get(source)), !data || void 0 === data.res) {
                throw new ReferenceError("This should not happen: Alias anchor was not resolved?");
            }
            if (maxAliasCount >= 0 && (data.count += 1, 0 === data.aliasCount && (data.aliasCount = getAliasCount(doc, source, anchors)), 
            data.count * data.aliasCount > maxAliasCount)) {
                throw new ReferenceError("Excessive alias count indicates a resource exhaustion attack");
            }
            return data.res;
        }
        toString(ctx, _onComment, _onChompKeep) {
            const src = `*${this.source}`;
            if (ctx) {
                if (anchors.anchorIsValid(this.source), ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {
                    const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
                    throw new Error(msg);
                }
                if (ctx.implicitKey) return `${src} `;
            }
            return src;
        }
    };
    function getAliasCount(doc, node, anchors) {
        if (identity.isAlias(node)) {
            const source = node.resolve(doc), anchor = anchors && source && anchors.get(source);
            return anchor ? anchor.count * anchor.aliasCount : 0;
        }
        if (identity.isCollection(node)) {
            let count = 0;
            for (const item of node.items) {
                const c = getAliasCount(doc, item, anchors);
                c > count && (count = c);
            }
            return count;
        }
        if (identity.isPair(node)) {
            const kc = getAliasCount(doc, node.key, anchors), vc = getAliasCount(doc, node.value, anchors);
            return Math.max(kc, vc);
        }
        return 1;
    }
    return Alias.Alias = Alias$1, Alias;
}

var Collection = {}, createNode = {}, Scalar = {}, hasRequiredScalar, hasRequiredCreateNode, hasRequiredCollection;

function requireScalar() {
    if (hasRequiredScalar) return Scalar;
    hasRequiredScalar = 1;
    var identity = requireIdentity(), Node = requireNode$1(), toJS = requireToJS();
    let Scalar$1 = class extends Node.NodeBase {
        constructor(value) {
            super(identity.SCALAR), this.value = value;
        }
        toJSON(arg, ctx) {
            return ctx?.keep ? this.value : toJS.toJS(this.value, arg, ctx);
        }
        toString() {
            return String(this.value);
        }
    };
    return Scalar$1.BLOCK_FOLDED = "BLOCK_FOLDED", Scalar$1.BLOCK_LITERAL = "BLOCK_LITERAL", 
    Scalar$1.PLAIN = "PLAIN", Scalar$1.QUOTE_DOUBLE = "QUOTE_DOUBLE", Scalar$1.QUOTE_SINGLE = "QUOTE_SINGLE", 
    Scalar.Scalar = Scalar$1, Scalar.isScalarValue = value => !value || "function" != typeof value && "object" != typeof value, 
    Scalar;
}

function requireCreateNode() {
    if (hasRequiredCreateNode) return createNode;
    hasRequiredCreateNode = 1;
    var Alias = requireAlias(), identity = requireIdentity(), Scalar = requireScalar();
    return createNode.createNode = function(value, tagName, ctx) {
        if (identity.isDocument(value) && (value = value.contents), identity.isNode(value)) return value;
        if (identity.isPair(value)) {
            const map = ctx.schema[identity.MAP].createNode?.(ctx.schema, null, ctx);
            return map.items.push(value), map;
        }
        (value instanceof String || value instanceof Number || value instanceof Boolean || "undefined" != typeof BigInt && value instanceof BigInt) && (value = value.valueOf());
        const {aliasDuplicateObjects: aliasDuplicateObjects, onAnchor: onAnchor, onTagObj: onTagObj, schema: schema, sourceObjects: sourceObjects} = ctx;
        let ref;
        if (aliasDuplicateObjects && value && "object" == typeof value) {
            if (ref = sourceObjects.get(value), ref) return ref.anchor || (ref.anchor = onAnchor(value)), 
            new Alias.Alias(ref.anchor);
            ref = {
                anchor: null,
                node: null
            }, sourceObjects.set(value, ref);
        }
        tagName?.startsWith("!!") && (tagName = "tag:yaml.org,2002:" + tagName.slice(2));
        let tagObj = function(value, tagName, tags) {
            if (tagName) {
                const match = tags.filter((t => t.tag === tagName)), tagObj = match.find((t => !t.format)) ?? match[0];
                if (!tagObj) throw new Error(`Tag ${tagName} not found`);
                return tagObj;
            }
            return tags.find((t => t.identify?.(value) && !t.format));
        }(value, tagName, schema.tags);
        if (!tagObj) {
            if (value && "function" == typeof value.toJSON && (value = value.toJSON()), !value || "object" != typeof value) {
                const node = new Scalar.Scalar(value);
                return ref && (ref.node = node), node;
            }
            tagObj = value instanceof Map ? schema[identity.MAP] : Symbol.iterator in Object(value) ? schema[identity.SEQ] : schema[identity.MAP];
        }
        onTagObj && (onTagObj(tagObj), delete ctx.onTagObj);
        const node = tagObj?.createNode ? tagObj.createNode(ctx.schema, value, ctx) : "function" == typeof tagObj?.nodeClass?.from ? tagObj.nodeClass.from(ctx.schema, value, ctx) : new Scalar.Scalar(value);
        return tagName ? node.tag = tagName : tagObj.default || (node.tag = tagObj.tag), 
        ref && (ref.node = node), node;
    }, createNode;
}

function requireCollection() {
    if (hasRequiredCollection) return Collection;
    hasRequiredCollection = 1;
    var createNode = requireCreateNode(), identity = requireIdentity(), Node = requireNode$1();
    function collectionFromPath(schema, path, value) {
        let v = value;
        for (let i = path.length - 1; i >= 0; --i) {
            const k = path[i];
            if ("number" == typeof k && Number.isInteger(k) && k >= 0) {
                const a = [];
                a[k] = v, v = a;
            } else v = new Map([ [ k, v ] ]);
        }
        return createNode.createNode(v, void 0, {
            aliasDuplicateObjects: !1,
            keepUndefined: !1,
            onAnchor: () => {
                throw new Error("This should not happen, please report a bug.");
            },
            schema: schema,
            sourceObjects: new Map
        });
    }
    const isEmptyPath = path => null == path || "object" == typeof path && !!path[Symbol.iterator]().next().done;
    let Collection$1 = class extends Node.NodeBase {
        constructor(type, schema) {
            super(type), Object.defineProperty(this, "schema", {
                value: schema,
                configurable: !0,
                enumerable: !1,
                writable: !0
            });
        }
        clone(schema) {
            const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
            return schema && (copy.schema = schema), copy.items = copy.items.map((it => identity.isNode(it) || identity.isPair(it) ? it.clone(schema) : it)), 
            this.range && (copy.range = this.range.slice()), copy;
        }
        addIn(path, value) {
            if (isEmptyPath(path)) this.add(value); else {
                const [key, ...rest] = path, node = this.get(key, !0);
                if (identity.isCollection(node)) node.addIn(rest, value); else {
                    if (void 0 !== node || !this.schema) throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
                    this.set(key, collectionFromPath(this.schema, rest, value));
                }
            }
        }
        deleteIn(path) {
            const [key, ...rest] = path;
            if (0 === rest.length) return this.delete(key);
            const node = this.get(key, !0);
            if (identity.isCollection(node)) return node.deleteIn(rest);
            throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
        }
        getIn(path, keepScalar) {
            const [key, ...rest] = path, node = this.get(key, !0);
            return 0 === rest.length ? !keepScalar && identity.isScalar(node) ? node.value : node : identity.isCollection(node) ? node.getIn(rest, keepScalar) : void 0;
        }
        hasAllNullValues(allowScalar) {
            return this.items.every((node => {
                if (!identity.isPair(node)) return !1;
                const n = node.value;
                return null == n || allowScalar && identity.isScalar(n) && null == n.value && !n.commentBefore && !n.comment && !n.tag;
            }));
        }
        hasIn(path) {
            const [key, ...rest] = path;
            if (0 === rest.length) return this.has(key);
            const node = this.get(key, !0);
            return !!identity.isCollection(node) && node.hasIn(rest);
        }
        setIn(path, value) {
            const [key, ...rest] = path;
            if (0 === rest.length) this.set(key, value); else {
                const node = this.get(key, !0);
                if (identity.isCollection(node)) node.setIn(rest, value); else {
                    if (void 0 !== node || !this.schema) throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
                    this.set(key, collectionFromPath(this.schema, rest, value));
                }
            }
        }
    };
    return Collection.Collection = Collection$1, Collection.collectionFromPath = collectionFromPath, 
    Collection.isEmptyPath = isEmptyPath, Collection;
}

var Pair = {}, stringifyPair = {}, stringify$1 = {}, stringifyComment = {}, hasRequiredStringifyComment;

function requireStringifyComment() {
    if (hasRequiredStringifyComment) return stringifyComment;
    hasRequiredStringifyComment = 1;
    function indentComment(comment, indent) {
        return /^\n+$/.test(comment) ? comment.substring(1) : indent ? comment.replace(/^(?! *$)/gm, indent) : comment;
    }
    return stringifyComment.indentComment = indentComment, stringifyComment.lineComment = (str, indent, comment) => str.endsWith("\n") ? indentComment(comment, indent) : comment.includes("\n") ? "\n" + indentComment(comment, indent) : (str.endsWith(" ") ? "" : " ") + comment, 
    stringifyComment.stringifyComment = str => str.replace(/^(?!$)(?: $)?/gm, "#"), 
    stringifyComment;
}

var stringifyString = {}, foldFlowLines = {}, hasRequiredFoldFlowLines, hasRequiredStringifyString, hasRequiredStringify, hasRequiredStringifyPair;

function requireFoldFlowLines() {
    if (hasRequiredFoldFlowLines) return foldFlowLines;
    hasRequiredFoldFlowLines = 1;
    function consumeMoreIndentedLines(text, i, indent) {
        let end = i, start = i + 1, ch = text[start];
        for (;" " === ch || "\t" === ch; ) if (i < start + indent) ch = text[++i]; else {
            do {
                ch = text[++i];
            } while (ch && "\n" !== ch);
            end = i, start = i + 1, ch = text[start];
        }
        return end;
    }
    return foldFlowLines.FOLD_BLOCK = "block", foldFlowLines.FOLD_FLOW = "flow", foldFlowLines.FOLD_QUOTED = "quoted", 
    foldFlowLines.foldFlowLines = function(text, indent, mode = "flow", {indentAtStart: indentAtStart, lineWidth: lineWidth = 80, minContentWidth: minContentWidth = 20, onFold: onFold, onOverflow: onOverflow} = {}) {
        if (!lineWidth || lineWidth < 0) return text;
        lineWidth < minContentWidth && (minContentWidth = 0);
        const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
        if (text.length <= endStep) return text;
        const folds = [], escapedFolds = {};
        let split, prev, end = lineWidth - indent.length;
        "number" == typeof indentAtStart && (indentAtStart > lineWidth - Math.max(2, minContentWidth) ? folds.push(0) : end = lineWidth - indentAtStart);
        let overflow = !1, i = -1, escStart = -1, escEnd = -1;
        "block" === mode && (i = consumeMoreIndentedLines(text, i, indent.length), -1 !== i && (end = i + endStep));
        for (let ch; ch = text[i += 1]; ) {
            if ("quoted" === mode && "\\" === ch) {
                switch (escStart = i, text[i + 1]) {
                  case "x":
                    i += 3;
                    break;

                  case "u":
                    i += 5;
                    break;

                  case "U":
                    i += 9;
                    break;

                  default:
                    i += 1;
                }
                escEnd = i;
            }
            if ("\n" === ch) "block" === mode && (i = consumeMoreIndentedLines(text, i, indent.length)), 
            end = i + indent.length + endStep, split = void 0; else {
                if (" " === ch && prev && " " !== prev && "\n" !== prev && "\t" !== prev) {
                    const next = text[i + 1];
                    next && " " !== next && "\n" !== next && "\t" !== next && (split = i);
                }
                if (i >= end) if (split) folds.push(split), end = split + endStep, split = void 0; else if ("quoted" === mode) {
                    for (;" " === prev || "\t" === prev; ) prev = ch, ch = text[i += 1], overflow = !0;
                    const j = i > escEnd + 1 ? i - 2 : escStart - 1;
                    if (escapedFolds[j]) return text;
                    folds.push(j), escapedFolds[j] = !0, end = j + endStep, split = void 0;
                } else overflow = !0;
            }
            prev = ch;
        }
        if (overflow && onOverflow && onOverflow(), 0 === folds.length) return text;
        onFold && onFold();
        let res = text.slice(0, folds[0]);
        for (let i = 0; i < folds.length; ++i) {
            const fold = folds[i], end = folds[i + 1] || text.length;
            0 === fold ? res = `\n${indent}${text.slice(0, end)}` : ("quoted" === mode && escapedFolds[fold] && (res += `${text[fold]}\\`), 
            res += `\n${indent}${text.slice(fold + 1, end)}`);
        }
        return res;
    }, foldFlowLines;
}

function requireStringifyString() {
    if (hasRequiredStringifyString) return stringifyString;
    hasRequiredStringifyString = 1;
    var Scalar = requireScalar(), foldFlowLines = requireFoldFlowLines();
    const getFoldOptions = (ctx, isBlock) => ({
        indentAtStart: isBlock ? ctx.indent.length : ctx.indentAtStart,
        lineWidth: ctx.options.lineWidth,
        minContentWidth: ctx.options.minContentWidth
    }), containsDocumentMarker = str => /^(%|---|\.\.\.)/m.test(str);
    function doubleQuotedString(value, ctx) {
        const json = JSON.stringify(value);
        if (ctx.options.doubleQuotedAsJSON) return json;
        const {implicitKey: implicitKey} = ctx, minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength, indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
        let str = "", start = 0;
        for (let i = 0, ch = json[i]; ch; ch = json[++i]) if (" " === ch && "\\" === json[i + 1] && "n" === json[i + 2] && (str += json.slice(start, i) + "\\ ", 
        i += 1, start = i, ch = "\\"), "\\" === ch) switch (json[i + 1]) {
          case "u":
            {
                str += json.slice(start, i);
                const code = json.substr(i + 2, 4);
                switch (code) {
                  case "0000":
                    str += "\\0";
                    break;

                  case "0007":
                    str += "\\a";
                    break;

                  case "000b":
                    str += "\\v";
                    break;

                  case "001b":
                    str += "\\e";
                    break;

                  case "0085":
                    str += "\\N";
                    break;

                  case "00a0":
                    str += "\\_";
                    break;

                  case "2028":
                    str += "\\L";
                    break;

                  case "2029":
                    str += "\\P";
                    break;

                  default:
                    "00" === code.substr(0, 2) ? str += "\\x" + code.substr(2) : str += json.substr(i, 6);
                }
                i += 5, start = i + 1;
            }
            break;

          case "n":
            if (implicitKey || '"' === json[i + 2] || json.length < minMultiLineLength) i += 1; else {
                for (str += json.slice(start, i) + "\n\n"; "\\" === json[i + 2] && "n" === json[i + 3] && '"' !== json[i + 4]; ) str += "\n", 
                i += 2;
                str += indent, " " === json[i + 2] && (str += "\\"), i += 1, start = i + 1;
            }
            break;

          default:
            i += 1;
        }
        return str = start ? str + json.slice(start) : json, implicitKey ? str : foldFlowLines.foldFlowLines(str, indent, foldFlowLines.FOLD_QUOTED, getFoldOptions(ctx, !1));
    }
    function singleQuotedString(value, ctx) {
        if (!1 === ctx.options.singleQuote || ctx.implicitKey && value.includes("\n") || /[ \t]\n|\n[ \t]/.test(value)) return doubleQuotedString(value, ctx);
        const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : ""), res = "'" + value.replace(/'/g, "''").replace(/\n+/g, `$&\n${indent}`) + "'";
        return ctx.implicitKey ? res : foldFlowLines.foldFlowLines(res, indent, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx, !1));
    }
    function quotedString(value, ctx) {
        const {singleQuote: singleQuote} = ctx.options;
        let qs;
        if (!1 === singleQuote) qs = doubleQuotedString; else {
            const hasDouble = value.includes('"'), hasSingle = value.includes("'");
            qs = hasDouble && !hasSingle ? singleQuotedString : hasSingle && !hasDouble ? doubleQuotedString : singleQuote ? singleQuotedString : doubleQuotedString;
        }
        return qs(value, ctx);
    }
    let blockEndNewlines;
    try {
        blockEndNewlines = new RegExp("(^|(?<!\n))\n+(?!\n|$)", "g");
    } catch {
        blockEndNewlines = /\n+(?!\n|$)/g;
    }
    function blockString({comment: comment, type: type, value: value}, ctx, onComment, onChompKeep) {
        const {blockQuote: blockQuote, commentString: commentString, lineWidth: lineWidth} = ctx.options;
        if (!blockQuote || /\n[\t ]+$/.test(value) || /^\s*$/.test(value)) return quotedString(value, ctx);
        const indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? "  " : ""), literal = "literal" === blockQuote || "folded" !== blockQuote && type !== Scalar.Scalar.BLOCK_FOLDED && (type === Scalar.Scalar.BLOCK_LITERAL || !function(str, lineWidth, indentLength) {
            if (!lineWidth || lineWidth < 0) return !1;
            const limit = lineWidth - indentLength, strLen = str.length;
            if (strLen <= limit) return !1;
            for (let i = 0, start = 0; i < strLen; ++i) if ("\n" === str[i]) {
                if (i - start > limit) return !0;
                if (start = i + 1, strLen - start <= limit) return !1;
            }
            return !0;
        }(value, lineWidth, indent.length));
        if (!value) return literal ? "|\n" : ">\n";
        let chomp, endStart;
        for (endStart = value.length; endStart > 0; --endStart) {
            const ch = value[endStart - 1];
            if ("\n" !== ch && "\t" !== ch && " " !== ch) break;
        }
        let end = value.substring(endStart);
        const endNlPos = end.indexOf("\n");
        -1 === endNlPos ? chomp = "-" : value === end || endNlPos !== end.length - 1 ? (chomp = "+", 
        onChompKeep && onChompKeep()) : chomp = "", end && (value = value.slice(0, -end.length), 
        "\n" === end[end.length - 1] && (end = end.slice(0, -1)), end = end.replace(blockEndNewlines, `$&${indent}`));
        let startEnd, startWithSpace = !1, startNlPos = -1;
        for (startEnd = 0; startEnd < value.length; ++startEnd) {
            const ch = value[startEnd];
            if (" " === ch) startWithSpace = !0; else {
                if ("\n" !== ch) break;
                startNlPos = startEnd;
            }
        }
        let start = value.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);
        start && (value = value.substring(start.length), start = start.replace(/\n+/g, `$&${indent}`));
        let header = (literal ? "|" : ">") + (startWithSpace ? indent ? "2" : "1" : "") + chomp;
        if (comment && (header += " " + commentString(comment.replace(/ ?[\r\n]+/g, " ")), 
        onComment && onComment()), literal) return `${header}\n${indent}${start}${value = value.replace(/\n+/g, `$&${indent}`)}${end}`;
        value = value.replace(/\n+/g, "\n$&").replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${indent}`);
        return `${header}\n${indent}${foldFlowLines.foldFlowLines(`${start}${value}${end}`, indent, foldFlowLines.FOLD_BLOCK, getFoldOptions(ctx, !0))}`;
    }
    return stringifyString.stringifyString = function(item, ctx, onComment, onChompKeep) {
        const {implicitKey: implicitKey, inFlow: inFlow} = ctx, ss = "string" == typeof item.value ? item : Object.assign({}, item, {
            value: String(item.value)
        });
        let {type: type} = item;
        type !== Scalar.Scalar.QUOTE_DOUBLE && /[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(ss.value) && (type = Scalar.Scalar.QUOTE_DOUBLE);
        const _stringify = _type => {
            switch (_type) {
              case Scalar.Scalar.BLOCK_FOLDED:
              case Scalar.Scalar.BLOCK_LITERAL:
                return implicitKey || inFlow ? quotedString(ss.value, ctx) : blockString(ss, ctx, onComment, onChompKeep);

              case Scalar.Scalar.QUOTE_DOUBLE:
                return doubleQuotedString(ss.value, ctx);

              case Scalar.Scalar.QUOTE_SINGLE:
                return singleQuotedString(ss.value, ctx);

              case Scalar.Scalar.PLAIN:
                return function(item, ctx, onComment, onChompKeep) {
                    const {type: type, value: value} = item, {actualString: actualString, implicitKey: implicitKey, indent: indent, indentStep: indentStep, inFlow: inFlow} = ctx;
                    if (implicitKey && value.includes("\n") || inFlow && /[[\]{},]/.test(value)) return quotedString(value, ctx);
                    if (!value || /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)) return implicitKey || inFlow || !value.includes("\n") ? quotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);
                    if (!implicitKey && !inFlow && type !== Scalar.Scalar.PLAIN && value.includes("\n")) return blockString(item, ctx, onComment, onChompKeep);
                    if (containsDocumentMarker(value)) {
                        if ("" === indent) return ctx.forceBlockIndent = !0, blockString(item, ctx, onComment, onChompKeep);
                        if (implicitKey && indent === indentStep) return quotedString(value, ctx);
                    }
                    const str = value.replace(/\n+/g, `$&\n${indent}`);
                    if (actualString) {
                        const test = tag => tag.default && "tag:yaml.org,2002:str" !== tag.tag && tag.test?.test(str), {compat: compat, tags: tags} = ctx.doc.schema;
                        if (tags.some(test) || compat?.some(test)) return quotedString(value, ctx);
                    }
                    return implicitKey ? str : foldFlowLines.foldFlowLines(str, indent, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx, !1));
                }(ss, ctx, onComment, onChompKeep);

              default:
                return null;
            }
        };
        let res = _stringify(type);
        if (null === res) {
            const {defaultKeyType: defaultKeyType, defaultStringType: defaultStringType} = ctx.options, t = implicitKey && defaultKeyType || defaultStringType;
            if (res = _stringify(t), null === res) throw new Error(`Unsupported default string type ${t}`);
        }
        return res;
    }, stringifyString;
}

function requireStringify() {
    if (hasRequiredStringify) return stringify$1;
    hasRequiredStringify = 1;
    var anchors = requireAnchors(), identity = requireIdentity(), stringifyComment = requireStringifyComment(), stringifyString = requireStringifyString();
    return stringify$1.createStringifyContext = function(doc, options) {
        const opt = Object.assign({
            blockQuote: !0,
            commentString: stringifyComment.stringifyComment,
            defaultKeyType: null,
            defaultStringType: "PLAIN",
            directives: null,
            doubleQuotedAsJSON: !1,
            doubleQuotedMinMultiLineLength: 40,
            falseStr: "false",
            flowCollectionPadding: !0,
            indentSeq: !0,
            lineWidth: 80,
            minContentWidth: 20,
            nullStr: "null",
            simpleKeys: !1,
            singleQuote: null,
            trueStr: "true",
            verifyAliasOrder: !0
        }, doc.schema.toStringOptions, options);
        let inFlow;
        switch (opt.collectionStyle) {
          case "block":
            inFlow = !1;
            break;

          case "flow":
            inFlow = !0;
            break;

          default:
            inFlow = null;
        }
        return {
            anchors: new Set,
            doc: doc,
            flowCollectionPadding: opt.flowCollectionPadding ? " " : "",
            indent: "",
            indentStep: "number" == typeof opt.indent ? " ".repeat(opt.indent) : "  ",
            inFlow: inFlow,
            options: opt
        };
    }, stringify$1.stringify = function(item, ctx, onComment, onChompKeep) {
        if (identity.isPair(item)) return item.toString(ctx, onComment, onChompKeep);
        if (identity.isAlias(item)) {
            if (ctx.doc.directives) return item.toString(ctx);
            if (ctx.resolvedAliases?.has(item)) throw new TypeError("Cannot stringify circular structure without alias nodes");
            ctx.resolvedAliases ? ctx.resolvedAliases.add(item) : ctx.resolvedAliases = new Set([ item ]), 
            item = item.resolve(ctx.doc);
        }
        let tagObj;
        const node = identity.isNode(item) ? item : ctx.doc.createNode(item, {
            onTagObj: o => tagObj = o
        });
        tagObj || (tagObj = function(tags, item) {
            if (item.tag) {
                const match = tags.filter((t => t.tag === item.tag));
                if (match.length > 0) return match.find((t => t.format === item.format)) ?? match[0];
            }
            let tagObj, obj;
            if (identity.isScalar(item)) {
                obj = item.value;
                let match = tags.filter((t => t.identify?.(obj)));
                if (match.length > 1) {
                    const testMatch = match.filter((t => t.test));
                    testMatch.length > 0 && (match = testMatch);
                }
                tagObj = match.find((t => t.format === item.format)) ?? match.find((t => !t.format));
            } else obj = item, tagObj = tags.find((t => t.nodeClass && obj instanceof t.nodeClass));
            if (!tagObj) throw new Error(`Tag not resolved for ${obj?.constructor?.name ?? typeof obj} value`);
            return tagObj;
        }(ctx.doc.schema.tags, node));
        const props = function(node, tagObj, {anchors: anchors$1, doc: doc}) {
            if (!doc.directives) return "";
            const props = [], anchor = (identity.isScalar(node) || identity.isCollection(node)) && node.anchor;
            anchor && anchors.anchorIsValid(anchor) && (anchors$1.add(anchor), props.push(`&${anchor}`));
            const tag = node.tag ? node.tag : tagObj.default ? null : tagObj.tag;
            return tag && props.push(doc.directives.tagString(tag)), props.join(" ");
        }(node, tagObj, ctx);
        props.length > 0 && (ctx.indentAtStart = (ctx.indentAtStart ?? 0) + props.length + 1);
        const str = "function" == typeof tagObj.stringify ? tagObj.stringify(node, ctx, onComment, onChompKeep) : identity.isScalar(node) ? stringifyString.stringifyString(node, ctx, onComment, onChompKeep) : node.toString(ctx, onComment, onChompKeep);
        return props ? identity.isScalar(node) || "{" === str[0] || "[" === str[0] ? `${props} ${str}` : `${props}\n${ctx.indent}${str}` : str;
    }, stringify$1;
}

function requireStringifyPair() {
    if (hasRequiredStringifyPair) return stringifyPair;
    hasRequiredStringifyPair = 1;
    var identity = requireIdentity(), Scalar = requireScalar(), stringify = requireStringify(), stringifyComment = requireStringifyComment();
    return stringifyPair.stringifyPair = function({key: key, value: value}, ctx, onComment, onChompKeep) {
        const {allNullValues: allNullValues, doc: doc, indent: indent, indentStep: indentStep, options: {commentString: commentString, indentSeq: indentSeq, simpleKeys: simpleKeys}} = ctx;
        let keyComment = identity.isNode(key) && key.comment || null;
        if (simpleKeys) {
            if (keyComment) throw new Error("With simple keys, key nodes cannot have comments");
            if (identity.isCollection(key) || !identity.isNode(key) && "object" == typeof key) {
                throw new Error("With simple keys, collection cannot be used as a key value");
            }
        }
        let explicitKey = !simpleKeys && (!key || keyComment && null == value && !ctx.inFlow || identity.isCollection(key) || (identity.isScalar(key) ? key.type === Scalar.Scalar.BLOCK_FOLDED || key.type === Scalar.Scalar.BLOCK_LITERAL : "object" == typeof key));
        ctx = Object.assign({}, ctx, {
            allNullValues: !1,
            implicitKey: !explicitKey && (simpleKeys || !allNullValues),
            indent: indent + indentStep
        });
        let vsb, vcb, valueComment, keyCommentDone = !1, chompKeep = !1, str = stringify.stringify(key, ctx, (() => keyCommentDone = !0), (() => chompKeep = !0));
        if (!explicitKey && !ctx.inFlow && str.length > 1024) {
            if (simpleKeys) throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
            explicitKey = !0;
        }
        if (ctx.inFlow) {
            if (allNullValues || null == value) return keyCommentDone && onComment && onComment(), 
            "" === str ? "?" : explicitKey ? `? ${str}` : str;
        } else if (allNullValues && !simpleKeys || null == value && explicitKey) return str = `? ${str}`, 
        keyComment && !keyCommentDone ? str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment)) : chompKeep && onChompKeep && onChompKeep(), 
        str;
        keyCommentDone && (keyComment = null), explicitKey ? (keyComment && (str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment))), 
        str = `? ${str}\n${indent}:`) : (str = `${str}:`, keyComment && (str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment)))), 
        identity.isNode(value) ? (vsb = !!value.spaceBefore, vcb = value.commentBefore, 
        valueComment = value.comment) : (vsb = !1, vcb = null, valueComment = null, value && "object" == typeof value && (value = doc.createNode(value))), 
        ctx.implicitKey = !1, explicitKey || keyComment || !identity.isScalar(value) || (ctx.indentAtStart = str.length + 1), 
        chompKeep = !1, indentSeq || !(indentStep.length >= 2) || ctx.inFlow || explicitKey || !identity.isSeq(value) || value.flow || value.tag || value.anchor || (ctx.indent = ctx.indent.substring(2));
        let valueCommentDone = !1;
        const valueStr = stringify.stringify(value, ctx, (() => valueCommentDone = !0), (() => chompKeep = !0));
        let ws = " ";
        if (keyComment || vsb || vcb) {
            if (ws = vsb ? "\n" : "", vcb) {
                const cs = commentString(vcb);
                ws += `\n${stringifyComment.indentComment(cs, ctx.indent)}`;
            }
            "" !== valueStr || ctx.inFlow ? ws += `\n${ctx.indent}` : "\n" === ws && (ws = "\n\n");
        } else if (!explicitKey && identity.isCollection(value)) {
            const vs0 = valueStr[0], nl0 = valueStr.indexOf("\n"), hasNewline = -1 !== nl0, flow = ctx.inFlow ?? value.flow ?? 0 === value.items.length;
            if (hasNewline || !flow) {
                let hasPropsLine = !1;
                if (hasNewline && ("&" === vs0 || "!" === vs0)) {
                    let sp0 = valueStr.indexOf(" ");
                    "&" === vs0 && -1 !== sp0 && sp0 < nl0 && "!" === valueStr[sp0 + 1] && (sp0 = valueStr.indexOf(" ", sp0 + 1)), 
                    (-1 === sp0 || nl0 < sp0) && (hasPropsLine = !0);
                }
                hasPropsLine || (ws = `\n${ctx.indent}`);
            }
        } else "" !== valueStr && "\n" !== valueStr[0] || (ws = "");
        return str += ws + valueStr, ctx.inFlow ? valueCommentDone && onComment && onComment() : valueComment && !valueCommentDone ? str += stringifyComment.lineComment(str, ctx.indent, commentString(valueComment)) : chompKeep && onChompKeep && onChompKeep(), 
        str;
    }, stringifyPair;
}

var addPairToJSMap = {}, log = {}, hasRequiredLog;

function requireLog() {
    if (hasRequiredLog) return log;
    return hasRequiredLog = 1, log.debug = function(logLevel, ...messages) {
        "debug" === logLevel && console.log(...messages);
    }, log.warn = function(logLevel, warning) {
        "debug" !== logLevel && "warn" !== logLevel || "undefined" != typeof process && process.emitWarning && process.emitWarning(warning);
    }, log;
}

var merge = {}, hasRequiredMerge, hasRequiredAddPairToJSMap, hasRequiredPair;

function requireMerge() {
    if (hasRequiredMerge) return merge;
    hasRequiredMerge = 1;
    var identity = requireIdentity(), Scalar = requireScalar();
    const merge$1 = {
        identify: value => "<<" === value || "symbol" == typeof value && "<<" === value.description,
        default: "key",
        tag: "tag:yaml.org,2002:merge",
        test: /^<<$/,
        resolve: () => Object.assign(new Scalar.Scalar(Symbol("<<")), {
            addToJSMap: addMergeToJSMap
        }),
        stringify: () => "<<"
    };
    function addMergeToJSMap(ctx, map, value) {
        if (value = ctx && identity.isAlias(value) ? value.resolve(ctx.doc) : value, identity.isSeq(value)) for (const it of value.items) mergeValue(ctx, map, it); else if (Array.isArray(value)) for (const it of value) mergeValue(ctx, map, it); else mergeValue(ctx, map, value);
    }
    function mergeValue(ctx, map, value) {
        const source = ctx && identity.isAlias(value) ? value.resolve(ctx.doc) : value;
        if (!identity.isMap(source)) throw new Error("Merge sources must be maps or map aliases");
        const srcMap = source.toJSON(null, ctx, Map);
        for (const [key, value] of srcMap) map instanceof Map ? map.has(key) || map.set(key, value) : map instanceof Set ? map.add(key) : Object.prototype.hasOwnProperty.call(map, key) || Object.defineProperty(map, key, {
            value: value,
            writable: !0,
            enumerable: !0,
            configurable: !0
        });
        return map;
    }
    return merge.addMergeToJSMap = addMergeToJSMap, merge.isMergeKey = (ctx, key) => (merge$1.identify(key) || identity.isScalar(key) && (!key.type || key.type === Scalar.Scalar.PLAIN) && merge$1.identify(key.value)) && ctx?.doc.schema.tags.some((tag => tag.tag === merge$1.tag && tag.default)), 
    merge.merge = merge$1, merge;
}

function requireAddPairToJSMap() {
    if (hasRequiredAddPairToJSMap) return addPairToJSMap;
    hasRequiredAddPairToJSMap = 1;
    var log = requireLog(), merge = requireMerge(), stringify = requireStringify(), identity = requireIdentity(), toJS = requireToJS();
    return addPairToJSMap.addPairToJSMap = function(ctx, map, {key: key, value: value}) {
        if (identity.isNode(key) && key.addToJSMap) key.addToJSMap(ctx, map, value); else if (merge.isMergeKey(ctx, key)) merge.addMergeToJSMap(ctx, map, value); else {
            const jsKey = toJS.toJS(key, "", ctx);
            if (map instanceof Map) map.set(jsKey, toJS.toJS(value, jsKey, ctx)); else if (map instanceof Set) map.add(jsKey); else {
                const stringKey = function(key, jsKey, ctx) {
                    if (null === jsKey) return "";
                    if ("object" != typeof jsKey) return String(jsKey);
                    if (identity.isNode(key) && ctx?.doc) {
                        const strCtx = stringify.createStringifyContext(ctx.doc, {});
                        strCtx.anchors = new Set;
                        for (const node of ctx.anchors.keys()) strCtx.anchors.add(node.anchor);
                        strCtx.inFlow = !0, strCtx.inStringifyKey = !0;
                        const strKey = key.toString(strCtx);
                        if (!ctx.mapKeyWarned) {
                            let jsonStr = JSON.stringify(strKey);
                            jsonStr.length > 40 && (jsonStr = jsonStr.substring(0, 36) + '..."'), log.warn(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`), 
                            ctx.mapKeyWarned = !0;
                        }
                        return strKey;
                    }
                    return JSON.stringify(jsKey);
                }(key, jsKey, ctx), jsValue = toJS.toJS(value, stringKey, ctx);
                stringKey in map ? Object.defineProperty(map, stringKey, {
                    value: jsValue,
                    writable: !0,
                    enumerable: !0,
                    configurable: !0
                }) : map[stringKey] = jsValue;
            }
        }
        return map;
    }, addPairToJSMap;
}

function requirePair() {
    if (hasRequiredPair) return Pair;
    hasRequiredPair = 1;
    var createNode = requireCreateNode(), stringifyPair = requireStringifyPair(), addPairToJSMap = requireAddPairToJSMap(), identity = requireIdentity();
    let Pair$1 = class Pair {
        constructor(key, value = null) {
            Object.defineProperty(this, identity.NODE_TYPE, {
                value: identity.PAIR
            }), this.key = key, this.value = value;
        }
        clone(schema) {
            let {key: key, value: value} = this;
            return identity.isNode(key) && (key = key.clone(schema)), identity.isNode(value) && (value = value.clone(schema)), 
            new Pair(key, value);
        }
        toJSON(_, ctx) {
            const pair = ctx?.mapAsMap ? new Map : {};
            return addPairToJSMap.addPairToJSMap(ctx, pair, this);
        }
        toString(ctx, onComment, onChompKeep) {
            return ctx?.doc ? stringifyPair.stringifyPair(this, ctx, onComment, onChompKeep) : JSON.stringify(this);
        }
    };
    return Pair.Pair = Pair$1, Pair.createPair = function(key, value, ctx) {
        const k = createNode.createNode(key, void 0, ctx), v = createNode.createNode(value, void 0, ctx);
        return new Pair$1(k, v);
    }, Pair;
}

var Schema = {}, map$1 = {}, YAMLMap = {}, stringifyCollection = {}, hasRequiredStringifyCollection, hasRequiredYAMLMap, hasRequiredMap;

function requireStringifyCollection() {
    if (hasRequiredStringifyCollection) return stringifyCollection;
    hasRequiredStringifyCollection = 1;
    var identity = requireIdentity(), stringify = requireStringify(), stringifyComment = requireStringifyComment();
    function stringifyBlockCollection({comment: comment, items: items}, ctx, {blockItemPrefix: blockItemPrefix, flowChars: flowChars, itemIndent: itemIndent, onChompKeep: onChompKeep, onComment: onComment}) {
        const {indent: indent, options: {commentString: commentString}} = ctx, itemCtx = Object.assign({}, ctx, {
            indent: itemIndent,
            type: null
        });
        let chompKeep = !1;
        const lines = [];
        for (let i = 0; i < items.length; ++i) {
            const item = items[i];
            let comment = null;
            if (identity.isNode(item)) !chompKeep && item.spaceBefore && lines.push(""), addCommentBefore(ctx, lines, item.commentBefore, chompKeep), 
            item.comment && (comment = item.comment); else if (identity.isPair(item)) {
                const ik = identity.isNode(item.key) ? item.key : null;
                ik && (!chompKeep && ik.spaceBefore && lines.push(""), addCommentBefore(ctx, lines, ik.commentBefore, chompKeep));
            }
            chompKeep = !1;
            let str = stringify.stringify(item, itemCtx, (() => comment = null), (() => chompKeep = !0));
            comment && (str += stringifyComment.lineComment(str, itemIndent, commentString(comment))), 
            chompKeep && comment && (chompKeep = !1), lines.push(blockItemPrefix + str);
        }
        let str;
        if (0 === lines.length) str = flowChars.start + flowChars.end; else {
            str = lines[0];
            for (let i = 1; i < lines.length; ++i) {
                const line = lines[i];
                str += line ? `\n${indent}${line}` : "\n";
            }
        }
        return comment ? (str += "\n" + stringifyComment.indentComment(commentString(comment), indent), 
        onComment && onComment()) : chompKeep && onChompKeep && onChompKeep(), str;
    }
    function stringifyFlowCollection({items: items}, ctx, {flowChars: flowChars, itemIndent: itemIndent}) {
        const {indent: indent, indentStep: indentStep, flowCollectionPadding: fcPadding, options: {commentString: commentString}} = ctx;
        itemIndent += indentStep;
        const itemCtx = Object.assign({}, ctx, {
            indent: itemIndent,
            inFlow: !0,
            type: null
        });
        let reqNewline = !1, linesAtValue = 0;
        const lines = [];
        for (let i = 0; i < items.length; ++i) {
            const item = items[i];
            let comment = null;
            if (identity.isNode(item)) item.spaceBefore && lines.push(""), addCommentBefore(ctx, lines, item.commentBefore, !1), 
            item.comment && (comment = item.comment); else if (identity.isPair(item)) {
                const ik = identity.isNode(item.key) ? item.key : null;
                ik && (ik.spaceBefore && lines.push(""), addCommentBefore(ctx, lines, ik.commentBefore, !1), 
                ik.comment && (reqNewline = !0));
                const iv = identity.isNode(item.value) ? item.value : null;
                iv ? (iv.comment && (comment = iv.comment), iv.commentBefore && (reqNewline = !0)) : null == item.value && ik?.comment && (comment = ik.comment);
            }
            comment && (reqNewline = !0);
            let str = stringify.stringify(item, itemCtx, (() => comment = null));
            i < items.length - 1 && (str += ","), comment && (str += stringifyComment.lineComment(str, itemIndent, commentString(comment))), 
            !reqNewline && (lines.length > linesAtValue || str.includes("\n")) && (reqNewline = !0), 
            lines.push(str), linesAtValue = lines.length;
        }
        const {start: start, end: end} = flowChars;
        if (0 === lines.length) return start + end;
        if (!reqNewline) {
            const len = lines.reduce(((sum, line) => sum + line.length + 2), 2);
            reqNewline = ctx.options.lineWidth > 0 && len > ctx.options.lineWidth;
        }
        if (reqNewline) {
            let str = start;
            for (const line of lines) str += line ? `\n${indentStep}${indent}${line}` : "\n";
            return `${str}\n${indent}${end}`;
        }
        return `${start}${fcPadding}${lines.join(" ")}${fcPadding}${end}`;
    }
    function addCommentBefore({indent: indent, options: {commentString: commentString}}, lines, comment, chompKeep) {
        if (comment && chompKeep && (comment = comment.replace(/^\n+/, "")), comment) {
            const ic = stringifyComment.indentComment(commentString(comment), indent);
            lines.push(ic.trimStart());
        }
    }
    return stringifyCollection.stringifyCollection = function(collection, ctx, options) {
        return (ctx.inFlow ?? collection.flow ? stringifyFlowCollection : stringifyBlockCollection)(collection, ctx, options);
    }, stringifyCollection;
}

function requireYAMLMap() {
    if (hasRequiredYAMLMap) return YAMLMap;
    hasRequiredYAMLMap = 1;
    var stringifyCollection = requireStringifyCollection(), addPairToJSMap = requireAddPairToJSMap(), Collection = requireCollection(), identity = requireIdentity(), Pair = requirePair(), Scalar = requireScalar();
    function findPair(items, key) {
        const k = identity.isScalar(key) ? key.value : key;
        for (const it of items) if (identity.isPair(it)) {
            if (it.key === key || it.key === k) return it;
            if (identity.isScalar(it.key) && it.key.value === k) return it;
        }
    }
    let YAMLMap$1 = class extends Collection.Collection {
        static get tagName() {
            return "tag:yaml.org,2002:map";
        }
        constructor(schema) {
            super(identity.MAP, schema), this.items = [];
        }
        static from(schema, obj, ctx) {
            const {keepUndefined: keepUndefined, replacer: replacer} = ctx, map = new this(schema), add = (key, value) => {
                if ("function" == typeof replacer) value = replacer.call(obj, key, value); else if (Array.isArray(replacer) && !replacer.includes(key)) return;
                (void 0 !== value || keepUndefined) && map.items.push(Pair.createPair(key, value, ctx));
            };
            if (obj instanceof Map) for (const [key, value] of obj) add(key, value); else if (obj && "object" == typeof obj) for (const key of Object.keys(obj)) add(key, obj[key]);
            return "function" == typeof schema.sortMapEntries && map.items.sort(schema.sortMapEntries), 
            map;
        }
        add(pair, overwrite) {
            let _pair;
            _pair = identity.isPair(pair) ? pair : pair && "object" == typeof pair && "key" in pair ? new Pair.Pair(pair.key, pair.value) : new Pair.Pair(pair, pair?.value);
            const prev = findPair(this.items, _pair.key), sortEntries = this.schema?.sortMapEntries;
            if (prev) {
                if (!overwrite) throw new Error(`Key ${_pair.key} already set`);
                identity.isScalar(prev.value) && Scalar.isScalarValue(_pair.value) ? prev.value.value = _pair.value : prev.value = _pair.value;
            } else if (sortEntries) {
                const i = this.items.findIndex((item => sortEntries(_pair, item) < 0));
                -1 === i ? this.items.push(_pair) : this.items.splice(i, 0, _pair);
            } else this.items.push(_pair);
        }
        delete(key) {
            const it = findPair(this.items, key);
            if (!it) return !1;
            return this.items.splice(this.items.indexOf(it), 1).length > 0;
        }
        get(key, keepScalar) {
            const it = findPair(this.items, key), node = it?.value;
            return (!keepScalar && identity.isScalar(node) ? node.value : node) ?? void 0;
        }
        has(key) {
            return !!findPair(this.items, key);
        }
        set(key, value) {
            this.add(new Pair.Pair(key, value), !0);
        }
        toJSON(_, ctx, Type) {
            const map = Type ? new Type : ctx?.mapAsMap ? new Map : {};
            ctx?.onCreate && ctx.onCreate(map);
            for (const item of this.items) addPairToJSMap.addPairToJSMap(ctx, map, item);
            return map;
        }
        toString(ctx, onComment, onChompKeep) {
            if (!ctx) return JSON.stringify(this);
            for (const item of this.items) if (!identity.isPair(item)) throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
            return !ctx.allNullValues && this.hasAllNullValues(!1) && (ctx = Object.assign({}, ctx, {
                allNullValues: !0
            })), stringifyCollection.stringifyCollection(this, ctx, {
                blockItemPrefix: "",
                flowChars: {
                    start: "{",
                    end: "}"
                },
                itemIndent: ctx.indent || "",
                onChompKeep: onChompKeep,
                onComment: onComment
            });
        }
    };
    return YAMLMap.YAMLMap = YAMLMap$1, YAMLMap.findPair = findPair, YAMLMap;
}

function requireMap() {
    if (hasRequiredMap) return map$1;
    hasRequiredMap = 1;
    var identity = requireIdentity(), YAMLMap = requireYAMLMap();
    const map = {
        collection: "map",
        default: !0,
        nodeClass: YAMLMap.YAMLMap,
        tag: "tag:yaml.org,2002:map",
        resolve: (map, onError) => (identity.isMap(map) || onError("Expected a mapping for this tag"), 
        map),
        createNode: (schema, obj, ctx) => YAMLMap.YAMLMap.from(schema, obj, ctx)
    };
    return map$1.map = map, map$1;
}

var seq = {}, YAMLSeq = {}, hasRequiredYAMLSeq, hasRequiredSeq;

function requireYAMLSeq() {
    if (hasRequiredYAMLSeq) return YAMLSeq;
    hasRequiredYAMLSeq = 1;
    var createNode = requireCreateNode(), stringifyCollection = requireStringifyCollection(), Collection = requireCollection(), identity = requireIdentity(), Scalar = requireScalar(), toJS = requireToJS();
    let YAMLSeq$1 = class extends Collection.Collection {
        static get tagName() {
            return "tag:yaml.org,2002:seq";
        }
        constructor(schema) {
            super(identity.SEQ, schema), this.items = [];
        }
        add(value) {
            this.items.push(value);
        }
        delete(key) {
            const idx = asItemIndex(key);
            if ("number" != typeof idx) return !1;
            return this.items.splice(idx, 1).length > 0;
        }
        get(key, keepScalar) {
            const idx = asItemIndex(key);
            if ("number" != typeof idx) return;
            const it = this.items[idx];
            return !keepScalar && identity.isScalar(it) ? it.value : it;
        }
        has(key) {
            const idx = asItemIndex(key);
            return "number" == typeof idx && idx < this.items.length;
        }
        set(key, value) {
            const idx = asItemIndex(key);
            if ("number" != typeof idx) throw new Error(`Expected a valid index, not ${key}.`);
            const prev = this.items[idx];
            identity.isScalar(prev) && Scalar.isScalarValue(value) ? prev.value = value : this.items[idx] = value;
        }
        toJSON(_, ctx) {
            const seq = [];
            ctx?.onCreate && ctx.onCreate(seq);
            let i = 0;
            for (const item of this.items) seq.push(toJS.toJS(item, String(i++), ctx));
            return seq;
        }
        toString(ctx, onComment, onChompKeep) {
            return ctx ? stringifyCollection.stringifyCollection(this, ctx, {
                blockItemPrefix: "- ",
                flowChars: {
                    start: "[",
                    end: "]"
                },
                itemIndent: (ctx.indent || "") + "  ",
                onChompKeep: onChompKeep,
                onComment: onComment
            }) : JSON.stringify(this);
        }
        static from(schema, obj, ctx) {
            const {replacer: replacer} = ctx, seq = new this(schema);
            if (obj && Symbol.iterator in Object(obj)) {
                let i = 0;
                for (let it of obj) {
                    if ("function" == typeof replacer) {
                        const key = obj instanceof Set ? it : String(i++);
                        it = replacer.call(obj, key, it);
                    }
                    seq.items.push(createNode.createNode(it, void 0, ctx));
                }
            }
            return seq;
        }
    };
    function asItemIndex(key) {
        let idx = identity.isScalar(key) ? key.value : key;
        return idx && "string" == typeof idx && (idx = Number(idx)), "number" == typeof idx && Number.isInteger(idx) && idx >= 0 ? idx : null;
    }
    return YAMLSeq.YAMLSeq = YAMLSeq$1, YAMLSeq;
}

function requireSeq() {
    if (hasRequiredSeq) return seq;
    hasRequiredSeq = 1;
    var identity = requireIdentity(), YAMLSeq = requireYAMLSeq();
    const seq$1 = {
        collection: "seq",
        default: !0,
        nodeClass: YAMLSeq.YAMLSeq,
        tag: "tag:yaml.org,2002:seq",
        resolve: (seq, onError) => (identity.isSeq(seq) || onError("Expected a sequence for this tag"), 
        seq),
        createNode: (schema, obj, ctx) => YAMLSeq.YAMLSeq.from(schema, obj, ctx)
    };
    return seq.seq = seq$1, seq;
}

var string$1 = {}, hasRequiredString;

function requireString() {
    if (hasRequiredString) return string$1;
    hasRequiredString = 1;
    var stringifyString = requireStringifyString();
    const string = {
        identify: value => "string" == typeof value,
        default: !0,
        tag: "tag:yaml.org,2002:str",
        resolve: str => str,
        stringify: (item, ctx, onComment, onChompKeep) => (ctx = Object.assign({
            actualString: !0
        }, ctx), stringifyString.stringifyString(item, ctx, onComment, onChompKeep))
    };
    return string$1.string = string, string$1;
}

var tags = {}, _null = {}, hasRequired_null;

function require_null() {
    if (hasRequired_null) return _null;
    hasRequired_null = 1;
    var Scalar = requireScalar();
    const nullTag = {
        identify: value => null == value,
        createNode: () => new Scalar.Scalar(null),
        default: !0,
        tag: "tag:yaml.org,2002:null",
        test: /^(?:~|[Nn]ull|NULL)?$/,
        resolve: () => new Scalar.Scalar(null),
        stringify: ({source: source}, ctx) => "string" == typeof source && nullTag.test.test(source) ? source : ctx.options.nullStr
    };
    return _null.nullTag = nullTag, _null;
}

var bool$1 = {}, hasRequiredBool$1;

function requireBool$1() {
    if (hasRequiredBool$1) return bool$1;
    hasRequiredBool$1 = 1;
    var Scalar = requireScalar();
    const boolTag = {
        identify: value => "boolean" == typeof value,
        default: !0,
        tag: "tag:yaml.org,2002:bool",
        test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
        resolve: str => new Scalar.Scalar("t" === str[0] || "T" === str[0]),
        stringify({source: source, value: value}, ctx) {
            if (source && boolTag.test.test(source)) {
                if (value === ("t" === source[0] || "T" === source[0])) return source;
            }
            return value ? ctx.options.trueStr : ctx.options.falseStr;
        }
    };
    return bool$1.boolTag = boolTag, bool$1;
}

var float$1 = {}, stringifyNumber = {}, hasRequiredStringifyNumber, hasRequiredFloat$1;

function requireStringifyNumber() {
    if (hasRequiredStringifyNumber) return stringifyNumber;
    return hasRequiredStringifyNumber = 1, stringifyNumber.stringifyNumber = function({format: format, minFractionDigits: minFractionDigits, tag: tag, value: value}) {
        if ("bigint" == typeof value) return String(value);
        const num = "number" == typeof value ? value : Number(value);
        if (!isFinite(num)) return isNaN(num) ? ".nan" : num < 0 ? "-.inf" : ".inf";
        let n = JSON.stringify(value);
        if (!format && minFractionDigits && (!tag || "tag:yaml.org,2002:float" === tag) && /^\d/.test(n)) {
            let i = n.indexOf(".");
            i < 0 && (i = n.length, n += ".");
            let d = minFractionDigits - (n.length - i - 1);
            for (;d-- > 0; ) n += "0";
        }
        return n;
    }, stringifyNumber;
}

function requireFloat$1() {
    if (hasRequiredFloat$1) return float$1;
    hasRequiredFloat$1 = 1;
    var Scalar = requireScalar(), stringifyNumber = requireStringifyNumber();
    const floatNaN = {
        identify: value => "number" == typeof value,
        default: !0,
        tag: "tag:yaml.org,2002:float",
        test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
        resolve: str => "nan" === str.slice(-3).toLowerCase() ? NaN : "-" === str[0] ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
        stringify: stringifyNumber.stringifyNumber
    }, floatExp = {
        identify: value => "number" == typeof value,
        default: !0,
        tag: "tag:yaml.org,2002:float",
        format: "EXP",
        test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
        resolve: str => parseFloat(str),
        stringify(node) {
            const num = Number(node.value);
            return isFinite(num) ? num.toExponential() : stringifyNumber.stringifyNumber(node);
        }
    }, float = {
        identify: value => "number" == typeof value,
        default: !0,
        tag: "tag:yaml.org,2002:float",
        test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
        resolve(str) {
            const node = new Scalar.Scalar(parseFloat(str)), dot = str.indexOf(".");
            return -1 !== dot && "0" === str[str.length - 1] && (node.minFractionDigits = str.length - dot - 1), 
            node;
        },
        stringify: stringifyNumber.stringifyNumber
    };
    return float$1.float = float, float$1.floatExp = floatExp, float$1.floatNaN = floatNaN, 
    float$1;
}

var int$1 = {}, hasRequiredInt$1;

function requireInt$1() {
    if (hasRequiredInt$1) return int$1;
    hasRequiredInt$1 = 1;
    var stringifyNumber = requireStringifyNumber();
    const intIdentify = value => "bigint" == typeof value || Number.isInteger(value), intResolve = (str, offset, radix, {intAsBigInt: intAsBigInt}) => intAsBigInt ? BigInt(str) : parseInt(str.substring(offset), radix);
    function intStringify(node, radix, prefix) {
        const {value: value} = node;
        return intIdentify(value) && value >= 0 ? prefix + value.toString(radix) : stringifyNumber.stringifyNumber(node);
    }
    const intOct = {
        identify: value => intIdentify(value) && value >= 0,
        default: !0,
        tag: "tag:yaml.org,2002:int",
        format: "OCT",
        test: /^0o[0-7]+$/,
        resolve: (str, _onError, opt) => intResolve(str, 2, 8, opt),
        stringify: node => intStringify(node, 8, "0o")
    }, int = {
        identify: intIdentify,
        default: !0,
        tag: "tag:yaml.org,2002:int",
        test: /^[-+]?[0-9]+$/,
        resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
        stringify: stringifyNumber.stringifyNumber
    }, intHex = {
        identify: value => intIdentify(value) && value >= 0,
        default: !0,
        tag: "tag:yaml.org,2002:int",
        format: "HEX",
        test: /^0x[0-9a-fA-F]+$/,
        resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
        stringify: node => intStringify(node, 16, "0x")
    };
    return int$1.int = int, int$1.intHex = intHex, int$1.intOct = intOct, int$1;
}

var schema$2 = {}, hasRequiredSchema$3;

function requireSchema$3() {
    if (hasRequiredSchema$3) return schema$2;
    hasRequiredSchema$3 = 1;
    var map = requireMap(), _null = require_null(), seq = requireSeq(), string = requireString(), bool = requireBool$1(), float = requireFloat$1(), int = requireInt$1();
    const schema = [ map.map, seq.seq, string.string, _null.nullTag, bool.boolTag, int.intOct, int.int, int.intHex, float.floatNaN, float.floatExp, float.float ];
    return schema$2.schema = schema, schema$2;
}

var schema$1 = {}, hasRequiredSchema$2;

function requireSchema$2() {
    if (hasRequiredSchema$2) return schema$1;
    hasRequiredSchema$2 = 1;
    var Scalar = requireScalar(), map = requireMap(), seq = requireSeq();
    function intIdentify(value) {
        return "bigint" == typeof value || Number.isInteger(value);
    }
    const stringifyJSON = ({value: value}) => JSON.stringify(value), jsonScalars = [ {
        identify: value => "string" == typeof value,
        default: !0,
        tag: "tag:yaml.org,2002:str",
        resolve: str => str,
        stringify: stringifyJSON
    }, {
        identify: value => null == value,
        createNode: () => new Scalar.Scalar(null),
        default: !0,
        tag: "tag:yaml.org,2002:null",
        test: /^null$/,
        resolve: () => null,
        stringify: stringifyJSON
    }, {
        identify: value => "boolean" == typeof value,
        default: !0,
        tag: "tag:yaml.org,2002:bool",
        test: /^true|false$/,
        resolve: str => "true" === str,
        stringify: stringifyJSON
    }, {
        identify: intIdentify,
        default: !0,
        tag: "tag:yaml.org,2002:int",
        test: /^-?(?:0|[1-9][0-9]*)$/,
        resolve: (str, _onError, {intAsBigInt: intAsBigInt}) => intAsBigInt ? BigInt(str) : parseInt(str, 10),
        stringify: ({value: value}) => intIdentify(value) ? value.toString() : JSON.stringify(value)
    }, {
        identify: value => "number" == typeof value,
        default: !0,
        tag: "tag:yaml.org,2002:float",
        test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
        resolve: str => parseFloat(str),
        stringify: stringifyJSON
    } ], jsonError = {
        default: !0,
        tag: "",
        test: /^/,
        resolve: (str, onError) => (onError(`Unresolved plain scalar ${JSON.stringify(str)}`), 
        str)
    }, schema = [ map.map, seq.seq ].concat(jsonScalars, jsonError);
    return schema$1.schema = schema, schema$1;
}

var binary$1 = {}, hasRequiredBinary;

function requireBinary() {
    if (hasRequiredBinary) return binary$1;
    hasRequiredBinary = 1;
    var Scalar = requireScalar(), stringifyString = requireStringifyString();
    const binary = {
        identify: value => value instanceof Uint8Array,
        default: !1,
        tag: "tag:yaml.org,2002:binary",
        resolve(src, onError) {
            if ("function" == typeof Buffer) return Buffer.from(src, "base64");
            if ("function" == typeof atob) {
                const str = atob(src.replace(/[\n\r]/g, "")), buffer = new Uint8Array(str.length);
                for (let i = 0; i < str.length; ++i) buffer[i] = str.charCodeAt(i);
                return buffer;
            }
            return onError("This environment does not support reading binary tags; either Buffer or atob is required"), 
            src;
        },
        stringify({comment: comment, type: type, value: value}, ctx, onComment, onChompKeep) {
            const buf = value;
            let str;
            if ("function" == typeof Buffer) str = buf instanceof Buffer ? buf.toString("base64") : Buffer.from(buf.buffer).toString("base64"); else {
                if ("function" != typeof btoa) throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
                {
                    let s = "";
                    for (let i = 0; i < buf.length; ++i) s += String.fromCharCode(buf[i]);
                    str = btoa(s);
                }
            }
            if (type || (type = Scalar.Scalar.BLOCK_LITERAL), type !== Scalar.Scalar.QUOTE_DOUBLE) {
                const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth), n = Math.ceil(str.length / lineWidth), lines = new Array(n);
                for (let i = 0, o = 0; i < n; ++i, o += lineWidth) lines[i] = str.substr(o, lineWidth);
                str = lines.join(type === Scalar.Scalar.BLOCK_LITERAL ? "\n" : " ");
            }
            return stringifyString.stringifyString({
                comment: comment,
                type: type,
                value: str
            }, ctx, onComment, onChompKeep);
        }
    };
    return binary$1.binary = binary, binary$1;
}

var omap = {}, pairs = {}, hasRequiredPairs, hasRequiredOmap;

function requirePairs() {
    if (hasRequiredPairs) return pairs;
    hasRequiredPairs = 1;
    var identity = requireIdentity(), Pair = requirePair(), Scalar = requireScalar(), YAMLSeq = requireYAMLSeq();
    function resolvePairs(seq, onError) {
        if (identity.isSeq(seq)) for (let i = 0; i < seq.items.length; ++i) {
            let item = seq.items[i];
            if (!identity.isPair(item)) {
                if (identity.isMap(item)) {
                    item.items.length > 1 && onError("Each pair must have its own sequence indicator");
                    const pair = item.items[0] || new Pair.Pair(new Scalar.Scalar(null));
                    if (item.commentBefore && (pair.key.commentBefore = pair.key.commentBefore ? `${item.commentBefore}\n${pair.key.commentBefore}` : item.commentBefore), 
                    item.comment) {
                        const cn = pair.value ?? pair.key;
                        cn.comment = cn.comment ? `${item.comment}\n${cn.comment}` : item.comment;
                    }
                    item = pair;
                }
                seq.items[i] = identity.isPair(item) ? item : new Pair.Pair(item);
            }
        } else onError("Expected a sequence for this tag");
        return seq;
    }
    function createPairs(schema, iterable, ctx) {
        const {replacer: replacer} = ctx, pairs = new YAMLSeq.YAMLSeq(schema);
        pairs.tag = "tag:yaml.org,2002:pairs";
        let i = 0;
        if (iterable && Symbol.iterator in Object(iterable)) for (let it of iterable) {
            let key, value;
            if ("function" == typeof replacer && (it = replacer.call(iterable, String(i++), it)), 
            Array.isArray(it)) {
                if (2 !== it.length) throw new TypeError(`Expected [key, value] tuple: ${it}`);
                key = it[0], value = it[1];
            } else if (it && it instanceof Object) {
                const keys = Object.keys(it);
                if (1 !== keys.length) throw new TypeError(`Expected tuple with one key, not ${keys.length} keys`);
                key = keys[0], value = it[key];
            } else key = it;
            pairs.items.push(Pair.createPair(key, value, ctx));
        }
        return pairs;
    }
    const pairs$1 = {
        collection: "seq",
        default: !1,
        tag: "tag:yaml.org,2002:pairs",
        resolve: resolvePairs,
        createNode: createPairs
    };
    return pairs.createPairs = createPairs, pairs.pairs = pairs$1, pairs.resolvePairs = resolvePairs, 
    pairs;
}

function requireOmap() {
    if (hasRequiredOmap) return omap;
    hasRequiredOmap = 1;
    var identity = requireIdentity(), toJS = requireToJS(), YAMLMap = requireYAMLMap(), YAMLSeq = requireYAMLSeq(), pairs = requirePairs();
    class YAMLOMap extends YAMLSeq.YAMLSeq {
        constructor() {
            super(), this.add = YAMLMap.YAMLMap.prototype.add.bind(this), this.delete = YAMLMap.YAMLMap.prototype.delete.bind(this), 
            this.get = YAMLMap.YAMLMap.prototype.get.bind(this), this.has = YAMLMap.YAMLMap.prototype.has.bind(this), 
            this.set = YAMLMap.YAMLMap.prototype.set.bind(this), this.tag = YAMLOMap.tag;
        }
        toJSON(_, ctx) {
            if (!ctx) return super.toJSON(_);
            const map = new Map;
            ctx?.onCreate && ctx.onCreate(map);
            for (const pair of this.items) {
                let key, value;
                if (identity.isPair(pair) ? (key = toJS.toJS(pair.key, "", ctx), value = toJS.toJS(pair.value, key, ctx)) : key = toJS.toJS(pair, "", ctx), 
                map.has(key)) throw new Error("Ordered maps must not include duplicate keys");
                map.set(key, value);
            }
            return map;
        }
        static from(schema, iterable, ctx) {
            const pairs$1 = pairs.createPairs(schema, iterable, ctx), omap = new this;
            return omap.items = pairs$1.items, omap;
        }
    }
    YAMLOMap.tag = "tag:yaml.org,2002:omap";
    const omap$1 = {
        collection: "seq",
        identify: value => value instanceof Map,
        nodeClass: YAMLOMap,
        default: !1,
        tag: "tag:yaml.org,2002:omap",
        resolve(seq, onError) {
            const pairs$1 = pairs.resolvePairs(seq, onError), seenKeys = [];
            for (const {key: key} of pairs$1.items) identity.isScalar(key) && (seenKeys.includes(key.value) ? onError(`Ordered maps must not include duplicate keys: ${key.value}`) : seenKeys.push(key.value));
            return Object.assign(new YAMLOMap, pairs$1);
        },
        createNode: (schema, iterable, ctx) => YAMLOMap.from(schema, iterable, ctx)
    };
    return omap.YAMLOMap = YAMLOMap, omap.omap = omap$1, omap;
}

var schema = {}, bool = {}, hasRequiredBool;

function requireBool() {
    if (hasRequiredBool) return bool;
    hasRequiredBool = 1;
    var Scalar = requireScalar();
    function boolStringify({value: value, source: source}, ctx) {
        return source && (value ? trueTag : falseTag).test.test(source) ? source : value ? ctx.options.trueStr : ctx.options.falseStr;
    }
    const trueTag = {
        identify: value => !0 === value,
        default: !0,
        tag: "tag:yaml.org,2002:bool",
        test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
        resolve: () => new Scalar.Scalar(!0),
        stringify: boolStringify
    }, falseTag = {
        identify: value => !1 === value,
        default: !0,
        tag: "tag:yaml.org,2002:bool",
        test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/,
        resolve: () => new Scalar.Scalar(!1),
        stringify: boolStringify
    };
    return bool.falseTag = falseTag, bool.trueTag = trueTag, bool;
}

var float = {}, hasRequiredFloat;

function requireFloat() {
    if (hasRequiredFloat) return float;
    hasRequiredFloat = 1;
    var Scalar = requireScalar(), stringifyNumber = requireStringifyNumber();
    const floatNaN = {
        identify: value => "number" == typeof value,
        default: !0,
        tag: "tag:yaml.org,2002:float",
        test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
        resolve: str => "nan" === str.slice(-3).toLowerCase() ? NaN : "-" === str[0] ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
        stringify: stringifyNumber.stringifyNumber
    }, floatExp = {
        identify: value => "number" == typeof value,
        default: !0,
        tag: "tag:yaml.org,2002:float",
        format: "EXP",
        test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
        resolve: str => parseFloat(str.replace(/_/g, "")),
        stringify(node) {
            const num = Number(node.value);
            return isFinite(num) ? num.toExponential() : stringifyNumber.stringifyNumber(node);
        }
    }, float$1 = {
        identify: value => "number" == typeof value,
        default: !0,
        tag: "tag:yaml.org,2002:float",
        test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
        resolve(str) {
            const node = new Scalar.Scalar(parseFloat(str.replace(/_/g, ""))), dot = str.indexOf(".");
            if (-1 !== dot) {
                const f = str.substring(dot + 1).replace(/_/g, "");
                "0" === f[f.length - 1] && (node.minFractionDigits = f.length);
            }
            return node;
        },
        stringify: stringifyNumber.stringifyNumber
    };
    return float.float = float$1, float.floatExp = floatExp, float.floatNaN = floatNaN, 
    float;
}

var int = {}, hasRequiredInt;

function requireInt() {
    if (hasRequiredInt) return int;
    hasRequiredInt = 1;
    var stringifyNumber = requireStringifyNumber();
    const intIdentify = value => "bigint" == typeof value || Number.isInteger(value);
    function intResolve(str, offset, radix, {intAsBigInt: intAsBigInt}) {
        const sign = str[0];
        if ("-" !== sign && "+" !== sign || (offset += 1), str = str.substring(offset).replace(/_/g, ""), 
        intAsBigInt) {
            switch (radix) {
              case 2:
                str = `0b${str}`;
                break;

              case 8:
                str = `0o${str}`;
                break;

              case 16:
                str = `0x${str}`;
            }
            const n = BigInt(str);
            return "-" === sign ? BigInt(-1) * n : n;
        }
        const n = parseInt(str, radix);
        return "-" === sign ? -1 * n : n;
    }
    function intStringify(node, radix, prefix) {
        const {value: value} = node;
        if (intIdentify(value)) {
            const str = value.toString(radix);
            return value < 0 ? "-" + prefix + str.substr(1) : prefix + str;
        }
        return stringifyNumber.stringifyNumber(node);
    }
    const intBin = {
        identify: intIdentify,
        default: !0,
        tag: "tag:yaml.org,2002:int",
        format: "BIN",
        test: /^[-+]?0b[0-1_]+$/,
        resolve: (str, _onError, opt) => intResolve(str, 2, 2, opt),
        stringify: node => intStringify(node, 2, "0b")
    }, intOct = {
        identify: intIdentify,
        default: !0,
        tag: "tag:yaml.org,2002:int",
        format: "OCT",
        test: /^[-+]?0[0-7_]+$/,
        resolve: (str, _onError, opt) => intResolve(str, 1, 8, opt),
        stringify: node => intStringify(node, 8, "0")
    }, int$1 = {
        identify: intIdentify,
        default: !0,
        tag: "tag:yaml.org,2002:int",
        test: /^[-+]?[0-9][0-9_]*$/,
        resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
        stringify: stringifyNumber.stringifyNumber
    }, intHex = {
        identify: intIdentify,
        default: !0,
        tag: "tag:yaml.org,2002:int",
        format: "HEX",
        test: /^[-+]?0x[0-9a-fA-F_]+$/,
        resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
        stringify: node => intStringify(node, 16, "0x")
    };
    return int.int = int$1, int.intBin = intBin, int.intHex = intHex, int.intOct = intOct, 
    int;
}

var set = {}, hasRequiredSet;

function requireSet() {
    if (hasRequiredSet) return set;
    hasRequiredSet = 1;
    var identity = requireIdentity(), Pair = requirePair(), YAMLMap = requireYAMLMap();
    class YAMLSet extends YAMLMap.YAMLMap {
        constructor(schema) {
            super(schema), this.tag = YAMLSet.tag;
        }
        add(key) {
            let pair;
            pair = identity.isPair(key) ? key : key && "object" == typeof key && "key" in key && "value" in key && null === key.value ? new Pair.Pair(key.key, null) : new Pair.Pair(key, null);
            YAMLMap.findPair(this.items, pair.key) || this.items.push(pair);
        }
        get(key, keepPair) {
            const pair = YAMLMap.findPair(this.items, key);
            return !keepPair && identity.isPair(pair) ? identity.isScalar(pair.key) ? pair.key.value : pair.key : pair;
        }
        set(key, value) {
            if ("boolean" != typeof value) throw new Error("Expected boolean value for set(key, value) in a YAML set, not " + typeof value);
            const prev = YAMLMap.findPair(this.items, key);
            prev && !value ? this.items.splice(this.items.indexOf(prev), 1) : !prev && value && this.items.push(new Pair.Pair(key));
        }
        toJSON(_, ctx) {
            return super.toJSON(_, ctx, Set);
        }
        toString(ctx, onComment, onChompKeep) {
            if (!ctx) return JSON.stringify(this);
            if (this.hasAllNullValues(!0)) return super.toString(Object.assign({}, ctx, {
                allNullValues: !0
            }), onComment, onChompKeep);
            throw new Error("Set items must all have null values");
        }
        static from(schema, iterable, ctx) {
            const {replacer: replacer} = ctx, set = new this(schema);
            if (iterable && Symbol.iterator in Object(iterable)) for (let value of iterable) "function" == typeof replacer && (value = replacer.call(iterable, value, value)), 
            set.items.push(Pair.createPair(value, null, ctx));
            return set;
        }
    }
    YAMLSet.tag = "tag:yaml.org,2002:set";
    const set$1 = {
        collection: "map",
        identify: value => value instanceof Set,
        nodeClass: YAMLSet,
        default: !1,
        tag: "tag:yaml.org,2002:set",
        createNode: (schema, iterable, ctx) => YAMLSet.from(schema, iterable, ctx),
        resolve(map, onError) {
            if (identity.isMap(map)) {
                if (map.hasAllNullValues(!0)) return Object.assign(new YAMLSet, map);
                onError("Set items must all have null values");
            } else onError("Expected a mapping for this tag");
            return map;
        }
    };
    return set.YAMLSet = YAMLSet, set.set = set$1, set;
}

var timestamp = {}, hasRequiredTimestamp, hasRequiredSchema$1, hasRequiredTags, hasRequiredSchema;

function requireTimestamp() {
    if (hasRequiredTimestamp) return timestamp;
    hasRequiredTimestamp = 1;
    var stringifyNumber = requireStringifyNumber();
    function parseSexagesimal(str, asBigInt) {
        const sign = str[0], parts = "-" === sign || "+" === sign ? str.substring(1) : str, num = n => asBigInt ? BigInt(n) : Number(n), res = parts.replace(/_/g, "").split(":").reduce(((res, p) => res * num(60) + num(p)), num(0));
        return "-" === sign ? num(-1) * res : res;
    }
    function stringifySexagesimal(node) {
        let {value: value} = node, num = n => n;
        if ("bigint" == typeof value) num = n => BigInt(n); else if (isNaN(value) || !isFinite(value)) return stringifyNumber.stringifyNumber(node);
        let sign = "";
        value < 0 && (sign = "-", value *= num(-1));
        const _60 = num(60), parts = [ value % _60 ];
        return value < 60 ? parts.unshift(0) : (value = (value - parts[0]) / _60, parts.unshift(value % _60), 
        value >= 60 && (value = (value - parts[0]) / _60, parts.unshift(value))), sign + parts.map((n => String(n).padStart(2, "0"))).join(":").replace(/000000\d*$/, "");
    }
    const intTime = {
        identify: value => "bigint" == typeof value || Number.isInteger(value),
        default: !0,
        tag: "tag:yaml.org,2002:int",
        format: "TIME",
        test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
        resolve: (str, _onError, {intAsBigInt: intAsBigInt}) => parseSexagesimal(str, intAsBigInt),
        stringify: stringifySexagesimal
    }, floatTime = {
        identify: value => "number" == typeof value,
        default: !0,
        tag: "tag:yaml.org,2002:float",
        format: "TIME",
        test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
        resolve: str => parseSexagesimal(str, !1),
        stringify: stringifySexagesimal
    }, timestamp$1 = {
        identify: value => value instanceof Date,
        default: !0,
        tag: "tag:yaml.org,2002:timestamp",
        test: RegExp("^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?$"),
        resolve(str) {
            const match = str.match(timestamp$1.test);
            if (!match) throw new Error("!!timestamp expects a date, starting with yyyy-mm-dd");
            const [, year, month, day, hour, minute, second] = match.map(Number), millisec = match[7] ? Number((match[7] + "00").substr(1, 3)) : 0;
            let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec);
            const tz = match[8];
            if (tz && "Z" !== tz) {
                let d = parseSexagesimal(tz, !1);
                Math.abs(d) < 30 && (d *= 60), date -= 6e4 * d;
            }
            return new Date(date);
        },
        stringify: ({value: value}) => value.toISOString().replace(/((T00:00)?:00)?\.000Z$/, "")
    };
    return timestamp.floatTime = floatTime, timestamp.intTime = intTime, timestamp.timestamp = timestamp$1, 
    timestamp;
}

function requireSchema$1() {
    if (hasRequiredSchema$1) return schema;
    hasRequiredSchema$1 = 1;
    var map = requireMap(), _null = require_null(), seq = requireSeq(), string = requireString(), binary = requireBinary(), bool = requireBool(), float = requireFloat(), int = requireInt(), merge = requireMerge(), omap = requireOmap(), pairs = requirePairs(), set = requireSet(), timestamp = requireTimestamp();
    const schema$1 = [ map.map, seq.seq, string.string, _null.nullTag, bool.trueTag, bool.falseTag, int.intBin, int.intOct, int.int, int.intHex, float.floatNaN, float.floatExp, float.float, binary.binary, merge.merge, omap.omap, pairs.pairs, set.set, timestamp.intTime, timestamp.floatTime, timestamp.timestamp ];
    return schema.schema = schema$1, schema;
}

function requireTags() {
    if (hasRequiredTags) return tags;
    hasRequiredTags = 1;
    var map = requireMap(), _null = require_null(), seq = requireSeq(), string = requireString(), bool = requireBool$1(), float = requireFloat$1(), int = requireInt$1(), schema = requireSchema$3(), schema$1 = requireSchema$2(), binary = requireBinary(), merge = requireMerge(), omap = requireOmap(), pairs = requirePairs(), schema$2 = requireSchema$1(), set = requireSet(), timestamp = requireTimestamp();
    const schemas = new Map([ [ "core", schema.schema ], [ "failsafe", [ map.map, seq.seq, string.string ] ], [ "json", schema$1.schema ], [ "yaml11", schema$2.schema ], [ "yaml-1.1", schema$2.schema ] ]), tagsByName = {
        binary: binary.binary,
        bool: bool.boolTag,
        float: float.float,
        floatExp: float.floatExp,
        floatNaN: float.floatNaN,
        floatTime: timestamp.floatTime,
        int: int.int,
        intHex: int.intHex,
        intOct: int.intOct,
        intTime: timestamp.intTime,
        map: map.map,
        merge: merge.merge,
        null: _null.nullTag,
        omap: omap.omap,
        pairs: pairs.pairs,
        seq: seq.seq,
        set: set.set,
        timestamp: timestamp.timestamp
    }, coreKnownTags = {
        "tag:yaml.org,2002:binary": binary.binary,
        "tag:yaml.org,2002:merge": merge.merge,
        "tag:yaml.org,2002:omap": omap.omap,
        "tag:yaml.org,2002:pairs": pairs.pairs,
        "tag:yaml.org,2002:set": set.set,
        "tag:yaml.org,2002:timestamp": timestamp.timestamp
    };
    return tags.coreKnownTags = coreKnownTags, tags.getTags = function(customTags, schemaName, addMergeTag) {
        const schemaTags = schemas.get(schemaName);
        if (schemaTags && !customTags) return addMergeTag && !schemaTags.includes(merge.merge) ? schemaTags.concat(merge.merge) : schemaTags.slice();
        let tags = schemaTags;
        if (!tags) {
            if (!Array.isArray(customTags)) {
                const keys = Array.from(schemas.keys()).filter((key => "yaml11" !== key)).map((key => JSON.stringify(key))).join(", ");
                throw new Error(`Unknown schema "${schemaName}"; use one of ${keys} or define customTags array`);
            }
            tags = [];
        }
        if (Array.isArray(customTags)) for (const tag of customTags) tags = tags.concat(tag); else "function" == typeof customTags && (tags = customTags(tags.slice()));
        return addMergeTag && (tags = tags.concat(merge.merge)), tags.reduce(((tags, tag) => {
            const tagObj = "string" == typeof tag ? tagsByName[tag] : tag;
            if (!tagObj) {
                const tagName = JSON.stringify(tag), keys = Object.keys(tagsByName).map((key => JSON.stringify(key))).join(", ");
                throw new Error(`Unknown custom tag ${tagName}; use one of ${keys}`);
            }
            return tags.includes(tagObj) || tags.push(tagObj), tags;
        }), []);
    }, tags;
}

function requireSchema() {
    if (hasRequiredSchema) return Schema;
    hasRequiredSchema = 1;
    var identity = requireIdentity(), map = requireMap(), seq = requireSeq(), string = requireString(), tags = requireTags();
    const sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0;
    return Schema.Schema = class Schema {
        constructor({compat: compat, customTags: customTags, merge: merge, resolveKnownTags: resolveKnownTags, schema: schema, sortMapEntries: sortMapEntries, toStringDefaults: toStringDefaults}) {
            this.compat = Array.isArray(compat) ? tags.getTags(compat, "compat") : compat ? tags.getTags(null, compat) : null, 
            this.name = "string" == typeof schema && schema || "core", this.knownTags = resolveKnownTags ? tags.coreKnownTags : {}, 
            this.tags = tags.getTags(customTags, this.name, merge), this.toStringOptions = toStringDefaults ?? null, 
            Object.defineProperty(this, identity.MAP, {
                value: map.map
            }), Object.defineProperty(this, identity.SCALAR, {
                value: string.string
            }), Object.defineProperty(this, identity.SEQ, {
                value: seq.seq
            }), this.sortMapEntries = "function" == typeof sortMapEntries ? sortMapEntries : !0 === sortMapEntries ? sortMapEntriesByKey : null;
        }
        clone() {
            const copy = Object.create(Schema.prototype, Object.getOwnPropertyDescriptors(this));
            return copy.tags = this.tags.slice(), copy;
        }
    }, Schema;
}

var stringifyDocument = {}, hasRequiredStringifyDocument, hasRequiredDocument;

function requireStringifyDocument() {
    if (hasRequiredStringifyDocument) return stringifyDocument;
    hasRequiredStringifyDocument = 1;
    var identity = requireIdentity(), stringify = requireStringify(), stringifyComment = requireStringifyComment();
    return stringifyDocument.stringifyDocument = function(doc, options) {
        const lines = [];
        let hasDirectives = !0 === options.directives;
        if (!1 !== options.directives && doc.directives) {
            const dir = doc.directives.toString(doc);
            dir ? (lines.push(dir), hasDirectives = !0) : doc.directives.docStart && (hasDirectives = !0);
        }
        hasDirectives && lines.push("---");
        const ctx = stringify.createStringifyContext(doc, options), {commentString: commentString} = ctx.options;
        if (doc.commentBefore) {
            1 !== lines.length && lines.unshift("");
            const cs = commentString(doc.commentBefore);
            lines.unshift(stringifyComment.indentComment(cs, ""));
        }
        let chompKeep = !1, contentComment = null;
        if (doc.contents) {
            if (identity.isNode(doc.contents)) {
                if (doc.contents.spaceBefore && hasDirectives && lines.push(""), doc.contents.commentBefore) {
                    const cs = commentString(doc.contents.commentBefore);
                    lines.push(stringifyComment.indentComment(cs, ""));
                }
                ctx.forceBlockIndent = !!doc.comment, contentComment = doc.contents.comment;
            }
            const onChompKeep = contentComment ? void 0 : () => chompKeep = !0;
            let body = stringify.stringify(doc.contents, ctx, (() => contentComment = null), onChompKeep);
            contentComment && (body += stringifyComment.lineComment(body, "", commentString(contentComment))), 
            "|" !== body[0] && ">" !== body[0] || "---" !== lines[lines.length - 1] ? lines.push(body) : lines[lines.length - 1] = `--- ${body}`;
        } else lines.push(stringify.stringify(doc.contents, ctx));
        if (doc.directives?.docEnd) if (doc.comment) {
            const cs = commentString(doc.comment);
            cs.includes("\n") ? (lines.push("..."), lines.push(stringifyComment.indentComment(cs, ""))) : lines.push(`... ${cs}`);
        } else lines.push("..."); else {
            let dc = doc.comment;
            dc && chompKeep && (dc = dc.replace(/^\n+/, "")), dc && (chompKeep && !contentComment || "" === lines[lines.length - 1] || lines.push(""), 
            lines.push(stringifyComment.indentComment(commentString(dc), "")));
        }
        return lines.join("\n") + "\n";
    }, stringifyDocument;
}

function requireDocument() {
    if (hasRequiredDocument) return Document;
    hasRequiredDocument = 1;
    var Alias = requireAlias(), Collection = requireCollection(), identity = requireIdentity(), Pair = requirePair(), toJS = requireToJS(), Schema = requireSchema(), stringifyDocument = requireStringifyDocument(), anchors = requireAnchors(), applyReviver = requireApplyReviver(), createNode = requireCreateNode(), directives = requireDirectives();
    function assertCollection(contents) {
        if (identity.isCollection(contents)) return !0;
        throw new Error("Expected a YAML collection as document contents");
    }
    return Document.Document = class Document {
        constructor(value, replacer, options) {
            this.commentBefore = null, this.comment = null, this.errors = [], this.warnings = [], 
            Object.defineProperty(this, identity.NODE_TYPE, {
                value: identity.DOC
            });
            let _replacer = null;
            "function" == typeof replacer || Array.isArray(replacer) ? _replacer = replacer : void 0 === options && replacer && (options = replacer, 
            replacer = void 0);
            const opt = Object.assign({
                intAsBigInt: !1,
                keepSourceTokens: !1,
                logLevel: "warn",
                prettyErrors: !0,
                strict: !0,
                stringKeys: !1,
                uniqueKeys: !0,
                version: "1.2"
            }, options);
            this.options = opt;
            let {version: version} = opt;
            options?._directives ? (this.directives = options._directives.atDocument(), this.directives.yaml.explicit && (version = this.directives.yaml.version)) : this.directives = new directives.Directives({
                version: version
            }), this.setSchema(version, options), this.contents = void 0 === value ? null : this.createNode(value, _replacer, options);
        }
        clone() {
            const copy = Object.create(Document.prototype, {
                [identity.NODE_TYPE]: {
                    value: identity.DOC
                }
            });
            return copy.commentBefore = this.commentBefore, copy.comment = this.comment, copy.errors = this.errors.slice(), 
            copy.warnings = this.warnings.slice(), copy.options = Object.assign({}, this.options), 
            this.directives && (copy.directives = this.directives.clone()), copy.schema = this.schema.clone(), 
            copy.contents = identity.isNode(this.contents) ? this.contents.clone(copy.schema) : this.contents, 
            this.range && (copy.range = this.range.slice()), copy;
        }
        add(value) {
            assertCollection(this.contents) && this.contents.add(value);
        }
        addIn(path, value) {
            assertCollection(this.contents) && this.contents.addIn(path, value);
        }
        createAlias(node, name) {
            if (!node.anchor) {
                const prev = anchors.anchorNames(this);
                node.anchor = !name || prev.has(name) ? anchors.findNewAnchor(name || "a", prev) : name;
            }
            return new Alias.Alias(node.anchor);
        }
        createNode(value, replacer, options) {
            let _replacer;
            if ("function" == typeof replacer) value = replacer.call({
                "": value
            }, "", value), _replacer = replacer; else if (Array.isArray(replacer)) {
                const keyToStr = v => "number" == typeof v || v instanceof String || v instanceof Number, asStr = replacer.filter(keyToStr).map(String);
                asStr.length > 0 && (replacer = replacer.concat(asStr)), _replacer = replacer;
            } else void 0 === options && replacer && (options = replacer, replacer = void 0);
            const {aliasDuplicateObjects: aliasDuplicateObjects, anchorPrefix: anchorPrefix, flow: flow, keepUndefined: keepUndefined, onTagObj: onTagObj, tag: tag} = options ?? {}, {onAnchor: onAnchor, setAnchors: setAnchors, sourceObjects: sourceObjects} = anchors.createNodeAnchors(this, anchorPrefix || "a"), ctx = {
                aliasDuplicateObjects: aliasDuplicateObjects ?? !0,
                keepUndefined: keepUndefined ?? !1,
                onAnchor: onAnchor,
                onTagObj: onTagObj,
                replacer: _replacer,
                schema: this.schema,
                sourceObjects: sourceObjects
            }, node = createNode.createNode(value, tag, ctx);
            return flow && identity.isCollection(node) && (node.flow = !0), setAnchors(), node;
        }
        createPair(key, value, options = {}) {
            const k = this.createNode(key, null, options), v = this.createNode(value, null, options);
            return new Pair.Pair(k, v);
        }
        delete(key) {
            return !!assertCollection(this.contents) && this.contents.delete(key);
        }
        deleteIn(path) {
            return Collection.isEmptyPath(path) ? null != this.contents && (this.contents = null, 
            !0) : !!assertCollection(this.contents) && this.contents.deleteIn(path);
        }
        get(key, keepScalar) {
            return identity.isCollection(this.contents) ? this.contents.get(key, keepScalar) : void 0;
        }
        getIn(path, keepScalar) {
            return Collection.isEmptyPath(path) ? !keepScalar && identity.isScalar(this.contents) ? this.contents.value : this.contents : identity.isCollection(this.contents) ? this.contents.getIn(path, keepScalar) : void 0;
        }
        has(key) {
            return !!identity.isCollection(this.contents) && this.contents.has(key);
        }
        hasIn(path) {
            return Collection.isEmptyPath(path) ? void 0 !== this.contents : !!identity.isCollection(this.contents) && this.contents.hasIn(path);
        }
        set(key, value) {
            null == this.contents ? this.contents = Collection.collectionFromPath(this.schema, [ key ], value) : assertCollection(this.contents) && this.contents.set(key, value);
        }
        setIn(path, value) {
            Collection.isEmptyPath(path) ? this.contents = value : null == this.contents ? this.contents = Collection.collectionFromPath(this.schema, Array.from(path), value) : assertCollection(this.contents) && this.contents.setIn(path, value);
        }
        setSchema(version, options = {}) {
            let opt;
            switch ("number" == typeof version && (version = String(version)), version) {
              case "1.1":
                this.directives ? this.directives.yaml.version = "1.1" : this.directives = new directives.Directives({
                    version: "1.1"
                }), opt = {
                    resolveKnownTags: !1,
                    schema: "yaml-1.1"
                };
                break;

              case "1.2":
              case "next":
                this.directives ? this.directives.yaml.version = version : this.directives = new directives.Directives({
                    version: version
                }), opt = {
                    resolveKnownTags: !0,
                    schema: "core"
                };
                break;

              case null:
                this.directives && delete this.directives, opt = null;
                break;

              default:
                {
                    const sv = JSON.stringify(version);
                    throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${sv}`);
                }
            }
            if (options.schema instanceof Object) this.schema = options.schema; else {
                if (!opt) throw new Error("With a null YAML version, the { schema: Schema } option is required");
                this.schema = new Schema.Schema(Object.assign(opt, options));
            }
        }
        toJS({json: json, jsonArg: jsonArg, mapAsMap: mapAsMap, maxAliasCount: maxAliasCount, onAnchor: onAnchor, reviver: reviver} = {}) {
            const ctx = {
                anchors: new Map,
                doc: this,
                keep: !json,
                mapAsMap: !0 === mapAsMap,
                mapKeyWarned: !1,
                maxAliasCount: "number" == typeof maxAliasCount ? maxAliasCount : 100
            }, res = toJS.toJS(this.contents, jsonArg ?? "", ctx);
            if ("function" == typeof onAnchor) for (const {count: count, res: res} of ctx.anchors.values()) onAnchor(res, count);
            return "function" == typeof reviver ? applyReviver.applyReviver(reviver, {
                "": res
            }, "", res) : res;
        }
        toJSON(jsonArg, onAnchor) {
            return this.toJS({
                json: !0,
                jsonArg: jsonArg,
                mapAsMap: !1,
                onAnchor: onAnchor
            });
        }
        toString(options = {}) {
            if (this.errors.length > 0) throw new Error("Document with errors cannot be stringified");
            if ("indent" in options && (!Number.isInteger(options.indent) || Number(options.indent) <= 0)) {
                const s = JSON.stringify(options.indent);
                throw new Error(`"indent" option must be a positive integer, not ${s}`);
            }
            return stringifyDocument.stringifyDocument(this, options);
        }
    }, Document;
}

var errors$1 = {}, hasRequiredErrors;

function requireErrors() {
    if (hasRequiredErrors) return errors$1;
    hasRequiredErrors = 1;
    class YAMLError extends Error {
        constructor(name, pos, code, message) {
            super(), this.name = name, this.code = code, this.message = message, this.pos = pos;
        }
    }
    return errors$1.YAMLError = YAMLError, errors$1.YAMLParseError = class extends YAMLError {
        constructor(pos, code, message) {
            super("YAMLParseError", pos, code, message);
        }
    }, errors$1.YAMLWarning = class extends YAMLError {
        constructor(pos, code, message) {
            super("YAMLWarning", pos, code, message);
        }
    }, errors$1.prettifyError = (src, lc) => error => {
        if (-1 === error.pos[0]) return;
        error.linePos = error.pos.map((pos => lc.linePos(pos)));
        const {line: line, col: col} = error.linePos[0];
        error.message += ` at line ${line}, column ${col}`;
        let ci = col - 1, lineStr = src.substring(lc.lineStarts[line - 1], lc.lineStarts[line]).replace(/[\n\r]+$/, "");
        if (ci >= 60 && lineStr.length > 80) {
            const trimStart = Math.min(ci - 39, lineStr.length - 79);
            lineStr = "…" + lineStr.substring(trimStart), ci -= trimStart - 1;
        }
        if (lineStr.length > 80 && (lineStr = lineStr.substring(0, 79) + "…"), line > 1 && /^ *$/.test(lineStr.substring(0, ci))) {
            let prev = src.substring(lc.lineStarts[line - 2], lc.lineStarts[line - 1]);
            prev.length > 80 && (prev = prev.substring(0, 79) + "…\n"), lineStr = prev + lineStr;
        }
        if (/[^ ]/.test(lineStr)) {
            let count = 1;
            const end = error.linePos[1];
            end && end.line === line && end.col > col && (count = Math.max(1, Math.min(end.col - col, 80 - ci)));
            const pointer = " ".repeat(ci) + "^".repeat(count);
            error.message += `:\n\n${lineStr}\n${pointer}\n`;
        }
    }, errors$1;
}

var composeDoc = {}, composeNode = {}, composeCollection = {}, resolveBlockMap = {}, resolveProps = {}, hasRequiredResolveProps;

function requireResolveProps() {
    if (hasRequiredResolveProps) return resolveProps;
    return hasRequiredResolveProps = 1, resolveProps.resolveProps = function(tokens, {flow: flow, indicator: indicator, next: next, offset: offset, onError: onError, parentIndent: parentIndent, startOnNewline: startOnNewline}) {
        let spaceBefore = !1, atNewline = startOnNewline, hasSpace = startOnNewline, comment = "", commentSep = "", hasNewline = !1, reqSpace = !1, tab = null, anchor = null, tag = null, newlineAfterProp = null, comma = null, found = null, start = null;
        for (const token of tokens) switch (reqSpace && ("space" !== token.type && "newline" !== token.type && "comma" !== token.type && onError(token.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space"), 
        reqSpace = !1), tab && (atNewline && "comment" !== token.type && "newline" !== token.type && onError(tab, "TAB_AS_INDENT", "Tabs are not allowed as indentation"), 
        tab = null), token.type) {
          case "space":
            flow || "doc-start" === indicator && "flow-collection" === next?.type || !token.source.includes("\t") || (tab = token), 
            hasSpace = !0;
            break;

          case "comment":
            {
                hasSpace || onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
                const cb = token.source.substring(1) || " ";
                comment ? comment += commentSep + cb : comment = cb, commentSep = "", atNewline = !1;
                break;
            }

          case "newline":
            atNewline ? comment ? comment += token.source : spaceBefore = !0 : commentSep += token.source, 
            atNewline = !0, hasNewline = !0, (anchor || tag) && (newlineAfterProp = token), 
            hasSpace = !0;
            break;

          case "anchor":
            anchor && onError(token, "MULTIPLE_ANCHORS", "A node can have at most one anchor"), 
            token.source.endsWith(":") && onError(token.offset + token.source.length - 1, "BAD_ALIAS", "Anchor ending in : is ambiguous", !0), 
            anchor = token, null === start && (start = token.offset), atNewline = !1, hasSpace = !1, 
            reqSpace = !0;
            break;

          case "tag":
            tag && onError(token, "MULTIPLE_TAGS", "A node can have at most one tag"), tag = token, 
            null === start && (start = token.offset), atNewline = !1, hasSpace = !1, reqSpace = !0;
            break;

          case indicator:
            (anchor || tag) && onError(token, "BAD_PROP_ORDER", `Anchors and tags must be after the ${token.source} indicator`), 
            found && onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.source} in ${flow ?? "collection"}`), 
            found = token, atNewline = "seq-item-ind" === indicator || "explicit-key-ind" === indicator, 
            hasSpace = !1;
            break;

          case "comma":
            if (flow) {
                comma && onError(token, "UNEXPECTED_TOKEN", `Unexpected , in ${flow}`), comma = token, 
                atNewline = !1, hasSpace = !1;
                break;
            }

          default:
            onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.type} token`), atNewline = !1, 
            hasSpace = !1;
        }
        const last = tokens[tokens.length - 1], end = last ? last.offset + last.source.length : offset;
        return reqSpace && next && "space" !== next.type && "newline" !== next.type && "comma" !== next.type && ("scalar" !== next.type || "" !== next.source) && onError(next.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space"), 
        tab && (atNewline && tab.indent <= parentIndent || "block-map" === next?.type || "block-seq" === next?.type) && onError(tab, "TAB_AS_INDENT", "Tabs are not allowed as indentation"), 
        {
            comma: comma,
            found: found,
            spaceBefore: spaceBefore,
            comment: comment,
            hasNewline: hasNewline,
            anchor: anchor,
            tag: tag,
            newlineAfterProp: newlineAfterProp,
            end: end,
            start: start ?? end
        };
    }, resolveProps;
}

var utilContainsNewline = {}, hasRequiredUtilContainsNewline;

function requireUtilContainsNewline() {
    if (hasRequiredUtilContainsNewline) return utilContainsNewline;
    return hasRequiredUtilContainsNewline = 1, utilContainsNewline.containsNewline = function containsNewline(key) {
        if (!key) return null;
        switch (key.type) {
          case "alias":
          case "scalar":
          case "double-quoted-scalar":
          case "single-quoted-scalar":
            if (key.source.includes("\n")) return !0;
            if (key.end) for (const st of key.end) if ("newline" === st.type) return !0;
            return !1;

          case "flow-collection":
            for (const it of key.items) {
                for (const st of it.start) if ("newline" === st.type) return !0;
                if (it.sep) for (const st of it.sep) if ("newline" === st.type) return !0;
                if (containsNewline(it.key) || containsNewline(it.value)) return !0;
            }
            return !1;

          default:
            return !0;
        }
    }, utilContainsNewline;
}

var utilFlowIndentCheck = {}, hasRequiredUtilFlowIndentCheck;

function requireUtilFlowIndentCheck() {
    if (hasRequiredUtilFlowIndentCheck) return utilFlowIndentCheck;
    hasRequiredUtilFlowIndentCheck = 1;
    var utilContainsNewline = requireUtilContainsNewline();
    return utilFlowIndentCheck.flowIndentCheck = function(indent, fc, onError) {
        if ("flow-collection" === fc?.type) {
            const end = fc.end[0];
            if (end.indent === indent && ("]" === end.source || "}" === end.source) && utilContainsNewline.containsNewline(fc)) {
                onError(end, "BAD_INDENT", "Flow end indicator should be more indented than parent", !0);
            }
        }
    }, utilFlowIndentCheck;
}

var utilMapIncludes = {}, hasRequiredUtilMapIncludes, hasRequiredResolveBlockMap;

function requireUtilMapIncludes() {
    if (hasRequiredUtilMapIncludes) return utilMapIncludes;
    hasRequiredUtilMapIncludes = 1;
    var identity = requireIdentity();
    return utilMapIncludes.mapIncludes = function(ctx, items, search) {
        const {uniqueKeys: uniqueKeys} = ctx.options;
        if (!1 === uniqueKeys) return !1;
        const isEqual = "function" == typeof uniqueKeys ? uniqueKeys : (a, b) => a === b || identity.isScalar(a) && identity.isScalar(b) && a.value === b.value;
        return items.some((pair => isEqual(pair.key, search)));
    }, utilMapIncludes;
}

function requireResolveBlockMap() {
    if (hasRequiredResolveBlockMap) return resolveBlockMap;
    hasRequiredResolveBlockMap = 1;
    var Pair = requirePair(), YAMLMap = requireYAMLMap(), resolveProps = requireResolveProps(), utilContainsNewline = requireUtilContainsNewline(), utilFlowIndentCheck = requireUtilFlowIndentCheck(), utilMapIncludes = requireUtilMapIncludes();
    const startColMsg = "All mapping items must start at the same column";
    return resolveBlockMap.resolveBlockMap = function({composeNode: composeNode, composeEmptyNode: composeEmptyNode}, ctx, bm, onError, tag) {
        const map = new (tag?.nodeClass ?? YAMLMap.YAMLMap)(ctx.schema);
        ctx.atRoot && (ctx.atRoot = !1);
        let offset = bm.offset, commentEnd = null;
        for (const collItem of bm.items) {
            const {start: start, key: key, sep: sep, value: value} = collItem, keyProps = resolveProps.resolveProps(start, {
                indicator: "explicit-key-ind",
                next: key ?? sep?.[0],
                offset: offset,
                onError: onError,
                parentIndent: bm.indent,
                startOnNewline: !0
            }), implicitKey = !keyProps.found;
            if (implicitKey) {
                if (key && ("block-seq" === key.type ? onError(offset, "BLOCK_AS_IMPLICIT_KEY", "A block sequence may not be used as an implicit map key") : "indent" in key && key.indent !== bm.indent && onError(offset, "BAD_INDENT", startColMsg)), 
                !keyProps.anchor && !keyProps.tag && !sep) {
                    commentEnd = keyProps.end, keyProps.comment && (map.comment ? map.comment += "\n" + keyProps.comment : map.comment = keyProps.comment);
                    continue;
                }
                (keyProps.newlineAfterProp || utilContainsNewline.containsNewline(key)) && onError(key ?? start[start.length - 1], "MULTILINE_IMPLICIT_KEY", "Implicit keys need to be on a single line");
            } else keyProps.found?.indent !== bm.indent && onError(offset, "BAD_INDENT", startColMsg);
            ctx.atKey = !0;
            const keyStart = keyProps.end, keyNode = key ? composeNode(ctx, key, keyProps, onError) : composeEmptyNode(ctx, keyStart, start, null, keyProps, onError);
            ctx.schema.compat && utilFlowIndentCheck.flowIndentCheck(bm.indent, key, onError), 
            ctx.atKey = !1, utilMapIncludes.mapIncludes(ctx, map.items, keyNode) && onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
            const valueProps = resolveProps.resolveProps(sep ?? [], {
                indicator: "map-value-ind",
                next: value,
                offset: keyNode.range[2],
                onError: onError,
                parentIndent: bm.indent,
                startOnNewline: !key || "block-scalar" === key.type
            });
            if (offset = valueProps.end, valueProps.found) {
                implicitKey && ("block-map" !== value?.type || valueProps.hasNewline || onError(offset, "BLOCK_AS_IMPLICIT_KEY", "Nested mappings are not allowed in compact mappings"), 
                ctx.options.strict && keyProps.start < valueProps.found.offset - 1024 && onError(keyNode.range, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit block mapping key"));
                const valueNode = value ? composeNode(ctx, value, valueProps, onError) : composeEmptyNode(ctx, offset, sep, null, valueProps, onError);
                ctx.schema.compat && utilFlowIndentCheck.flowIndentCheck(bm.indent, value, onError), 
                offset = valueNode.range[2];
                const pair = new Pair.Pair(keyNode, valueNode);
                ctx.options.keepSourceTokens && (pair.srcToken = collItem), map.items.push(pair);
            } else {
                implicitKey && onError(keyNode.range, "MISSING_CHAR", "Implicit map keys need to be followed by map values"), 
                valueProps.comment && (keyNode.comment ? keyNode.comment += "\n" + valueProps.comment : keyNode.comment = valueProps.comment);
                const pair = new Pair.Pair(keyNode);
                ctx.options.keepSourceTokens && (pair.srcToken = collItem), map.items.push(pair);
            }
        }
        return commentEnd && commentEnd < offset && onError(commentEnd, "IMPOSSIBLE", "Map comment with trailing content"), 
        map.range = [ bm.offset, offset, commentEnd ?? offset ], map;
    }, resolveBlockMap;
}

var resolveBlockSeq = {}, hasRequiredResolveBlockSeq;

function requireResolveBlockSeq() {
    if (hasRequiredResolveBlockSeq) return resolveBlockSeq;
    hasRequiredResolveBlockSeq = 1;
    var YAMLSeq = requireYAMLSeq(), resolveProps = requireResolveProps(), utilFlowIndentCheck = requireUtilFlowIndentCheck();
    return resolveBlockSeq.resolveBlockSeq = function({composeNode: composeNode, composeEmptyNode: composeEmptyNode}, ctx, bs, onError, tag) {
        const seq = new (tag?.nodeClass ?? YAMLSeq.YAMLSeq)(ctx.schema);
        ctx.atRoot && (ctx.atRoot = !1), ctx.atKey && (ctx.atKey = !1);
        let offset = bs.offset, commentEnd = null;
        for (const {start: start, value: value} of bs.items) {
            const props = resolveProps.resolveProps(start, {
                indicator: "seq-item-ind",
                next: value,
                offset: offset,
                onError: onError,
                parentIndent: bs.indent,
                startOnNewline: !0
            });
            if (!props.found) {
                if (!(props.anchor || props.tag || value)) {
                    commentEnd = props.end, props.comment && (seq.comment = props.comment);
                    continue;
                }
                value && "block-seq" === value.type ? onError(props.end, "BAD_INDENT", "All sequence items must start at the same column") : onError(offset, "MISSING_CHAR", "Sequence item without - indicator");
            }
            const node = value ? composeNode(ctx, value, props, onError) : composeEmptyNode(ctx, props.end, start, null, props, onError);
            ctx.schema.compat && utilFlowIndentCheck.flowIndentCheck(bs.indent, value, onError), 
            offset = node.range[2], seq.items.push(node);
        }
        return seq.range = [ bs.offset, offset, commentEnd ?? offset ], seq;
    }, resolveBlockSeq;
}

var resolveFlowCollection = {}, resolveEnd = {}, hasRequiredResolveEnd, hasRequiredResolveFlowCollection, hasRequiredComposeCollection;

function requireResolveEnd() {
    if (hasRequiredResolveEnd) return resolveEnd;
    return hasRequiredResolveEnd = 1, resolveEnd.resolveEnd = function(end, offset, reqSpace, onError) {
        let comment = "";
        if (end) {
            let hasSpace = !1, sep = "";
            for (const token of end) {
                const {source: source, type: type} = token;
                switch (type) {
                  case "space":
                    hasSpace = !0;
                    break;

                  case "comment":
                    {
                        reqSpace && !hasSpace && onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
                        const cb = source.substring(1) || " ";
                        comment ? comment += sep + cb : comment = cb, sep = "";
                        break;
                    }

                  case "newline":
                    comment && (sep += source), hasSpace = !0;
                    break;

                  default:
                    onError(token, "UNEXPECTED_TOKEN", `Unexpected ${type} at node end`);
                }
                offset += source.length;
            }
        }
        return {
            comment: comment,
            offset: offset
        };
    }, resolveEnd;
}

function requireResolveFlowCollection() {
    if (hasRequiredResolveFlowCollection) return resolveFlowCollection;
    hasRequiredResolveFlowCollection = 1;
    var identity = requireIdentity(), Pair = requirePair(), YAMLMap = requireYAMLMap(), YAMLSeq = requireYAMLSeq(), resolveEnd = requireResolveEnd(), resolveProps = requireResolveProps(), utilContainsNewline = requireUtilContainsNewline(), utilMapIncludes = requireUtilMapIncludes();
    const blockMsg = "Block collections are not allowed within flow collections", isBlock = token => token && ("block-map" === token.type || "block-seq" === token.type);
    return resolveFlowCollection.resolveFlowCollection = function({composeNode: composeNode, composeEmptyNode: composeEmptyNode}, ctx, fc, onError, tag) {
        const isMap = "{" === fc.start.source, fcName = isMap ? "flow map" : "flow sequence", coll = new (tag?.nodeClass ?? (isMap ? YAMLMap.YAMLMap : YAMLSeq.YAMLSeq))(ctx.schema);
        coll.flow = !0;
        const atRoot = ctx.atRoot;
        atRoot && (ctx.atRoot = !1), ctx.atKey && (ctx.atKey = !1);
        let offset = fc.offset + fc.start.source.length;
        for (let i = 0; i < fc.items.length; ++i) {
            const collItem = fc.items[i], {start: start, key: key, sep: sep, value: value} = collItem, props = resolveProps.resolveProps(start, {
                flow: fcName,
                indicator: "explicit-key-ind",
                next: key ?? sep?.[0],
                offset: offset,
                onError: onError,
                parentIndent: fc.indent,
                startOnNewline: !1
            });
            if (!props.found) {
                if (!(props.anchor || props.tag || sep || value)) {
                    0 === i && props.comma ? onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`) : i < fc.items.length - 1 && onError(props.start, "UNEXPECTED_TOKEN", `Unexpected empty item in ${fcName}`), 
                    props.comment && (coll.comment ? coll.comment += "\n" + props.comment : coll.comment = props.comment), 
                    offset = props.end;
                    continue;
                }
                !isMap && ctx.options.strict && utilContainsNewline.containsNewline(key) && onError(key, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
            }
            if (0 === i) props.comma && onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`); else if (props.comma || onError(props.start, "MISSING_CHAR", `Missing , between ${fcName} items`), 
            props.comment) {
                let prevItemComment = "";
                loop: for (const st of start) switch (st.type) {
                  case "comma":
                  case "space":
                    break;

                  case "comment":
                    prevItemComment = st.source.substring(1);
                    break loop;

                  default:
                    break loop;
                }
                if (prevItemComment) {
                    let prev = coll.items[coll.items.length - 1];
                    identity.isPair(prev) && (prev = prev.value ?? prev.key), prev.comment ? prev.comment += "\n" + prevItemComment : prev.comment = prevItemComment, 
                    props.comment = props.comment.substring(prevItemComment.length + 1);
                }
            }
            if (isMap || sep || props.found) {
                ctx.atKey = !0;
                const keyStart = props.end, keyNode = key ? composeNode(ctx, key, props, onError) : composeEmptyNode(ctx, keyStart, start, null, props, onError);
                isBlock(key) && onError(keyNode.range, "BLOCK_IN_FLOW", blockMsg), ctx.atKey = !1;
                const valueProps = resolveProps.resolveProps(sep ?? [], {
                    flow: fcName,
                    indicator: "map-value-ind",
                    next: value,
                    offset: keyNode.range[2],
                    onError: onError,
                    parentIndent: fc.indent,
                    startOnNewline: !1
                });
                if (valueProps.found) {
                    if (!isMap && !props.found && ctx.options.strict) {
                        if (sep) for (const st of sep) {
                            if (st === valueProps.found) break;
                            if ("newline" === st.type) {
                                onError(st, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
                                break;
                            }
                        }
                        props.start < valueProps.found.offset - 1024 && onError(valueProps.found, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit flow sequence key");
                    }
                } else value && ("source" in value && value.source && ":" === value.source[0] ? onError(value, "MISSING_CHAR", `Missing space after : in ${fcName}`) : onError(valueProps.start, "MISSING_CHAR", `Missing , or : between ${fcName} items`));
                const valueNode = value ? composeNode(ctx, value, valueProps, onError) : valueProps.found ? composeEmptyNode(ctx, valueProps.end, sep, null, valueProps, onError) : null;
                valueNode ? isBlock(value) && onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg) : valueProps.comment && (keyNode.comment ? keyNode.comment += "\n" + valueProps.comment : keyNode.comment = valueProps.comment);
                const pair = new Pair.Pair(keyNode, valueNode);
                if (ctx.options.keepSourceTokens && (pair.srcToken = collItem), isMap) {
                    const map = coll;
                    utilMapIncludes.mapIncludes(ctx, map.items, keyNode) && onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique"), 
                    map.items.push(pair);
                } else {
                    const map = new YAMLMap.YAMLMap(ctx.schema);
                    map.flow = !0, map.items.push(pair);
                    const endRange = (valueNode ?? keyNode).range;
                    map.range = [ keyNode.range[0], endRange[1], endRange[2] ], coll.items.push(map);
                }
                offset = valueNode ? valueNode.range[2] : valueProps.end;
            } else {
                const valueNode = value ? composeNode(ctx, value, props, onError) : composeEmptyNode(ctx, props.end, sep, null, props, onError);
                coll.items.push(valueNode), offset = valueNode.range[2], isBlock(value) && onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
            }
        }
        const expectedEnd = isMap ? "}" : "]", [ce, ...ee] = fc.end;
        let cePos = offset;
        if (ce && ce.source === expectedEnd) cePos = ce.offset + ce.source.length; else {
            const name = fcName[0].toUpperCase() + fcName.substring(1);
            onError(offset, atRoot ? "MISSING_CHAR" : "BAD_INDENT", atRoot ? `${name} must end with a ${expectedEnd}` : `${name} in block collection must be sufficiently indented and end with a ${expectedEnd}`), 
            ce && 1 !== ce.source.length && ee.unshift(ce);
        }
        if (ee.length > 0) {
            const end = resolveEnd.resolveEnd(ee, cePos, ctx.options.strict, onError);
            end.comment && (coll.comment ? coll.comment += "\n" + end.comment : coll.comment = end.comment), 
            coll.range = [ fc.offset, cePos, end.offset ];
        } else coll.range = [ fc.offset, cePos, cePos ];
        return coll;
    }, resolveFlowCollection;
}

function requireComposeCollection() {
    if (hasRequiredComposeCollection) return composeCollection;
    hasRequiredComposeCollection = 1;
    var identity = requireIdentity(), Scalar = requireScalar(), YAMLMap = requireYAMLMap(), YAMLSeq = requireYAMLSeq(), resolveBlockMap = requireResolveBlockMap(), resolveBlockSeq = requireResolveBlockSeq(), resolveFlowCollection = requireResolveFlowCollection();
    function resolveCollection(CN, ctx, token, onError, tagName, tag) {
        const coll = "block-map" === token.type ? resolveBlockMap.resolveBlockMap(CN, ctx, token, onError, tag) : "block-seq" === token.type ? resolveBlockSeq.resolveBlockSeq(CN, ctx, token, onError, tag) : resolveFlowCollection.resolveFlowCollection(CN, ctx, token, onError, tag), Coll = coll.constructor;
        return "!" === tagName || tagName === Coll.tagName ? (coll.tag = Coll.tagName, coll) : (tagName && (coll.tag = tagName), 
        coll);
    }
    return composeCollection.composeCollection = function(CN, ctx, token, props, onError) {
        const tagToken = props.tag, tagName = tagToken ? ctx.directives.tagName(tagToken.source, (msg => onError(tagToken, "TAG_RESOLVE_FAILED", msg))) : null;
        if ("block-seq" === token.type) {
            const {anchor: anchor, newlineAfterProp: nl} = props, lastProp = anchor && tagToken ? anchor.offset > tagToken.offset ? anchor : tagToken : anchor ?? tagToken;
            if (lastProp && (!nl || nl.offset < lastProp.offset)) {
                onError(lastProp, "MISSING_CHAR", "Missing newline after block sequence props");
            }
        }
        const expType = "block-map" === token.type ? "map" : "block-seq" === token.type ? "seq" : "{" === token.start.source ? "map" : "seq";
        if (!tagToken || !tagName || "!" === tagName || tagName === YAMLMap.YAMLMap.tagName && "map" === expType || tagName === YAMLSeq.YAMLSeq.tagName && "seq" === expType) return resolveCollection(CN, ctx, token, onError, tagName);
        let tag = ctx.schema.tags.find((t => t.tag === tagName && t.collection === expType));
        if (!tag) {
            const kt = ctx.schema.knownTags[tagName];
            if (!kt || kt.collection !== expType) return kt?.collection ? onError(tagToken, "BAD_COLLECTION_TYPE", `${kt.tag} used for ${expType} collection, but expects ${kt.collection}`, !0) : onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, !0), 
            resolveCollection(CN, ctx, token, onError, tagName);
            ctx.schema.tags.push(Object.assign({}, kt, {
                default: !1
            })), tag = kt;
        }
        const coll = resolveCollection(CN, ctx, token, onError, tagName, tag), res = tag.resolve?.(coll, (msg => onError(tagToken, "TAG_RESOLVE_FAILED", msg)), ctx.options) ?? coll, node = identity.isNode(res) ? res : new Scalar.Scalar(res);
        return node.range = coll.range, node.tag = tagName, tag?.format && (node.format = tag.format), 
        node;
    }, composeCollection;
}

var composeScalar = {}, resolveBlockScalar = {}, hasRequiredResolveBlockScalar;

function requireResolveBlockScalar() {
    if (hasRequiredResolveBlockScalar) return resolveBlockScalar;
    hasRequiredResolveBlockScalar = 1;
    var Scalar = requireScalar();
    return resolveBlockScalar.resolveBlockScalar = function(ctx, scalar, onError) {
        const start = scalar.offset, header = function({offset: offset, props: props}, strict, onError) {
            if ("block-scalar-header" !== props[0].type) return onError(props[0], "IMPOSSIBLE", "Block scalar header not found"), 
            null;
            const {source: source} = props[0], mode = source[0];
            let indent = 0, chomp = "", error = -1;
            for (let i = 1; i < source.length; ++i) {
                const ch = source[i];
                if (chomp || "-" !== ch && "+" !== ch) {
                    const n = Number(ch);
                    !indent && n ? indent = n : -1 === error && (error = offset + i);
                } else chomp = ch;
            }
            -1 !== error && onError(error, "UNEXPECTED_TOKEN", `Block scalar header includes extra characters: ${source}`);
            let hasSpace = !1, comment = "", length = source.length;
            for (let i = 1; i < props.length; ++i) {
                const token = props[i];
                switch (token.type) {
                  case "space":
                    hasSpace = !0;

                  case "newline":
                    length += token.source.length;
                    break;

                  case "comment":
                    if (strict && !hasSpace) {
                        onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
                    }
                    length += token.source.length, comment = token.source.substring(1);
                    break;

                  case "error":
                    onError(token, "UNEXPECTED_TOKEN", token.message), length += token.source.length;
                    break;

                  default:
                    {
                        onError(token, "UNEXPECTED_TOKEN", `Unexpected token in block scalar header: ${token.type}`);
                        const ts = token.source;
                        ts && "string" == typeof ts && (length += ts.length);
                    }
                }
            }
            return {
                mode: mode,
                indent: indent,
                chomp: chomp,
                comment: comment,
                length: length
            };
        }(scalar, ctx.options.strict, onError);
        if (!header) return {
            value: "",
            type: null,
            comment: "",
            range: [ start, start, start ]
        };
        const type = ">" === header.mode ? Scalar.Scalar.BLOCK_FOLDED : Scalar.Scalar.BLOCK_LITERAL, lines = scalar.source ? function(source) {
            const split = source.split(/\n( *)/), first = split[0], m = first.match(/^( *)/), line0 = m?.[1] ? [ m[1], first.slice(m[1].length) ] : [ "", first ], lines = [ line0 ];
            for (let i = 1; i < split.length; i += 2) lines.push([ split[i], split[i + 1] ]);
            return lines;
        }(scalar.source) : [];
        let chompStart = lines.length;
        for (let i = lines.length - 1; i >= 0; --i) {
            const content = lines[i][1];
            if ("" !== content && "\r" !== content) break;
            chompStart = i;
        }
        if (0 === chompStart) {
            const value = "+" === header.chomp && lines.length > 0 ? "\n".repeat(Math.max(1, lines.length - 1)) : "";
            let end = start + header.length;
            return scalar.source && (end += scalar.source.length), {
                value: value,
                type: type,
                comment: header.comment,
                range: [ start, end, end ]
            };
        }
        let trimIndent = scalar.indent + header.indent, offset = scalar.offset + header.length, contentStart = 0;
        for (let i = 0; i < chompStart; ++i) {
            const [indent, content] = lines[i];
            if ("" !== content && "\r" !== content) {
                if (indent.length < trimIndent) {
                    const message = "Block scalars with more-indented leading empty lines must use an explicit indentation indicator";
                    onError(offset + indent.length, "MISSING_CHAR", message);
                }
                if (0 === header.indent && (trimIndent = indent.length), contentStart = i, 0 === trimIndent && !ctx.atRoot) {
                    onError(offset, "BAD_INDENT", "Block scalar values in collections must be indented");
                }
                break;
            }
            0 === header.indent && indent.length > trimIndent && (trimIndent = indent.length), 
            offset += indent.length + content.length + 1;
        }
        for (let i = lines.length - 1; i >= chompStart; --i) lines[i][0].length > trimIndent && (chompStart = i + 1);
        let value = "", sep = "", prevMoreIndented = !1;
        for (let i = 0; i < contentStart; ++i) value += lines[i][0].slice(trimIndent) + "\n";
        for (let i = contentStart; i < chompStart; ++i) {
            let [indent, content] = lines[i];
            offset += indent.length + content.length + 1;
            const crlf = "\r" === content[content.length - 1];
            if (crlf && (content = content.slice(0, -1)), content && indent.length < trimIndent) {
                const message = `Block scalar lines must not be less indented than their ${header.indent ? "explicit indentation indicator" : "first line"}`;
                onError(offset - content.length - (crlf ? 2 : 1), "BAD_INDENT", message), indent = "";
            }
            type === Scalar.Scalar.BLOCK_LITERAL ? (value += sep + indent.slice(trimIndent) + content, 
            sep = "\n") : indent.length > trimIndent || "\t" === content[0] ? (" " === sep ? sep = "\n" : prevMoreIndented || "\n" !== sep || (sep = "\n\n"), 
            value += sep + indent.slice(trimIndent) + content, sep = "\n", prevMoreIndented = !0) : "" === content ? "\n" === sep ? value += "\n" : sep = "\n" : (value += sep + content, 
            sep = " ", prevMoreIndented = !1);
        }
        switch (header.chomp) {
          case "-":
            break;

          case "+":
            for (let i = chompStart; i < lines.length; ++i) value += "\n" + lines[i][0].slice(trimIndent);
            "\n" !== value[value.length - 1] && (value += "\n");
            break;

          default:
            value += "\n";
        }
        const end = start + header.length + scalar.source.length;
        return {
            value: value,
            type: type,
            comment: header.comment,
            range: [ start, end, end ]
        };
    }, resolveBlockScalar;
}

var resolveFlowScalar = {}, hasRequiredResolveFlowScalar, hasRequiredComposeScalar;

function requireResolveFlowScalar() {
    if (hasRequiredResolveFlowScalar) return resolveFlowScalar;
    hasRequiredResolveFlowScalar = 1;
    var Scalar = requireScalar(), resolveEnd = requireResolveEnd();
    function foldLines(source) {
        let first, line;
        try {
            first = new RegExp("(.*?)(?<![ \t])[ \t]*\r?\n", "sy"), line = new RegExp("[ \t]*(.*?)(?:(?<![ \t])[ \t]*)?\r?\n", "sy");
        } catch {
            first = /(.*?)[ \t]*\r?\n/sy, line = /[ \t]*(.*?)[ \t]*\r?\n/sy;
        }
        let match = first.exec(source);
        if (!match) return source;
        let res = match[1], sep = " ", pos = first.lastIndex;
        for (line.lastIndex = pos; match = line.exec(source); ) "" === match[1] ? "\n" === sep ? res += sep : sep = "\n" : (res += sep + match[1], 
        sep = " "), pos = line.lastIndex;
        const last = /[ \t]*(.*)/sy;
        return last.lastIndex = pos, match = last.exec(source), res + sep + (match?.[1] ?? "");
    }
    function foldNewline(source, offset) {
        let fold = "", ch = source[offset + 1];
        for (;!(" " !== ch && "\t" !== ch && "\n" !== ch && "\r" !== ch || "\r" === ch && "\n" !== source[offset + 2]); ) "\n" === ch && (fold += "\n"), 
        ch = source[(offset += 1) + 1];
        return fold || (fold = " "), {
            fold: fold,
            offset: offset
        };
    }
    const escapeCodes = {
        0: "\0",
        a: "",
        b: "\b",
        e: "",
        f: "\f",
        n: "\n",
        r: "\r",
        t: "\t",
        v: "\v",
        N: "",
        _: " ",
        L: "\u2028",
        P: "\u2029",
        " ": " ",
        '"': '"',
        "/": "/",
        "\\": "\\",
        "\t": "\t"
    };
    function parseCharCode(source, offset, length, onError) {
        const cc = source.substr(offset, length), code = cc.length === length && /^[0-9a-fA-F]+$/.test(cc) ? parseInt(cc, 16) : NaN;
        if (isNaN(code)) {
            const raw = source.substr(offset - 2, length + 2);
            return onError(offset - 2, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`), raw;
        }
        return String.fromCodePoint(code);
    }
    return resolveFlowScalar.resolveFlowScalar = function(scalar, strict, onError) {
        const {offset: offset, type: type, source: source, end: end} = scalar;
        let _type, value;
        const _onError = (rel, code, msg) => onError(offset + rel, code, msg);
        switch (type) {
          case "scalar":
            _type = Scalar.Scalar.PLAIN, value = function(source, onError) {
                let badChar = "";
                switch (source[0]) {
                  case "\t":
                    badChar = "a tab character";
                    break;

                  case ",":
                    badChar = "flow indicator character ,";
                    break;

                  case "%":
                    badChar = "directive indicator character %";
                    break;

                  case "|":
                  case ">":
                    badChar = `block scalar indicator ${source[0]}`;
                    break;

                  case "@":
                  case "`":
                    badChar = `reserved character ${source[0]}`;
                }
                badChar && onError(0, "BAD_SCALAR_START", `Plain value cannot start with ${badChar}`);
                return foldLines(source);
            }(source, _onError);
            break;

          case "single-quoted-scalar":
            _type = Scalar.Scalar.QUOTE_SINGLE, value = function(source, onError) {
                "'" === source[source.length - 1] && 1 !== source.length || onError(source.length, "MISSING_CHAR", "Missing closing 'quote");
                return foldLines(source.slice(1, -1)).replace(/''/g, "'");
            }(source, _onError);
            break;

          case "double-quoted-scalar":
            _type = Scalar.Scalar.QUOTE_DOUBLE, value = function(source, onError) {
                let res = "";
                for (let i = 1; i < source.length - 1; ++i) {
                    const ch = source[i];
                    if ("\r" !== ch || "\n" !== source[i + 1]) if ("\n" === ch) {
                        const {fold: fold, offset: offset} = foldNewline(source, i);
                        res += fold, i = offset;
                    } else if ("\\" === ch) {
                        let next = source[++i];
                        const cc = escapeCodes[next];
                        if (cc) res += cc; else if ("\n" === next) for (next = source[i + 1]; " " === next || "\t" === next; ) next = source[1 + ++i]; else if ("\r" === next && "\n" === source[i + 1]) for (next = source[1 + ++i]; " " === next || "\t" === next; ) next = source[1 + ++i]; else if ("x" === next || "u" === next || "U" === next) {
                            const length = {
                                x: 2,
                                u: 4,
                                U: 8
                            }[next];
                            res += parseCharCode(source, i + 1, length, onError), i += length;
                        } else {
                            const raw = source.substr(i - 1, 2);
                            onError(i - 1, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`), res += raw;
                        }
                    } else if (" " === ch || "\t" === ch) {
                        const wsStart = i;
                        let next = source[i + 1];
                        for (;" " === next || "\t" === next; ) next = source[1 + ++i];
                        "\n" === next || "\r" === next && "\n" === source[i + 2] || (res += i > wsStart ? source.slice(wsStart, i + 1) : ch);
                    } else res += ch;
                }
                '"' === source[source.length - 1] && 1 !== source.length || onError(source.length, "MISSING_CHAR", 'Missing closing "quote');
                return res;
            }(source, _onError);
            break;

          default:
            return onError(scalar, "UNEXPECTED_TOKEN", `Expected a flow scalar value, but found: ${type}`), 
            {
                value: "",
                type: null,
                comment: "",
                range: [ offset, offset + source.length, offset + source.length ]
            };
        }
        const valueEnd = offset + source.length, re = resolveEnd.resolveEnd(end, valueEnd, strict, onError);
        return {
            value: value,
            type: _type,
            comment: re.comment,
            range: [ offset, valueEnd, re.offset ]
        };
    }, resolveFlowScalar;
}

function requireComposeScalar() {
    if (hasRequiredComposeScalar) return composeScalar;
    hasRequiredComposeScalar = 1;
    var identity = requireIdentity(), Scalar = requireScalar(), resolveBlockScalar = requireResolveBlockScalar(), resolveFlowScalar = requireResolveFlowScalar();
    return composeScalar.composeScalar = function(ctx, token, tagToken, onError) {
        const {value: value, type: type, comment: comment, range: range} = "block-scalar" === token.type ? resolveBlockScalar.resolveBlockScalar(ctx, token, onError) : resolveFlowScalar.resolveFlowScalar(token, ctx.options.strict, onError), tagName = tagToken ? ctx.directives.tagName(tagToken.source, (msg => onError(tagToken, "TAG_RESOLVE_FAILED", msg))) : null;
        let tag, scalar;
        tag = ctx.options.stringKeys && ctx.atKey ? ctx.schema[identity.SCALAR] : tagName ? function(schema, value, tagName, tagToken, onError) {
            if ("!" === tagName) return schema[identity.SCALAR];
            const matchWithTest = [];
            for (const tag of schema.tags) if (!tag.collection && tag.tag === tagName) {
                if (!tag.default || !tag.test) return tag;
                matchWithTest.push(tag);
            }
            for (const tag of matchWithTest) if (tag.test?.test(value)) return tag;
            const kt = schema.knownTags[tagName];
            if (kt && !kt.collection) return schema.tags.push(Object.assign({}, kt, {
                default: !1,
                test: void 0
            })), kt;
            return onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, "tag:yaml.org,2002:str" !== tagName), 
            schema[identity.SCALAR];
        }(ctx.schema, value, tagName, tagToken, onError) : "scalar" === token.type ? function({atKey: atKey, directives: directives, schema: schema}, value, token, onError) {
            const tag = schema.tags.find((tag => (!0 === tag.default || atKey && "key" === tag.default) && tag.test?.test(value))) || schema[identity.SCALAR];
            if (schema.compat) {
                const compat = schema.compat.find((tag => tag.default && tag.test?.test(value))) ?? schema[identity.SCALAR];
                if (tag.tag !== compat.tag) {
                    onError(token, "TAG_RESOLVE_FAILED", `Value may be parsed as either ${directives.tagString(tag.tag)} or ${directives.tagString(compat.tag)}`, !0);
                }
            }
            return tag;
        }(ctx, value, token, onError) : ctx.schema[identity.SCALAR];
        try {
            const res = tag.resolve(value, (msg => onError(tagToken ?? token, "TAG_RESOLVE_FAILED", msg)), ctx.options);
            scalar = identity.isScalar(res) ? res : new Scalar.Scalar(res);
        } catch (error) {
            const msg = error instanceof Error ? error.message : String(error);
            onError(tagToken ?? token, "TAG_RESOLVE_FAILED", msg), scalar = new Scalar.Scalar(value);
        }
        return scalar.range = range, scalar.source = value, type && (scalar.type = type), 
        tagName && (scalar.tag = tagName), tag.format && (scalar.format = tag.format), comment && (scalar.comment = comment), 
        scalar;
    }, composeScalar;
}

var utilEmptyScalarPosition = {}, hasRequiredUtilEmptyScalarPosition, hasRequiredComposeNode, hasRequiredComposeDoc, hasRequiredComposer;

function requireUtilEmptyScalarPosition() {
    if (hasRequiredUtilEmptyScalarPosition) return utilEmptyScalarPosition;
    return hasRequiredUtilEmptyScalarPosition = 1, utilEmptyScalarPosition.emptyScalarPosition = function(offset, before, pos) {
        if (before) {
            null === pos && (pos = before.length);
            for (let i = pos - 1; i >= 0; --i) {
                let st = before[i];
                switch (st.type) {
                  case "space":
                  case "comment":
                  case "newline":
                    offset -= st.source.length;
                    continue;
                }
                for (st = before[++i]; "space" === st?.type; ) offset += st.source.length, st = before[++i];
                break;
            }
        }
        return offset;
    }, utilEmptyScalarPosition;
}

function requireComposeNode() {
    if (hasRequiredComposeNode) return composeNode;
    hasRequiredComposeNode = 1;
    var Alias = requireAlias(), identity = requireIdentity(), composeCollection = requireComposeCollection(), composeScalar = requireComposeScalar(), resolveEnd = requireResolveEnd(), utilEmptyScalarPosition = requireUtilEmptyScalarPosition();
    const CN = {
        composeNode: composeNode$1,
        composeEmptyNode: composeEmptyNode
    };
    function composeNode$1(ctx, token, props, onError) {
        const atKey = ctx.atKey, {spaceBefore: spaceBefore, comment: comment, anchor: anchor, tag: tag} = props;
        let node, isSrcToken = !0;
        switch (token.type) {
          case "alias":
            node = function({options: options}, {offset: offset, source: source, end: end}, onError) {
                const alias = new Alias.Alias(source.substring(1));
                "" === alias.source && onError(offset, "BAD_ALIAS", "Alias cannot be an empty string");
                alias.source.endsWith(":") && onError(offset + source.length - 1, "BAD_ALIAS", "Alias ending in : is ambiguous", !0);
                const valueEnd = offset + source.length, re = resolveEnd.resolveEnd(end, valueEnd, options.strict, onError);
                alias.range = [ offset, valueEnd, re.offset ], re.comment && (alias.comment = re.comment);
                return alias;
            }(ctx, token, onError), (anchor || tag) && onError(token, "ALIAS_PROPS", "An alias node must not specify any properties");
            break;

          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar":
          case "block-scalar":
            node = composeScalar.composeScalar(ctx, token, tag, onError), anchor && (node.anchor = anchor.source.substring(1));
            break;

          case "block-map":
          case "block-seq":
          case "flow-collection":
            node = composeCollection.composeCollection(CN, ctx, token, props, onError), anchor && (node.anchor = anchor.source.substring(1));
            break;

          default:
            onError(token, "UNEXPECTED_TOKEN", "error" === token.type ? token.message : `Unsupported token (type: ${token.type})`), 
            node = composeEmptyNode(ctx, token.offset, void 0, null, props, onError), isSrcToken = !1;
        }
        if (anchor && "" === node.anchor && onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string"), 
        atKey && ctx.options.stringKeys && (!identity.isScalar(node) || "string" != typeof node.value || node.tag && "tag:yaml.org,2002:str" !== node.tag)) {
            onError(tag ?? token, "NON_STRING_KEY", "With stringKeys, all keys must be strings");
        }
        return spaceBefore && (node.spaceBefore = !0), comment && ("scalar" === token.type && "" === token.source ? node.comment = comment : node.commentBefore = comment), 
        ctx.options.keepSourceTokens && isSrcToken && (node.srcToken = token), node;
    }
    function composeEmptyNode(ctx, offset, before, pos, {spaceBefore: spaceBefore, comment: comment, anchor: anchor, tag: tag, end: end}, onError) {
        const token = {
            type: "scalar",
            offset: utilEmptyScalarPosition.emptyScalarPosition(offset, before, pos),
            indent: -1,
            source: ""
        }, node = composeScalar.composeScalar(ctx, token, tag, onError);
        return anchor && (node.anchor = anchor.source.substring(1), "" === node.anchor && onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string")), 
        spaceBefore && (node.spaceBefore = !0), comment && (node.comment = comment, node.range[2] = end), 
        node;
    }
    return composeNode.composeEmptyNode = composeEmptyNode, composeNode.composeNode = composeNode$1, 
    composeNode;
}

function requireComposeDoc() {
    if (hasRequiredComposeDoc) return composeDoc;
    hasRequiredComposeDoc = 1;
    var Document = requireDocument(), composeNode = requireComposeNode(), resolveEnd = requireResolveEnd(), resolveProps = requireResolveProps();
    return composeDoc.composeDoc = function(options, directives, {offset: offset, start: start, value: value, end: end}, onError) {
        const opts = Object.assign({
            _directives: directives
        }, options), doc = new Document.Document(void 0, opts), ctx = {
            atKey: !1,
            atRoot: !0,
            directives: doc.directives,
            options: doc.options,
            schema: doc.schema
        }, props = resolveProps.resolveProps(start, {
            indicator: "doc-start",
            next: value ?? end?.[0],
            offset: offset,
            onError: onError,
            parentIndent: 0,
            startOnNewline: !0
        });
        props.found && (doc.directives.docStart = !0, !value || "block-map" !== value.type && "block-seq" !== value.type || props.hasNewline || onError(props.end, "MISSING_CHAR", "Block collection cannot start on same line with directives-end marker")), 
        doc.contents = value ? composeNode.composeNode(ctx, value, props, onError) : composeNode.composeEmptyNode(ctx, props.end, start, null, props, onError);
        const contentEnd = doc.contents.range[2], re = resolveEnd.resolveEnd(end, contentEnd, !1, onError);
        return re.comment && (doc.comment = re.comment), doc.range = [ offset, contentEnd, re.offset ], 
        doc;
    }, composeDoc;
}

function requireComposer() {
    if (hasRequiredComposer) return composer;
    hasRequiredComposer = 1;
    var directives = requireDirectives(), Document = requireDocument(), errors = requireErrors(), identity = requireIdentity(), composeDoc = requireComposeDoc(), resolveEnd = requireResolveEnd();
    function getErrorPos(src) {
        if ("number" == typeof src) return [ src, src + 1 ];
        if (Array.isArray(src)) return 2 === src.length ? src : [ src[0], src[1] ];
        const {offset: offset, source: source} = src;
        return [ offset, offset + ("string" == typeof source ? source.length : 1) ];
    }
    function parsePrelude(prelude) {
        let comment = "", atComment = !1, afterEmptyLine = !1;
        for (let i = 0; i < prelude.length; ++i) {
            const source = prelude[i];
            switch (source[0]) {
              case "#":
                comment += ("" === comment ? "" : afterEmptyLine ? "\n\n" : "\n") + (source.substring(1) || " "), 
                atComment = !0, afterEmptyLine = !1;
                break;

              case "%":
                "#" !== prelude[i + 1]?.[0] && (i += 1), atComment = !1;
                break;

              default:
                atComment || (afterEmptyLine = !0), atComment = !1;
            }
        }
        return {
            comment: comment,
            afterEmptyLine: afterEmptyLine
        };
    }
    return composer.Composer = class {
        constructor(options = {}) {
            this.doc = null, this.atDirectives = !1, this.prelude = [], this.errors = [], this.warnings = [], 
            this.onError = (source, code, message, warning) => {
                const pos = getErrorPos(source);
                warning ? this.warnings.push(new errors.YAMLWarning(pos, code, message)) : this.errors.push(new errors.YAMLParseError(pos, code, message));
            }, this.directives = new directives.Directives({
                version: options.version || "1.2"
            }), this.options = options;
        }
        decorate(doc, afterDoc) {
            const {comment: comment, afterEmptyLine: afterEmptyLine} = parsePrelude(this.prelude);
            if (comment) {
                const dc = doc.contents;
                if (afterDoc) doc.comment = doc.comment ? `${doc.comment}\n${comment}` : comment; else if (afterEmptyLine || doc.directives.docStart || !dc) doc.commentBefore = comment; else if (identity.isCollection(dc) && !dc.flow && dc.items.length > 0) {
                    let it = dc.items[0];
                    identity.isPair(it) && (it = it.key);
                    const cb = it.commentBefore;
                    it.commentBefore = cb ? `${comment}\n${cb}` : comment;
                } else {
                    const cb = dc.commentBefore;
                    dc.commentBefore = cb ? `${comment}\n${cb}` : comment;
                }
            }
            afterDoc ? (Array.prototype.push.apply(doc.errors, this.errors), Array.prototype.push.apply(doc.warnings, this.warnings)) : (doc.errors = this.errors, 
            doc.warnings = this.warnings), this.prelude = [], this.errors = [], this.warnings = [];
        }
        streamInfo() {
            return {
                comment: parsePrelude(this.prelude).comment,
                directives: this.directives,
                errors: this.errors,
                warnings: this.warnings
            };
        }
        * compose(tokens, forceDoc = !1, endOffset = -1) {
            for (const token of tokens) yield* this.next(token);
            yield* this.end(forceDoc, endOffset);
        }
        * next(token) {
            switch (process.env.LOG_STREAM && console.dir(token, {
                depth: null
            }), token.type) {
              case "directive":
                this.directives.add(token.source, ((offset, message, warning) => {
                    const pos = getErrorPos(token);
                    pos[0] += offset, this.onError(pos, "BAD_DIRECTIVE", message, warning);
                })), this.prelude.push(token.source), this.atDirectives = !0;
                break;

              case "document":
                {
                    const doc = composeDoc.composeDoc(this.options, this.directives, token, this.onError);
                    this.atDirectives && !doc.directives.docStart && this.onError(token, "MISSING_CHAR", "Missing directives-end/doc-start indicator line"), 
                    this.decorate(doc, !1), this.doc && (yield this.doc), this.doc = doc, this.atDirectives = !1;
                    break;
                }

              case "byte-order-mark":
              case "space":
                break;

              case "comment":
              case "newline":
                this.prelude.push(token.source);
                break;

              case "error":
                {
                    const msg = token.source ? `${token.message}: ${JSON.stringify(token.source)}` : token.message, error = new errors.YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg);
                    this.atDirectives || !this.doc ? this.errors.push(error) : this.doc.errors.push(error);
                    break;
                }

              case "doc-end":
                {
                    if (!this.doc) {
                        const msg = "Unexpected doc-end without preceding document";
                        this.errors.push(new errors.YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg));
                        break;
                    }
                    this.doc.directives.docEnd = !0;
                    const end = resolveEnd.resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);
                    if (this.decorate(this.doc, !0), end.comment) {
                        const dc = this.doc.comment;
                        this.doc.comment = dc ? `${dc}\n${end.comment}` : end.comment;
                    }
                    this.doc.range[2] = end.offset;
                    break;
                }

              default:
                this.errors.push(new errors.YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", `Unsupported token ${token.type}`));
            }
        }
        * end(forceDoc = !1, endOffset = -1) {
            if (this.doc) this.decorate(this.doc, !0), yield this.doc, this.doc = null; else if (forceDoc) {
                const opts = Object.assign({
                    _directives: this.directives
                }, this.options), doc = new Document.Document(void 0, opts);
                this.atDirectives && this.onError(endOffset, "MISSING_CHAR", "Missing directives-end indicator line"), 
                doc.range = [ 0, endOffset, endOffset ], this.decorate(doc, !1), yield doc;
            }
        }
    }, composer;
}

var cst = {}, cstScalar = {}, hasRequiredCstScalar;

function requireCstScalar() {
    if (hasRequiredCstScalar) return cstScalar;
    hasRequiredCstScalar = 1;
    var resolveBlockScalar = requireResolveBlockScalar(), resolveFlowScalar = requireResolveFlowScalar(), errors = requireErrors(), stringifyString = requireStringifyString();
    function addEndtoBlockProps(props, end) {
        if (end) for (const st of end) switch (st.type) {
          case "space":
          case "comment":
            props.push(st);
            break;

          case "newline":
            return props.push(st), !0;
        }
        return !1;
    }
    function setFlowScalarValue(token, source, type) {
        switch (token.type) {
          case "scalar":
          case "double-quoted-scalar":
          case "single-quoted-scalar":
            token.type = type, token.source = source;
            break;

          case "block-scalar":
            {
                const end = token.props.slice(1);
                let oa = source.length;
                "block-scalar-header" === token.props[0].type && (oa -= token.props[0].source.length);
                for (const tok of end) tok.offset += oa;
                delete token.props, Object.assign(token, {
                    type: type,
                    source: source,
                    end: end
                });
                break;
            }

          case "block-map":
          case "block-seq":
            {
                const nl = {
                    type: "newline",
                    offset: token.offset + source.length,
                    indent: token.indent,
                    source: "\n"
                };
                delete token.items, Object.assign(token, {
                    type: type,
                    source: source,
                    end: [ nl ]
                });
                break;
            }

          default:
            {
                const indent = "indent" in token ? token.indent : -1, end = "end" in token && Array.isArray(token.end) ? token.end.filter((st => "space" === st.type || "comment" === st.type || "newline" === st.type)) : [];
                for (const key of Object.keys(token)) "type" !== key && "offset" !== key && delete token[key];
                Object.assign(token, {
                    type: type,
                    indent: indent,
                    source: source,
                    end: end
                });
            }
        }
    }
    return cstScalar.createScalarToken = function(value, context) {
        const {implicitKey: implicitKey = !1, indent: indent, inFlow: inFlow = !1, offset: offset = -1, type: type = "PLAIN"} = context, source = stringifyString.stringifyString({
            type: type,
            value: value
        }, {
            implicitKey: implicitKey,
            indent: indent > 0 ? " ".repeat(indent) : "",
            inFlow: inFlow,
            options: {
                blockQuote: !0,
                lineWidth: -1
            }
        }), end = context.end ?? [ {
            type: "newline",
            offset: -1,
            indent: indent,
            source: "\n"
        } ];
        switch (source[0]) {
          case "|":
          case ">":
            {
                const he = source.indexOf("\n"), head = source.substring(0, he), body = source.substring(he + 1) + "\n", props = [ {
                    type: "block-scalar-header",
                    offset: offset,
                    indent: indent,
                    source: head
                } ];
                return addEndtoBlockProps(props, end) || props.push({
                    type: "newline",
                    offset: -1,
                    indent: indent,
                    source: "\n"
                }), {
                    type: "block-scalar",
                    offset: offset,
                    indent: indent,
                    props: props,
                    source: body
                };
            }

          case '"':
            return {
                type: "double-quoted-scalar",
                offset: offset,
                indent: indent,
                source: source,
                end: end
            };

          case "'":
            return {
                type: "single-quoted-scalar",
                offset: offset,
                indent: indent,
                source: source,
                end: end
            };

          default:
            return {
                type: "scalar",
                offset: offset,
                indent: indent,
                source: source,
                end: end
            };
        }
    }, cstScalar.resolveAsScalar = function(token, strict = !0, onError) {
        if (token) {
            const _onError = (pos, code, message) => {
                const offset = "number" == typeof pos ? pos : Array.isArray(pos) ? pos[0] : pos.offset;
                if (!onError) throw new errors.YAMLParseError([ offset, offset + 1 ], code, message);
                onError(offset, code, message);
            };
            switch (token.type) {
              case "scalar":
              case "single-quoted-scalar":
              case "double-quoted-scalar":
                return resolveFlowScalar.resolveFlowScalar(token, strict, _onError);

              case "block-scalar":
                return resolveBlockScalar.resolveBlockScalar({
                    options: {
                        strict: strict
                    }
                }, token, _onError);
            }
        }
        return null;
    }, cstScalar.setScalarValue = function(token, value, context = {}) {
        let {afterKey: afterKey = !1, implicitKey: implicitKey = !1, inFlow: inFlow = !1, type: type} = context, indent = "indent" in token ? token.indent : null;
        if (afterKey && "number" == typeof indent && (indent += 2), !type) switch (token.type) {
          case "single-quoted-scalar":
            type = "QUOTE_SINGLE";
            break;

          case "double-quoted-scalar":
            type = "QUOTE_DOUBLE";
            break;

          case "block-scalar":
            {
                const header = token.props[0];
                if ("block-scalar-header" !== header.type) throw new Error("Invalid block scalar header");
                type = ">" === header.source[0] ? "BLOCK_FOLDED" : "BLOCK_LITERAL";
                break;
            }

          default:
            type = "PLAIN";
        }
        const source = stringifyString.stringifyString({
            type: type,
            value: value
        }, {
            implicitKey: implicitKey || null === indent,
            indent: null !== indent && indent > 0 ? " ".repeat(indent) : "",
            inFlow: inFlow,
            options: {
                blockQuote: !0,
                lineWidth: -1
            }
        });
        switch (source[0]) {
          case "|":
          case ">":
            !function(token, source) {
                const he = source.indexOf("\n"), head = source.substring(0, he), body = source.substring(he + 1) + "\n";
                if ("block-scalar" === token.type) {
                    const header = token.props[0];
                    if ("block-scalar-header" !== header.type) throw new Error("Invalid block scalar header");
                    header.source = head, token.source = body;
                } else {
                    const {offset: offset} = token, indent = "indent" in token ? token.indent : -1, props = [ {
                        type: "block-scalar-header",
                        offset: offset,
                        indent: indent,
                        source: head
                    } ];
                    addEndtoBlockProps(props, "end" in token ? token.end : void 0) || props.push({
                        type: "newline",
                        offset: -1,
                        indent: indent,
                        source: "\n"
                    });
                    for (const key of Object.keys(token)) "type" !== key && "offset" !== key && delete token[key];
                    Object.assign(token, {
                        type: "block-scalar",
                        indent: indent,
                        props: props,
                        source: body
                    });
                }
            }(token, source);
            break;

          case '"':
            setFlowScalarValue(token, source, "double-quoted-scalar");
            break;

          case "'":
            setFlowScalarValue(token, source, "single-quoted-scalar");
            break;

          default:
            setFlowScalarValue(token, source, "scalar");
        }
    }, cstScalar;
}

var cstStringify = {}, hasRequiredCstStringify;

function requireCstStringify() {
    if (hasRequiredCstStringify) return cstStringify;
    hasRequiredCstStringify = 1;
    function stringifyToken(token) {
        switch (token.type) {
          case "block-scalar":
            {
                let res = "";
                for (const tok of token.props) res += stringifyToken(tok);
                return res + token.source;
            }

          case "block-map":
          case "block-seq":
            {
                let res = "";
                for (const item of token.items) res += stringifyItem(item);
                return res;
            }

          case "flow-collection":
            {
                let res = token.start.source;
                for (const item of token.items) res += stringifyItem(item);
                for (const st of token.end) res += st.source;
                return res;
            }

          case "document":
            {
                let res = stringifyItem(token);
                if (token.end) for (const st of token.end) res += st.source;
                return res;
            }

          default:
            {
                let res = token.source;
                if ("end" in token && token.end) for (const st of token.end) res += st.source;
                return res;
            }
        }
    }
    function stringifyItem({start: start, key: key, sep: sep, value: value}) {
        let res = "";
        for (const st of start) res += st.source;
        if (key && (res += stringifyToken(key)), sep) for (const st of sep) res += st.source;
        return value && (res += stringifyToken(value)), res;
    }
    return cstStringify.stringify = cst => "type" in cst ? stringifyToken(cst) : stringifyItem(cst), 
    cstStringify;
}

var cstVisit = {}, hasRequiredCstVisit, hasRequiredCst;

function requireCstVisit() {
    if (hasRequiredCstVisit) return cstVisit;
    hasRequiredCstVisit = 1;
    const BREAK = Symbol("break visit"), SKIP = Symbol("skip children"), REMOVE = Symbol("remove item");
    function visit(cst, visitor) {
        "type" in cst && "document" === cst.type && (cst = {
            start: cst.start,
            value: cst.value
        }), _visit(Object.freeze([]), cst, visitor);
    }
    function _visit(path, item, visitor) {
        let ctrl = visitor(item, path);
        if ("symbol" == typeof ctrl) return ctrl;
        for (const field of [ "key", "value" ]) {
            const token = item[field];
            if (token && "items" in token) {
                for (let i = 0; i < token.items.length; ++i) {
                    const ci = _visit(Object.freeze(path.concat([ [ field, i ] ])), token.items[i], visitor);
                    if ("number" == typeof ci) i = ci - 1; else {
                        if (ci === BREAK) return BREAK;
                        ci === REMOVE && (token.items.splice(i, 1), i -= 1);
                    }
                }
                "function" == typeof ctrl && "key" === field && (ctrl = ctrl(item, path));
            }
        }
        return "function" == typeof ctrl ? ctrl(item, path) : ctrl;
    }
    return visit.BREAK = BREAK, visit.SKIP = SKIP, visit.REMOVE = REMOVE, visit.itemAtPath = (cst, path) => {
        let item = cst;
        for (const [field, index] of path) {
            const tok = item?.[field];
            if (!tok || !("items" in tok)) return;
            item = tok.items[index];
        }
        return item;
    }, visit.parentCollection = (cst, path) => {
        const parent = visit.itemAtPath(cst, path.slice(0, -1)), field = path[path.length - 1][0], coll = parent?.[field];
        if (coll && "items" in coll) return coll;
        throw new Error("Parent collection not found");
    }, cstVisit.visit = visit, cstVisit;
}

function requireCst() {
    if (hasRequiredCst) return cst;
    hasRequiredCst = 1;
    var cstScalar = requireCstScalar(), cstStringify = requireCstStringify(), cstVisit = requireCstVisit();
    return cst.createScalarToken = cstScalar.createScalarToken, cst.resolveAsScalar = cstScalar.resolveAsScalar, 
    cst.setScalarValue = cstScalar.setScalarValue, cst.stringify = cstStringify.stringify, 
    cst.visit = cstVisit.visit, cst.BOM = "\ufeff", cst.DOCUMENT = "", cst.FLOW_END = "", 
    cst.SCALAR = "", cst.isCollection = token => !!token && "items" in token, cst.isScalar = token => !!token && ("scalar" === token.type || "single-quoted-scalar" === token.type || "double-quoted-scalar" === token.type || "block-scalar" === token.type), 
    cst.prettyToken = function(token) {
        switch (token) {
          case "\ufeff":
            return "<BOM>";

          case "":
            return "<DOC>";

          case "":
            return "<FLOW_END>";

          case "":
            return "<SCALAR>";

          default:
            return JSON.stringify(token);
        }
    }, cst.tokenType = function(source) {
        switch (source) {
          case "\ufeff":
            return "byte-order-mark";

          case "":
            return "doc-mode";

          case "":
            return "flow-error-end";

          case "":
            return "scalar";

          case "---":
            return "doc-start";

          case "...":
            return "doc-end";

          case "":
          case "\n":
          case "\r\n":
            return "newline";

          case "-":
            return "seq-item-ind";

          case "?":
            return "explicit-key-ind";

          case ":":
            return "map-value-ind";

          case "{":
            return "flow-map-start";

          case "}":
            return "flow-map-end";

          case "[":
            return "flow-seq-start";

          case "]":
            return "flow-seq-end";

          case ",":
            return "comma";
        }
        switch (source[0]) {
          case " ":
          case "\t":
            return "space";

          case "#":
            return "comment";

          case "%":
            return "directive-line";

          case "*":
            return "alias";

          case "&":
            return "anchor";

          case "!":
            return "tag";

          case "'":
            return "single-quoted-scalar";

          case '"':
            return "double-quoted-scalar";

          case "|":
          case ">":
            return "block-scalar-header";
        }
        return null;
    }, cst;
}

var lexer = {}, hasRequiredLexer;

function requireLexer() {
    if (hasRequiredLexer) return lexer;
    hasRequiredLexer = 1;
    var cst = requireCst();
    function isEmpty(ch) {
        switch (ch) {
          case void 0:
          case " ":
          case "\n":
          case "\r":
          case "\t":
            return !0;

          default:
            return !1;
        }
    }
    const hexDigits = new Set("0123456789ABCDEFabcdef"), tagChars = new Set("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()"), flowIndicatorChars = new Set(",[]{}"), invalidAnchorChars = new Set(" ,[]{}\n\r\t"), isNotAnchorChar = ch => !ch || invalidAnchorChars.has(ch);
    return lexer.Lexer = class {
        constructor() {
            this.atEnd = !1, this.blockScalarIndent = -1, this.blockScalarKeep = !1, this.buffer = "", 
            this.flowKey = !1, this.flowLevel = 0, this.indentNext = 0, this.indentValue = 0, 
            this.lineEndPos = null, this.next = null, this.pos = 0;
        }
        * lex(source, incomplete = !1) {
            if (source) {
                if ("string" != typeof source) throw TypeError("source is not a string");
                this.buffer = this.buffer ? this.buffer + source : source, this.lineEndPos = null;
            }
            this.atEnd = !incomplete;
            let next = this.next ?? "stream";
            for (;next && (incomplete || this.hasChars(1)); ) next = yield* this.parseNext(next);
        }
        atLineEnd() {
            let i = this.pos, ch = this.buffer[i];
            for (;" " === ch || "\t" === ch; ) ch = this.buffer[++i];
            return !ch || "#" === ch || "\n" === ch || "\r" === ch && "\n" === this.buffer[i + 1];
        }
        charAt(n) {
            return this.buffer[this.pos + n];
        }
        continueScalar(offset) {
            let ch = this.buffer[offset];
            if (this.indentNext > 0) {
                let indent = 0;
                for (;" " === ch; ) ch = this.buffer[++indent + offset];
                if ("\r" === ch) {
                    const next = this.buffer[indent + offset + 1];
                    if ("\n" === next || !next && !this.atEnd) return offset + indent + 1;
                }
                return "\n" === ch || indent >= this.indentNext || !ch && !this.atEnd ? offset + indent : -1;
            }
            if ("-" === ch || "." === ch) {
                const dt = this.buffer.substr(offset, 3);
                if (("---" === dt || "..." === dt) && isEmpty(this.buffer[offset + 3])) return -1;
            }
            return offset;
        }
        getLine() {
            let end = this.lineEndPos;
            return ("number" != typeof end || -1 !== end && end < this.pos) && (end = this.buffer.indexOf("\n", this.pos), 
            this.lineEndPos = end), -1 === end ? this.atEnd ? this.buffer.substring(this.pos) : null : ("\r" === this.buffer[end - 1] && (end -= 1), 
            this.buffer.substring(this.pos, end));
        }
        hasChars(n) {
            return this.pos + n <= this.buffer.length;
        }
        setNext(state) {
            return this.buffer = this.buffer.substring(this.pos), this.pos = 0, this.lineEndPos = null, 
            this.next = state, null;
        }
        peek(n) {
            return this.buffer.substr(this.pos, n);
        }
        * parseNext(next) {
            switch (next) {
              case "stream":
                return yield* this.parseStream();

              case "line-start":
                return yield* this.parseLineStart();

              case "block-start":
                return yield* this.parseBlockStart();

              case "doc":
                return yield* this.parseDocument();

              case "flow":
                return yield* this.parseFlowCollection();

              case "quoted-scalar":
                return yield* this.parseQuotedScalar();

              case "block-scalar":
                return yield* this.parseBlockScalar();

              case "plain-scalar":
                return yield* this.parsePlainScalar();
            }
        }
        * parseStream() {
            let line = this.getLine();
            if (null === line) return this.setNext("stream");
            if (line[0] === cst.BOM && (yield* this.pushCount(1), line = line.substring(1)), 
            "%" === line[0]) {
                let dirEnd = line.length, cs = line.indexOf("#");
                for (;-1 !== cs; ) {
                    const ch = line[cs - 1];
                    if (" " === ch || "\t" === ch) {
                        dirEnd = cs - 1;
                        break;
                    }
                    cs = line.indexOf("#", cs + 1);
                }
                for (;;) {
                    const ch = line[dirEnd - 1];
                    if (" " !== ch && "\t" !== ch) break;
                    dirEnd -= 1;
                }
                const n = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(!0));
                return yield* this.pushCount(line.length - n), this.pushNewline(), "stream";
            }
            if (this.atLineEnd()) {
                const sp = yield* this.pushSpaces(!0);
                return yield* this.pushCount(line.length - sp), yield* this.pushNewline(), "stream";
            }
            return yield cst.DOCUMENT, yield* this.parseLineStart();
        }
        * parseLineStart() {
            const ch = this.charAt(0);
            if (!ch && !this.atEnd) return this.setNext("line-start");
            if ("-" === ch || "." === ch) {
                if (!this.atEnd && !this.hasChars(4)) return this.setNext("line-start");
                const s = this.peek(3);
                if (("---" === s || "..." === s) && isEmpty(this.charAt(3))) return yield* this.pushCount(3), 
                this.indentValue = 0, this.indentNext = 0, "---" === s ? "doc" : "stream";
            }
            return this.indentValue = yield* this.pushSpaces(!1), this.indentNext > this.indentValue && !isEmpty(this.charAt(1)) && (this.indentNext = this.indentValue), 
            yield* this.parseBlockStart();
        }
        * parseBlockStart() {
            const [ch0, ch1] = this.peek(2);
            if (!ch1 && !this.atEnd) return this.setNext("block-start");
            if (("-" === ch0 || "?" === ch0 || ":" === ch0) && isEmpty(ch1)) {
                const n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(!0));
                return this.indentNext = this.indentValue + 1, this.indentValue += n, yield* this.parseBlockStart();
            }
            return "doc";
        }
        * parseDocument() {
            yield* this.pushSpaces(!0);
            const line = this.getLine();
            if (null === line) return this.setNext("doc");
            let n = yield* this.pushIndicators();
            switch (line[n]) {
              case "#":
                yield* this.pushCount(line.length - n);

              case void 0:
                return yield* this.pushNewline(), yield* this.parseLineStart();

              case "{":
              case "[":
                return yield* this.pushCount(1), this.flowKey = !1, this.flowLevel = 1, "flow";

              case "}":
              case "]":
                return yield* this.pushCount(1), "doc";

              case "*":
                return yield* this.pushUntil(isNotAnchorChar), "doc";

              case '"':
              case "'":
                return yield* this.parseQuotedScalar();

              case "|":
              case ">":
                return n += (yield* this.parseBlockScalarHeader()), n += (yield* this.pushSpaces(!0)), 
                yield* this.pushCount(line.length - n), yield* this.pushNewline(), yield* this.parseBlockScalar();

              default:
                return yield* this.parsePlainScalar();
            }
        }
        * parseFlowCollection() {
            let nl, sp, indent = -1;
            do {
                nl = yield* this.pushNewline(), nl > 0 ? (sp = yield* this.pushSpaces(!1), this.indentValue = indent = sp) : sp = 0, 
                sp += (yield* this.pushSpaces(!0));
            } while (nl + sp > 0);
            const line = this.getLine();
            if (null === line) return this.setNext("flow");
            if (-1 !== indent && indent < this.indentNext && "#" !== line[0] || 0 === indent && (line.startsWith("---") || line.startsWith("...")) && isEmpty(line[3])) {
                if (!(indent === this.indentNext - 1 && 1 === this.flowLevel && ("]" === line[0] || "}" === line[0]))) return this.flowLevel = 0, 
                yield cst.FLOW_END, yield* this.parseLineStart();
            }
            let n = 0;
            for (;"," === line[n]; ) n += (yield* this.pushCount(1)), n += (yield* this.pushSpaces(!0)), 
            this.flowKey = !1;
            switch (n += (yield* this.pushIndicators()), line[n]) {
              case void 0:
                return "flow";

              case "#":
                return yield* this.pushCount(line.length - n), "flow";

              case "{":
              case "[":
                return yield* this.pushCount(1), this.flowKey = !1, this.flowLevel += 1, "flow";

              case "}":
              case "]":
                return yield* this.pushCount(1), this.flowKey = !0, this.flowLevel -= 1, this.flowLevel ? "flow" : "doc";

              case "*":
                return yield* this.pushUntil(isNotAnchorChar), "flow";

              case '"':
              case "'":
                return this.flowKey = !0, yield* this.parseQuotedScalar();

              case ":":
                {
                    const next = this.charAt(1);
                    if (this.flowKey || isEmpty(next) || "," === next) return this.flowKey = !1, yield* this.pushCount(1), 
                    yield* this.pushSpaces(!0), "flow";
                }

              default:
                return this.flowKey = !1, yield* this.parsePlainScalar();
            }
        }
        * parseQuotedScalar() {
            const quote = this.charAt(0);
            let end = this.buffer.indexOf(quote, this.pos + 1);
            if ("'" === quote) for (;-1 !== end && "'" === this.buffer[end + 1]; ) end = this.buffer.indexOf("'", end + 2); else for (;-1 !== end; ) {
                let n = 0;
                for (;"\\" === this.buffer[end - 1 - n]; ) n += 1;
                if (n % 2 == 0) break;
                end = this.buffer.indexOf('"', end + 1);
            }
            const qb = this.buffer.substring(0, end);
            let nl = qb.indexOf("\n", this.pos);
            if (-1 !== nl) {
                for (;-1 !== nl; ) {
                    const cs = this.continueScalar(nl + 1);
                    if (-1 === cs) break;
                    nl = qb.indexOf("\n", cs);
                }
                -1 !== nl && (end = nl - ("\r" === qb[nl - 1] ? 2 : 1));
            }
            if (-1 === end) {
                if (!this.atEnd) return this.setNext("quoted-scalar");
                end = this.buffer.length;
            }
            return yield* this.pushToIndex(end + 1, !1), this.flowLevel ? "flow" : "doc";
        }
        * parseBlockScalarHeader() {
            this.blockScalarIndent = -1, this.blockScalarKeep = !1;
            let i = this.pos;
            for (;;) {
                const ch = this.buffer[++i];
                if ("+" === ch) this.blockScalarKeep = !0; else if (ch > "0" && ch <= "9") this.blockScalarIndent = Number(ch) - 1; else if ("-" !== ch) break;
            }
            return yield* this.pushUntil((ch => isEmpty(ch) || "#" === ch));
        }
        * parseBlockScalar() {
            let ch, nl = this.pos - 1, indent = 0;
            loop: for (let i = this.pos; ch = this.buffer[i]; ++i) switch (ch) {
              case " ":
                indent += 1;
                break;

              case "\n":
                nl = i, indent = 0;
                break;

              case "\r":
                {
                    const next = this.buffer[i + 1];
                    if (!next && !this.atEnd) return this.setNext("block-scalar");
                    if ("\n" === next) break;
                }

              default:
                break loop;
            }
            if (!ch && !this.atEnd) return this.setNext("block-scalar");
            if (indent >= this.indentNext) {
                -1 === this.blockScalarIndent ? this.indentNext = indent : this.indentNext = this.blockScalarIndent + (0 === this.indentNext ? 1 : this.indentNext);
                do {
                    const cs = this.continueScalar(nl + 1);
                    if (-1 === cs) break;
                    nl = this.buffer.indexOf("\n", cs);
                } while (-1 !== nl);
                if (-1 === nl) {
                    if (!this.atEnd) return this.setNext("block-scalar");
                    nl = this.buffer.length;
                }
            }
            let i = nl + 1;
            for (ch = this.buffer[i]; " " === ch; ) ch = this.buffer[++i];
            if ("\t" === ch) {
                for (;"\t" === ch || " " === ch || "\r" === ch || "\n" === ch; ) ch = this.buffer[++i];
                nl = i - 1;
            } else if (!this.blockScalarKeep) for (;;) {
                let i = nl - 1, ch = this.buffer[i];
                "\r" === ch && (ch = this.buffer[--i]);
                const lastChar = i;
                for (;" " === ch; ) ch = this.buffer[--i];
                if (!("\n" === ch && i >= this.pos && i + 1 + indent > lastChar)) break;
                nl = i;
            }
            return yield cst.SCALAR, yield* this.pushToIndex(nl + 1, !0), yield* this.parseLineStart();
        }
        * parsePlainScalar() {
            const inFlow = this.flowLevel > 0;
            let ch, end = this.pos - 1, i = this.pos - 1;
            for (;ch = this.buffer[++i]; ) if (":" === ch) {
                const next = this.buffer[i + 1];
                if (isEmpty(next) || inFlow && flowIndicatorChars.has(next)) break;
                end = i;
            } else if (isEmpty(ch)) {
                let next = this.buffer[i + 1];
                if ("\r" === ch && ("\n" === next ? (i += 1, ch = "\n", next = this.buffer[i + 1]) : end = i), 
                "#" === next || inFlow && flowIndicatorChars.has(next)) break;
                if ("\n" === ch) {
                    const cs = this.continueScalar(i + 1);
                    if (-1 === cs) break;
                    i = Math.max(i, cs - 2);
                }
            } else {
                if (inFlow && flowIndicatorChars.has(ch)) break;
                end = i;
            }
            return ch || this.atEnd ? (yield cst.SCALAR, yield* this.pushToIndex(end + 1, !0), 
            inFlow ? "flow" : "doc") : this.setNext("plain-scalar");
        }
        * pushCount(n) {
            return n > 0 ? (yield this.buffer.substr(this.pos, n), this.pos += n, n) : 0;
        }
        * pushToIndex(i, allowEmpty) {
            const s = this.buffer.slice(this.pos, i);
            return s ? (yield s, this.pos += s.length, s.length) : (allowEmpty && (yield ""), 
            0);
        }
        * pushIndicators() {
            switch (this.charAt(0)) {
              case "!":
                return (yield* this.pushTag()) + (yield* this.pushSpaces(!0)) + (yield* this.pushIndicators());

              case "&":
                return (yield* this.pushUntil(isNotAnchorChar)) + (yield* this.pushSpaces(!0)) + (yield* this.pushIndicators());

              case "-":
              case "?":
              case ":":
                {
                    const inFlow = this.flowLevel > 0, ch1 = this.charAt(1);
                    if (isEmpty(ch1) || inFlow && flowIndicatorChars.has(ch1)) return inFlow ? this.flowKey && (this.flowKey = !1) : this.indentNext = this.indentValue + 1, 
                    (yield* this.pushCount(1)) + (yield* this.pushSpaces(!0)) + (yield* this.pushIndicators());
                }
            }
            return 0;
        }
        * pushTag() {
            if ("<" === this.charAt(1)) {
                let i = this.pos + 2, ch = this.buffer[i];
                for (;!isEmpty(ch) && ">" !== ch; ) ch = this.buffer[++i];
                return yield* this.pushToIndex(">" === ch ? i + 1 : i, !1);
            }
            {
                let i = this.pos + 1, ch = this.buffer[i];
                for (;ch; ) if (tagChars.has(ch)) ch = this.buffer[++i]; else {
                    if ("%" !== ch || !hexDigits.has(this.buffer[i + 1]) || !hexDigits.has(this.buffer[i + 2])) break;
                    ch = this.buffer[i += 3];
                }
                return yield* this.pushToIndex(i, !1);
            }
        }
        * pushNewline() {
            const ch = this.buffer[this.pos];
            return "\n" === ch ? yield* this.pushCount(1) : "\r" === ch && "\n" === this.charAt(1) ? yield* this.pushCount(2) : 0;
        }
        * pushSpaces(allowTabs) {
            let ch, i = this.pos - 1;
            do {
                ch = this.buffer[++i];
            } while (" " === ch || allowTabs && "\t" === ch);
            const n = i - this.pos;
            return n > 0 && (yield this.buffer.substr(this.pos, n), this.pos = i), n;
        }
        * pushUntil(test) {
            let i = this.pos, ch = this.buffer[i];
            for (;!test(ch); ) ch = this.buffer[++i];
            return yield* this.pushToIndex(i, !1);
        }
    }, lexer;
}

var lineCounter = {}, hasRequiredLineCounter;

function requireLineCounter() {
    if (hasRequiredLineCounter) return lineCounter;
    hasRequiredLineCounter = 1;
    return lineCounter.LineCounter = class {
        constructor() {
            this.lineStarts = [], this.addNewLine = offset => this.lineStarts.push(offset), 
            this.linePos = offset => {
                let low = 0, high = this.lineStarts.length;
                for (;low < high; ) {
                    const mid = low + high >> 1;
                    this.lineStarts[mid] < offset ? low = mid + 1 : high = mid;
                }
                if (this.lineStarts[low] === offset) return {
                    line: low + 1,
                    col: 1
                };
                if (0 === low) return {
                    line: 0,
                    col: offset
                };
                return {
                    line: low,
                    col: offset - this.lineStarts[low - 1] + 1
                };
            };
        }
    }, lineCounter;
}

var parser = {}, hasRequiredParser;

function requireParser() {
    if (hasRequiredParser) return parser;
    hasRequiredParser = 1;
    var cst = requireCst(), lexer = requireLexer();
    function includesToken(list, type) {
        for (let i = 0; i < list.length; ++i) if (list[i].type === type) return !0;
        return !1;
    }
    function findNonEmptyIndex(list) {
        for (let i = 0; i < list.length; ++i) switch (list[i].type) {
          case "space":
          case "comment":
          case "newline":
            break;

          default:
            return i;
        }
        return -1;
    }
    function isFlowToken(token) {
        switch (token?.type) {
          case "alias":
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar":
          case "flow-collection":
            return !0;

          default:
            return !1;
        }
    }
    function getPrevProps(parent) {
        switch (parent.type) {
          case "document":
            return parent.start;

          case "block-map":
            {
                const it = parent.items[parent.items.length - 1];
                return it.sep ?? it.start;
            }

          case "block-seq":
            return parent.items[parent.items.length - 1].start;

          default:
            return [];
        }
    }
    function getFirstKeyStartProps(prev) {
        if (0 === prev.length) return [];
        let i = prev.length;
        loop: for (;--i >= 0; ) switch (prev[i].type) {
          case "doc-start":
          case "explicit-key-ind":
          case "map-value-ind":
          case "seq-item-ind":
          case "newline":
            break loop;
        }
        for (;"space" === prev[++i]?.type; ) ;
        return prev.splice(i, prev.length);
    }
    function fixFlowSeqItems(fc) {
        if ("flow-seq-start" === fc.start.type) for (const it of fc.items) !it.sep || it.value || includesToken(it.start, "explicit-key-ind") || includesToken(it.sep, "map-value-ind") || (it.key && (it.value = it.key), 
        delete it.key, isFlowToken(it.value) ? it.value.end ? Array.prototype.push.apply(it.value.end, it.sep) : it.value.end = it.sep : Array.prototype.push.apply(it.start, it.sep), 
        delete it.sep);
    }
    return parser.Parser = class {
        constructor(onNewLine) {
            this.atNewLine = !0, this.atScalar = !1, this.indent = 0, this.offset = 0, this.onKeyLine = !1, 
            this.stack = [], this.source = "", this.type = "", this.lexer = new lexer.Lexer, 
            this.onNewLine = onNewLine;
        }
        * parse(source, incomplete = !1) {
            this.onNewLine && 0 === this.offset && this.onNewLine(0);
            for (const lexeme of this.lexer.lex(source, incomplete)) yield* this.next(lexeme);
            incomplete || (yield* this.end());
        }
        * next(source) {
            if (this.source = source, process.env.LOG_TOKENS && console.log("|", cst.prettyToken(source)), 
            this.atScalar) return this.atScalar = !1, yield* this.step(), void (this.offset += source.length);
            const type = cst.tokenType(source);
            if (type) if ("scalar" === type) this.atNewLine = !1, this.atScalar = !0, this.type = "scalar"; else {
                switch (this.type = type, yield* this.step(), type) {
                  case "newline":
                    this.atNewLine = !0, this.indent = 0, this.onNewLine && this.onNewLine(this.offset + source.length);
                    break;

                  case "space":
                    this.atNewLine && " " === source[0] && (this.indent += source.length);
                    break;

                  case "explicit-key-ind":
                  case "map-value-ind":
                  case "seq-item-ind":
                    this.atNewLine && (this.indent += source.length);
                    break;

                  case "doc-mode":
                  case "flow-error-end":
                    return;

                  default:
                    this.atNewLine = !1;
                }
                this.offset += source.length;
            } else {
                const message = `Not a YAML token: ${source}`;
                yield* this.pop({
                    type: "error",
                    offset: this.offset,
                    message: message,
                    source: source
                }), this.offset += source.length;
            }
        }
        * end() {
            for (;this.stack.length > 0; ) yield* this.pop();
        }
        get sourceToken() {
            return {
                type: this.type,
                offset: this.offset,
                indent: this.indent,
                source: this.source
            };
        }
        * step() {
            const top = this.peek(1);
            if ("doc-end" !== this.type || top && "doc-end" === top.type) {
                if (!top) return yield* this.stream();
                switch (top.type) {
                  case "document":
                    return yield* this.document(top);

                  case "alias":
                  case "scalar":
                  case "single-quoted-scalar":
                  case "double-quoted-scalar":
                    return yield* this.scalar(top);

                  case "block-scalar":
                    return yield* this.blockScalar(top);

                  case "block-map":
                    return yield* this.blockMap(top);

                  case "block-seq":
                    return yield* this.blockSequence(top);

                  case "flow-collection":
                    return yield* this.flowCollection(top);

                  case "doc-end":
                    return yield* this.documentEnd(top);
                }
                yield* this.pop();
            } else {
                for (;this.stack.length > 0; ) yield* this.pop();
                this.stack.push({
                    type: "doc-end",
                    offset: this.offset,
                    source: this.source
                });
            }
        }
        peek(n) {
            return this.stack[this.stack.length - n];
        }
        * pop(error) {
            const token = error ?? this.stack.pop();
            if (token) if (0 === this.stack.length) yield token; else {
                const top = this.peek(1);
                switch ("block-scalar" === token.type ? token.indent = "indent" in top ? top.indent : 0 : "flow-collection" === token.type && "document" === top.type && (token.indent = 0), 
                "flow-collection" === token.type && fixFlowSeqItems(token), top.type) {
                  case "document":
                    top.value = token;
                    break;

                  case "block-scalar":
                    top.props.push(token);
                    break;

                  case "block-map":
                    {
                        const it = top.items[top.items.length - 1];
                        if (it.value) return top.items.push({
                            start: [],
                            key: token,
                            sep: []
                        }), void (this.onKeyLine = !0);
                        if (!it.sep) return Object.assign(it, {
                            key: token,
                            sep: []
                        }), void (this.onKeyLine = !it.explicitKey);
                        it.value = token;
                        break;
                    }

                  case "block-seq":
                    {
                        const it = top.items[top.items.length - 1];
                        it.value ? top.items.push({
                            start: [],
                            value: token
                        }) : it.value = token;
                        break;
                    }

                  case "flow-collection":
                    {
                        const it = top.items[top.items.length - 1];
                        return void (!it || it.value ? top.items.push({
                            start: [],
                            key: token,
                            sep: []
                        }) : it.sep ? it.value = token : Object.assign(it, {
                            key: token,
                            sep: []
                        }));
                    }

                  default:
                    yield* this.pop(), yield* this.pop(token);
                }
                if (!("document" !== top.type && "block-map" !== top.type && "block-seq" !== top.type || "block-map" !== token.type && "block-seq" !== token.type)) {
                    const last = token.items[token.items.length - 1];
                    last && !last.sep && !last.value && last.start.length > 0 && -1 === findNonEmptyIndex(last.start) && (0 === token.indent || last.start.every((st => "comment" !== st.type || st.indent < token.indent))) && ("document" === top.type ? top.end = last.start : top.items.push({
                        start: last.start
                    }), token.items.splice(-1, 1));
                }
            } else {
                const message = "Tried to pop an empty stack";
                yield {
                    type: "error",
                    offset: this.offset,
                    source: "",
                    message: message
                };
            }
        }
        * stream() {
            switch (this.type) {
              case "directive-line":
                return void (yield {
                    type: "directive",
                    offset: this.offset,
                    source: this.source
                });

              case "byte-order-mark":
              case "space":
              case "comment":
              case "newline":
                return void (yield this.sourceToken);

              case "doc-mode":
              case "doc-start":
                {
                    const doc = {
                        type: "document",
                        offset: this.offset,
                        start: []
                    };
                    return "doc-start" === this.type && doc.start.push(this.sourceToken), void this.stack.push(doc);
                }
            }
            yield {
                type: "error",
                offset: this.offset,
                message: `Unexpected ${this.type} token in YAML stream`,
                source: this.source
            };
        }
        * document(doc) {
            if (doc.value) return yield* this.lineEnd(doc);
            switch (this.type) {
              case "doc-start":
                return void (-1 !== findNonEmptyIndex(doc.start) ? (yield* this.pop(), yield* this.step()) : doc.start.push(this.sourceToken));

              case "anchor":
              case "tag":
              case "space":
              case "comment":
              case "newline":
                return void doc.start.push(this.sourceToken);
            }
            const bv = this.startBlockValue(doc);
            bv ? this.stack.push(bv) : yield {
                type: "error",
                offset: this.offset,
                message: `Unexpected ${this.type} token in YAML document`,
                source: this.source
            };
        }
        * scalar(scalar) {
            if ("map-value-ind" === this.type) {
                const start = getFirstKeyStartProps(getPrevProps(this.peek(2)));
                let sep;
                scalar.end ? (sep = scalar.end, sep.push(this.sourceToken), delete scalar.end) : sep = [ this.sourceToken ];
                const map = {
                    type: "block-map",
                    offset: scalar.offset,
                    indent: scalar.indent,
                    items: [ {
                        start: start,
                        key: scalar,
                        sep: sep
                    } ]
                };
                this.onKeyLine = !0, this.stack[this.stack.length - 1] = map;
            } else yield* this.lineEnd(scalar);
        }
        * blockScalar(scalar) {
            switch (this.type) {
              case "space":
              case "comment":
              case "newline":
                return void scalar.props.push(this.sourceToken);

              case "scalar":
                if (scalar.source = this.source, this.atNewLine = !0, this.indent = 0, this.onNewLine) {
                    let nl = this.source.indexOf("\n") + 1;
                    for (;0 !== nl; ) this.onNewLine(this.offset + nl), nl = this.source.indexOf("\n", nl) + 1;
                }
                yield* this.pop();
                break;

              default:
                yield* this.pop(), yield* this.step();
            }
        }
        * blockMap(map) {
            const it = map.items[map.items.length - 1];
            switch (this.type) {
              case "newline":
                if (this.onKeyLine = !1, it.value) {
                    const end = "end" in it.value ? it.value.end : void 0, last = Array.isArray(end) ? end[end.length - 1] : void 0;
                    "comment" === last?.type ? end?.push(this.sourceToken) : map.items.push({
                        start: [ this.sourceToken ]
                    });
                } else it.sep ? it.sep.push(this.sourceToken) : it.start.push(this.sourceToken);
                return;

              case "space":
              case "comment":
                if (it.value) map.items.push({
                    start: [ this.sourceToken ]
                }); else if (it.sep) it.sep.push(this.sourceToken); else {
                    if (this.atIndentedComment(it.start, map.indent)) {
                        const prev = map.items[map.items.length - 2], end = prev?.value?.end;
                        if (Array.isArray(end)) return Array.prototype.push.apply(end, it.start), end.push(this.sourceToken), 
                        void map.items.pop();
                    }
                    it.start.push(this.sourceToken);
                }
                return;
            }
            if (this.indent >= map.indent) {
                const atMapIndent = !this.onKeyLine && this.indent === map.indent, atNextItem = atMapIndent && (it.sep || it.explicitKey) && "seq-item-ind" !== this.type;
                let start = [];
                if (atNextItem && it.sep && !it.value) {
                    const nl = [];
                    for (let i = 0; i < it.sep.length; ++i) {
                        const st = it.sep[i];
                        switch (st.type) {
                          case "newline":
                            nl.push(i);
                            break;

                          case "space":
                            break;

                          case "comment":
                            st.indent > map.indent && (nl.length = 0);
                            break;

                          default:
                            nl.length = 0;
                        }
                    }
                    nl.length >= 2 && (start = it.sep.splice(nl[1]));
                }
                switch (this.type) {
                  case "anchor":
                  case "tag":
                    return void (atNextItem || it.value ? (start.push(this.sourceToken), map.items.push({
                        start: start
                    }), this.onKeyLine = !0) : it.sep ? it.sep.push(this.sourceToken) : it.start.push(this.sourceToken));

                  case "explicit-key-ind":
                    return it.sep || it.explicitKey ? atNextItem || it.value ? (start.push(this.sourceToken), 
                    map.items.push({
                        start: start,
                        explicitKey: !0
                    })) : this.stack.push({
                        type: "block-map",
                        offset: this.offset,
                        indent: this.indent,
                        items: [ {
                            start: [ this.sourceToken ],
                            explicitKey: !0
                        } ]
                    }) : (it.start.push(this.sourceToken), it.explicitKey = !0), void (this.onKeyLine = !0);

                  case "map-value-ind":
                    if (it.explicitKey) if (it.sep) if (it.value) map.items.push({
                        start: [],
                        key: null,
                        sep: [ this.sourceToken ]
                    }); else if (includesToken(it.sep, "map-value-ind")) this.stack.push({
                        type: "block-map",
                        offset: this.offset,
                        indent: this.indent,
                        items: [ {
                            start: start,
                            key: null,
                            sep: [ this.sourceToken ]
                        } ]
                    }); else if (isFlowToken(it.key) && !includesToken(it.sep, "newline")) {
                        const start = getFirstKeyStartProps(it.start), key = it.key, sep = it.sep;
                        sep.push(this.sourceToken), delete it.key, delete it.sep, this.stack.push({
                            type: "block-map",
                            offset: this.offset,
                            indent: this.indent,
                            items: [ {
                                start: start,
                                key: key,
                                sep: sep
                            } ]
                        });
                    } else start.length > 0 ? it.sep = it.sep.concat(start, this.sourceToken) : it.sep.push(this.sourceToken); else if (includesToken(it.start, "newline")) Object.assign(it, {
                        key: null,
                        sep: [ this.sourceToken ]
                    }); else {
                        const start = getFirstKeyStartProps(it.start);
                        this.stack.push({
                            type: "block-map",
                            offset: this.offset,
                            indent: this.indent,
                            items: [ {
                                start: start,
                                key: null,
                                sep: [ this.sourceToken ]
                            } ]
                        });
                    } else it.sep ? it.value || atNextItem ? map.items.push({
                        start: start,
                        key: null,
                        sep: [ this.sourceToken ]
                    }) : includesToken(it.sep, "map-value-ind") ? this.stack.push({
                        type: "block-map",
                        offset: this.offset,
                        indent: this.indent,
                        items: [ {
                            start: [],
                            key: null,
                            sep: [ this.sourceToken ]
                        } ]
                    }) : it.sep.push(this.sourceToken) : Object.assign(it, {
                        key: null,
                        sep: [ this.sourceToken ]
                    });
                    return void (this.onKeyLine = !0);

                  case "alias":
                  case "scalar":
                  case "single-quoted-scalar":
                  case "double-quoted-scalar":
                    {
                        const fs = this.flowScalar(this.type);
                        return void (atNextItem || it.value ? (map.items.push({
                            start: start,
                            key: fs,
                            sep: []
                        }), this.onKeyLine = !0) : it.sep ? this.stack.push(fs) : (Object.assign(it, {
                            key: fs,
                            sep: []
                        }), this.onKeyLine = !0));
                    }

                  default:
                    {
                        const bv = this.startBlockValue(map);
                        if (bv) return atMapIndent && "block-seq" !== bv.type && map.items.push({
                            start: start
                        }), void this.stack.push(bv);
                    }
                }
            }
            yield* this.pop(), yield* this.step();
        }
        * blockSequence(seq) {
            const it = seq.items[seq.items.length - 1];
            switch (this.type) {
              case "newline":
                if (it.value) {
                    const end = "end" in it.value ? it.value.end : void 0, last = Array.isArray(end) ? end[end.length - 1] : void 0;
                    "comment" === last?.type ? end?.push(this.sourceToken) : seq.items.push({
                        start: [ this.sourceToken ]
                    });
                } else it.start.push(this.sourceToken);
                return;

              case "space":
              case "comment":
                if (it.value) seq.items.push({
                    start: [ this.sourceToken ]
                }); else {
                    if (this.atIndentedComment(it.start, seq.indent)) {
                        const prev = seq.items[seq.items.length - 2], end = prev?.value?.end;
                        if (Array.isArray(end)) return Array.prototype.push.apply(end, it.start), end.push(this.sourceToken), 
                        void seq.items.pop();
                    }
                    it.start.push(this.sourceToken);
                }
                return;

              case "anchor":
              case "tag":
                if (it.value || this.indent <= seq.indent) break;
                return void it.start.push(this.sourceToken);

              case "seq-item-ind":
                if (this.indent !== seq.indent) break;
                return void (it.value || includesToken(it.start, "seq-item-ind") ? seq.items.push({
                    start: [ this.sourceToken ]
                }) : it.start.push(this.sourceToken));
            }
            if (this.indent > seq.indent) {
                const bv = this.startBlockValue(seq);
                if (bv) return void this.stack.push(bv);
            }
            yield* this.pop(), yield* this.step();
        }
        * flowCollection(fc) {
            const it = fc.items[fc.items.length - 1];
            if ("flow-error-end" === this.type) {
                let top;
                do {
                    yield* this.pop(), top = this.peek(1);
                } while (top && "flow-collection" === top.type);
            } else if (0 === fc.end.length) {
                switch (this.type) {
                  case "comma":
                  case "explicit-key-ind":
                    return void (!it || it.sep ? fc.items.push({
                        start: [ this.sourceToken ]
                    }) : it.start.push(this.sourceToken));

                  case "map-value-ind":
                    return void (!it || it.value ? fc.items.push({
                        start: [],
                        key: null,
                        sep: [ this.sourceToken ]
                    }) : it.sep ? it.sep.push(this.sourceToken) : Object.assign(it, {
                        key: null,
                        sep: [ this.sourceToken ]
                    }));

                  case "space":
                  case "comment":
                  case "newline":
                  case "anchor":
                  case "tag":
                    return void (!it || it.value ? fc.items.push({
                        start: [ this.sourceToken ]
                    }) : it.sep ? it.sep.push(this.sourceToken) : it.start.push(this.sourceToken));

                  case "alias":
                  case "scalar":
                  case "single-quoted-scalar":
                  case "double-quoted-scalar":
                    {
                        const fs = this.flowScalar(this.type);
                        return void (!it || it.value ? fc.items.push({
                            start: [],
                            key: fs,
                            sep: []
                        }) : it.sep ? this.stack.push(fs) : Object.assign(it, {
                            key: fs,
                            sep: []
                        }));
                    }

                  case "flow-map-end":
                  case "flow-seq-end":
                    return void fc.end.push(this.sourceToken);
                }
                const bv = this.startBlockValue(fc);
                bv ? this.stack.push(bv) : (yield* this.pop(), yield* this.step());
            } else {
                const parent = this.peek(2);
                if ("block-map" === parent.type && ("map-value-ind" === this.type && parent.indent === fc.indent || "newline" === this.type && !parent.items[parent.items.length - 1].sep)) yield* this.pop(), 
                yield* this.step(); else if ("map-value-ind" === this.type && "flow-collection" !== parent.type) {
                    const start = getFirstKeyStartProps(getPrevProps(parent));
                    fixFlowSeqItems(fc);
                    const sep = fc.end.splice(1, fc.end.length);
                    sep.push(this.sourceToken);
                    const map = {
                        type: "block-map",
                        offset: fc.offset,
                        indent: fc.indent,
                        items: [ {
                            start: start,
                            key: fc,
                            sep: sep
                        } ]
                    };
                    this.onKeyLine = !0, this.stack[this.stack.length - 1] = map;
                } else yield* this.lineEnd(fc);
            }
        }
        flowScalar(type) {
            if (this.onNewLine) {
                let nl = this.source.indexOf("\n") + 1;
                for (;0 !== nl; ) this.onNewLine(this.offset + nl), nl = this.source.indexOf("\n", nl) + 1;
            }
            return {
                type: type,
                offset: this.offset,
                indent: this.indent,
                source: this.source
            };
        }
        startBlockValue(parent) {
            switch (this.type) {
              case "alias":
              case "scalar":
              case "single-quoted-scalar":
              case "double-quoted-scalar":
                return this.flowScalar(this.type);

              case "block-scalar-header":
                return {
                    type: "block-scalar",
                    offset: this.offset,
                    indent: this.indent,
                    props: [ this.sourceToken ],
                    source: ""
                };

              case "flow-map-start":
              case "flow-seq-start":
                return {
                    type: "flow-collection",
                    offset: this.offset,
                    indent: this.indent,
                    start: this.sourceToken,
                    items: [],
                    end: []
                };

              case "seq-item-ind":
                return {
                    type: "block-seq",
                    offset: this.offset,
                    indent: this.indent,
                    items: [ {
                        start: [ this.sourceToken ]
                    } ]
                };

              case "explicit-key-ind":
                {
                    this.onKeyLine = !0;
                    const start = getFirstKeyStartProps(getPrevProps(parent));
                    return start.push(this.sourceToken), {
                        type: "block-map",
                        offset: this.offset,
                        indent: this.indent,
                        items: [ {
                            start: start,
                            explicitKey: !0
                        } ]
                    };
                }

              case "map-value-ind":
                {
                    this.onKeyLine = !0;
                    const start = getFirstKeyStartProps(getPrevProps(parent));
                    return {
                        type: "block-map",
                        offset: this.offset,
                        indent: this.indent,
                        items: [ {
                            start: start,
                            key: null,
                            sep: [ this.sourceToken ]
                        } ]
                    };
                }
            }
            return null;
        }
        atIndentedComment(start, indent) {
            return "comment" === this.type && (!(this.indent <= indent) && start.every((st => "newline" === st.type || "space" === st.type)));
        }
        * documentEnd(docEnd) {
            "doc-mode" !== this.type && (docEnd.end ? docEnd.end.push(this.sourceToken) : docEnd.end = [ this.sourceToken ], 
            "newline" === this.type && (yield* this.pop()));
        }
        * lineEnd(token) {
            switch (this.type) {
              case "comma":
              case "doc-start":
              case "doc-end":
              case "flow-seq-end":
              case "flow-map-end":
              case "map-value-ind":
                yield* this.pop(), yield* this.step();
                break;

              case "newline":
                this.onKeyLine = !1;

              default:
                token.end ? token.end.push(this.sourceToken) : token.end = [ this.sourceToken ], 
                "newline" === this.type && (yield* this.pop());
            }
        }
    }, parser;
}

var publicApi$1 = {}, hasRequiredPublicApi$1, hasRequiredDist;

function requirePublicApi$1() {
    if (hasRequiredPublicApi$1) return publicApi$1;
    hasRequiredPublicApi$1 = 1;
    var composer = requireComposer(), Document = requireDocument(), errors = requireErrors(), log = requireLog(), identity = requireIdentity(), lineCounter = requireLineCounter(), parser = requireParser();
    function parseOptions(options) {
        const prettyErrors = !1 !== options.prettyErrors;
        return {
            lineCounter: options.lineCounter || prettyErrors && new lineCounter.LineCounter || null,
            prettyErrors: prettyErrors
        };
    }
    function parseDocument(source, options = {}) {
        const {lineCounter: lineCounter, prettyErrors: prettyErrors} = parseOptions(options), parser$1 = new parser.Parser(lineCounter?.addNewLine), composer$1 = new composer.Composer(options);
        let doc = null;
        for (const _doc of composer$1.compose(parser$1.parse(source), !0, source.length)) if (doc) {
            if ("silent" !== doc.options.logLevel) {
                doc.errors.push(new errors.YAMLParseError(_doc.range.slice(0, 2), "MULTIPLE_DOCS", "Source contains multiple documents; please use YAML.parseAllDocuments()"));
                break;
            }
        } else doc = _doc;
        return prettyErrors && lineCounter && (doc.errors.forEach(errors.prettifyError(source, lineCounter)), 
        doc.warnings.forEach(errors.prettifyError(source, lineCounter))), doc;
    }
    return publicApi$1.parse = function(src, reviver, options) {
        let _reviver;
        "function" == typeof reviver ? _reviver = reviver : void 0 === options && reviver && "object" == typeof reviver && (options = reviver);
        const doc = parseDocument(src, options);
        if (!doc) return null;
        if (doc.warnings.forEach((warning => log.warn(doc.options.logLevel, warning))), 
        doc.errors.length > 0) {
            if ("silent" !== doc.options.logLevel) throw doc.errors[0];
            doc.errors = [];
        }
        return doc.toJS(Object.assign({
            reviver: _reviver
        }, options));
    }, publicApi$1.parseAllDocuments = function(source, options = {}) {
        const {lineCounter: lineCounter, prettyErrors: prettyErrors} = parseOptions(options), parser$1 = new parser.Parser(lineCounter?.addNewLine), composer$1 = new composer.Composer(options), docs = Array.from(composer$1.compose(parser$1.parse(source)));
        if (prettyErrors && lineCounter) for (const doc of docs) doc.errors.forEach(errors.prettifyError(source, lineCounter)), 
        doc.warnings.forEach(errors.prettifyError(source, lineCounter));
        return docs.length > 0 ? docs : Object.assign([], {
            empty: !0
        }, composer$1.streamInfo());
    }, publicApi$1.parseDocument = parseDocument, publicApi$1.stringify = function(value, replacer, options) {
        let _replacer = null;
        if ("function" == typeof replacer || Array.isArray(replacer) ? _replacer = replacer : void 0 === options && replacer && (options = replacer), 
        "string" == typeof options && (options = options.length), "number" == typeof options) {
            const indent = Math.round(options);
            options = indent < 1 ? void 0 : indent > 8 ? {
                indent: 8
            } : {
                indent: indent
            };
        }
        if (void 0 === value) {
            const {keepUndefined: keepUndefined} = options ?? replacer ?? {};
            if (!keepUndefined) return;
        }
        return identity.isDocument(value) && !_replacer ? value.toString(options) : new Document.Document(value, _replacer, options).toString(options);
    }, publicApi$1;
}

function requireDist() {
    if (hasRequiredDist) return dist;
    hasRequiredDist = 1;
    var composer = requireComposer(), Document = requireDocument(), Schema = requireSchema(), errors = requireErrors(), Alias = requireAlias(), identity = requireIdentity(), Pair = requirePair(), Scalar = requireScalar(), YAMLMap = requireYAMLMap(), YAMLSeq = requireYAMLSeq(), cst = requireCst(), lexer = requireLexer(), lineCounter = requireLineCounter(), parser = requireParser(), publicApi = requirePublicApi$1(), visit = requireVisit();
    return dist.Composer = composer.Composer, dist.Document = Document.Document, dist.Schema = Schema.Schema, 
    dist.YAMLError = errors.YAMLError, dist.YAMLParseError = errors.YAMLParseError, 
    dist.YAMLWarning = errors.YAMLWarning, dist.Alias = Alias.Alias, dist.isAlias = identity.isAlias, 
    dist.isCollection = identity.isCollection, dist.isDocument = identity.isDocument, 
    dist.isMap = identity.isMap, dist.isNode = identity.isNode, dist.isPair = identity.isPair, 
    dist.isScalar = identity.isScalar, dist.isSeq = identity.isSeq, dist.Pair = Pair.Pair, 
    dist.Scalar = Scalar.Scalar, dist.YAMLMap = YAMLMap.YAMLMap, dist.YAMLSeq = YAMLSeq.YAMLSeq, 
    dist.CST = cst, dist.Lexer = lexer.Lexer, dist.LineCounter = lineCounter.LineCounter, 
    dist.Parser = parser.Parser, dist.parse = publicApi.parse, dist.parseAllDocuments = publicApi.parseAllDocuments, 
    dist.parseDocument = publicApi.parseDocument, dist.stringify = publicApi.stringify, 
    dist.visit = visit.visit, dist.visitAsync = visit.visitAsync, dist;
}

var distExports = requireDist();

function resolveTilde(filePath) {
    return filePath.startsWith("~") ? path.join(homedir(), filePath.slice(1)) : filePath;
}

function loadPlaintextFile(filePath) {
    try {
        return fs.readFileSync(resolveTilde(filePath), "utf-8");
    } catch (error) {
        return "ENOENT" === error.code ? console.error("File not found:", filePath) : console.error("Error reading file:", error.message), 
        null;
    }
}

function loadJsonFile(filePath) {
    try {
        return parseJson(loadPlaintextFile(filePath));
    } catch (error) {
        return null;
    }
}

function loadYamlFile(filePath) {
    try {
        return distExports.parse(loadPlaintextFile(filePath));
    } catch (error) {
        return null;
    }
}

function parseJson(input) {
    try {
        return JSON.parse(input);
    } catch (error) {
        return error instanceof SyntaxError && console.error("Error parsing JSON:", error.message), 
        null;
    }
}

function loadTomlFile(filePath, injectConfigPath = !0) {
    try {
        const data = loadPlaintextFile(filePath), parsedData = tomlExports.parse(data);
        return injectConfigPath && (parsedData.configPath = filePath), parsedData;
    } catch (error) {
        return error instanceof SyntaxError && console.error("Error parsing TOML:", error.message), 
        null;
    }
}

function createFolders(filePath, resolve = !0) {
    return filePath = resolveTilde(filePath), resolve && (filePath = path.resolve(filePath), 
    path.basename(filePath).includes(".") && (filePath = path.dirname(filePath))), fs.mkdirSync(filePath, {
        recursive: !0
    });
}

function doesFileExist(filePath, resolve = !0) {
    try {
        return filePath = resolveTilde(filePath), resolve && (filePath = path.resolve(filePath)), 
        fs.statfsSync(filePath), !0;
    } catch (err) {}
    return !1;
}

function directoryExists(directoryPath) {
    try {
        return fs.statSync(resolveTilde(directoryPath)).isDirectory();
    } catch (err) {
        return !1;
    }
}

function moveFiles(sourceDir, destinationDir, overwrite = !1) {
    if (!directoryExists(sourceDir)) return void warnMessage(`[moveFiles] Source directory does not exist: ${sourceDir}`);
    const files = fs.readdirSync(sourceDir);
    directoryExists(destinationDir) || createFolders(destinationDir), files.forEach((file => {
        const sourceFile = path.join(sourceDir, file), destinationFile = path.join(destinationDir, file);
        if (fs.existsSync(destinationFile)) {
            if (!overwrite) return;
            fs.unlinkSync(destinationFile);
        }
        fs.cpSync(sourceFile, destinationFile);
    }));
}

function loadFileNamesToMap(dir, extension) {
    const fileMap = new Map;
    if (!directoryExists(dir)) return fileMap;
    return fs.readdirSync(dir).forEach((file => {
        const filePath = path.join(dir, file);
        if (fs.statSync(filePath).isFile()) {
            const fileNameWithoutExt = path.basename(file, path.extname(file));
            extension && path.extname(file) !== extension || fileMap.set(fileNameWithoutExt, file);
        }
    })), fileMap;
}

function updateGitignore(items, gitignorePath = path.join(process.cwd(), ".gitignore")) {
    let gitignoreContent = "";
    doesFileExist(gitignorePath) && (gitignoreContent = loadPlaintextFile(gitignorePath));
    const gitignoreLines = gitignoreContent.split("\n").map((line => line.trim()));
    let updated = !1;
    items.forEach((item => {
        gitignoreLines.includes(item.trim()) || (gitignoreContent += `\n${item.trim()}`, 
        updated = !0);
    })), updated && fs.writeFileSync(gitignorePath, gitignoreContent.trim() + "\n", "utf-8");
}

function findFileInRepo(targetFilename, startDir = process.cwd(), maxDepth = 5, skipDirs = [ "node_modules", ".cache" ]) {
    let currentDir = startDir, depth = 0;
    for (;depth < maxDepth; ) {
        const filePath = findFileInDirectory(currentDir, targetFilename.toLowerCase(), skipDirs);
        if (filePath) return filePath;
        const gitDir = path.join(currentDir, ".git");
        if (fs.existsSync(gitDir) && fs.statSync(gitDir).isDirectory()) return null;
        const parentDir = path.dirname(currentDir);
        if (parentDir === currentDir) return null;
        currentDir = parentDir, depth++;
    }
    return null;
}

function findFileInDirectory(dir, targetFilename, skipDirs) {
    const files = fs.readdirSync(dir);
    for (const file of files) {
        const absolutePath = path.join(dir, file);
        try {
            if (fs.statSync(absolutePath).isDirectory()) {
                if (skipDirs.includes(file)) continue;
                const result = findFileInDirectory(absolutePath, targetFilename, skipDirs);
                if (result) return result;
            } else if (file.toLowerCase() === targetFilename) return absolutePath;
        } catch (err) {}
    }
    return null;
}

function isInCurrentDir(filePath) {
    return path.resolve(process.cwd()) === path.resolve(path.dirname(filePath));
}

function deepMerge$1(obj1, obj2) {
    const result = {
        ...obj1
    };
    for (const key in obj2) obj2.hasOwnProperty(key) && (isObject$1(obj2[key]) && isObject$1(result[key]) ? result[key] = deepMerge$1(result[key], obj2[key]) : result[key] = obj2[key]);
    return result;
}

function isObject$1(value) {
    return value && "object" == typeof value && !Array.isArray(value);
}

const DEFAULT_CONFIG_FILE = "Solana.toml", DEFAULT_ACCOUNTS_DIR = "fixtures", DEFAULT_CACHE_DIR = ".cache", DEFAULT_TEST_LEDGER_DIR = "test-ledger", DEFAULT_ACCOUNTS_DIR_TEMP = ".cache/staging/fixtures", DEFAULT_ACCOUNTS_DIR_LOADED = ".cache/loaded/fixtures", DEFAULT_KEYPAIR_PATH = "~/.config/solana/id.json", DEFAULT_CLI_YAML_PATH = "~/.config/solana/cli/config.yml", DEFAULT_BUILD_DIR = "target/deploy", cliConfig = loadSolanaCliConfig(), COMMON_OPTIONS = {
    config: new Option("-c --config <PATH>", "path to a Solana.toml config file").default(DEFAULT_CONFIG_FILE),
    keypair: new Option("--keypair <PATH>", "path to a keypair file").default(cliConfig.keypair_path || DEFAULT_KEYPAIR_PATH),
    url: new Option("-u --url <URL_OR_MONIKER>", "URL for Solana's JSON RPC or moniker"),
    outputOnly: new Option("--output-only", "only output the generated command, do not execute it"),
    accountDir: new Option("--account-dir <ACCOUNT_DIR>", "local directory path to store any cloned accounts").default(DEFAULT_ACCOUNTS_DIR),
    manifestPath: new Option("--manifest-path <PATH>", "path to Cargo.toml").default(join(process.cwd(), "Cargo.toml"))
};

function loadSolanaCliConfig(filePath = DEFAULT_CLI_YAML_PATH) {
    const cliConfig = loadYamlFile(filePath);
    if (cliConfig?.json_rpc_url) switch (cliConfig.json_rpc_url) {
      case "https://api.devnet.solana.com":
        cliConfig.json_rpc_url = "devnet";
        break;

      case "https://api.testnet.solana.com":
        cliConfig.json_rpc_url = "testnet";
        break;

      case "https://api.mainnet-beta.solana.com":
        cliConfig.json_rpc_url = "mainnet";
        break;

      case "http://localhost:8899":
        cliConfig.json_rpc_url = "localhost";
    }
    return cliConfig;
}

function loadConfigToml(configPath = DEFAULT_CONFIG_FILE, settings = {}, isConfigRequired = !1) {
    if (directoryExists(configPath) && (configPath = join(configPath, DEFAULT_CONFIG_FILE)), 
    configPath === DEFAULT_CONFIG_FILE) {
        const newPath = findFileInRepo(DEFAULT_CONFIG_FILE);
        newPath && (configPath = newPath, isInCurrentDir(newPath) || warnMessage(`Using closest Solana.toml located at: ${newPath}`));
    }
    let config = {
        configPath: configPath
    };
    doesFileExist(configPath, !0) ? config = loadTomlFile(configPath) || config : isConfigRequired ? warningOutro("No Solana.toml config file found. Operation canceled.") : warnMessage("No Solana.toml config file found. Skipping.");
    const defaultSettings = {
        cluster: COMMON_OPTIONS.url.defaultValue,
        accountDir: COMMON_OPTIONS.accountDir.defaultValue,
        keypair: COMMON_OPTIONS.keypair.defaultValue
    };
    return config.settings = Object.assign(defaultSettings, config.settings || {}), 
    config = deconflictSolanaTomlConfig(config, settings), config.configPath = configPath, 
    config;
}

function deconflictSolanaTomlConfig(config, args) {
    return args?.url && args.url !== COMMON_OPTIONS.url.defaultValue && (config.settings.cluster = args.url), 
    args?.accountDir && args.accountDir !== COMMON_OPTIONS.accountDir.defaultValue && (config.settings.accountDir = args.accountDir), 
    args?.keypair && args.keypair !== COMMON_OPTIONS.keypair.defaultValue && (config.settings.keypair = args.keypair), 
    config;
}

const cliOutputConfig = {
    writeErr(str) {
        console.log(str.trim() + "\n");
    },
    writeOut(str) {
        console.log(str.trim() + "\n");
    }
};

var name = "solana", version$1 = "2.8.0", description = "", license = "MIT", type$1 = "module", publishConfig = {
    access: "public"
}, main$2 = "./bin/index.mjs", scripts = {
    dev: "yarn build && yarn nsolana",
    build: "rollup -c",
    watch: "rollup -c --watch",
    solana: "node ./bin/index.mjs",
    "changeset:version": 'changeset version && git add -A && git commit -m "chore: version"',
    "changeset:publish": "pnpm build && changeset publish",
    postpublish: "git push --follow-tags"
}, bin = {
    nsolana: "bin/index.mjs",
    "solana-node": "bin/index.mjs"
}, files = [ "/bin" ], dependencies = {
    "@commander-js/extra-typings": "^12.1.0",
    "@iarna/toml": "^2.2.5",
    "@inquirer/prompts": "^7.0.0",
    "@solana/buffer-layout": "^4.0.1",
    "@solana/buffer-layout-utils": "^0.2.0",
    "@solana/spl-token": "^0.4.9",
    "@solana/web3.js": "^1.95.3",
    commander: "^12.1.0",
    dotenv: "^16.4.5",
    inquirer: "^12.0.0",
    ora: "^8.1.0",
    picocolors: "^1.1.1",
    punycode: "^2.3.1",
    "shell-exec": "^1.1.2",
    yaml: "^2.6.0"
}, devDependencies = {
    "@changesets/cli": "^2.27.9",
    "@rollup/plugin-commonjs": "^28.0.1",
    "@rollup/plugin-json": "^6.1.0",
    "@rollup/plugin-node-resolve": "^15.3.0",
    "@rollup/plugin-terser": "^0.4.4",
    "@rollup/plugin-typescript": "^12.1.1",
    "@types/bn.js": "^5.1.6",
    "@types/inquirer": "^9.0.7",
    "@types/node": "^22.7.6",
    "@types/prompts": "^2.4.9",
    rollup: "^4.24.0",
    tslib: "^2.8.0",
    typescript: "^5.6.3"
}, keywords = [], homepage = "https://github.com/solana-developers/solana-node-cli#readme", bugs = {
    url: "https://github.com/solana-developers/solana-node-cli/issues"
}, repository = {
    name: "solana-developers/solana-node-cli",
    type: "git",
    url: "git+https://github.com/solana-developers/solana-node-cli.git"
}, contributors = [ {
    name: "Nick Frostbutter",
    url: "https://github.com/nickfrosty"
} ], packageJson = {
    name: name,
    version: version$1,
    description: description,
    license: license,
    type: type$1,
    publishConfig: publishConfig,
    main: main$2,
    scripts: scripts,
    bin: bin,
    files: files,
    dependencies: dependencies,
    devDependencies: devDependencies,
    keywords: keywords,
    homepage: homepage,
    bugs: bugs,
    repository: repository,
    contributors: contributors
};

function getAppInfo() {
    return {
        version: packageJson.version,
        name: packageJson.name
    };
}

function cliProgramRoot() {
    const app = getAppInfo();
    return (new Command).name("npx solana").version(app.version, "--version", "output the version number of this tool").configureOutput(cliOutputConfig);
}

var __defProp = Object.defineProperty, __defProps = Object.defineProperties, __getOwnPropDescs = Object.getOwnPropertyDescriptors, __getOwnPropSymbols = Object.getOwnPropertySymbols, __hasOwnProp = Object.prototype.hasOwnProperty, __propIsEnum = Object.prototype.propertyIsEnumerable, __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: value
}) : obj[key] = value, __spreadValues = (a, b) => {
    for (var prop in b || (b = {})) __hasOwnProp.call(b, prop) && __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) __propIsEnum.call(b, prop) && __defNormalProp(a, prop, b[prop]);
    return a;
}, __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));

function shellExec(cmd, opts) {
    const executable = Array.isArray(cmd) ? cmd.join(";") : cmd, options = __spreadProps(__spreadValues({}, opts), {
        stdio: "pipe",
        cwd: process.cwd()
    }), {platform: platform} = process;
    try {
        const cmd2 = "win32" === platform ? "cmd" : "sh", arg = "win32" === platform ? "/C" : "-c", child = childProcess.spawn(cmd2, [ arg, executable ], options);
        return new Promise((resolve => {
            const stdoutList = [], stderrList = [];
            child.stdout && child.stdout.on("data", (data => {
                if (Buffer.isBuffer(data)) return stdoutList.push(data.toString());
                stdoutList.push(data);
            })), child.stderr && child.stderr.on("data", (data => {
                if (Buffer.isBuffer(data)) return stderrList.push(data.toString());
                stderrList.push(JSON.stringify(data));
            }));
            const getDefaultResult = () => {
                const stderr = stderrList.join("\n");
                return {
                    stdout: stdoutList.join("\n"),
                    stderr: stderr,
                    cmd: executable
                };
            };
            child.on("error", (error => resolve(__spreadProps(__spreadValues({}, getDefaultResult()), {
                error: error
            })))), child.on("close", (code => resolve(__spreadProps(__spreadValues({}, getDefaultResult()), {
                code: code
            }))));
        }));
    } catch (error) {
        return Promise.reject(error);
    }
}

var src_default = shellExec;

const TOOL_CONFIG = {
    rust: {
        pathSource: "$HOME/.cargo/env",
        version: "rustc --version"
    },
    solana: {
        dependencies: [ "rust" ],
        pathSource: "$HOME/.local/share/solana/install/active_release/bin",
        version: "solana --version"
    },
    avm: {
        dependencies: [ "rust" ],
        version: "avm --version"
    },
    anchor: {
        dependencies: [ "avm" ],
        version: "anchor --version"
    },
    yarn: {
        version: "yarn --version"
    },
    trident: {
        dependencies: [ "rust" ],
        version: "cargo install --list | grep trident-cli"
    },
    zest: {
        dependencies: [ "rust" ],
        version: "cargo install --list | grep zest"
    },
    verify: {
        dependencies: [ "rust" ],
        version: "solana-verify --version"
    }
};

var PathSourceStatus;

!function(PathSourceStatus) {
    PathSourceStatus[PathSourceStatus.SUCCESS = 0] = "SUCCESS", PathSourceStatus[PathSourceStatus.FAILED = 1] = "FAILED", 
    PathSourceStatus[PathSourceStatus.OUTPUT_MISMATCH = 2] = "OUTPUT_MISMATCH", PathSourceStatus[PathSourceStatus.MISSING_PATH = 3] = "MISSING_PATH";
}(PathSourceStatus || (PathSourceStatus = {}));

const VERSION_REGEX = /(?:[\w-]+\s+)?(\d+\.\d+\.?\d+?)/;

async function installedToolVersion(name) {
    let command = "";
    if (Object.prototype.hasOwnProperty.call(TOOL_CONFIG, name) && (command = TOOL_CONFIG[name].version, 
    TOOL_CONFIG[name].pathSource && (command = `export PATH="${TOOL_CONFIG[name].pathSource}:$PATH" && ${command}`)), 
    !command) return !1;
    const res = await checkCommand(command);
    return res && VERSION_REGEX.exec(res)[1] || res;
}

async function checkCommand(cmd, errorOptions = null) {
    try {
        const {stdout: stdout} = await src_default(cmd);
        if (stdout) return stdout.trim();
        if (errorOptions) throw "Command not found";
        return !1;
    } catch (err) {
        if (errorOptions) if ("function" == typeof errorOptions?.onError) {
            const res = await errorOptions.onError();
            if (errorOptions.doubleCheck) return await checkCommand(cmd, {
                exit: errorOptions.exit
            });
            !res && errorOptions?.exit && process.exit(1);
        } else warnMessage(errorOptions.message || `Unable to execute command: ${cmd.split(" ")[0]}`), 
        errorOptions.exit && process.exit(1);
        return !1;
    }
}

function detectOperatingSystem() {
    switch (os.platform()) {
      case "darwin":
        return "mac";

      case "win32":
        return "windows";

      case "linux":
        return "linux";

      default:
        return "unknown";
    }
}

function appendPathToRCFiles(newPath, name = void 0) {
    const homeDir = process.env.HOME || process.env.USERPROFILE;
    if (!homeDir) return void console.error("[appendPathToRCFiles]", "Unable to find the user home directory.");
    const rcFiles = [ ".bashrc", ".zshrc" ].map((file => path.join(homeDir, file)));
    let exportLine = `export PATH=${newPath}:$PATH\n`;
    if (name) {
        const exportName = `${name.toUpperCase()}_HOME`;
        exportLine = `\n# ${name}\nexport ${exportName}="${newPath}"\ncase ":$PATH:" in\n  *":$${exportName}:"*) ;;\n  *) export PATH="$${exportName}:$PATH" ;;\nesac\n# ${name} end\n\n`;
    }
    rcFiles.forEach((rcFile => {
        if (fs.existsSync(rcFile)) {
            fs.readFileSync(rcFile, "utf-8").includes(newPath) || fs.appendFileSync(rcFile, exportLine);
        }
    }));
}

function shellExecInSession({command: command, args: args, outputOnly: outputOnly}) {
    return outputOnly ? ((args = args || []).unshift(command), console.log(args.join(" "))) : spawn(command, args, {
        detached: !1,
        stdio: "inherit",
        shell: !0
    });
}

const ANSI_BACKGROUND_OFFSET = 10, wrapAnsi16 = (offset = 0) => code => `[${code + offset}m`, wrapAnsi256 = (offset = 0) => code => `[${38 + offset};5;${code}m`, wrapAnsi16m = (offset = 0) => (red, green, blue) => `[${38 + offset};2;${red};${green};${blue}m`, styles$1 = {
    modifier: {
        reset: [ 0, 0 ],
        bold: [ 1, 22 ],
        dim: [ 2, 22 ],
        italic: [ 3, 23 ],
        underline: [ 4, 24 ],
        overline: [ 53, 55 ],
        inverse: [ 7, 27 ],
        hidden: [ 8, 28 ],
        strikethrough: [ 9, 29 ]
    },
    color: {
        black: [ 30, 39 ],
        red: [ 31, 39 ],
        green: [ 32, 39 ],
        yellow: [ 33, 39 ],
        blue: [ 34, 39 ],
        magenta: [ 35, 39 ],
        cyan: [ 36, 39 ],
        white: [ 37, 39 ],
        blackBright: [ 90, 39 ],
        gray: [ 90, 39 ],
        grey: [ 90, 39 ],
        redBright: [ 91, 39 ],
        greenBright: [ 92, 39 ],
        yellowBright: [ 93, 39 ],
        blueBright: [ 94, 39 ],
        magentaBright: [ 95, 39 ],
        cyanBright: [ 96, 39 ],
        whiteBright: [ 97, 39 ]
    },
    bgColor: {
        bgBlack: [ 40, 49 ],
        bgRed: [ 41, 49 ],
        bgGreen: [ 42, 49 ],
        bgYellow: [ 43, 49 ],
        bgBlue: [ 44, 49 ],
        bgMagenta: [ 45, 49 ],
        bgCyan: [ 46, 49 ],
        bgWhite: [ 47, 49 ],
        bgBlackBright: [ 100, 49 ],
        bgGray: [ 100, 49 ],
        bgGrey: [ 100, 49 ],
        bgRedBright: [ 101, 49 ],
        bgGreenBright: [ 102, 49 ],
        bgYellowBright: [ 103, 49 ],
        bgBlueBright: [ 104, 49 ],
        bgMagentaBright: [ 105, 49 ],
        bgCyanBright: [ 106, 49 ],
        bgWhiteBright: [ 107, 49 ]
    }
};

Object.keys(styles$1.modifier);

const foregroundColorNames = Object.keys(styles$1.color), backgroundColorNames = Object.keys(styles$1.bgColor);

function assembleStyles() {
    const codes = new Map;
    for (const [groupName, group] of Object.entries(styles$1)) {
        for (const [styleName, style] of Object.entries(group)) styles$1[styleName] = {
            open: `[${style[0]}m`,
            close: `[${style[1]}m`
        }, group[styleName] = styles$1[styleName], codes.set(style[0], style[1]);
        Object.defineProperty(styles$1, groupName, {
            value: group,
            enumerable: !1
        });
    }
    return Object.defineProperty(styles$1, "codes", {
        value: codes,
        enumerable: !1
    }), styles$1.color.close = "[39m", styles$1.bgColor.close = "[49m", styles$1.color.ansi = wrapAnsi16(), 
    styles$1.color.ansi256 = wrapAnsi256(), styles$1.color.ansi16m = wrapAnsi16m(), 
    styles$1.bgColor.ansi = wrapAnsi16(ANSI_BACKGROUND_OFFSET), styles$1.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET), 
    styles$1.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET), Object.defineProperties(styles$1, {
        rgbToAnsi256: {
            value: (red, green, blue) => red === green && green === blue ? red < 8 ? 16 : red > 248 ? 231 : Math.round((red - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(red / 255 * 5) + 6 * Math.round(green / 255 * 5) + Math.round(blue / 255 * 5),
            enumerable: !1
        },
        hexToRgb: {
            value(hex) {
                const matches = /[a-f\d]{6}|[a-f\d]{3}/i.exec(hex.toString(16));
                if (!matches) return [ 0, 0, 0 ];
                let [colorString] = matches;
                3 === colorString.length && (colorString = [ ...colorString ].map((character => character + character)).join(""));
                const integer = Number.parseInt(colorString, 16);
                return [ integer >> 16 & 255, integer >> 8 & 255, 255 & integer ];
            },
            enumerable: !1
        },
        hexToAnsi256: {
            value: hex => styles$1.rgbToAnsi256(...styles$1.hexToRgb(hex)),
            enumerable: !1
        },
        ansi256ToAnsi: {
            value(code) {
                if (code < 8) return 30 + code;
                if (code < 16) return code - 8 + 90;
                let red, green, blue;
                if (code >= 232) red = (10 * (code - 232) + 8) / 255, green = red, blue = red; else {
                    const remainder = (code -= 16) % 36;
                    red = Math.floor(code / 36) / 5, green = Math.floor(remainder / 6) / 5, blue = remainder % 6 / 5;
                }
                const value = 2 * Math.max(red, green, blue);
                if (0 === value) return 30;
                let result = 30 + (Math.round(blue) << 2 | Math.round(green) << 1 | Math.round(red));
                return 2 === value && (result += 60), result;
            },
            enumerable: !1
        },
        rgbToAnsi: {
            value: (red, green, blue) => styles$1.ansi256ToAnsi(styles$1.rgbToAnsi256(red, green, blue)),
            enumerable: !1
        },
        hexToAnsi: {
            value: hex => styles$1.ansi256ToAnsi(styles$1.hexToAnsi256(hex)),
            enumerable: !1
        }
    }), styles$1;
}

const ansiStyles$1 = assembleStyles();

function hasFlag(flag, argv = (globalThis.Deno ? globalThis.Deno.args : process$2.argv)) {
    const prefix = flag.startsWith("-") ? "" : 1 === flag.length ? "-" : "--", position = argv.indexOf(prefix + flag), terminatorPosition = argv.indexOf("--");
    return -1 !== position && (-1 === terminatorPosition || position < terminatorPosition);
}

const {env: env} = process$2;

let flagForceColor;

function envForceColor() {
    if ("FORCE_COLOR" in env) return "true" === env.FORCE_COLOR ? 1 : "false" === env.FORCE_COLOR ? 0 : 0 === env.FORCE_COLOR.length ? 1 : Math.min(Number.parseInt(env.FORCE_COLOR, 10), 3);
}

function translateLevel(level) {
    return 0 !== level && {
        level: level,
        hasBasic: !0,
        has256: level >= 2,
        has16m: level >= 3
    };
}

function _supportsColor(haveStream, {streamIsTTY: streamIsTTY, sniffFlags: sniffFlags = !0} = {}) {
    const noFlagForceColor = envForceColor();
    void 0 !== noFlagForceColor && (flagForceColor = noFlagForceColor);
    const forceColor = sniffFlags ? flagForceColor : noFlagForceColor;
    if (0 === forceColor) return 0;
    if (sniffFlags) {
        if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) return 3;
        if (hasFlag("color=256")) return 2;
    }
    if ("TF_BUILD" in env && "AGENT_NAME" in env) return 1;
    if (haveStream && !streamIsTTY && void 0 === forceColor) return 0;
    const min = forceColor || 0;
    if ("dumb" === env.TERM) return min;
    if ("win32" === process$2.platform) {
        const osRelease = os.release().split(".");
        return Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586 ? Number(osRelease[2]) >= 14931 ? 3 : 2 : 1;
    }
    if ("CI" in env) return "GITHUB_ACTIONS" in env || "GITEA_ACTIONS" in env ? 3 : [ "TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "BUILDKITE", "DRONE" ].some((sign => sign in env)) || "codeship" === env.CI_NAME ? 1 : min;
    if ("TEAMCITY_VERSION" in env) return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
    if ("truecolor" === env.COLORTERM) return 3;
    if ("xterm-kitty" === env.TERM) return 3;
    if ("TERM_PROGRAM" in env) {
        const version = Number.parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version >= 3 ? 3 : 2;

          case "Apple_Terminal":
            return 2;
        }
    }
    return /-256(color)?$/i.test(env.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM) || "COLORTERM" in env ? 1 : min;
}

function createSupportsColor(stream, options = {}) {
    return translateLevel(_supportsColor(stream, {
        streamIsTTY: stream && stream.isTTY,
        ...options
    }));
}

hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never") ? flagForceColor = 0 : (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) && (flagForceColor = 1);

const supportsColor = {
    stdout: createSupportsColor({
        isTTY: tty.isatty(1)
    }),
    stderr: createSupportsColor({
        isTTY: tty.isatty(2)
    })
};

function stringReplaceAll(string, substring, replacer) {
    let index = string.indexOf(substring);
    if (-1 === index) return string;
    const substringLength = substring.length;
    let endIndex = 0, returnValue = "";
    do {
        returnValue += string.slice(endIndex, index) + substring + replacer, endIndex = index + substringLength, 
        index = string.indexOf(substring, endIndex);
    } while (-1 !== index);
    return returnValue += string.slice(endIndex), returnValue;
}

function stringEncaseCRLFWithFirstIndex(string, prefix, postfix, index) {
    let endIndex = 0, returnValue = "";
    do {
        const gotCR = "\r" === string[index - 1];
        returnValue += string.slice(endIndex, gotCR ? index - 1 : index) + prefix + (gotCR ? "\r\n" : "\n") + postfix, 
        endIndex = index + 1, index = string.indexOf("\n", endIndex);
    } while (-1 !== index);
    return returnValue += string.slice(endIndex), returnValue;
}

const {stdout: stdoutColor, stderr: stderrColor} = supportsColor, GENERATOR = Symbol("GENERATOR"), STYLER = Symbol("STYLER"), IS_EMPTY = Symbol("IS_EMPTY"), levelMapping = [ "ansi", "ansi", "ansi256", "ansi16m" ], styles = Object.create(null), applyOptions = (object, options = {}) => {
    if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) throw new Error("The `level` option should be an integer from 0 to 3");
    const colorLevel = stdoutColor ? stdoutColor.level : 0;
    object.level = void 0 === options.level ? colorLevel : options.level;
}, chalkFactory = options => {
    const chalk = (...strings) => strings.join(" ");
    return applyOptions(chalk, options), Object.setPrototypeOf(chalk, createChalk.prototype), 
    chalk;
};

function createChalk(options) {
    return chalkFactory(options);
}

Object.setPrototypeOf(createChalk.prototype, Function.prototype);

for (const [styleName, style] of Object.entries(ansiStyles$1)) styles[styleName] = {
    get() {
        const builder = createBuilder(this, createStyler(style.open, style.close, this[STYLER]), this[IS_EMPTY]);
        return Object.defineProperty(this, styleName, {
            value: builder
        }), builder;
    }
};

styles.visible = {
    get() {
        const builder = createBuilder(this, this[STYLER], !0);
        return Object.defineProperty(this, "visible", {
            value: builder
        }), builder;
    }
};

const getModelAnsi = (model, level, type, ...arguments_) => "rgb" === model ? "ansi16m" === level ? ansiStyles$1[type].ansi16m(...arguments_) : "ansi256" === level ? ansiStyles$1[type].ansi256(ansiStyles$1.rgbToAnsi256(...arguments_)) : ansiStyles$1[type].ansi(ansiStyles$1.rgbToAnsi(...arguments_)) : "hex" === model ? getModelAnsi("rgb", level, type, ...ansiStyles$1.hexToRgb(...arguments_)) : ansiStyles$1[type][model](...arguments_), usedModels = [ "rgb", "hex", "ansi256" ];

for (const model of usedModels) {
    styles[model] = {
        get() {
            const {level: level} = this;
            return function(...arguments_) {
                const styler = createStyler(getModelAnsi(model, levelMapping[level], "color", ...arguments_), ansiStyles$1.color.close, this[STYLER]);
                return createBuilder(this, styler, this[IS_EMPTY]);
            };
        }
    };
    const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
    styles[bgModel] = {
        get() {
            const {level: level} = this;
            return function(...arguments_) {
                const styler = createStyler(getModelAnsi(model, levelMapping[level], "bgColor", ...arguments_), ansiStyles$1.bgColor.close, this[STYLER]);
                return createBuilder(this, styler, this[IS_EMPTY]);
            };
        }
    };
}

const proto = Object.defineProperties((() => {}), {
    ...styles,
    level: {
        enumerable: !0,
        get() {
            return this[GENERATOR].level;
        },
        set(level) {
            this[GENERATOR].level = level;
        }
    }
}), createStyler = (open, close, parent) => {
    let openAll, closeAll;
    return void 0 === parent ? (openAll = open, closeAll = close) : (openAll = parent.openAll + open, 
    closeAll = close + parent.closeAll), {
        open: open,
        close: close,
        openAll: openAll,
        closeAll: closeAll,
        parent: parent
    };
}, createBuilder = (self, _styler, _isEmpty) => {
    const builder = (...arguments_) => applyStyle(builder, 1 === arguments_.length ? "" + arguments_[0] : arguments_.join(" "));
    return Object.setPrototypeOf(builder, proto), builder[GENERATOR] = self, builder[STYLER] = _styler, 
    builder[IS_EMPTY] = _isEmpty, builder;
}, applyStyle = (self, string) => {
    if (self.level <= 0 || !string) return self[IS_EMPTY] ? "" : string;
    let styler = self[STYLER];
    if (void 0 === styler) return string;
    const {openAll: openAll, closeAll: closeAll} = styler;
    if (string.includes("")) for (;void 0 !== styler; ) string = stringReplaceAll(string, styler.close, styler.open), 
    styler = styler.parent;
    const lfIndex = string.indexOf("\n");
    return -1 !== lfIndex && (string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex)), 
    openAll + string + closeAll;
};

Object.defineProperties(createChalk.prototype, styles);

const chalk = createChalk();

createChalk({
    level: stderrColor ? stderrColor.level : 0
});

const copyProperty = (to, from, property, ignoreNonConfigurable) => {
    if ("length" === property || "prototype" === property) return;
    if ("arguments" === property || "caller" === property) return;
    const toDescriptor = Object.getOwnPropertyDescriptor(to, property), fromDescriptor = Object.getOwnPropertyDescriptor(from, property);
    !canCopyProperty(toDescriptor, fromDescriptor) && ignoreNonConfigurable || Object.defineProperty(to, property, fromDescriptor);
}, canCopyProperty = function(toDescriptor, fromDescriptor) {
    return void 0 === toDescriptor || toDescriptor.configurable || toDescriptor.writable === fromDescriptor.writable && toDescriptor.enumerable === fromDescriptor.enumerable && toDescriptor.configurable === fromDescriptor.configurable && (toDescriptor.writable || toDescriptor.value === fromDescriptor.value);
}, changePrototype = (to, from) => {
    const fromPrototype = Object.getPrototypeOf(from);
    fromPrototype !== Object.getPrototypeOf(to) && Object.setPrototypeOf(to, fromPrototype);
}, wrappedToString = (withName, fromBody) => `/* Wrapped ${withName}*/\n${fromBody}`, toStringDescriptor = Object.getOwnPropertyDescriptor(Function.prototype, "toString"), toStringName = Object.getOwnPropertyDescriptor(Function.prototype.toString, "name"), changeToString = (to, from, name) => {
    const withName = "" === name ? "" : `with ${name.trim()}() `, newToString = wrappedToString.bind(null, withName, from.toString());
    Object.defineProperty(newToString, "name", toStringName);
    const {writable: writable, enumerable: enumerable, configurable: configurable} = toStringDescriptor;
    Object.defineProperty(to, "toString", {
        value: newToString,
        writable: writable,
        enumerable: enumerable,
        configurable: configurable
    });
};

function mimicFunction(to, from, {ignoreNonConfigurable: ignoreNonConfigurable = !1} = {}) {
    const {name: name} = to;
    for (const property of Reflect.ownKeys(from)) copyProperty(to, from, property, ignoreNonConfigurable);
    return changePrototype(to, from), changeToString(to, from, name), to;
}

const calledFunctions = new WeakMap, onetime = (function_, options = {}) => {
    if ("function" != typeof function_) throw new TypeError("Expected a function");
    let returnValue, callCount = 0;
    const functionName = function_.displayName || function_.name || "<anonymous>", onetime = function(...arguments_) {
        if (calledFunctions.set(onetime, ++callCount), 1 === callCount) returnValue = function_.apply(this, arguments_), 
        function_ = void 0; else if (!0 === options.throw) throw new Error(`Function \`${functionName}\` can only be called once`);
        return returnValue;
    };
    return mimicFunction(onetime, function_), calledFunctions.set(onetime, callCount), 
    onetime;
};

onetime.callCount = function_ => {
    if (!calledFunctions.has(function_)) throw new Error(`The given function \`${function_.name}\` is not wrapped by the \`onetime\` package`);
    return calledFunctions.get(function_);
};

const signals = [];

signals.push("SIGHUP", "SIGINT", "SIGTERM"), "win32" !== process.platform && signals.push("SIGALRM", "SIGABRT", "SIGVTALRM", "SIGXCPU", "SIGXFSZ", "SIGUSR2", "SIGTRAP", "SIGSYS", "SIGQUIT", "SIGIOT"), 
"linux" === process.platform && signals.push("SIGIO", "SIGPOLL", "SIGPWR", "SIGSTKFLT");

const processOk = process => !!process && "object" == typeof process && "function" == typeof process.removeListener && "function" == typeof process.emit && "function" == typeof process.reallyExit && "function" == typeof process.listeners && "function" == typeof process.kill && "number" == typeof process.pid && "function" == typeof process.on, kExitEmitter = Symbol.for("signal-exit emitter"), global$1 = globalThis, ObjectDefineProperty = Object.defineProperty.bind(Object);

class Emitter {
    emitted={
        afterExit: !1,
        exit: !1
    };
    listeners={
        afterExit: [],
        exit: []
    };
    count=0;
    id=Math.random();
    constructor() {
        if (global$1[kExitEmitter]) return global$1[kExitEmitter];
        ObjectDefineProperty(global$1, kExitEmitter, {
            value: this,
            writable: !1,
            enumerable: !1,
            configurable: !1
        });
    }
    on(ev, fn) {
        this.listeners[ev].push(fn);
    }
    removeListener(ev, fn) {
        const list = this.listeners[ev], i = list.indexOf(fn);
        -1 !== i && (0 === i && 1 === list.length ? list.length = 0 : list.splice(i, 1));
    }
    emit(ev, code, signal) {
        if (this.emitted[ev]) return !1;
        this.emitted[ev] = !0;
        let ret = !1;
        for (const fn of this.listeners[ev]) ret = !0 === fn(code, signal) || ret;
        return "exit" === ev && (ret = this.emit("afterExit", code, signal) || ret), ret;
    }
}

class SignalExitBase {}

const signalExitWrap = handler => ({
    onExit: (cb, opts) => handler.onExit(cb, opts),
    load: () => handler.load(),
    unload: () => handler.unload()
});

class SignalExitFallback extends SignalExitBase {
    onExit() {
        return () => {};
    }
    load() {}
    unload() {}
}

class SignalExit extends SignalExitBase {
    #hupSig="win32" === process$1.platform ? "SIGINT" : "SIGHUP";
    #emitter=new Emitter;
    #process;
    #originalProcessEmit;
    #originalProcessReallyExit;
    #sigListeners={};
    #loaded=!1;
    constructor(process) {
        super(), this.#process = process, this.#sigListeners = {};
        for (const sig of signals) this.#sigListeners[sig] = () => {
            const listeners = this.#process.listeners(sig);
            let {count: count} = this.#emitter;
            const p = process;
            if ("object" == typeof p.__signal_exit_emitter__ && "number" == typeof p.__signal_exit_emitter__.count && (count += p.__signal_exit_emitter__.count), 
            listeners.length === count) {
                this.unload();
                const ret = this.#emitter.emit("exit", null, sig), s = "SIGHUP" === sig ? this.#hupSig : sig;
                ret || process.kill(process.pid, s);
            }
        };
        this.#originalProcessReallyExit = process.reallyExit, this.#originalProcessEmit = process.emit;
    }
    onExit(cb, opts) {
        if (!processOk(this.#process)) return () => {};
        !1 === this.#loaded && this.load();
        const ev = opts?.alwaysLast ? "afterExit" : "exit";
        return this.#emitter.on(ev, cb), () => {
            this.#emitter.removeListener(ev, cb), 0 === this.#emitter.listeners.exit.length && 0 === this.#emitter.listeners.afterExit.length && this.unload();
        };
    }
    load() {
        if (!this.#loaded) {
            this.#loaded = !0, this.#emitter.count += 1;
            for (const sig of signals) try {
                const fn = this.#sigListeners[sig];
                fn && this.#process.on(sig, fn);
            } catch (_) {}
            this.#process.emit = (ev, ...a) => this.#processEmit(ev, ...a), this.#process.reallyExit = code => this.#processReallyExit(code);
        }
    }
    unload() {
        this.#loaded && (this.#loaded = !1, signals.forEach((sig => {
            const listener = this.#sigListeners[sig];
            if (!listener) throw new Error("Listener not defined for signal: " + sig);
            try {
                this.#process.removeListener(sig, listener);
            } catch (_) {}
        })), this.#process.emit = this.#originalProcessEmit, this.#process.reallyExit = this.#originalProcessReallyExit, 
        this.#emitter.count -= 1);
    }
    #processReallyExit(code) {
        return processOk(this.#process) ? (this.#process.exitCode = code || 0, this.#emitter.emit("exit", this.#process.exitCode, null), 
        this.#originalProcessReallyExit.call(this.#process, this.#process.exitCode)) : 0;
    }
    #processEmit(ev, ...args) {
        const og = this.#originalProcessEmit;
        if ("exit" === ev && processOk(this.#process)) {
            "number" == typeof args[0] && (this.#process.exitCode = args[0]);
            const ret = og.call(this.#process, ev, ...args);
            return this.#emitter.emit("exit", this.#process.exitCode, null), ret;
        }
        return og.call(this.#process, ev, ...args);
    }
}

const process$1 = globalThis.process, {onExit: onExit, load: load, unload: unload} = signalExitWrap(processOk(process$1) ? new SignalExit(process$1) : new SignalExitFallback), terminal = process$2.stderr.isTTY ? process$2.stderr : process$2.stdout.isTTY ? process$2.stdout : void 0, restoreCursor = terminal ? onetime((() => {
    onExit((() => {
        terminal.write("[?25h");
    }), {
        alwaysLast: !0
    });
})) : () => {};

let isHidden = !1;

const cliCursor = {
    show: (writableStream = process$2.stderr) => {
        writableStream.isTTY && (isHidden = !1, writableStream.write("[?25h"));
    },
    hide: (writableStream = process$2.stderr) => {
        writableStream.isTTY && (restoreCursor(), isHidden = !0, writableStream.write("[?25l"));
    },
    toggle: (force, writableStream) => {
        void 0 !== force && (isHidden = force), isHidden ? cliCursor.show(writableStream) : cliCursor.hide(writableStream);
    }
};

var dots = {
    interval: 80,
    frames: [ "⠋", "⠙", "⠹", "⠸", "⠼", "⠴", "⠦", "⠧", "⠇", "⠏" ]
}, dots2 = {
    interval: 80,
    frames: [ "⣾", "⣽", "⣻", "⢿", "⡿", "⣟", "⣯", "⣷" ]
}, dots3 = {
    interval: 80,
    frames: [ "⠋", "⠙", "⠚", "⠞", "⠖", "⠦", "⠴", "⠲", "⠳", "⠓" ]
}, dots4 = {
    interval: 80,
    frames: [ "⠄", "⠆", "⠇", "⠋", "⠙", "⠸", "⠰", "⠠", "⠰", "⠸", "⠙", "⠋", "⠇", "⠆" ]
}, dots5 = {
    interval: 80,
    frames: [ "⠋", "⠙", "⠚", "⠒", "⠂", "⠂", "⠒", "⠲", "⠴", "⠦", "⠖", "⠒", "⠐", "⠐", "⠒", "⠓", "⠋" ]
}, dots6 = {
    interval: 80,
    frames: [ "⠁", "⠉", "⠙", "⠚", "⠒", "⠂", "⠂", "⠒", "⠲", "⠴", "⠤", "⠄", "⠄", "⠤", "⠴", "⠲", "⠒", "⠂", "⠂", "⠒", "⠚", "⠙", "⠉", "⠁" ]
}, dots7 = {
    interval: 80,
    frames: [ "⠈", "⠉", "⠋", "⠓", "⠒", "⠐", "⠐", "⠒", "⠖", "⠦", "⠤", "⠠", "⠠", "⠤", "⠦", "⠖", "⠒", "⠐", "⠐", "⠒", "⠓", "⠋", "⠉", "⠈" ]
}, dots8 = {
    interval: 80,
    frames: [ "⠁", "⠁", "⠉", "⠙", "⠚", "⠒", "⠂", "⠂", "⠒", "⠲", "⠴", "⠤", "⠄", "⠄", "⠤", "⠠", "⠠", "⠤", "⠦", "⠖", "⠒", "⠐", "⠐", "⠒", "⠓", "⠋", "⠉", "⠈", "⠈" ]
}, dots9 = {
    interval: 80,
    frames: [ "⢹", "⢺", "⢼", "⣸", "⣇", "⡧", "⡗", "⡏" ]
}, dots10 = {
    interval: 80,
    frames: [ "⢄", "⢂", "⢁", "⡁", "⡈", "⡐", "⡠" ]
}, dots11 = {
    interval: 100,
    frames: [ "⠁", "⠂", "⠄", "⡀", "⢀", "⠠", "⠐", "⠈" ]
}, dots12 = {
    interval: 80,
    frames: [ "⢀⠀", "⡀⠀", "⠄⠀", "⢂⠀", "⡂⠀", "⠅⠀", "⢃⠀", "⡃⠀", "⠍⠀", "⢋⠀", "⡋⠀", "⠍⠁", "⢋⠁", "⡋⠁", "⠍⠉", "⠋⠉", "⠋⠉", "⠉⠙", "⠉⠙", "⠉⠩", "⠈⢙", "⠈⡙", "⢈⠩", "⡀⢙", "⠄⡙", "⢂⠩", "⡂⢘", "⠅⡘", "⢃⠨", "⡃⢐", "⠍⡐", "⢋⠠", "⡋⢀", "⠍⡁", "⢋⠁", "⡋⠁", "⠍⠉", "⠋⠉", "⠋⠉", "⠉⠙", "⠉⠙", "⠉⠩", "⠈⢙", "⠈⡙", "⠈⠩", "⠀⢙", "⠀⡙", "⠀⠩", "⠀⢘", "⠀⡘", "⠀⠨", "⠀⢐", "⠀⡐", "⠀⠠", "⠀⢀", "⠀⡀" ]
}, dots13 = {
    interval: 80,
    frames: [ "⣼", "⣹", "⢻", "⠿", "⡟", "⣏", "⣧", "⣶" ]
}, dots8Bit = {
    interval: 80,
    frames: [ "⠀", "⠁", "⠂", "⠃", "⠄", "⠅", "⠆", "⠇", "⡀", "⡁", "⡂", "⡃", "⡄", "⡅", "⡆", "⡇", "⠈", "⠉", "⠊", "⠋", "⠌", "⠍", "⠎", "⠏", "⡈", "⡉", "⡊", "⡋", "⡌", "⡍", "⡎", "⡏", "⠐", "⠑", "⠒", "⠓", "⠔", "⠕", "⠖", "⠗", "⡐", "⡑", "⡒", "⡓", "⡔", "⡕", "⡖", "⡗", "⠘", "⠙", "⠚", "⠛", "⠜", "⠝", "⠞", "⠟", "⡘", "⡙", "⡚", "⡛", "⡜", "⡝", "⡞", "⡟", "⠠", "⠡", "⠢", "⠣", "⠤", "⠥", "⠦", "⠧", "⡠", "⡡", "⡢", "⡣", "⡤", "⡥", "⡦", "⡧", "⠨", "⠩", "⠪", "⠫", "⠬", "⠭", "⠮", "⠯", "⡨", "⡩", "⡪", "⡫", "⡬", "⡭", "⡮", "⡯", "⠰", "⠱", "⠲", "⠳", "⠴", "⠵", "⠶", "⠷", "⡰", "⡱", "⡲", "⡳", "⡴", "⡵", "⡶", "⡷", "⠸", "⠹", "⠺", "⠻", "⠼", "⠽", "⠾", "⠿", "⡸", "⡹", "⡺", "⡻", "⡼", "⡽", "⡾", "⡿", "⢀", "⢁", "⢂", "⢃", "⢄", "⢅", "⢆", "⢇", "⣀", "⣁", "⣂", "⣃", "⣄", "⣅", "⣆", "⣇", "⢈", "⢉", "⢊", "⢋", "⢌", "⢍", "⢎", "⢏", "⣈", "⣉", "⣊", "⣋", "⣌", "⣍", "⣎", "⣏", "⢐", "⢑", "⢒", "⢓", "⢔", "⢕", "⢖", "⢗", "⣐", "⣑", "⣒", "⣓", "⣔", "⣕", "⣖", "⣗", "⢘", "⢙", "⢚", "⢛", "⢜", "⢝", "⢞", "⢟", "⣘", "⣙", "⣚", "⣛", "⣜", "⣝", "⣞", "⣟", "⢠", "⢡", "⢢", "⢣", "⢤", "⢥", "⢦", "⢧", "⣠", "⣡", "⣢", "⣣", "⣤", "⣥", "⣦", "⣧", "⢨", "⢩", "⢪", "⢫", "⢬", "⢭", "⢮", "⢯", "⣨", "⣩", "⣪", "⣫", "⣬", "⣭", "⣮", "⣯", "⢰", "⢱", "⢲", "⢳", "⢴", "⢵", "⢶", "⢷", "⣰", "⣱", "⣲", "⣳", "⣴", "⣵", "⣶", "⣷", "⢸", "⢹", "⢺", "⢻", "⢼", "⢽", "⢾", "⢿", "⣸", "⣹", "⣺", "⣻", "⣼", "⣽", "⣾", "⣿" ]
}, sand = {
    interval: 80,
    frames: [ "⠁", "⠂", "⠄", "⡀", "⡈", "⡐", "⡠", "⣀", "⣁", "⣂", "⣄", "⣌", "⣔", "⣤", "⣥", "⣦", "⣮", "⣶", "⣷", "⣿", "⡿", "⠿", "⢟", "⠟", "⡛", "⠛", "⠫", "⢋", "⠋", "⠍", "⡉", "⠉", "⠑", "⠡", "⢁" ]
}, line = {
    interval: 130,
    frames: [ "-", "\\", "|", "/" ]
}, line2 = {
    interval: 100,
    frames: [ "⠂", "-", "–", "—", "–", "-" ]
}, pipe = {
    interval: 100,
    frames: [ "┤", "┘", "┴", "└", "├", "┌", "┬", "┐" ]
}, simpleDots = {
    interval: 400,
    frames: [ ".  ", ".. ", "...", "   " ]
}, simpleDotsScrolling = {
    interval: 200,
    frames: [ ".  ", ".. ", "...", " ..", "  .", "   " ]
}, star = {
    interval: 70,
    frames: [ "✶", "✸", "✹", "✺", "✹", "✷" ]
}, star2 = {
    interval: 80,
    frames: [ "+", "x", "*" ]
}, flip = {
    interval: 70,
    frames: [ "_", "_", "_", "-", "`", "`", "'", "´", "-", "_", "_", "_" ]
}, hamburger = {
    interval: 100,
    frames: [ "☱", "☲", "☴" ]
}, growVertical = {
    interval: 120,
    frames: [ "▁", "▃", "▄", "▅", "▆", "▇", "▆", "▅", "▄", "▃" ]
}, growHorizontal = {
    interval: 120,
    frames: [ "▏", "▎", "▍", "▌", "▋", "▊", "▉", "▊", "▋", "▌", "▍", "▎" ]
}, balloon = {
    interval: 140,
    frames: [ " ", ".", "o", "O", "@", "*", " " ]
}, balloon2 = {
    interval: 120,
    frames: [ ".", "o", "O", "°", "O", "o", "." ]
}, noise = {
    interval: 100,
    frames: [ "▓", "▒", "░" ]
}, bounce = {
    interval: 120,
    frames: [ "⠁", "⠂", "⠄", "⠂" ]
}, boxBounce = {
    interval: 120,
    frames: [ "▖", "▘", "▝", "▗" ]
}, boxBounce2 = {
    interval: 100,
    frames: [ "▌", "▀", "▐", "▄" ]
}, triangle = {
    interval: 50,
    frames: [ "◢", "◣", "◤", "◥" ]
}, binary = {
    interval: 80,
    frames: [ "010010", "001100", "100101", "111010", "111101", "010111", "101011", "111000", "110011", "110101" ]
}, arc = {
    interval: 100,
    frames: [ "◜", "◠", "◝", "◞", "◡", "◟" ]
}, circle = {
    interval: 120,
    frames: [ "◡", "⊙", "◠" ]
}, squareCorners = {
    interval: 180,
    frames: [ "◰", "◳", "◲", "◱" ]
}, circleQuarters = {
    interval: 120,
    frames: [ "◴", "◷", "◶", "◵" ]
}, circleHalves = {
    interval: 50,
    frames: [ "◐", "◓", "◑", "◒" ]
}, squish = {
    interval: 100,
    frames: [ "╫", "╪" ]
}, toggle = {
    interval: 250,
    frames: [ "⊶", "⊷" ]
}, toggle2 = {
    interval: 80,
    frames: [ "▫", "▪" ]
}, toggle3 = {
    interval: 120,
    frames: [ "□", "■" ]
}, toggle4 = {
    interval: 100,
    frames: [ "■", "□", "▪", "▫" ]
}, toggle5 = {
    interval: 100,
    frames: [ "▮", "▯" ]
}, toggle6 = {
    interval: 300,
    frames: [ "ဝ", "၀" ]
}, toggle7 = {
    interval: 80,
    frames: [ "⦾", "⦿" ]
}, toggle8 = {
    interval: 100,
    frames: [ "◍", "◌" ]
}, toggle9 = {
    interval: 100,
    frames: [ "◉", "◎" ]
}, toggle10 = {
    interval: 100,
    frames: [ "㊂", "㊀", "㊁" ]
}, toggle11 = {
    interval: 50,
    frames: [ "⧇", "⧆" ]
}, toggle12 = {
    interval: 120,
    frames: [ "☗", "☖" ]
}, toggle13 = {
    interval: 80,
    frames: [ "=", "*", "-" ]
}, arrow = {
    interval: 100,
    frames: [ "←", "↖", "↑", "↗", "→", "↘", "↓", "↙" ]
}, arrow2 = {
    interval: 80,
    frames: [ "⬆️ ", "↗️ ", "➡️ ", "↘️ ", "⬇️ ", "↙️ ", "⬅️ ", "↖️ " ]
}, arrow3 = {
    interval: 120,
    frames: [ "▹▹▹▹▹", "▸▹▹▹▹", "▹▸▹▹▹", "▹▹▸▹▹", "▹▹▹▸▹", "▹▹▹▹▸" ]
}, bouncingBar = {
    interval: 80,
    frames: [ "[    ]", "[=   ]", "[==  ]", "[=== ]", "[====]", "[ ===]", "[  ==]", "[   =]", "[    ]", "[   =]", "[  ==]", "[ ===]", "[====]", "[=== ]", "[==  ]", "[=   ]" ]
}, bouncingBall = {
    interval: 80,
    frames: [ "( ●    )", "(  ●   )", "(   ●  )", "(    ● )", "(     ●)", "(    ● )", "(   ●  )", "(  ●   )", "( ●    )", "(●     )" ]
}, smiley = {
    interval: 200,
    frames: [ "😄 ", "😝 " ]
}, monkey = {
    interval: 300,
    frames: [ "🙈 ", "🙈 ", "🙉 ", "🙊 " ]
}, hearts = {
    interval: 100,
    frames: [ "💛 ", "💙 ", "💜 ", "💚 ", "❤️ " ]
}, clock = {
    interval: 100,
    frames: [ "🕛 ", "🕐 ", "🕑 ", "🕒 ", "🕓 ", "🕔 ", "🕕 ", "🕖 ", "🕗 ", "🕘 ", "🕙 ", "🕚 " ]
}, earth = {
    interval: 180,
    frames: [ "🌍 ", "🌎 ", "🌏 " ]
}, material = {
    interval: 17,
    frames: [ "█▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁", "██▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁", "███▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁", "████▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁", "██████▁▁▁▁▁▁▁▁▁▁▁▁▁▁", "██████▁▁▁▁▁▁▁▁▁▁▁▁▁▁", "███████▁▁▁▁▁▁▁▁▁▁▁▁▁", "████████▁▁▁▁▁▁▁▁▁▁▁▁", "█████████▁▁▁▁▁▁▁▁▁▁▁", "█████████▁▁▁▁▁▁▁▁▁▁▁", "██████████▁▁▁▁▁▁▁▁▁▁", "███████████▁▁▁▁▁▁▁▁▁", "█████████████▁▁▁▁▁▁▁", "██████████████▁▁▁▁▁▁", "██████████████▁▁▁▁▁▁", "▁██████████████▁▁▁▁▁", "▁██████████████▁▁▁▁▁", "▁██████████████▁▁▁▁▁", "▁▁██████████████▁▁▁▁", "▁▁▁██████████████▁▁▁", "▁▁▁▁█████████████▁▁▁", "▁▁▁▁██████████████▁▁", "▁▁▁▁██████████████▁▁", "▁▁▁▁▁██████████████▁", "▁▁▁▁▁██████████████▁", "▁▁▁▁▁██████████████▁", "▁▁▁▁▁▁██████████████", "▁▁▁▁▁▁██████████████", "▁▁▁▁▁▁▁█████████████", "▁▁▁▁▁▁▁█████████████", "▁▁▁▁▁▁▁▁████████████", "▁▁▁▁▁▁▁▁████████████", "▁▁▁▁▁▁▁▁▁███████████", "▁▁▁▁▁▁▁▁▁███████████", "▁▁▁▁▁▁▁▁▁▁██████████", "▁▁▁▁▁▁▁▁▁▁██████████", "▁▁▁▁▁▁▁▁▁▁▁▁████████", "▁▁▁▁▁▁▁▁▁▁▁▁▁███████", "▁▁▁▁▁▁▁▁▁▁▁▁▁▁██████", "▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█████", "▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█████", "█▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁████", "██▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁███", "██▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁███", "███▁▁▁▁▁▁▁▁▁▁▁▁▁▁███", "████▁▁▁▁▁▁▁▁▁▁▁▁▁▁██", "█████▁▁▁▁▁▁▁▁▁▁▁▁▁▁█", "█████▁▁▁▁▁▁▁▁▁▁▁▁▁▁█", "██████▁▁▁▁▁▁▁▁▁▁▁▁▁█", "████████▁▁▁▁▁▁▁▁▁▁▁▁", "█████████▁▁▁▁▁▁▁▁▁▁▁", "█████████▁▁▁▁▁▁▁▁▁▁▁", "█████████▁▁▁▁▁▁▁▁▁▁▁", "█████████▁▁▁▁▁▁▁▁▁▁▁", "███████████▁▁▁▁▁▁▁▁▁", "████████████▁▁▁▁▁▁▁▁", "████████████▁▁▁▁▁▁▁▁", "██████████████▁▁▁▁▁▁", "██████████████▁▁▁▁▁▁", "▁██████████████▁▁▁▁▁", "▁██████████████▁▁▁▁▁", "▁▁▁█████████████▁▁▁▁", "▁▁▁▁▁████████████▁▁▁", "▁▁▁▁▁████████████▁▁▁", "▁▁▁▁▁▁███████████▁▁▁", "▁▁▁▁▁▁▁▁█████████▁▁▁", "▁▁▁▁▁▁▁▁█████████▁▁▁", "▁▁▁▁▁▁▁▁▁█████████▁▁", "▁▁▁▁▁▁▁▁▁█████████▁▁", "▁▁▁▁▁▁▁▁▁▁█████████▁", "▁▁▁▁▁▁▁▁▁▁▁████████▁", "▁▁▁▁▁▁▁▁▁▁▁████████▁", "▁▁▁▁▁▁▁▁▁▁▁▁███████▁", "▁▁▁▁▁▁▁▁▁▁▁▁███████▁", "▁▁▁▁▁▁▁▁▁▁▁▁▁███████", "▁▁▁▁▁▁▁▁▁▁▁▁▁███████", "▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█████", "▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁████", "▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁████", "▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁████", "▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁███", "▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁███", "▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁██", "▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁██", "▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁██", "▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█", "▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█", "▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█", "▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁", "▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁", "▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁", "▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁" ]
}, moon = {
    interval: 80,
    frames: [ "🌑 ", "🌒 ", "🌓 ", "🌔 ", "🌕 ", "🌖 ", "🌗 ", "🌘 " ]
}, runner = {
    interval: 140,
    frames: [ "🚶 ", "🏃 " ]
}, pong = {
    interval: 80,
    frames: [ "▐⠂       ▌", "▐⠈       ▌", "▐ ⠂      ▌", "▐ ⠠      ▌", "▐  ⡀     ▌", "▐  ⠠     ▌", "▐   ⠂    ▌", "▐   ⠈    ▌", "▐    ⠂   ▌", "▐    ⠠   ▌", "▐     ⡀  ▌", "▐     ⠠  ▌", "▐      ⠂ ▌", "▐      ⠈ ▌", "▐       ⠂▌", "▐       ⠠▌", "▐       ⡀▌", "▐      ⠠ ▌", "▐      ⠂ ▌", "▐     ⠈  ▌", "▐     ⠂  ▌", "▐    ⠠   ▌", "▐    ⡀   ▌", "▐   ⠠    ▌", "▐   ⠂    ▌", "▐  ⠈     ▌", "▐  ⠂     ▌", "▐ ⠠      ▌", "▐ ⡀      ▌", "▐⠠       ▌" ]
}, shark = {
    interval: 120,
    frames: [ "▐|\\____________▌", "▐_|\\___________▌", "▐__|\\__________▌", "▐___|\\_________▌", "▐____|\\________▌", "▐_____|\\_______▌", "▐______|\\______▌", "▐_______|\\_____▌", "▐________|\\____▌", "▐_________|\\___▌", "▐__________|\\__▌", "▐___________|\\_▌", "▐____________|\\▌", "▐____________/|▌", "▐___________/|_▌", "▐__________/|__▌", "▐_________/|___▌", "▐________/|____▌", "▐_______/|_____▌", "▐______/|______▌", "▐_____/|_______▌", "▐____/|________▌", "▐___/|_________▌", "▐__/|__________▌", "▐_/|___________▌", "▐/|____________▌" ]
}, dqpb = {
    interval: 100,
    frames: [ "d", "q", "p", "b" ]
}, weather = {
    interval: 100,
    frames: [ "☀️ ", "☀️ ", "☀️ ", "🌤 ", "⛅️ ", "🌥 ", "☁️ ", "🌧 ", "🌨 ", "🌧 ", "🌨 ", "🌧 ", "🌨 ", "⛈ ", "🌨 ", "🌧 ", "🌨 ", "☁️ ", "🌥 ", "⛅️ ", "🌤 ", "☀️ ", "☀️ " ]
}, christmas = {
    interval: 400,
    frames: [ "🌲", "🎄" ]
}, grenade = {
    interval: 80,
    frames: [ "،  ", "′  ", " ´ ", " ‾ ", "  ⸌", "  ⸊", "  |", "  ⁎", "  ⁕", " ෴ ", "  ⁓", "   ", "   ", "   " ]
}, point = {
    interval: 125,
    frames: [ "∙∙∙", "●∙∙", "∙●∙", "∙∙●", "∙∙∙" ]
}, layer = {
    interval: 150,
    frames: [ "-", "=", "≡" ]
}, betaWave = {
    interval: 80,
    frames: [ "ρββββββ", "βρβββββ", "ββρββββ", "βββρβββ", "ββββρββ", "βββββρβ", "ββββββρ" ]
}, fingerDance = {
    interval: 160,
    frames: [ "🤘 ", "🤟 ", "🖖 ", "✋ ", "🤚 ", "👆 " ]
}, fistBump = {
    interval: 80,
    frames: [ "🤜　　　　🤛 ", "🤜　　　　🤛 ", "🤜　　　　🤛 ", "　🤜　　🤛　 ", "　　🤜🤛　　 ", "　🤜✨🤛　　 ", "🤜　✨　🤛　 " ]
}, soccerHeader = {
    interval: 80,
    frames: [ " 🧑⚽️       🧑 ", "🧑  ⚽️      🧑 ", "🧑   ⚽️     🧑 ", "🧑    ⚽️    🧑 ", "🧑     ⚽️   🧑 ", "🧑      ⚽️  🧑 ", "🧑       ⚽️🧑  ", "🧑      ⚽️  🧑 ", "🧑     ⚽️   🧑 ", "🧑    ⚽️    🧑 ", "🧑   ⚽️     🧑 ", "🧑  ⚽️      🧑 " ]
}, mindblown = {
    interval: 160,
    frames: [ "😐 ", "😐 ", "😮 ", "😮 ", "😦 ", "😦 ", "😧 ", "😧 ", "🤯 ", "💥 ", "✨ ", "　 ", "　 ", "　 " ]
}, speaker = {
    interval: 160,
    frames: [ "🔈 ", "🔉 ", "🔊 ", "🔉 " ]
}, orangePulse = {
    interval: 100,
    frames: [ "🔸 ", "🔶 ", "🟠 ", "🟠 ", "🔶 " ]
}, bluePulse = {
    interval: 100,
    frames: [ "🔹 ", "🔷 ", "🔵 ", "🔵 ", "🔷 " ]
}, orangeBluePulse = {
    interval: 100,
    frames: [ "🔸 ", "🔶 ", "🟠 ", "🟠 ", "🔶 ", "🔹 ", "🔷 ", "🔵 ", "🔵 ", "🔷 " ]
}, timeTravel = {
    interval: 100,
    frames: [ "🕛 ", "🕚 ", "🕙 ", "🕘 ", "🕗 ", "🕖 ", "🕕 ", "🕔 ", "🕓 ", "🕒 ", "🕑 ", "🕐 " ]
}, aesthetic = {
    interval: 80,
    frames: [ "▰▱▱▱▱▱▱", "▰▰▱▱▱▱▱", "▰▰▰▱▱▱▱", "▰▰▰▰▱▱▱", "▰▰▰▰▰▱▱", "▰▰▰▰▰▰▱", "▰▰▰▰▰▰▰", "▰▱▱▱▱▱▱" ]
}, dwarfFortress = {
    interval: 80,
    frames: [ " ██████£££  ", "☺██████£££  ", "☺██████£££  ", "☺▓█████£££  ", "☺▓█████£££  ", "☺▒█████£££  ", "☺▒█████£££  ", "☺░█████£££  ", "☺░█████£££  ", "☺ █████£££  ", " ☺█████£££  ", " ☺█████£££  ", " ☺▓████£££  ", " ☺▓████£££  ", " ☺▒████£££  ", " ☺▒████£££  ", " ☺░████£££  ", " ☺░████£££  ", " ☺ ████£££  ", "  ☺████£££  ", "  ☺████£££  ", "  ☺▓███£££  ", "  ☺▓███£££  ", "  ☺▒███£££  ", "  ☺▒███£££  ", "  ☺░███£££  ", "  ☺░███£££  ", "  ☺ ███£££  ", "   ☺███£££  ", "   ☺███£££  ", "   ☺▓██£££  ", "   ☺▓██£££  ", "   ☺▒██£££  ", "   ☺▒██£££  ", "   ☺░██£££  ", "   ☺░██£££  ", "   ☺ ██£££  ", "    ☺██£££  ", "    ☺██£££  ", "    ☺▓█£££  ", "    ☺▓█£££  ", "    ☺▒█£££  ", "    ☺▒█£££  ", "    ☺░█£££  ", "    ☺░█£££  ", "    ☺ █£££  ", "     ☺█£££  ", "     ☺█£££  ", "     ☺▓£££  ", "     ☺▓£££  ", "     ☺▒£££  ", "     ☺▒£££  ", "     ☺░£££  ", "     ☺░£££  ", "     ☺ £££  ", "      ☺£££  ", "      ☺£££  ", "      ☺▓££  ", "      ☺▓££  ", "      ☺▒££  ", "      ☺▒££  ", "      ☺░££  ", "      ☺░££  ", "      ☺ ££  ", "       ☺££  ", "       ☺££  ", "       ☺▓£  ", "       ☺▓£  ", "       ☺▒£  ", "       ☺▒£  ", "       ☺░£  ", "       ☺░£  ", "       ☺ £  ", "        ☺£  ", "        ☺£  ", "        ☺▓  ", "        ☺▓  ", "        ☺▒  ", "        ☺▒  ", "        ☺░  ", "        ☺░  ", "        ☺   ", "        ☺  &", "        ☺ ☼&", "       ☺ ☼ &", "       ☺☼  &", "      ☺☼  & ", "      ‼   & ", "     ☺   &  ", "    ‼    &  ", "   ☺    &   ", "  ‼     &   ", " ☺     &    ", "‼      &    ", "      &     ", "      &     ", "     &   ░  ", "     &   ▒  ", "    &    ▓  ", "    &    £  ", "   &    ░£  ", "   &    ▒£  ", "  &     ▓£  ", "  &     ££  ", " &     ░££  ", " &     ▒££  ", "&      ▓££  ", "&      £££  ", "      ░£££  ", "      ▒£££  ", "      ▓£££  ", "      █£££  ", "     ░█£££  ", "     ▒█£££  ", "     ▓█£££  ", "     ██£££  ", "    ░██£££  ", "    ▒██£££  ", "    ▓██£££  ", "    ███£££  ", "   ░███£££  ", "   ▒███£££  ", "   ▓███£££  ", "   ████£££  ", "  ░████£££  ", "  ▒████£££  ", "  ▓████£££  ", "  █████£££  ", " ░█████£££  ", " ▒█████£££  ", " ▓█████£££  ", " ██████£££  ", " ██████£££  " ]
}, require$$0$2 = {
    dots: dots,
    dots2: dots2,
    dots3: dots3,
    dots4: dots4,
    dots5: dots5,
    dots6: dots6,
    dots7: dots7,
    dots8: dots8,
    dots9: dots9,
    dots10: dots10,
    dots11: dots11,
    dots12: dots12,
    dots13: dots13,
    dots8Bit: dots8Bit,
    sand: sand,
    line: line,
    line2: line2,
    pipe: pipe,
    simpleDots: simpleDots,
    simpleDotsScrolling: simpleDotsScrolling,
    star: star,
    star2: star2,
    flip: flip,
    hamburger: hamburger,
    growVertical: growVertical,
    growHorizontal: growHorizontal,
    balloon: balloon,
    balloon2: balloon2,
    noise: noise,
    bounce: bounce,
    boxBounce: boxBounce,
    boxBounce2: boxBounce2,
    triangle: triangle,
    binary: binary,
    arc: arc,
    circle: circle,
    squareCorners: squareCorners,
    circleQuarters: circleQuarters,
    circleHalves: circleHalves,
    squish: squish,
    toggle: toggle,
    toggle2: toggle2,
    toggle3: toggle3,
    toggle4: toggle4,
    toggle5: toggle5,
    toggle6: toggle6,
    toggle7: toggle7,
    toggle8: toggle8,
    toggle9: toggle9,
    toggle10: toggle10,
    toggle11: toggle11,
    toggle12: toggle12,
    toggle13: toggle13,
    arrow: arrow,
    arrow2: arrow2,
    arrow3: arrow3,
    bouncingBar: bouncingBar,
    bouncingBall: bouncingBall,
    smiley: smiley,
    monkey: monkey,
    hearts: hearts,
    clock: clock,
    earth: earth,
    material: material,
    moon: moon,
    runner: runner,
    pong: pong,
    shark: shark,
    dqpb: dqpb,
    weather: weather,
    christmas: christmas,
    grenade: grenade,
    point: point,
    layer: layer,
    betaWave: betaWave,
    fingerDance: fingerDance,
    fistBump: fistBump,
    soccerHeader: soccerHeader,
    mindblown: mindblown,
    speaker: speaker,
    orangePulse: orangePulse,
    bluePulse: bluePulse,
    orangeBluePulse: orangeBluePulse,
    timeTravel: timeTravel,
    aesthetic: aesthetic,
    dwarfFortress: dwarfFortress
}, cliSpinners$1, hasRequiredCliSpinners;

function requireCliSpinners() {
    if (hasRequiredCliSpinners) return cliSpinners$1;
    hasRequiredCliSpinners = 1;
    const spinners = Object.assign({}, require$$0$2), spinnersList = Object.keys(spinners);
    return Object.defineProperty(spinners, "random", {
        get() {
            const randomIndex = Math.floor(Math.random() * spinnersList.length), spinnerName = spinnersList[randomIndex];
            return spinners[spinnerName];
        }
    }), cliSpinners$1 = spinners;
}

var cliSpinnersExports = requireCliSpinners(), cliSpinners = getDefaultExportFromCjs(cliSpinnersExports);

function isUnicodeSupported$2() {
    return "win32" !== process$2.platform ? "linux" !== process$2.env.TERM : Boolean(process$2.env.CI) || Boolean(process$2.env.WT_SESSION) || Boolean(process$2.env.TERMINUS_SUBLIME) || "{cmd::Cmder}" === process$2.env.ConEmuTask || "Terminus-Sublime" === process$2.env.TERM_PROGRAM || "vscode" === process$2.env.TERM_PROGRAM || "xterm-256color" === process$2.env.TERM || "alacritty" === process$2.env.TERM || "JetBrains-JediTerm" === process$2.env.TERMINAL_EMULATOR;
}

const main$1 = {
    info: chalk.blue("ℹ"),
    success: chalk.green("✔"),
    warning: chalk.yellow("⚠"),
    error: chalk.red("✖")
}, fallback$2 = {
    info: chalk.blue("i"),
    success: chalk.green("√"),
    warning: chalk.yellow("‼"),
    error: chalk.red("×")
}, logSymbols = isUnicodeSupported$2() ? main$1 : fallback$2;

function ansiRegex$1({onlyFirst: onlyFirst = !1} = {}) {
    const pattern = [ "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?(?:\\u0007|\\u001B\\u005C|\\u009C))", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]))" ].join("|");
    return new RegExp(pattern, onlyFirst ? void 0 : "g");
}

const regex = ansiRegex$1();

function stripAnsi$2(string) {
    if ("string" != typeof string) throw new TypeError(`Expected a \`string\`, got \`${typeof string}\``);
    return string.replace(regex, "");
}

function isAmbiguous(x) {
    return 161 === x || 164 === x || 167 === x || 168 === x || 170 === x || 173 === x || 174 === x || x >= 176 && x <= 180 || x >= 182 && x <= 186 || x >= 188 && x <= 191 || 198 === x || 208 === x || 215 === x || 216 === x || x >= 222 && x <= 225 || 230 === x || x >= 232 && x <= 234 || 236 === x || 237 === x || 240 === x || 242 === x || 243 === x || x >= 247 && x <= 250 || 252 === x || 254 === x || 257 === x || 273 === x || 275 === x || 283 === x || 294 === x || 295 === x || 299 === x || x >= 305 && x <= 307 || 312 === x || x >= 319 && x <= 322 || 324 === x || x >= 328 && x <= 331 || 333 === x || 338 === x || 339 === x || 358 === x || 359 === x || 363 === x || 462 === x || 464 === x || 466 === x || 468 === x || 470 === x || 472 === x || 474 === x || 476 === x || 593 === x || 609 === x || 708 === x || 711 === x || x >= 713 && x <= 715 || 717 === x || 720 === x || x >= 728 && x <= 731 || 733 === x || 735 === x || x >= 768 && x <= 879 || x >= 913 && x <= 929 || x >= 931 && x <= 937 || x >= 945 && x <= 961 || x >= 963 && x <= 969 || 1025 === x || x >= 1040 && x <= 1103 || 1105 === x || 8208 === x || x >= 8211 && x <= 8214 || 8216 === x || 8217 === x || 8220 === x || 8221 === x || x >= 8224 && x <= 8226 || x >= 8228 && x <= 8231 || 8240 === x || 8242 === x || 8243 === x || 8245 === x || 8251 === x || 8254 === x || 8308 === x || 8319 === x || x >= 8321 && x <= 8324 || 8364 === x || 8451 === x || 8453 === x || 8457 === x || 8467 === x || 8470 === x || 8481 === x || 8482 === x || 8486 === x || 8491 === x || 8531 === x || 8532 === x || x >= 8539 && x <= 8542 || x >= 8544 && x <= 8555 || x >= 8560 && x <= 8569 || 8585 === x || x >= 8592 && x <= 8601 || 8632 === x || 8633 === x || 8658 === x || 8660 === x || 8679 === x || 8704 === x || 8706 === x || 8707 === x || 8711 === x || 8712 === x || 8715 === x || 8719 === x || 8721 === x || 8725 === x || 8730 === x || x >= 8733 && x <= 8736 || 8739 === x || 8741 === x || x >= 8743 && x <= 8748 || 8750 === x || x >= 8756 && x <= 8759 || 8764 === x || 8765 === x || 8776 === x || 8780 === x || 8786 === x || 8800 === x || 8801 === x || x >= 8804 && x <= 8807 || 8810 === x || 8811 === x || 8814 === x || 8815 === x || 8834 === x || 8835 === x || 8838 === x || 8839 === x || 8853 === x || 8857 === x || 8869 === x || 8895 === x || 8978 === x || x >= 9312 && x <= 9449 || x >= 9451 && x <= 9547 || x >= 9552 && x <= 9587 || x >= 9600 && x <= 9615 || x >= 9618 && x <= 9621 || 9632 === x || 9633 === x || x >= 9635 && x <= 9641 || 9650 === x || 9651 === x || 9654 === x || 9655 === x || 9660 === x || 9661 === x || 9664 === x || 9665 === x || x >= 9670 && x <= 9672 || 9675 === x || x >= 9678 && x <= 9681 || x >= 9698 && x <= 9701 || 9711 === x || 9733 === x || 9734 === x || 9737 === x || 9742 === x || 9743 === x || 9756 === x || 9758 === x || 9792 === x || 9794 === x || 9824 === x || 9825 === x || x >= 9827 && x <= 9829 || x >= 9831 && x <= 9834 || 9836 === x || 9837 === x || 9839 === x || 9886 === x || 9887 === x || 9919 === x || x >= 9926 && x <= 9933 || x >= 9935 && x <= 9939 || x >= 9941 && x <= 9953 || 9955 === x || 9960 === x || 9961 === x || x >= 9963 && x <= 9969 || 9972 === x || x >= 9974 && x <= 9977 || 9979 === x || 9980 === x || 9982 === x || 9983 === x || 10045 === x || x >= 10102 && x <= 10111 || x >= 11094 && x <= 11097 || x >= 12872 && x <= 12879 || x >= 57344 && x <= 63743 || x >= 65024 && x <= 65039 || 65533 === x || x >= 127232 && x <= 127242 || x >= 127248 && x <= 127277 || x >= 127280 && x <= 127337 || x >= 127344 && x <= 127373 || 127375 === x || 127376 === x || x >= 127387 && x <= 127404 || x >= 917760 && x <= 917999 || x >= 983040 && x <= 1048573 || x >= 1048576 && x <= 1114109;
}

function isFullWidth(x) {
    return 12288 === x || x >= 65281 && x <= 65376 || x >= 65504 && x <= 65510;
}

function isWide(x) {
    return x >= 4352 && x <= 4447 || 8986 === x || 8987 === x || 9001 === x || 9002 === x || x >= 9193 && x <= 9196 || 9200 === x || 9203 === x || 9725 === x || 9726 === x || 9748 === x || 9749 === x || x >= 9800 && x <= 9811 || 9855 === x || 9875 === x || 9889 === x || 9898 === x || 9899 === x || 9917 === x || 9918 === x || 9924 === x || 9925 === x || 9934 === x || 9940 === x || 9962 === x || 9970 === x || 9971 === x || 9973 === x || 9978 === x || 9981 === x || 9989 === x || 9994 === x || 9995 === x || 10024 === x || 10060 === x || 10062 === x || x >= 10067 && x <= 10069 || 10071 === x || x >= 10133 && x <= 10135 || 10160 === x || 10175 === x || 11035 === x || 11036 === x || 11088 === x || 11093 === x || x >= 11904 && x <= 11929 || x >= 11931 && x <= 12019 || x >= 12032 && x <= 12245 || x >= 12272 && x <= 12287 || x >= 12289 && x <= 12350 || x >= 12353 && x <= 12438 || x >= 12441 && x <= 12543 || x >= 12549 && x <= 12591 || x >= 12593 && x <= 12686 || x >= 12688 && x <= 12771 || x >= 12783 && x <= 12830 || x >= 12832 && x <= 12871 || x >= 12880 && x <= 19903 || x >= 19968 && x <= 42124 || x >= 42128 && x <= 42182 || x >= 43360 && x <= 43388 || x >= 44032 && x <= 55203 || x >= 63744 && x <= 64255 || x >= 65040 && x <= 65049 || x >= 65072 && x <= 65106 || x >= 65108 && x <= 65126 || x >= 65128 && x <= 65131 || x >= 94176 && x <= 94180 || 94192 === x || 94193 === x || x >= 94208 && x <= 100343 || x >= 100352 && x <= 101589 || x >= 101632 && x <= 101640 || x >= 110576 && x <= 110579 || x >= 110581 && x <= 110587 || 110589 === x || 110590 === x || x >= 110592 && x <= 110882 || 110898 === x || x >= 110928 && x <= 110930 || 110933 === x || x >= 110948 && x <= 110951 || x >= 110960 && x <= 111355 || 126980 === x || 127183 === x || 127374 === x || x >= 127377 && x <= 127386 || x >= 127488 && x <= 127490 || x >= 127504 && x <= 127547 || x >= 127552 && x <= 127560 || 127568 === x || 127569 === x || x >= 127584 && x <= 127589 || x >= 127744 && x <= 127776 || x >= 127789 && x <= 127797 || x >= 127799 && x <= 127868 || x >= 127870 && x <= 127891 || x >= 127904 && x <= 127946 || x >= 127951 && x <= 127955 || x >= 127968 && x <= 127984 || 127988 === x || x >= 127992 && x <= 128062 || 128064 === x || x >= 128066 && x <= 128252 || x >= 128255 && x <= 128317 || x >= 128331 && x <= 128334 || x >= 128336 && x <= 128359 || 128378 === x || 128405 === x || 128406 === x || 128420 === x || x >= 128507 && x <= 128591 || x >= 128640 && x <= 128709 || 128716 === x || x >= 128720 && x <= 128722 || x >= 128725 && x <= 128727 || x >= 128732 && x <= 128735 || 128747 === x || 128748 === x || x >= 128756 && x <= 128764 || x >= 128992 && x <= 129003 || 129008 === x || x >= 129292 && x <= 129338 || x >= 129340 && x <= 129349 || x >= 129351 && x <= 129535 || x >= 129648 && x <= 129660 || x >= 129664 && x <= 129672 || x >= 129680 && x <= 129725 || x >= 129727 && x <= 129733 || x >= 129742 && x <= 129755 || x >= 129760 && x <= 129768 || x >= 129776 && x <= 129784 || x >= 131072 && x <= 196605 || x >= 196608 && x <= 262141;
}

function validate$2(codePoint) {
    if (!Number.isSafeInteger(codePoint)) throw new TypeError(`Expected a code point, got \`${typeof codePoint}\`.`);
}

function eastAsianWidth(codePoint, {ambiguousAsWide: ambiguousAsWide = !1} = {}) {
    return validate$2(codePoint), isFullWidth(codePoint) || isWide(codePoint) || ambiguousAsWide && isAmbiguous(codePoint) ? 2 : 1;
}

var emojiRegex$1 = () => /[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26D3\uFE0F?(?:\u200D\uD83D\uDCA5)?|\u26F9(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF43\uDF45-\uDF4A\uDF4C-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDF44(?:\u200D\uD83D\uDFEB)?|\uDF4B(?:\u200D\uD83D\uDFE9)?|\uDFC3(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4\uDEB5](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE41\uDE43\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC08(?:\u200D\u2B1B)?|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC26(?:\u200D(?:\u2B1B|\uD83D\uDD25))?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE])))?))?|\uDC6F(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDD75(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?|\uDE42(?:\u200D[\u2194\u2195]\uFE0F?)?|\uDEB6(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE89\uDE8F-\uDEC2\uDEC6\uDECE-\uDEDC\uDEDF-\uDEE9]|\uDD3C(?:\u200D[\u2640\u2642]\uFE0F?|\uD83C[\uDFFB-\uDFFF])?|\uDDCE(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1|\uDDD1\u200D\uD83E\uDDD2(?:\u200D\uD83E\uDDD2)?|\uDDD2(?:\u200D\uD83E\uDDD2)?))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g;

const segmenter = new Intl.Segmenter, defaultIgnorableCodePointRegex = /^\p{Default_Ignorable_Code_Point}$/u;

function stringWidth$1(string, options = {}) {
    if ("string" != typeof string || 0 === string.length) return 0;
    const {ambiguousIsNarrow: ambiguousIsNarrow = !0, countAnsiEscapeCodes: countAnsiEscapeCodes = !1} = options;
    if (countAnsiEscapeCodes || (string = stripAnsi$2(string)), 0 === string.length) return 0;
    let width = 0;
    const eastAsianWidthOptions = {
        ambiguousAsWide: !ambiguousIsNarrow
    };
    for (const {segment: character} of segmenter.segment(string)) {
        const codePoint = character.codePointAt(0);
        codePoint <= 31 || codePoint >= 127 && codePoint <= 159 || (codePoint >= 8203 && codePoint <= 8207 || 65279 === codePoint || codePoint >= 768 && codePoint <= 879 || codePoint >= 6832 && codePoint <= 6911 || codePoint >= 7616 && codePoint <= 7679 || codePoint >= 8400 && codePoint <= 8447 || codePoint >= 65056 && codePoint <= 65071 || codePoint >= 55296 && codePoint <= 57343 || codePoint >= 65024 && codePoint <= 65039 || defaultIgnorableCodePointRegex.test(character) || (emojiRegex$1().test(character) ? width += 2 : width += eastAsianWidth(codePoint, eastAsianWidthOptions)));
    }
    return width;
}

function isInteractive({stream: stream = process.stdout} = {}) {
    return Boolean(stream && stream.isTTY && "dumb" !== process.env.TERM && !("CI" in process.env));
}

function isUnicodeSupported$1() {
    const {env: env} = process$2, {TERM: TERM, TERM_PROGRAM: TERM_PROGRAM} = env;
    return "win32" !== process$2.platform ? "linux" !== TERM : Boolean(env.WT_SESSION) || Boolean(env.TERMINUS_SUBLIME) || "{cmd::Cmder}" === env.ConEmuTask || "Terminus-Sublime" === TERM_PROGRAM || "vscode" === TERM_PROGRAM || "xterm-256color" === TERM || "alacritty" === TERM || "rxvt-unicode" === TERM || "rxvt-unicode-256color" === TERM || "JetBrains-JediTerm" === env.TERMINAL_EMULATOR;
}

const ASCII_ETX_CODE = 3;

class StdinDiscarder {
    #activeCount=0;
    start() {
        this.#activeCount++, 1 === this.#activeCount && this.#realStart();
    }
    stop() {
        if (this.#activeCount <= 0) throw new Error("`stop` called more times than `start`");
        this.#activeCount--, 0 === this.#activeCount && this.#realStop();
    }
    #realStart() {
        "win32" !== process$2.platform && process$2.stdin.isTTY && (process$2.stdin.setRawMode(!0), 
        process$2.stdin.on("data", this.#handleInput), process$2.stdin.resume());
    }
    #realStop() {
        process$2.stdin.isTTY && (process$2.stdin.off("data", this.#handleInput), process$2.stdin.pause(), 
        process$2.stdin.setRawMode(!1));
    }
    #handleInput(chunk) {
        chunk[0] === ASCII_ETX_CODE && process$2.emit("SIGINT");
    }
}

const stdinDiscarder = new StdinDiscarder;

class Ora {
    #linesToClear=0;
    #isDiscardingStdin=!1;
    #lineCount=0;
    #frameIndex=0;
    #options;
    #spinner;
    #stream;
    #id;
    #initialInterval;
    #isEnabled;
    #isSilent;
    #indent;
    #text;
    #prefixText;
    #suffixText;
    color;
    constructor(options) {
        "string" == typeof options && (options = {
            text: options
        }), this.#options = {
            color: "cyan",
            stream: process$2.stderr,
            discardStdin: !0,
            hideCursor: !0,
            ...options
        }, this.color = this.#options.color, this.spinner = this.#options.spinner, this.#initialInterval = this.#options.interval, 
        this.#stream = this.#options.stream, this.#isEnabled = "boolean" == typeof this.#options.isEnabled ? this.#options.isEnabled : isInteractive({
            stream: this.#stream
        }), this.#isSilent = "boolean" == typeof this.#options.isSilent && this.#options.isSilent, 
        this.text = this.#options.text, this.prefixText = this.#options.prefixText, this.suffixText = this.#options.suffixText, 
        this.indent = this.#options.indent, "test" === process$2.env.NODE_ENV && (this._stream = this.#stream, 
        this._isEnabled = this.#isEnabled, Object.defineProperty(this, "_linesToClear", {
            get() {
                return this.#linesToClear;
            },
            set(newValue) {
                this.#linesToClear = newValue;
            }
        }), Object.defineProperty(this, "_frameIndex", {
            get() {
                return this.#frameIndex;
            }
        }), Object.defineProperty(this, "_lineCount", {
            get() {
                return this.#lineCount;
            }
        }));
    }
    get indent() {
        return this.#indent;
    }
    set indent(indent = 0) {
        if (!(indent >= 0 && Number.isInteger(indent))) throw new Error("The `indent` option must be an integer from 0 and up");
        this.#indent = indent, this.#updateLineCount();
    }
    get interval() {
        return this.#initialInterval ?? this.#spinner.interval ?? 100;
    }
    get spinner() {
        return this.#spinner;
    }
    set spinner(spinner) {
        if (this.#frameIndex = 0, this.#initialInterval = void 0, "object" == typeof spinner) {
            if (void 0 === spinner.frames) throw new Error("The given spinner must have a `frames` property");
            this.#spinner = spinner;
        } else if (isUnicodeSupported$1()) if (void 0 === spinner) this.#spinner = cliSpinners.dots; else {
            if ("default" === spinner || !cliSpinners[spinner]) throw new Error(`There is no built-in spinner named '${spinner}'. See https://github.com/sindresorhus/cli-spinners/blob/main/spinners.json for a full list.`);
            this.#spinner = cliSpinners[spinner];
        } else this.#spinner = cliSpinners.line;
    }
    get text() {
        return this.#text;
    }
    set text(value = "") {
        this.#text = value, this.#updateLineCount();
    }
    get prefixText() {
        return this.#prefixText;
    }
    set prefixText(value = "") {
        this.#prefixText = value, this.#updateLineCount();
    }
    get suffixText() {
        return this.#suffixText;
    }
    set suffixText(value = "") {
        this.#suffixText = value, this.#updateLineCount();
    }
    get isSpinning() {
        return void 0 !== this.#id;
    }
    #getFullPrefixText(prefixText = this.#prefixText, postfix = " ") {
        return "string" == typeof prefixText && "" !== prefixText ? prefixText + postfix : "function" == typeof prefixText ? prefixText() + postfix : "";
    }
    #getFullSuffixText(suffixText = this.#suffixText, prefix = " ") {
        return "string" == typeof suffixText && "" !== suffixText ? prefix + suffixText : "function" == typeof suffixText ? prefix + suffixText() : "";
    }
    #updateLineCount() {
        const columns = this.#stream.columns ?? 80, fullPrefixText = this.#getFullPrefixText(this.#prefixText, "-"), fullSuffixText = this.#getFullSuffixText(this.#suffixText, "-"), fullText = " ".repeat(this.#indent) + fullPrefixText + "--" + this.#text + "--" + fullSuffixText;
        this.#lineCount = 0;
        for (const line of stripAnsi$2(fullText).split("\n")) this.#lineCount += Math.max(1, Math.ceil(stringWidth$1(line, {
            countAnsiEscapeCodes: !0
        }) / columns));
    }
    get isEnabled() {
        return this.#isEnabled && !this.#isSilent;
    }
    set isEnabled(value) {
        if ("boolean" != typeof value) throw new TypeError("The `isEnabled` option must be a boolean");
        this.#isEnabled = value;
    }
    get isSilent() {
        return this.#isSilent;
    }
    set isSilent(value) {
        if ("boolean" != typeof value) throw new TypeError("The `isSilent` option must be a boolean");
        this.#isSilent = value;
    }
    frame() {
        const {frames: frames} = this.#spinner;
        let frame = frames[this.#frameIndex];
        this.color && (frame = chalk[this.color](frame)), this.#frameIndex = ++this.#frameIndex % frames.length;
        return ("string" == typeof this.#prefixText && "" !== this.#prefixText ? this.#prefixText + " " : "") + frame + ("string" == typeof this.text ? " " + this.text : "") + ("string" == typeof this.#suffixText && "" !== this.#suffixText ? " " + this.#suffixText : "");
    }
    clear() {
        if (!this.#isEnabled || !this.#stream.isTTY) return this;
        this.#stream.cursorTo(0);
        for (let index = 0; index < this.#linesToClear; index++) index > 0 && this.#stream.moveCursor(0, -1), 
        this.#stream.clearLine(1);
        return (this.#indent || this.lastIndent !== this.#indent) && this.#stream.cursorTo(this.#indent), 
        this.lastIndent = this.#indent, this.#linesToClear = 0, this;
    }
    render() {
        return this.#isSilent || (this.clear(), this.#stream.write(this.frame()), this.#linesToClear = this.#lineCount), 
        this;
    }
    start(text) {
        return text && (this.text = text), this.#isSilent ? this : this.#isEnabled ? (this.isSpinning || (this.#options.hideCursor && cliCursor.hide(this.#stream), 
        this.#options.discardStdin && process$2.stdin.isTTY && (this.#isDiscardingStdin = !0, 
        stdinDiscarder.start()), this.render(), this.#id = setInterval(this.render.bind(this), this.interval)), 
        this) : (this.text && this.#stream.write(`- ${this.text}\n`), this);
    }
    stop() {
        return this.#isEnabled ? (clearInterval(this.#id), this.#id = void 0, this.#frameIndex = 0, 
        this.clear(), this.#options.hideCursor && cliCursor.show(this.#stream), this.#options.discardStdin && process$2.stdin.isTTY && this.#isDiscardingStdin && (stdinDiscarder.stop(), 
        this.#isDiscardingStdin = !1), this) : this;
    }
    succeed(text) {
        return this.stopAndPersist({
            symbol: logSymbols.success,
            text: text
        });
    }
    fail(text) {
        return this.stopAndPersist({
            symbol: logSymbols.error,
            text: text
        });
    }
    warn(text) {
        return this.stopAndPersist({
            symbol: logSymbols.warning,
            text: text
        });
    }
    info(text) {
        return this.stopAndPersist({
            symbol: logSymbols.info,
            text: text
        });
    }
    stopAndPersist(options = {}) {
        if (this.#isSilent) return this;
        const prefixText = options.prefixText ?? this.#prefixText, fullPrefixText = this.#getFullPrefixText(prefixText, " "), symbolText = options.symbol ?? " ", text = options.text ?? this.text, fullText = "string" == typeof text ? " " + text : "", suffixText = options.suffixText ?? this.#suffixText, textToWrite = fullPrefixText + symbolText + fullText + this.#getFullSuffixText(suffixText, " ") + "\n";
        return this.stop(), this.#stream.write(textToWrite), this;
    }
}

function ora(options) {
    return new Ora(options);
}

async function checkDebianDependenciesInstalled(exitWhenMissing = !0, printInstallCommand = !0) {
    const deps = [ "build-essential", "pkg-config", "libudev-dev", "llvm", "libclang-dev", "protobuf-compiler", "libssl-dev" ], statuses = await Promise.allSettled(deps.map((dep => checkCommand(`apt list ${dep} | grep [installed]`, {
        exit: !1
    })))), missingDeps = [];
    if (statuses.map(((res, index) => {
        let isInstalled = !1;
        "rejected" != res.status && res?.value ? res.value.split("\n").map((data => {
            new RegExp(`^${deps[index]}/[^\\s]+.+\\[installed\\]`, "m").test(data) && (isInstalled = !0);
        })) : console.error("Unable to detect dependency:", deps[index]), isInstalled || missingDeps.push(deps[index]);
    })), 0 != missingDeps.length) return printInstallCommand && console.log("sudo apt update && sudo apt install -y", missingDeps.join(" ")), 
    exitWhenMissing && (console.error("Missing dependencies:", missingDeps.join(" ")), 
    process.exit(0)), missingDeps;
}

async function installRust({version: version} = {}) {
    const spinner = ora("Installing the rust toolchain using rustup").start();
    try {
        appendPathToRCFiles(TOOL_CONFIG.rust.pathSource, "rust");
        if ("linux" == detectOperatingSystem() && await checkCommand("apt --version")) {
            spinner.text = "Checking for required linux dependencies";
            const missingDeps = await checkDebianDependenciesInstalled(!0, !0);
            if (missingDeps && missingDeps.length > 0) throw "Your system is missing required system dependencies: " + missingDeps.join(" ");
        }
        let installedVersion = await installedToolVersion("rust");
        if (installedVersion) return spinner.info(`rust ${installedVersion} is already installed`), 
        !0;
        spinner.text = "Installing the rust toolchain using rustup";
        const result = await src_default("curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y");
        if (result && 0 != result.code) {
            throw result.stderr.trim().split("\n").join("\n");
        }
        return spinner.text = "Verifying rust was installed", installedVersion = await installedToolVersion("rust"), 
        installedVersion ? (spinner.succeed(`rust ${installedVersion} installed`), installedVersion) : (spinner.fail("rust failed to install"), 
        !1);
    } catch (err) {
        spinner.fail("Unable to install rust"), "string" == typeof err ? console.error(err) : (Error, 
        console.error(err.message));
    }
    return !1;
}

async function installSolana({version: version = "stable"} = {}) {
    const spinner = ora("Installing the Solana CLI tool suite...").start();
    try {
        appendPathToRCFiles(TOOL_CONFIG.solana.pathSource, "solana");
        let installedVersion = await installedToolVersion("solana");
        if (installedVersion) return spinner.info(`solana ${installedVersion} is already installed`), 
        !0;
        if ("stable" != (version = version.toLowerCase()) && !version.startsWith("v")) throw `Invalid version: '${version}'`;
        spinner.text = "Installing the Solana CLI tool suite...";
        const result = await src_default(`sh -c "$(curl -sSfL https://release.anza.xyz/${version}/install)"`);
        if (result && 0 != result.code) {
            throw result.stderr.trim().split("\n").join("\n");
        }
        return spinner.text = "Verifying solana was installed", installedVersion = await installedToolVersion("solana"), 
        installedVersion ? (spinner.succeed(`solana ${installedVersion} installed`), installedVersion) : (spinner.fail("solana failed to install"), 
        !1);
    } catch (err) {
        spinner.fail("Unable to install the Solana CLI tool suite"), "string" == typeof err ? console.error(err) : (Error, 
        console.error(err.message));
    }
    return !1;
}

async function installAnchorVersionManager({version: version = "latest"} = {}) {
    const spinner = ora("Installing avm (anchor version manager)").start();
    try {
        let installedVersion = await installedToolVersion("avm");
        if (installedVersion) return spinner.info(`avm ${installedVersion} is already installed`), 
        !0;
        spinner.text = "Installing avm (anchor version manager)";
        const result = await src_default("cargo install --git https://github.com/coral-xyz/anchor avm --locked --force");
        if (result && 0 != result.code) {
            throw result.stderr.trim().split("\n").join("\n");
        }
        return spinner.text = "Verifying avm was installed", installedVersion = await installedToolVersion("avm"), 
        installedVersion ? (spinner.succeed(`avm ${installedVersion} installed`), installedVersion) : (spinner.fail("avm failed to install"), 
        !1);
    } catch (err) {
        spinner.fail("Unable to install avm"), "string" == typeof err ? console.error(err) : (Error, 
        console.error(err.message));
    }
    return !1;
}

async function installAnchorUsingAvm({verifyParentCommand: verifyParentCommand = !0, version: version = "latest"} = {}) {
    const spinner = ora("Installing anchor using avm...").start();
    try {
        let installedVersion = await installedToolVersion("anchor");
        if (installedVersion && installedVersion == version) return spinner.info(`anchor ${installedVersion} is already installed`), 
        !0;
        spinner.text = "Verifying avm is installed";
        const avmVersion = await installedToolVersion("avm");
        if (!avmVersion) throw "avm is NOT already installed";
        if (version = avmVersion, installedVersion && installedVersion == version) return spinner.info(`anchor ${installedVersion} is already installed`), 
        !0;
        let result;
        try {
            spinner.text = `Installing anchor version '${version}'. This may take a few moments...`, 
            result = await src_default(`avm install ${version}`);
        } catch (err) {
            throw "Unable to execute `avm install`";
        }
        if (result && 0 != result.code) {
            throw result.stderr.trim().split("\n").join("\n");
        }
        try {
            spinner.text = "Setting anchor version with avm", result = await src_default(`avm use ${version}`);
        } catch (err) {
            throw "Unable to execute `avm use`";
        }
        return spinner.text = "Verifying anchor was installed", installedVersion = await installedToolVersion("anchor"), 
        installedVersion ? (spinner.succeed(`anchor ${installedVersion} installed using avm`), 
        installedVersion) : (spinner.fail("anchor failed to install"), !1);
    } catch (err) {
        spinner.fail("Unable to install anchor using avm"), "string" == typeof err ? console.error(err) : (Error, 
        console.error(err.message));
    }
    return !1;
}

async function installYarn({} = {}) {
    const spinner = ora("Installing yarn package manager...").start();
    try {
        let installedVersion = await installedToolVersion("yarn");
        return installedVersion ? (spinner.info(`yarn ${installedVersion} is already installed`), 
        !0) : (spinner.text = "Installing yarn package manager", await src_default("npm install -g yarn"), 
        spinner.text = "Verifying yarn was installed", installedVersion = await installedToolVersion("yarn"), 
        installedVersion ? (spinner.succeed(`yarn ${installedVersion} installed`), installedVersion) : (spinner.fail("yarn package manager failed to install"), 
        !1));
    } catch (err) {
        spinner.fail("Unable to install yarn package manager"), "string" == typeof err ? console.error(err) : (Error, 
        console.error(err.message));
    }
    return !1;
}

async function installTrident({version: version = "latest", verifyParentCommand: verifyParentCommand = !0} = {}) {
    const spinner = ora("Installing trident (fuzzer)").start();
    try {
        let installedVersion = await installedToolVersion("trident");
        if (installedVersion) return spinner.info(`trident ${installedVersion} is already installed`), 
        !0;
        if (verifyParentCommand) {
            if (!await installedToolVersion("rust")) throw spinner.fail("Rust/cargo was not found"), 
            "parent command not found";
        }
        spinner.text = "Installing trident (fuzzer)";
        const result = await src_default("cargo install honggfuzz trident-cli");
        if (result && 0 != result.code) {
            throw result.stderr.trim().split("\n").join("\n");
        }
        return spinner.text = "Verifying trident was installed", installedVersion = await installedToolVersion("trident"), 
        installedVersion ? (spinner.succeed(`trident ${installedVersion} installed`), installedVersion) : (spinner.fail("trident failed to install"), 
        !1);
    } catch (err) {
        spinner.fail("Unable to install the trident fuzzer"), "string" == typeof err ? console.error(err) : (Error, 
        console.error(err.message));
    }
    return !1;
}

async function installZest({version: version = "latest", verifyParentCommand: verifyParentCommand = !0} = {}) {
    const spinner = ora("Installing zest (code coverage)").start();
    try {
        let result, installedVersion = await installedToolVersion("zest");
        if (installedVersion) return spinner.info(`zest ${installedVersion} is already installed`), 
        !0;
        if (verifyParentCommand) {
            if (!await installedToolVersion("rust")) throw "rustc/cargo was not found but is required";
        }
        try {
            spinner.text = "Installing zest (code coverage)...", result = await src_default("cargo install --git https://github.com/LimeChain/zest zest --force");
        } catch (err) {
            throw "Unable to execute the zest installer";
        }
        if (result && 0 != result.code) {
            const error = result.stderr.trim().split("\n");
            let parsed = null;
            if (parsed = error.slice(-1)[0].match(/(?<=\bit requires rustc\s)\d+\.\d+(\.\d+)?(?=\sor newer\b)/gi)[0]) throw `Zest requires a minimum rustc version of ${parsed}. To set your rustc version, run the following command:\nrustup default ${parsed}`;
            throw error.join("\n");
        }
        try {
            spinner.text = "Installing the 'llvm-tools-preview' component in rustup", result = await src_default("rustup component add llvm-tools-preview");
        } catch (err) {
            throw "Unable to execute 'rustup component add llvm-tools-preview'. Try running manually.";
        }
        return spinner.text = "Verifying zest was installed", installedVersion = await installedToolVersion("zest"), 
        installedVersion ? (spinner.succeed(`zest ${installedVersion} installed`), installedVersion) : (spinner.fail("zest failed to install"), 
        !1);
    } catch (err) {
        spinner.fail("Unable to install zest"), "string" == typeof err ? console.error(err) : (Error, 
        console.error(err.message));
    }
    return !1;
}

async function installSolanaVerify({version: version = "latest", verifyParentCommand: verifyParentCommand = !0} = {}) {
    const spinner = ora("Installing solana-verify").start();
    try {
        let result, installedVersion = await installedToolVersion("verify");
        if (installedVersion) return spinner.info(`solana-verify ${installedVersion} is already installed`), 
        await isDockerInstalled(), !0;
        if (verifyParentCommand) {
            if (!await installedToolVersion("rust")) throw "rustc/cargo was not found but is required";
        }
        try {
            spinner.text = "Installing solana-verify...", result = await src_default("cargo install solana-verify");
        } catch (err) {
            throw "Unable to execute the solana-verify installer";
        }
        if (result && 0 != result.code) {
            const error = result.stderr.trim().split("\n");
            throw error.join("\n");
        }
        return spinner.text = "Verifying solana-verify was installed", installedVersion = await installedToolVersion("verify"), 
        installedVersion ? (spinner.succeed(`solana-verify ${installedVersion} installed`), 
        await isDockerInstalled(), installedVersion) : (spinner.fail("solana-verify failed to install"), 
        !1);
    } catch (err) {
        spinner.fail("Unable to install solana-verify"), "string" == typeof err ? console.error(err) : (Error, 
        console.error(err.message));
    }
    return !1;
}

async function isDockerInstalled() {
    return checkCommand("docker --version", {
        exit: !1,
        onError: () => {
            console.error("Unable to detect Docker (which is required for 'solana-verify'). Do you have it installed?"), 
            console.error("To install Docker, follow the instructions in the official Docker documentation:", "\nhttps://docs.docker.com/engine/install/");
        }
    });
}

async function checkInstalledTools({outputToolStatus: outputToolStatus = !1} = {}) {
    let allInstalled = !0, status = {
        rust: !1,
        solana: !1,
        avm: !1,
        anchor: !1,
        yarn: !1,
        trident: !1,
        zest: !1,
        verify: !1
    };
    if (await Promise.all(Object.keys(status).map((async tool => {
        const version = await installedToolVersion(tool);
        status[tool] = version, status[tool] || (allInstalled = !1);
    }))), outputToolStatus) {
        let noteContent = "";
        for (const command in status) Object.prototype.hasOwnProperty.call(status, command) && (noteContent += "- ", 
        status[command] ? noteContent += picocolors.green(command) : noteContent += picocolors.red(command), 
        noteContent += ` ${status[command] || "(not installed)"}\n`);
        console.log(noteContent.trim(), "\n");
    }
    return {
        allInstalled: allInstalled,
        status: status
    };
}

async function checkShellPathSource(cmd, pathSource) {
    const [withoutPath, withPath] = await Promise.allSettled([ src_default(cmd), src_default(`export PATH="${pathSource}:$PATH" && ${cmd}`) ]);
    if ("fulfilled" == withoutPath.status && "fulfilled" == withPath.status) {
        if (0 === withoutPath.value.code) return withoutPath.value.stdout.toLowerCase() == withPath.value.stdout.toLowerCase() ? PathSourceStatus.SUCCESS : PathSourceStatus.OUTPUT_MISMATCH;
        if (0 === withPath.value.code) return PathSourceStatus.MISSING_PATH;
    }
    return PathSourceStatus.FAILED;
}

const toolNames = [ "rust", "solana", "avm", "anchor", "trident", "zest", "yarn", "verify" ];

function installCommand() {
    return new Command("install").configureOutput(cliOutputConfig).description("install Solana development tooling").addArgument(new Argument("<tool>", "tool to install (default: all)").choices(toolNames).argOptional()).addArgument(new Argument("<version>", "desired tool version to install (default: stable)").argOptional()).action((async (toolName, version, options) => {
        titleMessage("Install Solana development tooling");
        const os = detectOperatingSystem();
        "windows" == os && warnMessage("Windows is not yet natively supported for the rust based tooling.\nWe recommend using WSL inside your Windows terminal."), 
        await checkInstalledTools({
            outputToolStatus: !1
        });
        const pathsToRefresh = [];
        toolName && "rust" != toolName || (await installRust({
            os: os,
            version: version
        }), await checkShellPathSource(TOOL_CONFIG.rust.version, TOOL_CONFIG.rust.pathSource).then((status => status != PathSourceStatus.MISSING_PATH || pathsToRefresh.push(TOOL_CONFIG.rust.pathSource)))), 
        toolName && "solana" != toolName || (await installSolana({
            os: os,
            version: version
        }), await checkShellPathSource(TOOL_CONFIG.solana.version, TOOL_CONFIG.solana.pathSource).then((status => status != PathSourceStatus.MISSING_PATH || pathsToRefresh.push(TOOL_CONFIG.solana.pathSource)))), 
        toolName && "avm" != toolName || await installAnchorVersionManager({
            os: os,
            version: version
        }), toolName && "anchor" != toolName || await installAnchorUsingAvm({
            os: os,
            version: version
        }), toolName && "trident" != toolName || await installTrident({
            os: os,
            version: version
        }), toolName && "zest" != toolName || await installZest({
            os: os,
            version: version
        }), toolName && "verify" != toolName || await installSolanaVerify({
            os: os,
            version: version
        }), toolName && "yarn" != toolName || await installYarn({
            os: os,
            version: version
        }), pathsToRefresh.length > 0 && (console.log("\nClose and reopen your terminal to apply the required", "PATH changes \nor run the following in your existing shell:", "\n"), 
        console.log(`export PATH="${pathsToRefresh.join(":")}:$PATH"`, "\n"));
    }));
}

function doctorCommand() {
    return new Command("doctor").configureOutput(cliOutputConfig).description("inspect and remedy your local development environment").addCommand(doctorListCommand());
}

function doctorListCommand() {
    return new Command("list").configureOutput(cliOutputConfig).description("list the current versions of Solana development tooling").action((async () => {
        "windows" == detectOperatingSystem() && warnMessage("Windows is not yet natively supported for the rust based tooling.\nWe recommend using WSL inside your Windows terminal.");
        if ((await checkInstalledTools({
            outputToolStatus: !0
        })).allInstalled) return successOutro("All tools are installed!");
        successOutro();
    }));
}

function number$1(n) {
    if (!Number.isSafeInteger(n) || n < 0) throw new Error(`positive integer expected, not ${n}`);
}

function isBytes$1(a) {
    return a instanceof Uint8Array || null != a && "object" == typeof a && "Uint8Array" === a.constructor.name;
}

function bytes(b, ...lengths) {
    if (!isBytes$1(b)) throw new Error("Uint8Array expected");
    if (lengths.length > 0 && !lengths.includes(b.length)) throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b.length}`);
}

function hash(h) {
    if ("function" != typeof h || "function" != typeof h.create) throw new Error("Hash should be wrapped by utils.wrapConstructor");
    number$1(h.outputLen), number$1(h.blockLen);
}

function exists(instance, checkFinished = !0) {
    if (instance.destroyed) throw new Error("Hash instance has been destroyed");
    if (checkFinished && instance.finished) throw new Error("Hash#digest() has already been called");
}

function output(out, instance) {
    bytes(out);
    const min = instance.outputLen;
    if (out.length < min) throw new Error(`digestInto() expects output buffer of length at least ${min}`);
}

const crypto = nc && "object" == typeof nc && "webcrypto" in nc ? nc.webcrypto : nc && "object" == typeof nc && "randomBytes" in nc ? nc : void 0, createView = arr => new DataView(arr.buffer, arr.byteOffset, arr.byteLength), rotr = (word, shift) => word << 32 - shift | word >>> shift;

/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ function utf8ToBytes$1(str) {
    if ("string" != typeof str) throw new Error("utf8ToBytes expected string, got " + typeof str);
    return new Uint8Array((new TextEncoder).encode(str));
}

function toBytes(data) {
    return "string" == typeof data && (data = utf8ToBytes$1(data)), bytes(data), data;
}

function concatBytes$1(...arrays) {
    let sum = 0;
    for (let i = 0; i < arrays.length; i++) {
        const a = arrays[i];
        bytes(a), sum += a.length;
    }
    const res = new Uint8Array(sum);
    for (let i = 0, pad = 0; i < arrays.length; i++) {
        const a = arrays[i];
        res.set(a, pad), pad += a.length;
    }
    return res;
}

new Uint8Array(new Uint32Array([ 287454020 ]).buffer)[0];

class Hash {
    clone() {
        return this._cloneInto();
    }
}

function wrapConstructor(hashCons) {
    const hashC = msg => hashCons().update(toBytes(msg)).digest(), tmp = hashCons();
    return hashC.outputLen = tmp.outputLen, hashC.blockLen = tmp.blockLen, hashC.create = () => hashCons(), 
    hashC;
}

function randomBytes(bytesLength = 32) {
    if (crypto && "function" == typeof crypto.getRandomValues) return crypto.getRandomValues(new Uint8Array(bytesLength));
    if (crypto && "function" == typeof crypto.randomBytes) return crypto.randomBytes(bytesLength);
    throw new Error("crypto.getRandomValues must be defined");
}

function setBigUint64(view, byteOffset, value, isLE) {
    if ("function" == typeof view.setBigUint64) return view.setBigUint64(byteOffset, value, isLE);
    const _32n = BigInt(32), _u32_max = BigInt(4294967295), wh = Number(value >> _32n & _u32_max), wl = Number(value & _u32_max), h = isLE ? 4 : 0, l = isLE ? 0 : 4;
    view.setUint32(byteOffset + h, wh, isLE), view.setUint32(byteOffset + l, wl, isLE);
}

const Chi = (a, b, c) => a & b ^ ~a & c, Maj = (a, b, c) => a & b ^ a & c ^ b & c;

class HashMD extends Hash {
    constructor(blockLen, outputLen, padOffset, isLE) {
        super(), this.blockLen = blockLen, this.outputLen = outputLen, this.padOffset = padOffset, 
        this.isLE = isLE, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, 
        this.buffer = new Uint8Array(blockLen), this.view = createView(this.buffer);
    }
    update(data) {
        exists(this);
        const {view: view, buffer: buffer, blockLen: blockLen} = this, len = (data = toBytes(data)).length;
        for (let pos = 0; pos < len; ) {
            const take = Math.min(blockLen - this.pos, len - pos);
            if (take !== blockLen) buffer.set(data.subarray(pos, pos + take), this.pos), this.pos += take, 
            pos += take, this.pos === blockLen && (this.process(view, 0), this.pos = 0); else {
                const dataView = createView(data);
                for (;blockLen <= len - pos; pos += blockLen) this.process(dataView, pos);
            }
        }
        return this.length += data.length, this.roundClean(), this;
    }
    digestInto(out) {
        exists(this), output(out, this), this.finished = !0;
        const {buffer: buffer, view: view, blockLen: blockLen, isLE: isLE} = this;
        let {pos: pos} = this;
        buffer[pos++] = 128, this.buffer.subarray(pos).fill(0), this.padOffset > blockLen - pos && (this.process(view, 0), 
        pos = 0);
        for (let i = pos; i < blockLen; i++) buffer[i] = 0;
        setBigUint64(view, blockLen - 8, BigInt(8 * this.length), isLE), this.process(view, 0);
        const oview = createView(out), len = this.outputLen;
        if (len % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
        const outLen = len / 4, state = this.get();
        if (outLen > state.length) throw new Error("_sha2: outputLen bigger than state");
        for (let i = 0; i < outLen; i++) oview.setUint32(4 * i, state[i], isLE);
    }
    digest() {
        const {buffer: buffer, outputLen: outputLen} = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        return this.destroy(), res;
    }
    _cloneInto(to) {
        to || (to = new this.constructor), to.set(...this.get());
        const {blockLen: blockLen, buffer: buffer, length: length, finished: finished, destroyed: destroyed, pos: pos} = this;
        return to.length = length, to.pos = pos, to.finished = finished, to.destroyed = destroyed, 
        length % blockLen && to.buffer.set(buffer), to;
    }
}

const U32_MASK64 = BigInt(2 ** 32 - 1), _32n = BigInt(32);

function fromBig(n, le = !1) {
    return le ? {
        h: Number(n & U32_MASK64),
        l: Number(n >> _32n & U32_MASK64)
    } : {
        h: 0 | Number(n >> _32n & U32_MASK64),
        l: 0 | Number(n & U32_MASK64)
    };
}

function split$1(lst, le = !1) {
    let Ah = new Uint32Array(lst.length), Al = new Uint32Array(lst.length);
    for (let i = 0; i < lst.length; i++) {
        const {h: h, l: l} = fromBig(lst[i], le);
        [Ah[i], Al[i]] = [ h, l ];
    }
    return [ Ah, Al ];
}

const toBig = (h, l) => BigInt(h >>> 0) << _32n | BigInt(l >>> 0), shrSH = (h, _l, s) => h >>> s, shrSL = (h, l, s) => h << 32 - s | l >>> s, rotrSH = (h, l, s) => h >>> s | l << 32 - s, rotrSL = (h, l, s) => h << 32 - s | l >>> s, rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32, rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s, rotr32H = (_h, l) => l, rotr32L = (h, _l) => h, rotlSH = (h, l, s) => h << s | l >>> 32 - s, rotlSL = (h, l, s) => l << s | h >>> 32 - s, rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s, rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;

function add(Ah, Al, Bh, Bl) {
    const l = (Al >>> 0) + (Bl >>> 0);
    return {
        h: Ah + Bh + (l / 2 ** 32 | 0) | 0,
        l: 0 | l
    };
}

const add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0), add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0, add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0), add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0, add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0), add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0, u64$1 = {
    fromBig: fromBig,
    split: split$1,
    toBig: toBig,
    shrSH: shrSH,
    shrSL: shrSL,
    rotrSH: rotrSH,
    rotrSL: rotrSL,
    rotrBH: rotrBH,
    rotrBL: rotrBL,
    rotr32H: rotr32H,
    rotr32L: rotr32L,
    rotlSH: rotlSH,
    rotlSL: rotlSL,
    rotlBH: rotlBH,
    rotlBL: rotlBL,
    add: add,
    add3L: add3L,
    add3H: add3H,
    add4L: add4L,
    add4H: add4H,
    add5H: add5H,
    add5L: add5L
}, [SHA512_Kh, SHA512_Kl] = (() => u64$1.split([ "0x428a2f98d728ae22", "0x7137449123ef65cd", "0xb5c0fbcfec4d3b2f", "0xe9b5dba58189dbbc", "0x3956c25bf348b538", "0x59f111f1b605d019", "0x923f82a4af194f9b", "0xab1c5ed5da6d8118", "0xd807aa98a3030242", "0x12835b0145706fbe", "0x243185be4ee4b28c", "0x550c7dc3d5ffb4e2", "0x72be5d74f27b896f", "0x80deb1fe3b1696b1", "0x9bdc06a725c71235", "0xc19bf174cf692694", "0xe49b69c19ef14ad2", "0xefbe4786384f25e3", "0x0fc19dc68b8cd5b5", "0x240ca1cc77ac9c65", "0x2de92c6f592b0275", "0x4a7484aa6ea6e483", "0x5cb0a9dcbd41fbd4", "0x76f988da831153b5", "0x983e5152ee66dfab", "0xa831c66d2db43210", "0xb00327c898fb213f", "0xbf597fc7beef0ee4", "0xc6e00bf33da88fc2", "0xd5a79147930aa725", "0x06ca6351e003826f", "0x142929670a0e6e70", "0x27b70a8546d22ffc", "0x2e1b21385c26c926", "0x4d2c6dfc5ac42aed", "0x53380d139d95b3df", "0x650a73548baf63de", "0x766a0abb3c77b2a8", "0x81c2c92e47edaee6", "0x92722c851482353b", "0xa2bfe8a14cf10364", "0xa81a664bbc423001", "0xc24b8b70d0f89791", "0xc76c51a30654be30", "0xd192e819d6ef5218", "0xd69906245565a910", "0xf40e35855771202a", "0x106aa07032bbd1b8", "0x19a4c116b8d2d0c8", "0x1e376c085141ab53", "0x2748774cdf8eeb99", "0x34b0bcb5e19b48a8", "0x391c0cb3c5c95a63", "0x4ed8aa4ae3418acb", "0x5b9cca4f7763e373", "0x682e6ff3d6b2b8a3", "0x748f82ee5defb2fc", "0x78a5636f43172f60", "0x84c87814a1f0ab72", "0x8cc702081a6439ec", "0x90befffa23631e28", "0xa4506cebde82bde9", "0xbef9a3f7b2c67915", "0xc67178f2e372532b", "0xca273eceea26619c", "0xd186b8c721c0c207", "0xeada7dd6cde0eb1e", "0xf57d4f7fee6ed178", "0x06f067aa72176fba", "0x0a637dc5a2c898a6", "0x113f9804bef90dae", "0x1b710b35131c471b", "0x28db77f523047d84", "0x32caab7b40c72493", "0x3c9ebe0a15c9bebc", "0x431d67c49c100d4c", "0x4cc5d4becb3e42b6", "0x597f299cfc657e2a", "0x5fcb6fab3ad6faec", "0x6c44198c4a475817" ].map((n => BigInt(n)))))(), SHA512_W_H = new Uint32Array(80), SHA512_W_L = new Uint32Array(80);

class SHA512 extends HashMD {
    constructor() {
        super(128, 64, 16, !1), this.Ah = 1779033703, this.Al = -205731576, this.Bh = -1150833019, 
        this.Bl = -2067093701, this.Ch = 1013904242, this.Cl = -23791573, this.Dh = -1521486534, 
        this.Dl = 1595750129, this.Eh = 1359893119, this.El = -1377402159, this.Fh = -1694144372, 
        this.Fl = 725511199, this.Gh = 528734635, this.Gl = -79577749, this.Hh = 1541459225, 
        this.Hl = 327033209;
    }
    get() {
        const {Ah: Ah, Al: Al, Bh: Bh, Bl: Bl, Ch: Ch, Cl: Cl, Dh: Dh, Dl: Dl, Eh: Eh, El: El, Fh: Fh, Fl: Fl, Gh: Gh, Gl: Gl, Hh: Hh, Hl: Hl} = this;
        return [ Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl ];
    }
    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
        this.Ah = 0 | Ah, this.Al = 0 | Al, this.Bh = 0 | Bh, this.Bl = 0 | Bl, this.Ch = 0 | Ch, 
        this.Cl = 0 | Cl, this.Dh = 0 | Dh, this.Dl = 0 | Dl, this.Eh = 0 | Eh, this.El = 0 | El, 
        this.Fh = 0 | Fh, this.Fl = 0 | Fl, this.Gh = 0 | Gh, this.Gl = 0 | Gl, this.Hh = 0 | Hh, 
        this.Hl = 0 | Hl;
    }
    process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4) SHA512_W_H[i] = view.getUint32(offset), 
        SHA512_W_L[i] = view.getUint32(offset += 4);
        for (let i = 16; i < 80; i++) {
            const W15h = 0 | SHA512_W_H[i - 15], W15l = 0 | SHA512_W_L[i - 15], s0h = u64$1.rotrSH(W15h, W15l, 1) ^ u64$1.rotrSH(W15h, W15l, 8) ^ u64$1.shrSH(W15h, W15l, 7), s0l = u64$1.rotrSL(W15h, W15l, 1) ^ u64$1.rotrSL(W15h, W15l, 8) ^ u64$1.shrSL(W15h, W15l, 7), W2h = 0 | SHA512_W_H[i - 2], W2l = 0 | SHA512_W_L[i - 2], s1h = u64$1.rotrSH(W2h, W2l, 19) ^ u64$1.rotrBH(W2h, W2l, 61) ^ u64$1.shrSH(W2h, W2l, 6), s1l = u64$1.rotrSL(W2h, W2l, 19) ^ u64$1.rotrBL(W2h, W2l, 61) ^ u64$1.shrSL(W2h, W2l, 6), SUMl = u64$1.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]), SUMh = u64$1.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
            SHA512_W_H[i] = 0 | SUMh, SHA512_W_L[i] = 0 | SUMl;
        }
        let {Ah: Ah, Al: Al, Bh: Bh, Bl: Bl, Ch: Ch, Cl: Cl, Dh: Dh, Dl: Dl, Eh: Eh, El: El, Fh: Fh, Fl: Fl, Gh: Gh, Gl: Gl, Hh: Hh, Hl: Hl} = this;
        for (let i = 0; i < 80; i++) {
            const sigma1h = u64$1.rotrSH(Eh, El, 14) ^ u64$1.rotrSH(Eh, El, 18) ^ u64$1.rotrBH(Eh, El, 41), sigma1l = u64$1.rotrSL(Eh, El, 14) ^ u64$1.rotrSL(Eh, El, 18) ^ u64$1.rotrBL(Eh, El, 41), CHIh = Eh & Fh ^ ~Eh & Gh, CHIl = El & Fl ^ ~El & Gl, T1ll = u64$1.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]), T1h = u64$1.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]), T1l = 0 | T1ll, sigma0h = u64$1.rotrSH(Ah, Al, 28) ^ u64$1.rotrBH(Ah, Al, 34) ^ u64$1.rotrBH(Ah, Al, 39), sigma0l = u64$1.rotrSL(Ah, Al, 28) ^ u64$1.rotrBL(Ah, Al, 34) ^ u64$1.rotrBL(Ah, Al, 39), MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch, MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
            Hh = 0 | Gh, Hl = 0 | Gl, Gh = 0 | Fh, Gl = 0 | Fl, Fh = 0 | Eh, Fl = 0 | El, ({h: Eh, l: El} = u64$1.add(0 | Dh, 0 | Dl, 0 | T1h, 0 | T1l)), 
            Dh = 0 | Ch, Dl = 0 | Cl, Ch = 0 | Bh, Cl = 0 | Bl, Bh = 0 | Ah, Bl = 0 | Al;
            const All = u64$1.add3L(T1l, sigma0l, MAJl);
            Ah = u64$1.add3H(All, T1h, sigma0h, MAJh), Al = 0 | All;
        }
        ({h: Ah, l: Al} = u64$1.add(0 | this.Ah, 0 | this.Al, 0 | Ah, 0 | Al)), ({h: Bh, l: Bl} = u64$1.add(0 | this.Bh, 0 | this.Bl, 0 | Bh, 0 | Bl)), 
        ({h: Ch, l: Cl} = u64$1.add(0 | this.Ch, 0 | this.Cl, 0 | Ch, 0 | Cl)), ({h: Dh, l: Dl} = u64$1.add(0 | this.Dh, 0 | this.Dl, 0 | Dh, 0 | Dl)), 
        ({h: Eh, l: El} = u64$1.add(0 | this.Eh, 0 | this.El, 0 | Eh, 0 | El)), ({h: Fh, l: Fl} = u64$1.add(0 | this.Fh, 0 | this.Fl, 0 | Fh, 0 | Fl)), 
        ({h: Gh, l: Gl} = u64$1.add(0 | this.Gh, 0 | this.Gl, 0 | Gh, 0 | Gl)), ({h: Hh, l: Hl} = u64$1.add(0 | this.Hh, 0 | this.Hl, 0 | Hh, 0 | Hl)), 
        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
    }
    roundClean() {
        SHA512_W_H.fill(0), SHA512_W_L.fill(0);
    }
    destroy() {
        this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
}

const sha512 = wrapConstructor((() => new SHA512)), _0n$4 = BigInt(0), _1n$6 = BigInt(1), _2n$4 = BigInt(2);

/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ function isBytes(a) {
    return a instanceof Uint8Array || null != a && "object" == typeof a && "Uint8Array" === a.constructor.name;
}

function abytes(item) {
    if (!isBytes(item)) throw new Error("Uint8Array expected");
}

function abool(title, value) {
    if ("boolean" != typeof value) throw new Error(`${title} must be valid boolean, got "${value}".`);
}

const hexes = Array.from({
    length: 256
}, ((_, i) => i.toString(16).padStart(2, "0")));

function bytesToHex(bytes) {
    abytes(bytes);
    let hex = "";
    for (let i = 0; i < bytes.length; i++) hex += hexes[bytes[i]];
    return hex;
}

function numberToHexUnpadded(num) {
    const hex = num.toString(16);
    return 1 & hex.length ? `0${hex}` : hex;
}

function hexToNumber(hex) {
    if ("string" != typeof hex) throw new Error("hex string expected, got " + typeof hex);
    return BigInt("" === hex ? "0" : `0x${hex}`);
}

const asciis = {
    _0: 48,
    _9: 57,
    _A: 65,
    _F: 70,
    _a: 97,
    _f: 102
};

function asciiToBase16(char) {
    return char >= asciis._0 && char <= asciis._9 ? char - asciis._0 : char >= asciis._A && char <= asciis._F ? char - (asciis._A - 10) : char >= asciis._a && char <= asciis._f ? char - (asciis._a - 10) : void 0;
}

function hexToBytes(hex) {
    if ("string" != typeof hex) throw new Error("hex string expected, got " + typeof hex);
    const hl = hex.length, al = hl / 2;
    if (hl % 2) throw new Error("padded hex string expected, got unpadded hex of length " + hl);
    const array = new Uint8Array(al);
    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
        const n1 = asciiToBase16(hex.charCodeAt(hi)), n2 = asciiToBase16(hex.charCodeAt(hi + 1));
        if (void 0 === n1 || void 0 === n2) {
            const char = hex[hi] + hex[hi + 1];
            throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
        }
        array[ai] = 16 * n1 + n2;
    }
    return array;
}

function bytesToNumberBE(bytes) {
    return hexToNumber(bytesToHex(bytes));
}

function bytesToNumberLE(bytes) {
    return abytes(bytes), hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));
}

function numberToBytesBE(n, len) {
    return hexToBytes(n.toString(16).padStart(2 * len, "0"));
}

function numberToBytesLE(n, len) {
    return numberToBytesBE(n, len).reverse();
}

function numberToVarBytesBE(n) {
    return hexToBytes(numberToHexUnpadded(n));
}

function ensureBytes(title, hex, expectedLength) {
    let res;
    if ("string" == typeof hex) try {
        res = hexToBytes(hex);
    } catch (e) {
        throw new Error(`${title} must be valid hex string, got "${hex}". Cause: ${e}`);
    } else {
        if (!isBytes(hex)) throw new Error(`${title} must be hex string or Uint8Array`);
        res = Uint8Array.from(hex);
    }
    const len = res.length;
    if ("number" == typeof expectedLength && len !== expectedLength) throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
    return res;
}

function concatBytes(...arrays) {
    let sum = 0;
    for (let i = 0; i < arrays.length; i++) {
        const a = arrays[i];
        abytes(a), sum += a.length;
    }
    const res = new Uint8Array(sum);
    for (let i = 0, pad = 0; i < arrays.length; i++) {
        const a = arrays[i];
        res.set(a, pad), pad += a.length;
    }
    return res;
}

function equalBytes(a, b) {
    if (a.length !== b.length) return !1;
    let diff = 0;
    for (let i = 0; i < a.length; i++) diff |= a[i] ^ b[i];
    return 0 === diff;
}

function utf8ToBytes(str) {
    if ("string" != typeof str) throw new Error("utf8ToBytes expected string, got " + typeof str);
    return new Uint8Array((new TextEncoder).encode(str));
}

const isPosBig = n => "bigint" == typeof n && _0n$4 <= n;

function inRange$1(n, min, max) {
    return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;
}

function aInRange(title, n, min, max) {
    if (!inRange$1(n, min, max)) throw new Error(`expected valid ${title}: ${min} <= n < ${max}, got ${typeof n} ${n}`);
}

function bitLen(n) {
    let len;
    for (len = 0; n > _0n$4; n >>= _1n$6, len += 1) ;
    return len;
}

function bitGet(n, pos) {
    return n >> BigInt(pos) & _1n$6;
}

function bitSet(n, pos, value) {
    return n | (value ? _1n$6 : _0n$4) << BigInt(pos);
}

const bitMask = n => (_2n$4 << BigInt(n - 1)) - _1n$6, u8n = data => new Uint8Array(data), u8fr = arr => Uint8Array.from(arr);

function createHmacDrbg(hashLen, qByteLen, hmacFn) {
    if ("number" != typeof hashLen || hashLen < 2) throw new Error("hashLen must be a number");
    if ("number" != typeof qByteLen || qByteLen < 2) throw new Error("qByteLen must be a number");
    if ("function" != typeof hmacFn) throw new Error("hmacFn must be a function");
    let v = u8n(hashLen), k = u8n(hashLen), i = 0;
    const reset = () => {
        v.fill(1), k.fill(0), i = 0;
    }, h = (...b) => hmacFn(k, v, ...b), reseed = (seed = u8n()) => {
        k = h(u8fr([ 0 ]), seed), v = h(), 0 !== seed.length && (k = h(u8fr([ 1 ]), seed), 
        v = h());
    }, gen = () => {
        if (i++ >= 1e3) throw new Error("drbg: tried 1000 values");
        let len = 0;
        const out = [];
        for (;len < qByteLen; ) {
            v = h();
            const sl = v.slice();
            out.push(sl), len += v.length;
        }
        return concatBytes(...out);
    };
    return (seed, pred) => {
        let res;
        for (reset(), reseed(seed); !(res = pred(gen())); ) reseed();
        return reset(), res;
    };
}

const validatorFns = {
    bigint: val => "bigint" == typeof val,
    function: val => "function" == typeof val,
    boolean: val => "boolean" == typeof val,
    string: val => "string" == typeof val,
    stringOrUint8Array: val => "string" == typeof val || isBytes(val),
    isSafeInteger: val => Number.isSafeInteger(val),
    array: val => Array.isArray(val),
    field: (val, object) => object.Fp.isValid(val),
    hash: val => "function" == typeof val && Number.isSafeInteger(val.outputLen)
};

function validateObject(object, validators, optValidators = {}) {
    const checkField = (fieldName, type, isOptional) => {
        const checkVal = validatorFns[type];
        if ("function" != typeof checkVal) throw new Error(`Invalid validator "${type}", expected function`);
        const val = object[fieldName];
        if (!(isOptional && void 0 === val || checkVal(val, object))) throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);
    };
    for (const [fieldName, type] of Object.entries(validators)) checkField(fieldName, type, !1);
    for (const [fieldName, type] of Object.entries(optValidators)) checkField(fieldName, type, !0);
    return object;
}

const notImplemented = () => {
    throw new Error("not implemented");
};

function memoized(fn) {
    const map = new WeakMap;
    return (arg, ...args) => {
        const val = map.get(arg);
        if (void 0 !== val) return val;
        const computed = fn(arg, ...args);
        return map.set(arg, computed), computed;
    };
}

var ut = Object.freeze({
    __proto__: null,
    aInRange: aInRange,
    abool: abool,
    abytes: abytes,
    bitGet: bitGet,
    bitLen: bitLen,
    bitMask: bitMask,
    bitSet: bitSet,
    bytesToHex: bytesToHex,
    bytesToNumberBE: bytesToNumberBE,
    bytesToNumberLE: bytesToNumberLE,
    concatBytes: concatBytes,
    createHmacDrbg: createHmacDrbg,
    ensureBytes: ensureBytes,
    equalBytes: equalBytes,
    hexToBytes: hexToBytes,
    hexToNumber: hexToNumber,
    inRange: inRange$1,
    isBytes: isBytes,
    memoized: memoized,
    notImplemented: notImplemented,
    numberToBytesBE: numberToBytesBE,
    numberToBytesLE: numberToBytesLE,
    numberToHexUnpadded: numberToHexUnpadded,
    numberToVarBytesBE: numberToVarBytesBE,
    utf8ToBytes: utf8ToBytes,
    validateObject: validateObject
});

/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const _0n$3 = BigInt(0), _1n$5 = BigInt(1), _2n$3 = BigInt(2), _3n$1 = BigInt(3), _4n = BigInt(4), _5n$1 = BigInt(5), _8n$2 = BigInt(8);

function mod(a, b) {
    const result = a % b;
    return result >= _0n$3 ? result : b + result;
}

function pow(num, power, modulo) {
    if (modulo <= _0n$3 || power < _0n$3) throw new Error("Expected power/modulo > 0");
    if (modulo === _1n$5) return _0n$3;
    let res = _1n$5;
    for (;power > _0n$3; ) power & _1n$5 && (res = res * num % modulo), num = num * num % modulo, 
    power >>= _1n$5;
    return res;
}

function pow2(x, power, modulo) {
    let res = x;
    for (;power-- > _0n$3; ) res *= res, res %= modulo;
    return res;
}

function invert(number, modulo) {
    if (number === _0n$3 || modulo <= _0n$3) throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);
    let a = mod(number, modulo), b = modulo, x = _0n$3, u = _1n$5;
    for (;a !== _0n$3; ) {
        const r = b % a, m = x - u * (b / a);
        b = a, a = r, x = u, u = m;
    }
    if (b !== _1n$5) throw new Error("invert: does not exist");
    return mod(x, modulo);
}

function tonelliShanks(P) {
    const legendreC = (P - _1n$5) / _2n$3;
    let Q, S, Z;
    for (Q = P - _1n$5, S = 0; Q % _2n$3 === _0n$3; Q /= _2n$3, S++) ;
    for (Z = _2n$3; Z < P && pow(Z, legendreC, P) !== P - _1n$5; Z++) ;
    if (1 === S) {
        const p1div4 = (P + _1n$5) / _4n;
        return function(Fp, n) {
            const root = Fp.pow(n, p1div4);
            if (!Fp.eql(Fp.sqr(root), n)) throw new Error("Cannot find square root");
            return root;
        };
    }
    const Q1div2 = (Q + _1n$5) / _2n$3;
    return function(Fp, n) {
        if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE)) throw new Error("Cannot find square root");
        let r = S, g = Fp.pow(Fp.mul(Fp.ONE, Z), Q), x = Fp.pow(n, Q1div2), b = Fp.pow(n, Q);
        for (;!Fp.eql(b, Fp.ONE); ) {
            if (Fp.eql(b, Fp.ZERO)) return Fp.ZERO;
            let m = 1;
            for (let t2 = Fp.sqr(b); m < r && !Fp.eql(t2, Fp.ONE); m++) t2 = Fp.sqr(t2);
            const ge = Fp.pow(g, _1n$5 << BigInt(r - m - 1));
            g = Fp.sqr(ge), x = Fp.mul(x, ge), b = Fp.mul(b, g), r = m;
        }
        return x;
    };
}

function FpSqrt(P) {
    if (P % _4n === _3n$1) {
        const p1div4 = (P + _1n$5) / _4n;
        return function(Fp, n) {
            const root = Fp.pow(n, p1div4);
            if (!Fp.eql(Fp.sqr(root), n)) throw new Error("Cannot find square root");
            return root;
        };
    }
    if (P % _8n$2 === _5n$1) {
        const c1 = (P - _5n$1) / _8n$2;
        return function(Fp, n) {
            const n2 = Fp.mul(n, _2n$3), v = Fp.pow(n2, c1), nv = Fp.mul(n, v), i = Fp.mul(Fp.mul(nv, _2n$3), v), root = Fp.mul(nv, Fp.sub(i, Fp.ONE));
            if (!Fp.eql(Fp.sqr(root), n)) throw new Error("Cannot find square root");
            return root;
        };
    }
    return tonelliShanks(P);
}

BigInt(9), BigInt(16);

const isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n$5) === _1n$5, FIELD_FIELDS = [ "create", "isValid", "is0", "neg", "inv", "sqrt", "sqr", "eql", "add", "sub", "mul", "pow", "div", "addN", "subN", "mulN", "sqrN" ];

function validateField(field) {
    const opts = FIELD_FIELDS.reduce(((map, val) => (map[val] = "function", map)), {
        ORDER: "bigint",
        MASK: "bigint",
        BYTES: "isSafeInteger",
        BITS: "isSafeInteger"
    });
    return validateObject(field, opts);
}

function FpPow(f, num, power) {
    if (power < _0n$3) throw new Error("Expected power > 0");
    if (power === _0n$3) return f.ONE;
    if (power === _1n$5) return num;
    let p = f.ONE, d = num;
    for (;power > _0n$3; ) power & _1n$5 && (p = f.mul(p, d)), d = f.sqr(d), power >>= _1n$5;
    return p;
}

function FpInvertBatch(f, nums) {
    const tmp = new Array(nums.length), lastMultiplied = nums.reduce(((acc, num, i) => f.is0(num) ? acc : (tmp[i] = acc, 
    f.mul(acc, num))), f.ONE), inverted = f.inv(lastMultiplied);
    return nums.reduceRight(((acc, num, i) => f.is0(num) ? acc : (tmp[i] = f.mul(acc, tmp[i]), 
    f.mul(acc, num))), inverted), tmp;
}

function nLength(n, nBitLength) {
    const _nBitLength = void 0 !== nBitLength ? nBitLength : n.toString(2).length;
    return {
        nBitLength: _nBitLength,
        nByteLength: Math.ceil(_nBitLength / 8)
    };
}

function Field(ORDER, bitLen, isLE = !1, redef = {}) {
    if (ORDER <= _0n$3) throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
    const {nBitLength: BITS, nByteLength: BYTES} = nLength(ORDER, bitLen);
    if (BYTES > 2048) throw new Error("Field lengths over 2048 bytes are not supported");
    const sqrtP = FpSqrt(ORDER), f = Object.freeze({
        ORDER: ORDER,
        BITS: BITS,
        BYTES: BYTES,
        MASK: bitMask(BITS),
        ZERO: _0n$3,
        ONE: _1n$5,
        create: num => mod(num, ORDER),
        isValid: num => {
            if ("bigint" != typeof num) throw new Error("Invalid field element: expected bigint, got " + typeof num);
            return _0n$3 <= num && num < ORDER;
        },
        is0: num => num === _0n$3,
        isOdd: num => (num & _1n$5) === _1n$5,
        neg: num => mod(-num, ORDER),
        eql: (lhs, rhs) => lhs === rhs,
        sqr: num => mod(num * num, ORDER),
        add: (lhs, rhs) => mod(lhs + rhs, ORDER),
        sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
        mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
        pow: (num, power) => FpPow(f, num, power),
        div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
        sqrN: num => num * num,
        addN: (lhs, rhs) => lhs + rhs,
        subN: (lhs, rhs) => lhs - rhs,
        mulN: (lhs, rhs) => lhs * rhs,
        inv: num => invert(num, ORDER),
        sqrt: redef.sqrt || (n => sqrtP(f, n)),
        invertBatch: lst => FpInvertBatch(f, lst),
        cmov: (a, b, c) => c ? b : a,
        toBytes: num => isLE ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES),
        fromBytes: bytes => {
            if (bytes.length !== BYTES) throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);
            return isLE ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);
        }
    });
    return Object.freeze(f);
}

function getFieldBytesLength(fieldOrder) {
    if ("bigint" != typeof fieldOrder) throw new Error("field order must be bigint");
    const bitLength = fieldOrder.toString(2).length;
    return Math.ceil(bitLength / 8);
}

function getMinHashLength(fieldOrder) {
    const length = getFieldBytesLength(fieldOrder);
    return length + Math.ceil(length / 2);
}

function mapHashToField(key, fieldOrder, isLE = !1) {
    const len = key.length, fieldLen = getFieldBytesLength(fieldOrder), minLen = getMinHashLength(fieldOrder);
    if (len < 16 || len < minLen || len > 1024) throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);
    const reduced = mod(isLE ? bytesToNumberBE(key) : bytesToNumberLE(key), fieldOrder - _1n$5) + _1n$5;
    return isLE ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);
}

/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const _0n$2 = BigInt(0), _1n$4 = BigInt(1), pointPrecomputes = new WeakMap, pointWindowSizes = new WeakMap;

function wNAF(c, bits) {
    const constTimeNegate = (condition, item) => {
        const neg = item.negate();
        return condition ? neg : item;
    }, validateW = W => {
        if (!Number.isSafeInteger(W) || W <= 0 || W > bits) throw new Error(`Wrong window size=${W}, should be [1..${bits}]`);
    }, opts = W => {
        validateW(W);
        return {
            windows: Math.ceil(bits / W) + 1,
            windowSize: 2 ** (W - 1)
        };
    };
    return {
        constTimeNegate: constTimeNegate,
        unsafeLadder(elm, n) {
            let p = c.ZERO, d = elm;
            for (;n > _0n$2; ) n & _1n$4 && (p = p.add(d)), d = d.double(), n >>= _1n$4;
            return p;
        },
        precomputeWindow(elm, W) {
            const {windows: windows, windowSize: windowSize} = opts(W), points = [];
            let p = elm, base = p;
            for (let window = 0; window < windows; window++) {
                base = p, points.push(base);
                for (let i = 1; i < windowSize; i++) base = base.add(p), points.push(base);
                p = base.double();
            }
            return points;
        },
        wNAF(W, precomputes, n) {
            const {windows: windows, windowSize: windowSize} = opts(W);
            let p = c.ZERO, f = c.BASE;
            const mask = BigInt(2 ** W - 1), maxNumber = 2 ** W, shiftBy = BigInt(W);
            for (let window = 0; window < windows; window++) {
                const offset = window * windowSize;
                let wbits = Number(n & mask);
                n >>= shiftBy, wbits > windowSize && (wbits -= maxNumber, n += _1n$4);
                const offset1 = offset, offset2 = offset + Math.abs(wbits) - 1, cond1 = window % 2 != 0, cond2 = wbits < 0;
                0 === wbits ? f = f.add(constTimeNegate(cond1, precomputes[offset1])) : p = p.add(constTimeNegate(cond2, precomputes[offset2]));
            }
            return {
                p: p,
                f: f
            };
        },
        wNAFCached(P, n, transform) {
            const W = pointWindowSizes.get(P) || 1;
            let comp = pointPrecomputes.get(P);
            return comp || (comp = this.precomputeWindow(P, W), 1 !== W && pointPrecomputes.set(P, transform(comp))), 
            this.wNAF(W, comp, n);
        },
        setWindowSize(P, W) {
            validateW(W), pointWindowSizes.set(P, W), pointPrecomputes.delete(P);
        }
    };
}

function pippenger(c, field, points, scalars) {
    if (!Array.isArray(points) || !Array.isArray(scalars) || scalars.length !== points.length) throw new Error("arrays of points and scalars must have equal length");
    scalars.forEach(((s, i) => {
        if (!field.isValid(s)) throw new Error(`wrong scalar at index ${i}`);
    })), points.forEach(((p, i) => {
        if (!(p instanceof c)) throw new Error(`wrong point at index ${i}`);
    }));
    const wbits = bitLen(BigInt(points.length)), windowSize = wbits > 12 ? wbits - 3 : wbits > 4 ? wbits - 2 : wbits ? 2 : 1, MASK = (1 << windowSize) - 1, buckets = new Array(MASK + 1).fill(c.ZERO), lastBits = Math.floor((field.BITS - 1) / windowSize) * windowSize;
    let sum = c.ZERO;
    for (let i = lastBits; i >= 0; i -= windowSize) {
        buckets.fill(c.ZERO);
        for (let j = 0; j < scalars.length; j++) {
            const scalar = scalars[j], wbits = Number(scalar >> BigInt(i) & BigInt(MASK));
            buckets[wbits] = buckets[wbits].add(points[j]);
        }
        let resI = c.ZERO;
        for (let j = buckets.length - 1, sumI = c.ZERO; j > 0; j--) sumI = sumI.add(buckets[j]), 
        resI = resI.add(sumI);
        if (sum = sum.add(resI), 0 !== i) for (let j = 0; j < windowSize; j++) sum = sum.double();
    }
    return sum;
}

function validateBasic(curve) {
    return validateField(curve.Fp), validateObject(curve, {
        n: "bigint",
        h: "bigint",
        Gx: "field",
        Gy: "field"
    }, {
        nBitLength: "isSafeInteger",
        nByteLength: "isSafeInteger"
    }), Object.freeze({
        ...nLength(curve.n, curve.nBitLength),
        ...curve,
        p: curve.Fp.ORDER
    });
}

/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const _0n$1 = BigInt(0), _1n$3 = BigInt(1), _2n$2 = BigInt(2), _8n$1 = BigInt(8), VERIFY_DEFAULT = {
    zip215: !0
};

function validateOpts$1(curve) {
    const opts = validateBasic(curve);
    return validateObject(curve, {
        hash: "function",
        a: "bigint",
        d: "bigint",
        randomBytes: "function"
    }, {
        adjustScalarBytes: "function",
        domain: "function",
        uvRatio: "function",
        mapToCurve: "function"
    }), Object.freeze({
        ...opts
    });
}

function twistedEdwards(curveDef) {
    const CURVE = validateOpts$1(curveDef), {Fp: Fp, n: CURVE_ORDER, prehash: prehash, hash: cHash, randomBytes: randomBytes, nByteLength: nByteLength, h: cofactor} = CURVE, MASK = _2n$2 << BigInt(8 * nByteLength) - _1n$3, modP = Fp.create, Fn = Field(CURVE.n, CURVE.nBitLength), uvRatio = CURVE.uvRatio || ((u, v) => {
        try {
            return {
                isValid: !0,
                value: Fp.sqrt(u * Fp.inv(v))
            };
        } catch (e) {
            return {
                isValid: !1,
                value: _0n$1
            };
        }
    }), adjustScalarBytes = CURVE.adjustScalarBytes || (bytes => bytes), domain = CURVE.domain || ((data, ctx, phflag) => {
        if (abool("phflag", phflag), ctx.length || phflag) throw new Error("Contexts/pre-hash are not supported");
        return data;
    });
    function aCoordinate(title, n) {
        aInRange("coordinate " + title, n, _0n$1, MASK);
    }
    function assertPoint(other) {
        if (!(other instanceof Point)) throw new Error("ExtendedPoint expected");
    }
    const toAffineMemo = memoized(((p, iz) => {
        const {ex: x, ey: y, ez: z} = p, is0 = p.is0();
        null == iz && (iz = is0 ? _8n$1 : Fp.inv(z));
        const ax = modP(x * iz), ay = modP(y * iz), zz = modP(z * iz);
        if (is0) return {
            x: _0n$1,
            y: _1n$3
        };
        if (zz !== _1n$3) throw new Error("invZ was invalid");
        return {
            x: ax,
            y: ay
        };
    })), assertValidMemo = memoized((p => {
        const {a: a, d: d} = CURVE;
        if (p.is0()) throw new Error("bad point: ZERO");
        const {ex: X, ey: Y, ez: Z, et: T} = p, X2 = modP(X * X), Y2 = modP(Y * Y), Z2 = modP(Z * Z), Z4 = modP(Z2 * Z2), aX2 = modP(X2 * a);
        if (modP(Z2 * modP(aX2 + Y2)) !== modP(Z4 + modP(d * modP(X2 * Y2)))) throw new Error("bad point: equation left != right (1)");
        if (modP(X * Y) !== modP(Z * T)) throw new Error("bad point: equation left != right (2)");
        return !0;
    }));
    class Point {
        constructor(ex, ey, ez, et) {
            this.ex = ex, this.ey = ey, this.ez = ez, this.et = et, aCoordinate("x", ex), aCoordinate("y", ey), 
            aCoordinate("z", ez), aCoordinate("t", et), Object.freeze(this);
        }
        get x() {
            return this.toAffine().x;
        }
        get y() {
            return this.toAffine().y;
        }
        static fromAffine(p) {
            if (p instanceof Point) throw new Error("extended point not allowed");
            const {x: x, y: y} = p || {};
            return aCoordinate("x", x), aCoordinate("y", y), new Point(x, y, _1n$3, modP(x * y));
        }
        static normalizeZ(points) {
            const toInv = Fp.invertBatch(points.map((p => p.ez)));
            return points.map(((p, i) => p.toAffine(toInv[i]))).map(Point.fromAffine);
        }
        static msm(points, scalars) {
            return pippenger(Point, Fn, points, scalars);
        }
        _setWindowSize(windowSize) {
            wnaf.setWindowSize(this, windowSize);
        }
        assertValidity() {
            assertValidMemo(this);
        }
        equals(other) {
            assertPoint(other);
            const {ex: X1, ey: Y1, ez: Z1} = this, {ex: X2, ey: Y2, ez: Z2} = other, X1Z2 = modP(X1 * Z2), X2Z1 = modP(X2 * Z1), Y1Z2 = modP(Y1 * Z2), Y2Z1 = modP(Y2 * Z1);
            return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
        }
        is0() {
            return this.equals(Point.ZERO);
        }
        negate() {
            return new Point(modP(-this.ex), this.ey, this.ez, modP(-this.et));
        }
        double() {
            const {a: a} = CURVE, {ex: X1, ey: Y1, ez: Z1} = this, A = modP(X1 * X1), B = modP(Y1 * Y1), C = modP(_2n$2 * modP(Z1 * Z1)), D = modP(a * A), x1y1 = X1 + Y1, E = modP(modP(x1y1 * x1y1) - A - B), G = D + B, F = G - C, H = D - B, X3 = modP(E * F), Y3 = modP(G * H), T3 = modP(E * H), Z3 = modP(F * G);
            return new Point(X3, Y3, Z3, T3);
        }
        add(other) {
            assertPoint(other);
            const {a: a, d: d} = CURVE, {ex: X1, ey: Y1, ez: Z1, et: T1} = this, {ex: X2, ey: Y2, ez: Z2, et: T2} = other;
            if (a === BigInt(-1)) {
                const A = modP((Y1 - X1) * (Y2 + X2)), B = modP((Y1 + X1) * (Y2 - X2)), F = modP(B - A);
                if (F === _0n$1) return this.double();
                const C = modP(Z1 * _2n$2 * T2), D = modP(T1 * _2n$2 * Z2), E = D + C, G = B + A, H = D - C, X3 = modP(E * F), Y3 = modP(G * H), T3 = modP(E * H), Z3 = modP(F * G);
                return new Point(X3, Y3, Z3, T3);
            }
            const A = modP(X1 * X2), B = modP(Y1 * Y2), C = modP(T1 * d * T2), D = modP(Z1 * Z2), E = modP((X1 + Y1) * (X2 + Y2) - A - B), F = D - C, G = D + C, H = modP(B - a * A), X3 = modP(E * F), Y3 = modP(G * H), T3 = modP(E * H), Z3 = modP(F * G);
            return new Point(X3, Y3, Z3, T3);
        }
        subtract(other) {
            return this.add(other.negate());
        }
        wNAF(n) {
            return wnaf.wNAFCached(this, n, Point.normalizeZ);
        }
        multiply(scalar) {
            const n = scalar;
            aInRange("scalar", n, _1n$3, CURVE_ORDER);
            const {p: p, f: f} = this.wNAF(n);
            return Point.normalizeZ([ p, f ])[0];
        }
        multiplyUnsafe(scalar) {
            const n = scalar;
            return aInRange("scalar", n, _0n$1, CURVE_ORDER), n === _0n$1 ? I : this.equals(I) || n === _1n$3 ? this : this.equals(G) ? this.wNAF(n).p : wnaf.unsafeLadder(this, n);
        }
        isSmallOrder() {
            return this.multiplyUnsafe(cofactor).is0();
        }
        isTorsionFree() {
            return wnaf.unsafeLadder(this, CURVE_ORDER).is0();
        }
        toAffine(iz) {
            return toAffineMemo(this, iz);
        }
        clearCofactor() {
            const {h: cofactor} = CURVE;
            return cofactor === _1n$3 ? this : this.multiplyUnsafe(cofactor);
        }
        static fromHex(hex, zip215 = !1) {
            const {d: d, a: a} = CURVE, len = Fp.BYTES;
            hex = ensureBytes("pointHex", hex, len), abool("zip215", zip215);
            const normed = hex.slice(), lastByte = hex[len - 1];
            normed[len - 1] = -129 & lastByte;
            const y = bytesToNumberLE(normed), max = zip215 ? MASK : Fp.ORDER;
            aInRange("pointHex.y", y, _0n$1, max);
            const y2 = modP(y * y), u = modP(y2 - _1n$3), v = modP(d * y2 - a);
            let {isValid: isValid, value: x} = uvRatio(u, v);
            if (!isValid) throw new Error("Point.fromHex: invalid y coordinate");
            const isXOdd = (x & _1n$3) === _1n$3, isLastByteOdd = !!(128 & lastByte);
            if (!zip215 && x === _0n$1 && isLastByteOdd) throw new Error("Point.fromHex: x=0 and x_0=1");
            return isLastByteOdd !== isXOdd && (x = modP(-x)), Point.fromAffine({
                x: x,
                y: y
            });
        }
        static fromPrivateKey(privKey) {
            return getExtendedPublicKey(privKey).point;
        }
        toRawBytes() {
            const {x: x, y: y} = this.toAffine(), bytes = numberToBytesLE(y, Fp.BYTES);
            return bytes[bytes.length - 1] |= x & _1n$3 ? 128 : 0, bytes;
        }
        toHex() {
            return bytesToHex(this.toRawBytes());
        }
    }
    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, _1n$3, modP(CURVE.Gx * CURVE.Gy)), Point.ZERO = new Point(_0n$1, _1n$3, _1n$3, _0n$1);
    const {BASE: G, ZERO: I} = Point, wnaf = wNAF(Point, 8 * nByteLength);
    function modN(a) {
        return mod(a, CURVE_ORDER);
    }
    function modN_LE(hash) {
        return modN(bytesToNumberLE(hash));
    }
    function getExtendedPublicKey(key) {
        const len = nByteLength;
        key = ensureBytes("private key", key, len);
        const hashed = ensureBytes("hashed private key", cHash(key), 2 * len), head = adjustScalarBytes(hashed.slice(0, len)), prefix = hashed.slice(len, 2 * len), scalar = modN_LE(head), point = G.multiply(scalar), pointBytes = point.toRawBytes();
        return {
            head: head,
            prefix: prefix,
            scalar: scalar,
            point: point,
            pointBytes: pointBytes
        };
    }
    function hashDomainToScalar(context = new Uint8Array, ...msgs) {
        const msg = concatBytes(...msgs);
        return modN_LE(cHash(domain(msg, ensureBytes("context", context), !!prehash)));
    }
    const verifyOpts = VERIFY_DEFAULT;
    G._setWindowSize(8);
    const utils = {
        getExtendedPublicKey: getExtendedPublicKey,
        randomPrivateKey: () => randomBytes(Fp.BYTES),
        precompute: (windowSize = 8, point = Point.BASE) => (point._setWindowSize(windowSize), 
        point.multiply(BigInt(3)), point)
    };
    return {
        CURVE: CURVE,
        getPublicKey: function(privKey) {
            return getExtendedPublicKey(privKey).pointBytes;
        },
        sign: function(msg, privKey, options = {}) {
            msg = ensureBytes("message", msg), prehash && (msg = prehash(msg));
            const {prefix: prefix, scalar: scalar, pointBytes: pointBytes} = getExtendedPublicKey(privKey), r = hashDomainToScalar(options.context, prefix, msg), R = G.multiply(r).toRawBytes(), s = modN(r + hashDomainToScalar(options.context, R, pointBytes, msg) * scalar);
            return aInRange("signature.s", s, _0n$1, CURVE_ORDER), ensureBytes("result", concatBytes(R, numberToBytesLE(s, Fp.BYTES)), 2 * nByteLength);
        },
        verify: function(sig, msg, publicKey, options = verifyOpts) {
            const {context: context, zip215: zip215} = options, len = Fp.BYTES;
            sig = ensureBytes("signature", sig, 2 * len), msg = ensureBytes("message", msg), 
            void 0 !== zip215 && abool("zip215", zip215), prehash && (msg = prehash(msg));
            const s = bytesToNumberLE(sig.slice(len, 2 * len));
            let A, R, SB;
            try {
                A = Point.fromHex(publicKey, zip215), R = Point.fromHex(sig.slice(0, len), zip215), 
                SB = G.multiplyUnsafe(s);
            } catch (error) {
                return !1;
            }
            if (!zip215 && A.isSmallOrder()) return !1;
            const k = hashDomainToScalar(context, R.toRawBytes(), A.toRawBytes(), msg);
            return R.add(A.multiplyUnsafe(k)).subtract(SB).clearCofactor().equals(Point.ZERO);
        },
        ExtendedPoint: Point,
        utils: utils
    };
}

/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const ED25519_P = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"), ED25519_SQRT_M1 = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");

BigInt(0);

const _1n$2 = BigInt(1), _2n$1 = BigInt(2);

BigInt(3);

const _5n = BigInt(5), _8n = BigInt(8);

function ed25519_pow_2_252_3(x) {
    const _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80), P = ED25519_P, b2 = x * x % P * x % P, b4 = pow2(b2, _2n$1, P) * b2 % P, b5 = pow2(b4, _1n$2, P) * x % P, b10 = pow2(b5, _5n, P) * b5 % P, b20 = pow2(b10, _10n, P) * b10 % P, b40 = pow2(b20, _20n, P) * b20 % P, b80 = pow2(b40, _40n, P) * b40 % P, b160 = pow2(b80, _80n, P) * b80 % P, b240 = pow2(b160, _80n, P) * b80 % P, b250 = pow2(b240, _10n, P) * b10 % P;
    return {
        pow_p_5_8: pow2(b250, _2n$1, P) * x % P,
        b2: b2
    };
}

function adjustScalarBytes(bytes) {
    return bytes[0] &= 248, bytes[31] &= 127, bytes[31] |= 64, bytes;
}

function uvRatio(u, v) {
    const P = ED25519_P, v3 = mod(v * v * v, P), v7 = mod(v3 * v3 * v, P);
    let x = mod(u * v3 * ed25519_pow_2_252_3(u * v7).pow_p_5_8, P);
    const vx2 = mod(v * x * x, P), root1 = x, root2 = mod(x * ED25519_SQRT_M1, P), useRoot1 = vx2 === u, useRoot2 = vx2 === mod(-u, P), noRoot = vx2 === mod(-u * ED25519_SQRT_M1, P);
    return useRoot1 && (x = root1), (useRoot2 || noRoot) && (x = root2), isNegativeLE(x, P) && (x = mod(-x, P)), 
    {
        isValid: useRoot1 || useRoot2,
        value: x
    };
}

const Fp$1 = (() => Field(ED25519_P, void 0, !0))(), ed25519Defaults = (() => ({
    a: BigInt(-1),
    d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),
    Fp: Fp$1,
    n: BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),
    h: _8n,
    Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),
    Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),
    hash: sha512,
    randomBytes: randomBytes,
    adjustScalarBytes: adjustScalarBytes,
    uvRatio: uvRatio
}))(), ed25519 = (() => twistedEdwards(ed25519Defaults))();

var bn$1 = {
    exports: {}
}, bn = bn$1.exports, hasRequiredBn;

function requireBn() {
    return hasRequiredBn || (hasRequiredBn = 1, function(module, exports) {
        function assert(val, msg) {
            if (!val) throw new Error(msg || "Assertion failed");
        }
        function inherits(ctor, superCtor) {
            ctor.super_ = superCtor;
            var TempCtor = function() {};
            TempCtor.prototype = superCtor.prototype, ctor.prototype = new TempCtor, ctor.prototype.constructor = ctor;
        }
        function BN(number, base, endian) {
            if (BN.isBN(number)) return number;
            this.negative = 0, this.words = null, this.length = 0, this.red = null, null !== number && ("le" !== base && "be" !== base || (endian = base, 
            base = 10), this._init(number || 0, base || 10, endian || "be"));
        }
        var Buffer;
        "object" == typeof module ? module.exports = BN : exports.BN = BN, BN.BN = BN, BN.wordSize = 26;
        try {
            Buffer = "undefined" != typeof window && void 0 !== window.Buffer ? window.Buffer : require("buffer").Buffer;
        } catch (e) {}
        function parseHex4Bits(string, index) {
            var c = string.charCodeAt(index);
            return c >= 48 && c <= 57 ? c - 48 : c >= 65 && c <= 70 ? c - 55 : c >= 97 && c <= 102 ? c - 87 : void assert(!1, "Invalid character in " + string);
        }
        function parseHexByte(string, lowerBound, index) {
            var r = parseHex4Bits(string, index);
            return index - 1 >= lowerBound && (r |= parseHex4Bits(string, index - 1) << 4), 
            r;
        }
        function parseBase(str, start, end, mul) {
            for (var r = 0, b = 0, len = Math.min(str.length, end), i = start; i < len; i++) {
                var c = str.charCodeAt(i) - 48;
                r *= mul, b = c >= 49 ? c - 49 + 10 : c >= 17 ? c - 17 + 10 : c, assert(c >= 0 && b < mul, "Invalid character"), 
                r += b;
            }
            return r;
        }
        function move(dest, src) {
            dest.words = src.words, dest.length = src.length, dest.negative = src.negative, 
            dest.red = src.red;
        }
        if (BN.isBN = function(num) {
            return num instanceof BN || null !== num && "object" == typeof num && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
        }, BN.max = function(left, right) {
            return left.cmp(right) > 0 ? left : right;
        }, BN.min = function(left, right) {
            return left.cmp(right) < 0 ? left : right;
        }, BN.prototype._init = function(number, base, endian) {
            if ("number" == typeof number) return this._initNumber(number, base, endian);
            if ("object" == typeof number) return this._initArray(number, base, endian);
            "hex" === base && (base = 16), assert(base === (0 | base) && base >= 2 && base <= 36);
            var start = 0;
            "-" === (number = number.toString().replace(/\s+/g, ""))[0] && (start++, this.negative = 1), 
            start < number.length && (16 === base ? this._parseHex(number, start, endian) : (this._parseBase(number, base, start), 
            "le" === endian && this._initArray(this.toArray(), base, endian)));
        }, BN.prototype._initNumber = function(number, base, endian) {
            number < 0 && (this.negative = 1, number = -number), number < 67108864 ? (this.words = [ 67108863 & number ], 
            this.length = 1) : number < 4503599627370496 ? (this.words = [ 67108863 & number, number / 67108864 & 67108863 ], 
            this.length = 2) : (assert(number < 9007199254740992), this.words = [ 67108863 & number, number / 67108864 & 67108863, 1 ], 
            this.length = 3), "le" === endian && this._initArray(this.toArray(), base, endian);
        }, BN.prototype._initArray = function(number, base, endian) {
            if (assert("number" == typeof number.length), number.length <= 0) return this.words = [ 0 ], 
            this.length = 1, this;
            this.length = Math.ceil(number.length / 3), this.words = new Array(this.length);
            for (var i = 0; i < this.length; i++) this.words[i] = 0;
            var j, w, off = 0;
            if ("be" === endian) for (i = number.length - 1, j = 0; i >= 0; i -= 3) w = number[i] | number[i - 1] << 8 | number[i - 2] << 16, 
            this.words[j] |= w << off & 67108863, this.words[j + 1] = w >>> 26 - off & 67108863, 
            (off += 24) >= 26 && (off -= 26, j++); else if ("le" === endian) for (i = 0, j = 0; i < number.length; i += 3) w = number[i] | number[i + 1] << 8 | number[i + 2] << 16, 
            this.words[j] |= w << off & 67108863, this.words[j + 1] = w >>> 26 - off & 67108863, 
            (off += 24) >= 26 && (off -= 26, j++);
            return this._strip();
        }, BN.prototype._parseHex = function(number, start, endian) {
            this.length = Math.ceil((number.length - start) / 6), this.words = new Array(this.length);
            for (var i = 0; i < this.length; i++) this.words[i] = 0;
            var w, off = 0, j = 0;
            if ("be" === endian) for (i = number.length - 1; i >= start; i -= 2) w = parseHexByte(number, start, i) << off, 
            this.words[j] |= 67108863 & w, off >= 18 ? (off -= 18, j += 1, this.words[j] |= w >>> 26) : off += 8; else for (i = (number.length - start) % 2 == 0 ? start + 1 : start; i < number.length; i += 2) w = parseHexByte(number, start, i) << off, 
            this.words[j] |= 67108863 & w, off >= 18 ? (off -= 18, j += 1, this.words[j] |= w >>> 26) : off += 8;
            this._strip();
        }, BN.prototype._parseBase = function(number, base, start) {
            this.words = [ 0 ], this.length = 1;
            for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) limbLen++;
            limbLen--, limbPow = limbPow / base | 0;
            for (var total = number.length - start, mod = total % limbLen, end = Math.min(total, total - mod) + start, word = 0, i = start; i < end; i += limbLen) word = parseBase(number, i, i + limbLen, base), 
            this.imuln(limbPow), this.words[0] + word < 67108864 ? this.words[0] += word : this._iaddn(word);
            if (0 !== mod) {
                var pow = 1;
                for (word = parseBase(number, i, number.length, base), i = 0; i < mod; i++) pow *= base;
                this.imuln(pow), this.words[0] + word < 67108864 ? this.words[0] += word : this._iaddn(word);
            }
            this._strip();
        }, BN.prototype.copy = function(dest) {
            dest.words = new Array(this.length);
            for (var i = 0; i < this.length; i++) dest.words[i] = this.words[i];
            dest.length = this.length, dest.negative = this.negative, dest.red = this.red;
        }, BN.prototype._move = function(dest) {
            move(dest, this);
        }, BN.prototype.clone = function() {
            var r = new BN(null);
            return this.copy(r), r;
        }, BN.prototype._expand = function(size) {
            for (;this.length < size; ) this.words[this.length++] = 0;
            return this;
        }, BN.prototype._strip = function() {
            for (;this.length > 1 && 0 === this.words[this.length - 1]; ) this.length--;
            return this._normSign();
        }, BN.prototype._normSign = function() {
            return 1 === this.length && 0 === this.words[0] && (this.negative = 0), this;
        }, "undefined" != typeof Symbol && "function" == typeof Symbol.for) try {
            BN.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect;
        } catch (e) {
            BN.prototype.inspect = inspect;
        } else BN.prototype.inspect = inspect;
        function inspect() {
            return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
        }
        var zeros = [ "", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000" ], groupSizes = [ 0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 ], groupBases = [ 0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176 ];
        function smallMulTo(self, num, out) {
            out.negative = num.negative ^ self.negative;
            var len = self.length + num.length | 0;
            out.length = len, len = len - 1 | 0;
            var a = 0 | self.words[0], b = 0 | num.words[0], r = a * b, lo = 67108863 & r, carry = r / 67108864 | 0;
            out.words[0] = lo;
            for (var k = 1; k < len; k++) {
                for (var ncarry = carry >>> 26, rword = 67108863 & carry, maxJ = Math.min(k, num.length - 1), j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
                    var i = k - j | 0;
                    ncarry += (r = (a = 0 | self.words[i]) * (b = 0 | num.words[j]) + rword) / 67108864 | 0, 
                    rword = 67108863 & r;
                }
                out.words[k] = 0 | rword, carry = 0 | ncarry;
            }
            return 0 !== carry ? out.words[k] = 0 | carry : out.length--, out._strip();
        }
        BN.prototype.toString = function(base, padding) {
            var out;
            if (padding = 0 | padding || 1, 16 === (base = base || 10) || "hex" === base) {
                out = "";
                for (var off = 0, carry = 0, i = 0; i < this.length; i++) {
                    var w = this.words[i], word = (16777215 & (w << off | carry)).toString(16);
                    carry = w >>> 24 - off & 16777215, (off += 2) >= 26 && (off -= 26, i--), out = 0 !== carry || i !== this.length - 1 ? zeros[6 - word.length] + word + out : word + out;
                }
                for (0 !== carry && (out = carry.toString(16) + out); out.length % padding != 0; ) out = "0" + out;
                return 0 !== this.negative && (out = "-" + out), out;
            }
            if (base === (0 | base) && base >= 2 && base <= 36) {
                var groupSize = groupSizes[base], groupBase = groupBases[base];
                out = "";
                var c = this.clone();
                for (c.negative = 0; !c.isZero(); ) {
                    var r = c.modrn(groupBase).toString(base);
                    out = (c = c.idivn(groupBase)).isZero() ? r + out : zeros[groupSize - r.length] + r + out;
                }
                for (this.isZero() && (out = "0" + out); out.length % padding != 0; ) out = "0" + out;
                return 0 !== this.negative && (out = "-" + out), out;
            }
            assert(!1, "Base should be between 2 and 36");
        }, BN.prototype.toNumber = function() {
            var ret = this.words[0];
            return 2 === this.length ? ret += 67108864 * this.words[1] : 3 === this.length && 1 === this.words[2] ? ret += 4503599627370496 + 67108864 * this.words[1] : this.length > 2 && assert(!1, "Number can only safely store up to 53 bits"), 
            0 !== this.negative ? -ret : ret;
        }, BN.prototype.toJSON = function() {
            return this.toString(16, 2);
        }, Buffer && (BN.prototype.toBuffer = function(endian, length) {
            return this.toArrayLike(Buffer, endian, length);
        }), BN.prototype.toArray = function(endian, length) {
            return this.toArrayLike(Array, endian, length);
        }, BN.prototype.toArrayLike = function(ArrayType, endian, length) {
            this._strip();
            var byteLength = this.byteLength(), reqLength = length || Math.max(1, byteLength);
            assert(byteLength <= reqLength, "byte array longer than desired length"), assert(reqLength > 0, "Requested array length <= 0");
            var res = function(ArrayType, size) {
                return ArrayType.allocUnsafe ? ArrayType.allocUnsafe(size) : new ArrayType(size);
            }(ArrayType, reqLength);
            return this["_toArrayLike" + ("le" === endian ? "LE" : "BE")](res, byteLength), 
            res;
        }, BN.prototype._toArrayLikeLE = function(res, byteLength) {
            for (var position = 0, carry = 0, i = 0, shift = 0; i < this.length; i++) {
                var word = this.words[i] << shift | carry;
                res[position++] = 255 & word, position < res.length && (res[position++] = word >> 8 & 255), 
                position < res.length && (res[position++] = word >> 16 & 255), 6 === shift ? (position < res.length && (res[position++] = word >> 24 & 255), 
                carry = 0, shift = 0) : (carry = word >>> 24, shift += 2);
            }
            if (position < res.length) for (res[position++] = carry; position < res.length; ) res[position++] = 0;
        }, BN.prototype._toArrayLikeBE = function(res, byteLength) {
            for (var position = res.length - 1, carry = 0, i = 0, shift = 0; i < this.length; i++) {
                var word = this.words[i] << shift | carry;
                res[position--] = 255 & word, position >= 0 && (res[position--] = word >> 8 & 255), 
                position >= 0 && (res[position--] = word >> 16 & 255), 6 === shift ? (position >= 0 && (res[position--] = word >> 24 & 255), 
                carry = 0, shift = 0) : (carry = word >>> 24, shift += 2);
            }
            if (position >= 0) for (res[position--] = carry; position >= 0; ) res[position--] = 0;
        }, Math.clz32 ? BN.prototype._countBits = function(w) {
            return 32 - Math.clz32(w);
        } : BN.prototype._countBits = function(w) {
            var t = w, r = 0;
            return t >= 4096 && (r += 13, t >>>= 13), t >= 64 && (r += 7, t >>>= 7), t >= 8 && (r += 4, 
            t >>>= 4), t >= 2 && (r += 2, t >>>= 2), r + t;
        }, BN.prototype._zeroBits = function(w) {
            if (0 === w) return 26;
            var t = w, r = 0;
            return 8191 & t || (r += 13, t >>>= 13), 127 & t || (r += 7, t >>>= 7), 15 & t || (r += 4, 
            t >>>= 4), 3 & t || (r += 2, t >>>= 2), 1 & t || r++, r;
        }, BN.prototype.bitLength = function() {
            var w = this.words[this.length - 1], hi = this._countBits(w);
            return 26 * (this.length - 1) + hi;
        }, BN.prototype.zeroBits = function() {
            if (this.isZero()) return 0;
            for (var r = 0, i = 0; i < this.length; i++) {
                var b = this._zeroBits(this.words[i]);
                if (r += b, 26 !== b) break;
            }
            return r;
        }, BN.prototype.byteLength = function() {
            return Math.ceil(this.bitLength() / 8);
        }, BN.prototype.toTwos = function(width) {
            return 0 !== this.negative ? this.abs().inotn(width).iaddn(1) : this.clone();
        }, BN.prototype.fromTwos = function(width) {
            return this.testn(width - 1) ? this.notn(width).iaddn(1).ineg() : this.clone();
        }, BN.prototype.isNeg = function() {
            return 0 !== this.negative;
        }, BN.prototype.neg = function() {
            return this.clone().ineg();
        }, BN.prototype.ineg = function() {
            return this.isZero() || (this.negative ^= 1), this;
        }, BN.prototype.iuor = function(num) {
            for (;this.length < num.length; ) this.words[this.length++] = 0;
            for (var i = 0; i < num.length; i++) this.words[i] = this.words[i] | num.words[i];
            return this._strip();
        }, BN.prototype.ior = function(num) {
            return assert(!(this.negative | num.negative)), this.iuor(num);
        }, BN.prototype.or = function(num) {
            return this.length > num.length ? this.clone().ior(num) : num.clone().ior(this);
        }, BN.prototype.uor = function(num) {
            return this.length > num.length ? this.clone().iuor(num) : num.clone().iuor(this);
        }, BN.prototype.iuand = function(num) {
            var b;
            b = this.length > num.length ? num : this;
            for (var i = 0; i < b.length; i++) this.words[i] = this.words[i] & num.words[i];
            return this.length = b.length, this._strip();
        }, BN.prototype.iand = function(num) {
            return assert(!(this.negative | num.negative)), this.iuand(num);
        }, BN.prototype.and = function(num) {
            return this.length > num.length ? this.clone().iand(num) : num.clone().iand(this);
        }, BN.prototype.uand = function(num) {
            return this.length > num.length ? this.clone().iuand(num) : num.clone().iuand(this);
        }, BN.prototype.iuxor = function(num) {
            var a, b;
            this.length > num.length ? (a = this, b = num) : (a = num, b = this);
            for (var i = 0; i < b.length; i++) this.words[i] = a.words[i] ^ b.words[i];
            if (this !== a) for (;i < a.length; i++) this.words[i] = a.words[i];
            return this.length = a.length, this._strip();
        }, BN.prototype.ixor = function(num) {
            return assert(!(this.negative | num.negative)), this.iuxor(num);
        }, BN.prototype.xor = function(num) {
            return this.length > num.length ? this.clone().ixor(num) : num.clone().ixor(this);
        }, BN.prototype.uxor = function(num) {
            return this.length > num.length ? this.clone().iuxor(num) : num.clone().iuxor(this);
        }, BN.prototype.inotn = function(width) {
            assert("number" == typeof width && width >= 0);
            var bytesNeeded = 0 | Math.ceil(width / 26), bitsLeft = width % 26;
            this._expand(bytesNeeded), bitsLeft > 0 && bytesNeeded--;
            for (var i = 0; i < bytesNeeded; i++) this.words[i] = 67108863 & ~this.words[i];
            return bitsLeft > 0 && (this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft), 
            this._strip();
        }, BN.prototype.notn = function(width) {
            return this.clone().inotn(width);
        }, BN.prototype.setn = function(bit, val) {
            assert("number" == typeof bit && bit >= 0);
            var off = bit / 26 | 0, wbit = bit % 26;
            return this._expand(off + 1), this.words[off] = val ? this.words[off] | 1 << wbit : this.words[off] & ~(1 << wbit), 
            this._strip();
        }, BN.prototype.iadd = function(num) {
            var r, a, b;
            if (0 !== this.negative && 0 === num.negative) return this.negative = 0, r = this.isub(num), 
            this.negative ^= 1, this._normSign();
            if (0 === this.negative && 0 !== num.negative) return num.negative = 0, r = this.isub(num), 
            num.negative = 1, r._normSign();
            this.length > num.length ? (a = this, b = num) : (a = num, b = this);
            for (var carry = 0, i = 0; i < b.length; i++) r = (0 | a.words[i]) + (0 | b.words[i]) + carry, 
            this.words[i] = 67108863 & r, carry = r >>> 26;
            for (;0 !== carry && i < a.length; i++) r = (0 | a.words[i]) + carry, this.words[i] = 67108863 & r, 
            carry = r >>> 26;
            if (this.length = a.length, 0 !== carry) this.words[this.length] = carry, this.length++; else if (a !== this) for (;i < a.length; i++) this.words[i] = a.words[i];
            return this;
        }, BN.prototype.add = function(num) {
            var res;
            return 0 !== num.negative && 0 === this.negative ? (num.negative = 0, res = this.sub(num), 
            num.negative ^= 1, res) : 0 === num.negative && 0 !== this.negative ? (this.negative = 0, 
            res = num.sub(this), this.negative = 1, res) : this.length > num.length ? this.clone().iadd(num) : num.clone().iadd(this);
        }, BN.prototype.isub = function(num) {
            if (0 !== num.negative) {
                num.negative = 0;
                var r = this.iadd(num);
                return num.negative = 1, r._normSign();
            }
            if (0 !== this.negative) return this.negative = 0, this.iadd(num), this.negative = 1, 
            this._normSign();
            var a, b, cmp = this.cmp(num);
            if (0 === cmp) return this.negative = 0, this.length = 1, this.words[0] = 0, this;
            cmp > 0 ? (a = this, b = num) : (a = num, b = this);
            for (var carry = 0, i = 0; i < b.length; i++) carry = (r = (0 | a.words[i]) - (0 | b.words[i]) + carry) >> 26, 
            this.words[i] = 67108863 & r;
            for (;0 !== carry && i < a.length; i++) carry = (r = (0 | a.words[i]) + carry) >> 26, 
            this.words[i] = 67108863 & r;
            if (0 === carry && i < a.length && a !== this) for (;i < a.length; i++) this.words[i] = a.words[i];
            return this.length = Math.max(this.length, i), a !== this && (this.negative = 1), 
            this._strip();
        }, BN.prototype.sub = function(num) {
            return this.clone().isub(num);
        };
        var comb10MulTo = function(self, num, out) {
            var lo, mid, hi, a = self.words, b = num.words, o = out.words, c = 0, a0 = 0 | a[0], al0 = 8191 & a0, ah0 = a0 >>> 13, a1 = 0 | a[1], al1 = 8191 & a1, ah1 = a1 >>> 13, a2 = 0 | a[2], al2 = 8191 & a2, ah2 = a2 >>> 13, a3 = 0 | a[3], al3 = 8191 & a3, ah3 = a3 >>> 13, a4 = 0 | a[4], al4 = 8191 & a4, ah4 = a4 >>> 13, a5 = 0 | a[5], al5 = 8191 & a5, ah5 = a5 >>> 13, a6 = 0 | a[6], al6 = 8191 & a6, ah6 = a6 >>> 13, a7 = 0 | a[7], al7 = 8191 & a7, ah7 = a7 >>> 13, a8 = 0 | a[8], al8 = 8191 & a8, ah8 = a8 >>> 13, a9 = 0 | a[9], al9 = 8191 & a9, ah9 = a9 >>> 13, b0 = 0 | b[0], bl0 = 8191 & b0, bh0 = b0 >>> 13, b1 = 0 | b[1], bl1 = 8191 & b1, bh1 = b1 >>> 13, b2 = 0 | b[2], bl2 = 8191 & b2, bh2 = b2 >>> 13, b3 = 0 | b[3], bl3 = 8191 & b3, bh3 = b3 >>> 13, b4 = 0 | b[4], bl4 = 8191 & b4, bh4 = b4 >>> 13, b5 = 0 | b[5], bl5 = 8191 & b5, bh5 = b5 >>> 13, b6 = 0 | b[6], bl6 = 8191 & b6, bh6 = b6 >>> 13, b7 = 0 | b[7], bl7 = 8191 & b7, bh7 = b7 >>> 13, b8 = 0 | b[8], bl8 = 8191 & b8, bh8 = b8 >>> 13, b9 = 0 | b[9], bl9 = 8191 & b9, bh9 = b9 >>> 13;
            out.negative = self.negative ^ num.negative, out.length = 19;
            var w0 = (c + (lo = Math.imul(al0, bl0)) | 0) + ((8191 & (mid = (mid = Math.imul(al0, bh0)) + Math.imul(ah0, bl0) | 0)) << 13) | 0;
            c = ((hi = Math.imul(ah0, bh0)) + (mid >>> 13) | 0) + (w0 >>> 26) | 0, w0 &= 67108863, 
            lo = Math.imul(al1, bl0), mid = (mid = Math.imul(al1, bh0)) + Math.imul(ah1, bl0) | 0, 
            hi = Math.imul(ah1, bh0);
            var w1 = (c + (lo = lo + Math.imul(al0, bl1) | 0) | 0) + ((8191 & (mid = (mid = mid + Math.imul(al0, bh1) | 0) + Math.imul(ah0, bl1) | 0)) << 13) | 0;
            c = ((hi = hi + Math.imul(ah0, bh1) | 0) + (mid >>> 13) | 0) + (w1 >>> 26) | 0, 
            w1 &= 67108863, lo = Math.imul(al2, bl0), mid = (mid = Math.imul(al2, bh0)) + Math.imul(ah2, bl0) | 0, 
            hi = Math.imul(ah2, bh0), lo = lo + Math.imul(al1, bl1) | 0, mid = (mid = mid + Math.imul(al1, bh1) | 0) + Math.imul(ah1, bl1) | 0, 
            hi = hi + Math.imul(ah1, bh1) | 0;
            var w2 = (c + (lo = lo + Math.imul(al0, bl2) | 0) | 0) + ((8191 & (mid = (mid = mid + Math.imul(al0, bh2) | 0) + Math.imul(ah0, bl2) | 0)) << 13) | 0;
            c = ((hi = hi + Math.imul(ah0, bh2) | 0) + (mid >>> 13) | 0) + (w2 >>> 26) | 0, 
            w2 &= 67108863, lo = Math.imul(al3, bl0), mid = (mid = Math.imul(al3, bh0)) + Math.imul(ah3, bl0) | 0, 
            hi = Math.imul(ah3, bh0), lo = lo + Math.imul(al2, bl1) | 0, mid = (mid = mid + Math.imul(al2, bh1) | 0) + Math.imul(ah2, bl1) | 0, 
            hi = hi + Math.imul(ah2, bh1) | 0, lo = lo + Math.imul(al1, bl2) | 0, mid = (mid = mid + Math.imul(al1, bh2) | 0) + Math.imul(ah1, bl2) | 0, 
            hi = hi + Math.imul(ah1, bh2) | 0;
            var w3 = (c + (lo = lo + Math.imul(al0, bl3) | 0) | 0) + ((8191 & (mid = (mid = mid + Math.imul(al0, bh3) | 0) + Math.imul(ah0, bl3) | 0)) << 13) | 0;
            c = ((hi = hi + Math.imul(ah0, bh3) | 0) + (mid >>> 13) | 0) + (w3 >>> 26) | 0, 
            w3 &= 67108863, lo = Math.imul(al4, bl0), mid = (mid = Math.imul(al4, bh0)) + Math.imul(ah4, bl0) | 0, 
            hi = Math.imul(ah4, bh0), lo = lo + Math.imul(al3, bl1) | 0, mid = (mid = mid + Math.imul(al3, bh1) | 0) + Math.imul(ah3, bl1) | 0, 
            hi = hi + Math.imul(ah3, bh1) | 0, lo = lo + Math.imul(al2, bl2) | 0, mid = (mid = mid + Math.imul(al2, bh2) | 0) + Math.imul(ah2, bl2) | 0, 
            hi = hi + Math.imul(ah2, bh2) | 0, lo = lo + Math.imul(al1, bl3) | 0, mid = (mid = mid + Math.imul(al1, bh3) | 0) + Math.imul(ah1, bl3) | 0, 
            hi = hi + Math.imul(ah1, bh3) | 0;
            var w4 = (c + (lo = lo + Math.imul(al0, bl4) | 0) | 0) + ((8191 & (mid = (mid = mid + Math.imul(al0, bh4) | 0) + Math.imul(ah0, bl4) | 0)) << 13) | 0;
            c = ((hi = hi + Math.imul(ah0, bh4) | 0) + (mid >>> 13) | 0) + (w4 >>> 26) | 0, 
            w4 &= 67108863, lo = Math.imul(al5, bl0), mid = (mid = Math.imul(al5, bh0)) + Math.imul(ah5, bl0) | 0, 
            hi = Math.imul(ah5, bh0), lo = lo + Math.imul(al4, bl1) | 0, mid = (mid = mid + Math.imul(al4, bh1) | 0) + Math.imul(ah4, bl1) | 0, 
            hi = hi + Math.imul(ah4, bh1) | 0, lo = lo + Math.imul(al3, bl2) | 0, mid = (mid = mid + Math.imul(al3, bh2) | 0) + Math.imul(ah3, bl2) | 0, 
            hi = hi + Math.imul(ah3, bh2) | 0, lo = lo + Math.imul(al2, bl3) | 0, mid = (mid = mid + Math.imul(al2, bh3) | 0) + Math.imul(ah2, bl3) | 0, 
            hi = hi + Math.imul(ah2, bh3) | 0, lo = lo + Math.imul(al1, bl4) | 0, mid = (mid = mid + Math.imul(al1, bh4) | 0) + Math.imul(ah1, bl4) | 0, 
            hi = hi + Math.imul(ah1, bh4) | 0;
            var w5 = (c + (lo = lo + Math.imul(al0, bl5) | 0) | 0) + ((8191 & (mid = (mid = mid + Math.imul(al0, bh5) | 0) + Math.imul(ah0, bl5) | 0)) << 13) | 0;
            c = ((hi = hi + Math.imul(ah0, bh5) | 0) + (mid >>> 13) | 0) + (w5 >>> 26) | 0, 
            w5 &= 67108863, lo = Math.imul(al6, bl0), mid = (mid = Math.imul(al6, bh0)) + Math.imul(ah6, bl0) | 0, 
            hi = Math.imul(ah6, bh0), lo = lo + Math.imul(al5, bl1) | 0, mid = (mid = mid + Math.imul(al5, bh1) | 0) + Math.imul(ah5, bl1) | 0, 
            hi = hi + Math.imul(ah5, bh1) | 0, lo = lo + Math.imul(al4, bl2) | 0, mid = (mid = mid + Math.imul(al4, bh2) | 0) + Math.imul(ah4, bl2) | 0, 
            hi = hi + Math.imul(ah4, bh2) | 0, lo = lo + Math.imul(al3, bl3) | 0, mid = (mid = mid + Math.imul(al3, bh3) | 0) + Math.imul(ah3, bl3) | 0, 
            hi = hi + Math.imul(ah3, bh3) | 0, lo = lo + Math.imul(al2, bl4) | 0, mid = (mid = mid + Math.imul(al2, bh4) | 0) + Math.imul(ah2, bl4) | 0, 
            hi = hi + Math.imul(ah2, bh4) | 0, lo = lo + Math.imul(al1, bl5) | 0, mid = (mid = mid + Math.imul(al1, bh5) | 0) + Math.imul(ah1, bl5) | 0, 
            hi = hi + Math.imul(ah1, bh5) | 0;
            var w6 = (c + (lo = lo + Math.imul(al0, bl6) | 0) | 0) + ((8191 & (mid = (mid = mid + Math.imul(al0, bh6) | 0) + Math.imul(ah0, bl6) | 0)) << 13) | 0;
            c = ((hi = hi + Math.imul(ah0, bh6) | 0) + (mid >>> 13) | 0) + (w6 >>> 26) | 0, 
            w6 &= 67108863, lo = Math.imul(al7, bl0), mid = (mid = Math.imul(al7, bh0)) + Math.imul(ah7, bl0) | 0, 
            hi = Math.imul(ah7, bh0), lo = lo + Math.imul(al6, bl1) | 0, mid = (mid = mid + Math.imul(al6, bh1) | 0) + Math.imul(ah6, bl1) | 0, 
            hi = hi + Math.imul(ah6, bh1) | 0, lo = lo + Math.imul(al5, bl2) | 0, mid = (mid = mid + Math.imul(al5, bh2) | 0) + Math.imul(ah5, bl2) | 0, 
            hi = hi + Math.imul(ah5, bh2) | 0, lo = lo + Math.imul(al4, bl3) | 0, mid = (mid = mid + Math.imul(al4, bh3) | 0) + Math.imul(ah4, bl3) | 0, 
            hi = hi + Math.imul(ah4, bh3) | 0, lo = lo + Math.imul(al3, bl4) | 0, mid = (mid = mid + Math.imul(al3, bh4) | 0) + Math.imul(ah3, bl4) | 0, 
            hi = hi + Math.imul(ah3, bh4) | 0, lo = lo + Math.imul(al2, bl5) | 0, mid = (mid = mid + Math.imul(al2, bh5) | 0) + Math.imul(ah2, bl5) | 0, 
            hi = hi + Math.imul(ah2, bh5) | 0, lo = lo + Math.imul(al1, bl6) | 0, mid = (mid = mid + Math.imul(al1, bh6) | 0) + Math.imul(ah1, bl6) | 0, 
            hi = hi + Math.imul(ah1, bh6) | 0;
            var w7 = (c + (lo = lo + Math.imul(al0, bl7) | 0) | 0) + ((8191 & (mid = (mid = mid + Math.imul(al0, bh7) | 0) + Math.imul(ah0, bl7) | 0)) << 13) | 0;
            c = ((hi = hi + Math.imul(ah0, bh7) | 0) + (mid >>> 13) | 0) + (w7 >>> 26) | 0, 
            w7 &= 67108863, lo = Math.imul(al8, bl0), mid = (mid = Math.imul(al8, bh0)) + Math.imul(ah8, bl0) | 0, 
            hi = Math.imul(ah8, bh0), lo = lo + Math.imul(al7, bl1) | 0, mid = (mid = mid + Math.imul(al7, bh1) | 0) + Math.imul(ah7, bl1) | 0, 
            hi = hi + Math.imul(ah7, bh1) | 0, lo = lo + Math.imul(al6, bl2) | 0, mid = (mid = mid + Math.imul(al6, bh2) | 0) + Math.imul(ah6, bl2) | 0, 
            hi = hi + Math.imul(ah6, bh2) | 0, lo = lo + Math.imul(al5, bl3) | 0, mid = (mid = mid + Math.imul(al5, bh3) | 0) + Math.imul(ah5, bl3) | 0, 
            hi = hi + Math.imul(ah5, bh3) | 0, lo = lo + Math.imul(al4, bl4) | 0, mid = (mid = mid + Math.imul(al4, bh4) | 0) + Math.imul(ah4, bl4) | 0, 
            hi = hi + Math.imul(ah4, bh4) | 0, lo = lo + Math.imul(al3, bl5) | 0, mid = (mid = mid + Math.imul(al3, bh5) | 0) + Math.imul(ah3, bl5) | 0, 
            hi = hi + Math.imul(ah3, bh5) | 0, lo = lo + Math.imul(al2, bl6) | 0, mid = (mid = mid + Math.imul(al2, bh6) | 0) + Math.imul(ah2, bl6) | 0, 
            hi = hi + Math.imul(ah2, bh6) | 0, lo = lo + Math.imul(al1, bl7) | 0, mid = (mid = mid + Math.imul(al1, bh7) | 0) + Math.imul(ah1, bl7) | 0, 
            hi = hi + Math.imul(ah1, bh7) | 0;
            var w8 = (c + (lo = lo + Math.imul(al0, bl8) | 0) | 0) + ((8191 & (mid = (mid = mid + Math.imul(al0, bh8) | 0) + Math.imul(ah0, bl8) | 0)) << 13) | 0;
            c = ((hi = hi + Math.imul(ah0, bh8) | 0) + (mid >>> 13) | 0) + (w8 >>> 26) | 0, 
            w8 &= 67108863, lo = Math.imul(al9, bl0), mid = (mid = Math.imul(al9, bh0)) + Math.imul(ah9, bl0) | 0, 
            hi = Math.imul(ah9, bh0), lo = lo + Math.imul(al8, bl1) | 0, mid = (mid = mid + Math.imul(al8, bh1) | 0) + Math.imul(ah8, bl1) | 0, 
            hi = hi + Math.imul(ah8, bh1) | 0, lo = lo + Math.imul(al7, bl2) | 0, mid = (mid = mid + Math.imul(al7, bh2) | 0) + Math.imul(ah7, bl2) | 0, 
            hi = hi + Math.imul(ah7, bh2) | 0, lo = lo + Math.imul(al6, bl3) | 0, mid = (mid = mid + Math.imul(al6, bh3) | 0) + Math.imul(ah6, bl3) | 0, 
            hi = hi + Math.imul(ah6, bh3) | 0, lo = lo + Math.imul(al5, bl4) | 0, mid = (mid = mid + Math.imul(al5, bh4) | 0) + Math.imul(ah5, bl4) | 0, 
            hi = hi + Math.imul(ah5, bh4) | 0, lo = lo + Math.imul(al4, bl5) | 0, mid = (mid = mid + Math.imul(al4, bh5) | 0) + Math.imul(ah4, bl5) | 0, 
            hi = hi + Math.imul(ah4, bh5) | 0, lo = lo + Math.imul(al3, bl6) | 0, mid = (mid = mid + Math.imul(al3, bh6) | 0) + Math.imul(ah3, bl6) | 0, 
            hi = hi + Math.imul(ah3, bh6) | 0, lo = lo + Math.imul(al2, bl7) | 0, mid = (mid = mid + Math.imul(al2, bh7) | 0) + Math.imul(ah2, bl7) | 0, 
            hi = hi + Math.imul(ah2, bh7) | 0, lo = lo + Math.imul(al1, bl8) | 0, mid = (mid = mid + Math.imul(al1, bh8) | 0) + Math.imul(ah1, bl8) | 0, 
            hi = hi + Math.imul(ah1, bh8) | 0;
            var w9 = (c + (lo = lo + Math.imul(al0, bl9) | 0) | 0) + ((8191 & (mid = (mid = mid + Math.imul(al0, bh9) | 0) + Math.imul(ah0, bl9) | 0)) << 13) | 0;
            c = ((hi = hi + Math.imul(ah0, bh9) | 0) + (mid >>> 13) | 0) + (w9 >>> 26) | 0, 
            w9 &= 67108863, lo = Math.imul(al9, bl1), mid = (mid = Math.imul(al9, bh1)) + Math.imul(ah9, bl1) | 0, 
            hi = Math.imul(ah9, bh1), lo = lo + Math.imul(al8, bl2) | 0, mid = (mid = mid + Math.imul(al8, bh2) | 0) + Math.imul(ah8, bl2) | 0, 
            hi = hi + Math.imul(ah8, bh2) | 0, lo = lo + Math.imul(al7, bl3) | 0, mid = (mid = mid + Math.imul(al7, bh3) | 0) + Math.imul(ah7, bl3) | 0, 
            hi = hi + Math.imul(ah7, bh3) | 0, lo = lo + Math.imul(al6, bl4) | 0, mid = (mid = mid + Math.imul(al6, bh4) | 0) + Math.imul(ah6, bl4) | 0, 
            hi = hi + Math.imul(ah6, bh4) | 0, lo = lo + Math.imul(al5, bl5) | 0, mid = (mid = mid + Math.imul(al5, bh5) | 0) + Math.imul(ah5, bl5) | 0, 
            hi = hi + Math.imul(ah5, bh5) | 0, lo = lo + Math.imul(al4, bl6) | 0, mid = (mid = mid + Math.imul(al4, bh6) | 0) + Math.imul(ah4, bl6) | 0, 
            hi = hi + Math.imul(ah4, bh6) | 0, lo = lo + Math.imul(al3, bl7) | 0, mid = (mid = mid + Math.imul(al3, bh7) | 0) + Math.imul(ah3, bl7) | 0, 
            hi = hi + Math.imul(ah3, bh7) | 0, lo = lo + Math.imul(al2, bl8) | 0, mid = (mid = mid + Math.imul(al2, bh8) | 0) + Math.imul(ah2, bl8) | 0, 
            hi = hi + Math.imul(ah2, bh8) | 0;
            var w10 = (c + (lo = lo + Math.imul(al1, bl9) | 0) | 0) + ((8191 & (mid = (mid = mid + Math.imul(al1, bh9) | 0) + Math.imul(ah1, bl9) | 0)) << 13) | 0;
            c = ((hi = hi + Math.imul(ah1, bh9) | 0) + (mid >>> 13) | 0) + (w10 >>> 26) | 0, 
            w10 &= 67108863, lo = Math.imul(al9, bl2), mid = (mid = Math.imul(al9, bh2)) + Math.imul(ah9, bl2) | 0, 
            hi = Math.imul(ah9, bh2), lo = lo + Math.imul(al8, bl3) | 0, mid = (mid = mid + Math.imul(al8, bh3) | 0) + Math.imul(ah8, bl3) | 0, 
            hi = hi + Math.imul(ah8, bh3) | 0, lo = lo + Math.imul(al7, bl4) | 0, mid = (mid = mid + Math.imul(al7, bh4) | 0) + Math.imul(ah7, bl4) | 0, 
            hi = hi + Math.imul(ah7, bh4) | 0, lo = lo + Math.imul(al6, bl5) | 0, mid = (mid = mid + Math.imul(al6, bh5) | 0) + Math.imul(ah6, bl5) | 0, 
            hi = hi + Math.imul(ah6, bh5) | 0, lo = lo + Math.imul(al5, bl6) | 0, mid = (mid = mid + Math.imul(al5, bh6) | 0) + Math.imul(ah5, bl6) | 0, 
            hi = hi + Math.imul(ah5, bh6) | 0, lo = lo + Math.imul(al4, bl7) | 0, mid = (mid = mid + Math.imul(al4, bh7) | 0) + Math.imul(ah4, bl7) | 0, 
            hi = hi + Math.imul(ah4, bh7) | 0, lo = lo + Math.imul(al3, bl8) | 0, mid = (mid = mid + Math.imul(al3, bh8) | 0) + Math.imul(ah3, bl8) | 0, 
            hi = hi + Math.imul(ah3, bh8) | 0;
            var w11 = (c + (lo = lo + Math.imul(al2, bl9) | 0) | 0) + ((8191 & (mid = (mid = mid + Math.imul(al2, bh9) | 0) + Math.imul(ah2, bl9) | 0)) << 13) | 0;
            c = ((hi = hi + Math.imul(ah2, bh9) | 0) + (mid >>> 13) | 0) + (w11 >>> 26) | 0, 
            w11 &= 67108863, lo = Math.imul(al9, bl3), mid = (mid = Math.imul(al9, bh3)) + Math.imul(ah9, bl3) | 0, 
            hi = Math.imul(ah9, bh3), lo = lo + Math.imul(al8, bl4) | 0, mid = (mid = mid + Math.imul(al8, bh4) | 0) + Math.imul(ah8, bl4) | 0, 
            hi = hi + Math.imul(ah8, bh4) | 0, lo = lo + Math.imul(al7, bl5) | 0, mid = (mid = mid + Math.imul(al7, bh5) | 0) + Math.imul(ah7, bl5) | 0, 
            hi = hi + Math.imul(ah7, bh5) | 0, lo = lo + Math.imul(al6, bl6) | 0, mid = (mid = mid + Math.imul(al6, bh6) | 0) + Math.imul(ah6, bl6) | 0, 
            hi = hi + Math.imul(ah6, bh6) | 0, lo = lo + Math.imul(al5, bl7) | 0, mid = (mid = mid + Math.imul(al5, bh7) | 0) + Math.imul(ah5, bl7) | 0, 
            hi = hi + Math.imul(ah5, bh7) | 0, lo = lo + Math.imul(al4, bl8) | 0, mid = (mid = mid + Math.imul(al4, bh8) | 0) + Math.imul(ah4, bl8) | 0, 
            hi = hi + Math.imul(ah4, bh8) | 0;
            var w12 = (c + (lo = lo + Math.imul(al3, bl9) | 0) | 0) + ((8191 & (mid = (mid = mid + Math.imul(al3, bh9) | 0) + Math.imul(ah3, bl9) | 0)) << 13) | 0;
            c = ((hi = hi + Math.imul(ah3, bh9) | 0) + (mid >>> 13) | 0) + (w12 >>> 26) | 0, 
            w12 &= 67108863, lo = Math.imul(al9, bl4), mid = (mid = Math.imul(al9, bh4)) + Math.imul(ah9, bl4) | 0, 
            hi = Math.imul(ah9, bh4), lo = lo + Math.imul(al8, bl5) | 0, mid = (mid = mid + Math.imul(al8, bh5) | 0) + Math.imul(ah8, bl5) | 0, 
            hi = hi + Math.imul(ah8, bh5) | 0, lo = lo + Math.imul(al7, bl6) | 0, mid = (mid = mid + Math.imul(al7, bh6) | 0) + Math.imul(ah7, bl6) | 0, 
            hi = hi + Math.imul(ah7, bh6) | 0, lo = lo + Math.imul(al6, bl7) | 0, mid = (mid = mid + Math.imul(al6, bh7) | 0) + Math.imul(ah6, bl7) | 0, 
            hi = hi + Math.imul(ah6, bh7) | 0, lo = lo + Math.imul(al5, bl8) | 0, mid = (mid = mid + Math.imul(al5, bh8) | 0) + Math.imul(ah5, bl8) | 0, 
            hi = hi + Math.imul(ah5, bh8) | 0;
            var w13 = (c + (lo = lo + Math.imul(al4, bl9) | 0) | 0) + ((8191 & (mid = (mid = mid + Math.imul(al4, bh9) | 0) + Math.imul(ah4, bl9) | 0)) << 13) | 0;
            c = ((hi = hi + Math.imul(ah4, bh9) | 0) + (mid >>> 13) | 0) + (w13 >>> 26) | 0, 
            w13 &= 67108863, lo = Math.imul(al9, bl5), mid = (mid = Math.imul(al9, bh5)) + Math.imul(ah9, bl5) | 0, 
            hi = Math.imul(ah9, bh5), lo = lo + Math.imul(al8, bl6) | 0, mid = (mid = mid + Math.imul(al8, bh6) | 0) + Math.imul(ah8, bl6) | 0, 
            hi = hi + Math.imul(ah8, bh6) | 0, lo = lo + Math.imul(al7, bl7) | 0, mid = (mid = mid + Math.imul(al7, bh7) | 0) + Math.imul(ah7, bl7) | 0, 
            hi = hi + Math.imul(ah7, bh7) | 0, lo = lo + Math.imul(al6, bl8) | 0, mid = (mid = mid + Math.imul(al6, bh8) | 0) + Math.imul(ah6, bl8) | 0, 
            hi = hi + Math.imul(ah6, bh8) | 0;
            var w14 = (c + (lo = lo + Math.imul(al5, bl9) | 0) | 0) + ((8191 & (mid = (mid = mid + Math.imul(al5, bh9) | 0) + Math.imul(ah5, bl9) | 0)) << 13) | 0;
            c = ((hi = hi + Math.imul(ah5, bh9) | 0) + (mid >>> 13) | 0) + (w14 >>> 26) | 0, 
            w14 &= 67108863, lo = Math.imul(al9, bl6), mid = (mid = Math.imul(al9, bh6)) + Math.imul(ah9, bl6) | 0, 
            hi = Math.imul(ah9, bh6), lo = lo + Math.imul(al8, bl7) | 0, mid = (mid = mid + Math.imul(al8, bh7) | 0) + Math.imul(ah8, bl7) | 0, 
            hi = hi + Math.imul(ah8, bh7) | 0, lo = lo + Math.imul(al7, bl8) | 0, mid = (mid = mid + Math.imul(al7, bh8) | 0) + Math.imul(ah7, bl8) | 0, 
            hi = hi + Math.imul(ah7, bh8) | 0;
            var w15 = (c + (lo = lo + Math.imul(al6, bl9) | 0) | 0) + ((8191 & (mid = (mid = mid + Math.imul(al6, bh9) | 0) + Math.imul(ah6, bl9) | 0)) << 13) | 0;
            c = ((hi = hi + Math.imul(ah6, bh9) | 0) + (mid >>> 13) | 0) + (w15 >>> 26) | 0, 
            w15 &= 67108863, lo = Math.imul(al9, bl7), mid = (mid = Math.imul(al9, bh7)) + Math.imul(ah9, bl7) | 0, 
            hi = Math.imul(ah9, bh7), lo = lo + Math.imul(al8, bl8) | 0, mid = (mid = mid + Math.imul(al8, bh8) | 0) + Math.imul(ah8, bl8) | 0, 
            hi = hi + Math.imul(ah8, bh8) | 0;
            var w16 = (c + (lo = lo + Math.imul(al7, bl9) | 0) | 0) + ((8191 & (mid = (mid = mid + Math.imul(al7, bh9) | 0) + Math.imul(ah7, bl9) | 0)) << 13) | 0;
            c = ((hi = hi + Math.imul(ah7, bh9) | 0) + (mid >>> 13) | 0) + (w16 >>> 26) | 0, 
            w16 &= 67108863, lo = Math.imul(al9, bl8), mid = (mid = Math.imul(al9, bh8)) + Math.imul(ah9, bl8) | 0, 
            hi = Math.imul(ah9, bh8);
            var w17 = (c + (lo = lo + Math.imul(al8, bl9) | 0) | 0) + ((8191 & (mid = (mid = mid + Math.imul(al8, bh9) | 0) + Math.imul(ah8, bl9) | 0)) << 13) | 0;
            c = ((hi = hi + Math.imul(ah8, bh9) | 0) + (mid >>> 13) | 0) + (w17 >>> 26) | 0, 
            w17 &= 67108863;
            var w18 = (c + (lo = Math.imul(al9, bl9)) | 0) + ((8191 & (mid = (mid = Math.imul(al9, bh9)) + Math.imul(ah9, bl9) | 0)) << 13) | 0;
            return c = ((hi = Math.imul(ah9, bh9)) + (mid >>> 13) | 0) + (w18 >>> 26) | 0, w18 &= 67108863, 
            o[0] = w0, o[1] = w1, o[2] = w2, o[3] = w3, o[4] = w4, o[5] = w5, o[6] = w6, o[7] = w7, 
            o[8] = w8, o[9] = w9, o[10] = w10, o[11] = w11, o[12] = w12, o[13] = w13, o[14] = w14, 
            o[15] = w15, o[16] = w16, o[17] = w17, o[18] = w18, 0 !== c && (o[19] = c, out.length++), 
            out;
        };
        function bigMulTo(self, num, out) {
            out.negative = num.negative ^ self.negative, out.length = self.length + num.length;
            for (var carry = 0, hncarry = 0, k = 0; k < out.length - 1; k++) {
                var ncarry = hncarry;
                hncarry = 0;
                for (var rword = 67108863 & carry, maxJ = Math.min(k, num.length - 1), j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
                    var i = k - j, r = (0 | self.words[i]) * (0 | num.words[j]), lo = 67108863 & r;
                    rword = 67108863 & (lo = lo + rword | 0), hncarry += (ncarry = (ncarry = ncarry + (r / 67108864 | 0) | 0) + (lo >>> 26) | 0) >>> 26, 
                    ncarry &= 67108863;
                }
                out.words[k] = rword, carry = ncarry, ncarry = hncarry;
            }
            return 0 !== carry ? out.words[k] = carry : out.length--, out._strip();
        }
        function jumboMulTo(self, num, out) {
            return bigMulTo(self, num, out);
        }
        Math.imul || (comb10MulTo = smallMulTo), BN.prototype.mulTo = function(num, out) {
            var len = this.length + num.length;
            return 10 === this.length && 10 === num.length ? comb10MulTo(this, num, out) : len < 63 ? smallMulTo(this, num, out) : len < 1024 ? bigMulTo(this, num, out) : jumboMulTo(this, num, out);
        }, BN.prototype.mul = function(num) {
            var out = new BN(null);
            return out.words = new Array(this.length + num.length), this.mulTo(num, out);
        }, BN.prototype.mulf = function(num) {
            var out = new BN(null);
            return out.words = new Array(this.length + num.length), jumboMulTo(this, num, out);
        }, BN.prototype.imul = function(num) {
            return this.clone().mulTo(num, this);
        }, BN.prototype.imuln = function(num) {
            var isNegNum = num < 0;
            isNegNum && (num = -num), assert("number" == typeof num), assert(num < 67108864);
            for (var carry = 0, i = 0; i < this.length; i++) {
                var w = (0 | this.words[i]) * num, lo = (67108863 & w) + (67108863 & carry);
                carry >>= 26, carry += w / 67108864 | 0, carry += lo >>> 26, this.words[i] = 67108863 & lo;
            }
            return 0 !== carry && (this.words[i] = carry, this.length++), isNegNum ? this.ineg() : this;
        }, BN.prototype.muln = function(num) {
            return this.clone().imuln(num);
        }, BN.prototype.sqr = function() {
            return this.mul(this);
        }, BN.prototype.isqr = function() {
            return this.imul(this.clone());
        }, BN.prototype.pow = function(num) {
            var w = function(num) {
                for (var w = new Array(num.bitLength()), bit = 0; bit < w.length; bit++) {
                    var off = bit / 26 | 0, wbit = bit % 26;
                    w[bit] = num.words[off] >>> wbit & 1;
                }
                return w;
            }(num);
            if (0 === w.length) return new BN(1);
            for (var res = this, i = 0; i < w.length && 0 === w[i]; i++, res = res.sqr()) ;
            if (++i < w.length) for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) 0 !== w[i] && (res = res.mul(q));
            return res;
        }, BN.prototype.iushln = function(bits) {
            assert("number" == typeof bits && bits >= 0);
            var i, r = bits % 26, s = (bits - r) / 26, carryMask = 67108863 >>> 26 - r << 26 - r;
            if (0 !== r) {
                var carry = 0;
                for (i = 0; i < this.length; i++) {
                    var newCarry = this.words[i] & carryMask, c = (0 | this.words[i]) - newCarry << r;
                    this.words[i] = c | carry, carry = newCarry >>> 26 - r;
                }
                carry && (this.words[i] = carry, this.length++);
            }
            if (0 !== s) {
                for (i = this.length - 1; i >= 0; i--) this.words[i + s] = this.words[i];
                for (i = 0; i < s; i++) this.words[i] = 0;
                this.length += s;
            }
            return this._strip();
        }, BN.prototype.ishln = function(bits) {
            return assert(0 === this.negative), this.iushln(bits);
        }, BN.prototype.iushrn = function(bits, hint, extended) {
            var h;
            assert("number" == typeof bits && bits >= 0), h = hint ? (hint - hint % 26) / 26 : 0;
            var r = bits % 26, s = Math.min((bits - r) / 26, this.length), mask = 67108863 ^ 67108863 >>> r << r, maskedWords = extended;
            if (h -= s, h = Math.max(0, h), maskedWords) {
                for (var i = 0; i < s; i++) maskedWords.words[i] = this.words[i];
                maskedWords.length = s;
            }
            if (0 === s) ; else if (this.length > s) for (this.length -= s, i = 0; i < this.length; i++) this.words[i] = this.words[i + s]; else this.words[0] = 0, 
            this.length = 1;
            var carry = 0;
            for (i = this.length - 1; i >= 0 && (0 !== carry || i >= h); i--) {
                var word = 0 | this.words[i];
                this.words[i] = carry << 26 - r | word >>> r, carry = word & mask;
            }
            return maskedWords && 0 !== carry && (maskedWords.words[maskedWords.length++] = carry), 
            0 === this.length && (this.words[0] = 0, this.length = 1), this._strip();
        }, BN.prototype.ishrn = function(bits, hint, extended) {
            return assert(0 === this.negative), this.iushrn(bits, hint, extended);
        }, BN.prototype.shln = function(bits) {
            return this.clone().ishln(bits);
        }, BN.prototype.ushln = function(bits) {
            return this.clone().iushln(bits);
        }, BN.prototype.shrn = function(bits) {
            return this.clone().ishrn(bits);
        }, BN.prototype.ushrn = function(bits) {
            return this.clone().iushrn(bits);
        }, BN.prototype.testn = function(bit) {
            assert("number" == typeof bit && bit >= 0);
            var r = bit % 26, s = (bit - r) / 26, q = 1 << r;
            return !(this.length <= s || !(this.words[s] & q));
        }, BN.prototype.imaskn = function(bits) {
            assert("number" == typeof bits && bits >= 0);
            var r = bits % 26, s = (bits - r) / 26;
            if (assert(0 === this.negative, "imaskn works only with positive numbers"), this.length <= s) return this;
            if (0 !== r && s++, this.length = Math.min(s, this.length), 0 !== r) {
                var mask = 67108863 ^ 67108863 >>> r << r;
                this.words[this.length - 1] &= mask;
            }
            return this._strip();
        }, BN.prototype.maskn = function(bits) {
            return this.clone().imaskn(bits);
        }, BN.prototype.iaddn = function(num) {
            return assert("number" == typeof num), assert(num < 67108864), num < 0 ? this.isubn(-num) : 0 !== this.negative ? 1 === this.length && (0 | this.words[0]) <= num ? (this.words[0] = num - (0 | this.words[0]), 
            this.negative = 0, this) : (this.negative = 0, this.isubn(num), this.negative = 1, 
            this) : this._iaddn(num);
        }, BN.prototype._iaddn = function(num) {
            this.words[0] += num;
            for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) this.words[i] -= 67108864, 
            i === this.length - 1 ? this.words[i + 1] = 1 : this.words[i + 1]++;
            return this.length = Math.max(this.length, i + 1), this;
        }, BN.prototype.isubn = function(num) {
            if (assert("number" == typeof num), assert(num < 67108864), num < 0) return this.iaddn(-num);
            if (0 !== this.negative) return this.negative = 0, this.iaddn(num), this.negative = 1, 
            this;
            if (this.words[0] -= num, 1 === this.length && this.words[0] < 0) this.words[0] = -this.words[0], 
            this.negative = 1; else for (var i = 0; i < this.length && this.words[i] < 0; i++) this.words[i] += 67108864, 
            this.words[i + 1] -= 1;
            return this._strip();
        }, BN.prototype.addn = function(num) {
            return this.clone().iaddn(num);
        }, BN.prototype.subn = function(num) {
            return this.clone().isubn(num);
        }, BN.prototype.iabs = function() {
            return this.negative = 0, this;
        }, BN.prototype.abs = function() {
            return this.clone().iabs();
        }, BN.prototype._ishlnsubmul = function(num, mul, shift) {
            var i, w, len = num.length + shift;
            this._expand(len);
            var carry = 0;
            for (i = 0; i < num.length; i++) {
                w = (0 | this.words[i + shift]) + carry;
                var right = (0 | num.words[i]) * mul;
                carry = ((w -= 67108863 & right) >> 26) - (right / 67108864 | 0), this.words[i + shift] = 67108863 & w;
            }
            for (;i < this.length - shift; i++) carry = (w = (0 | this.words[i + shift]) + carry) >> 26, 
            this.words[i + shift] = 67108863 & w;
            if (0 === carry) return this._strip();
            for (assert(-1 === carry), carry = 0, i = 0; i < this.length; i++) carry = (w = -(0 | this.words[i]) + carry) >> 26, 
            this.words[i] = 67108863 & w;
            return this.negative = 1, this._strip();
        }, BN.prototype._wordDiv = function(num, mode) {
            var shift = (this.length, num.length), a = this.clone(), b = num, bhi = 0 | b.words[b.length - 1];
            0 != (shift = 26 - this._countBits(bhi)) && (b = b.ushln(shift), a.iushln(shift), 
            bhi = 0 | b.words[b.length - 1]);
            var q, m = a.length - b.length;
            if ("mod" !== mode) {
                (q = new BN(null)).length = m + 1, q.words = new Array(q.length);
                for (var i = 0; i < q.length; i++) q.words[i] = 0;
            }
            var diff = a.clone()._ishlnsubmul(b, 1, m);
            0 === diff.negative && (a = diff, q && (q.words[m] = 1));
            for (var j = m - 1; j >= 0; j--) {
                var qj = 67108864 * (0 | a.words[b.length + j]) + (0 | a.words[b.length + j - 1]);
                for (qj = Math.min(qj / bhi | 0, 67108863), a._ishlnsubmul(b, qj, j); 0 !== a.negative; ) qj--, 
                a.negative = 0, a._ishlnsubmul(b, 1, j), a.isZero() || (a.negative ^= 1);
                q && (q.words[j] = qj);
            }
            return q && q._strip(), a._strip(), "div" !== mode && 0 !== shift && a.iushrn(shift), 
            {
                div: q || null,
                mod: a
            };
        }, BN.prototype.divmod = function(num, mode, positive) {
            return assert(!num.isZero()), this.isZero() ? {
                div: new BN(0),
                mod: new BN(0)
            } : 0 !== this.negative && 0 === num.negative ? (res = this.neg().divmod(num, mode), 
            "mod" !== mode && (div = res.div.neg()), "div" !== mode && (mod = res.mod.neg(), 
            positive && 0 !== mod.negative && mod.iadd(num)), {
                div: div,
                mod: mod
            }) : 0 === this.negative && 0 !== num.negative ? (res = this.divmod(num.neg(), mode), 
            "mod" !== mode && (div = res.div.neg()), {
                div: div,
                mod: res.mod
            }) : this.negative & num.negative ? (res = this.neg().divmod(num.neg(), mode), "div" !== mode && (mod = res.mod.neg(), 
            positive && 0 !== mod.negative && mod.isub(num)), {
                div: res.div,
                mod: mod
            }) : num.length > this.length || this.cmp(num) < 0 ? {
                div: new BN(0),
                mod: this
            } : 1 === num.length ? "div" === mode ? {
                div: this.divn(num.words[0]),
                mod: null
            } : "mod" === mode ? {
                div: null,
                mod: new BN(this.modrn(num.words[0]))
            } : {
                div: this.divn(num.words[0]),
                mod: new BN(this.modrn(num.words[0]))
            } : this._wordDiv(num, mode);
            var div, mod, res;
        }, BN.prototype.div = function(num) {
            return this.divmod(num, "div", !1).div;
        }, BN.prototype.mod = function(num) {
            return this.divmod(num, "mod", !1).mod;
        }, BN.prototype.umod = function(num) {
            return this.divmod(num, "mod", !0).mod;
        }, BN.prototype.divRound = function(num) {
            var dm = this.divmod(num);
            if (dm.mod.isZero()) return dm.div;
            var mod = 0 !== dm.div.negative ? dm.mod.isub(num) : dm.mod, half = num.ushrn(1), r2 = num.andln(1), cmp = mod.cmp(half);
            return cmp < 0 || 1 === r2 && 0 === cmp ? dm.div : 0 !== dm.div.negative ? dm.div.isubn(1) : dm.div.iaddn(1);
        }, BN.prototype.modrn = function(num) {
            var isNegNum = num < 0;
            isNegNum && (num = -num), assert(num <= 67108863);
            for (var p = (1 << 26) % num, acc = 0, i = this.length - 1; i >= 0; i--) acc = (p * acc + (0 | this.words[i])) % num;
            return isNegNum ? -acc : acc;
        }, BN.prototype.modn = function(num) {
            return this.modrn(num);
        }, BN.prototype.idivn = function(num) {
            var isNegNum = num < 0;
            isNegNum && (num = -num), assert(num <= 67108863);
            for (var carry = 0, i = this.length - 1; i >= 0; i--) {
                var w = (0 | this.words[i]) + 67108864 * carry;
                this.words[i] = w / num | 0, carry = w % num;
            }
            return this._strip(), isNegNum ? this.ineg() : this;
        }, BN.prototype.divn = function(num) {
            return this.clone().idivn(num);
        }, BN.prototype.egcd = function(p) {
            assert(0 === p.negative), assert(!p.isZero());
            var x = this, y = p.clone();
            x = 0 !== x.negative ? x.umod(p) : x.clone();
            for (var A = new BN(1), B = new BN(0), C = new BN(0), D = new BN(1), g = 0; x.isEven() && y.isEven(); ) x.iushrn(1), 
            y.iushrn(1), ++g;
            for (var yp = y.clone(), xp = x.clone(); !x.isZero(); ) {
                for (var i = 0, im = 1; !(x.words[0] & im) && i < 26; ++i, im <<= 1) ;
                if (i > 0) for (x.iushrn(i); i-- > 0; ) (A.isOdd() || B.isOdd()) && (A.iadd(yp), 
                B.isub(xp)), A.iushrn(1), B.iushrn(1);
                for (var j = 0, jm = 1; !(y.words[0] & jm) && j < 26; ++j, jm <<= 1) ;
                if (j > 0) for (y.iushrn(j); j-- > 0; ) (C.isOdd() || D.isOdd()) && (C.iadd(yp), 
                D.isub(xp)), C.iushrn(1), D.iushrn(1);
                x.cmp(y) >= 0 ? (x.isub(y), A.isub(C), B.isub(D)) : (y.isub(x), C.isub(A), D.isub(B));
            }
            return {
                a: C,
                b: D,
                gcd: y.iushln(g)
            };
        }, BN.prototype._invmp = function(p) {
            assert(0 === p.negative), assert(!p.isZero());
            var a = this, b = p.clone();
            a = 0 !== a.negative ? a.umod(p) : a.clone();
            for (var res, x1 = new BN(1), x2 = new BN(0), delta = b.clone(); a.cmpn(1) > 0 && b.cmpn(1) > 0; ) {
                for (var i = 0, im = 1; !(a.words[0] & im) && i < 26; ++i, im <<= 1) ;
                if (i > 0) for (a.iushrn(i); i-- > 0; ) x1.isOdd() && x1.iadd(delta), x1.iushrn(1);
                for (var j = 0, jm = 1; !(b.words[0] & jm) && j < 26; ++j, jm <<= 1) ;
                if (j > 0) for (b.iushrn(j); j-- > 0; ) x2.isOdd() && x2.iadd(delta), x2.iushrn(1);
                a.cmp(b) >= 0 ? (a.isub(b), x1.isub(x2)) : (b.isub(a), x2.isub(x1));
            }
            return (res = 0 === a.cmpn(1) ? x1 : x2).cmpn(0) < 0 && res.iadd(p), res;
        }, BN.prototype.gcd = function(num) {
            if (this.isZero()) return num.abs();
            if (num.isZero()) return this.abs();
            var a = this.clone(), b = num.clone();
            a.negative = 0, b.negative = 0;
            for (var shift = 0; a.isEven() && b.isEven(); shift++) a.iushrn(1), b.iushrn(1);
            for (;;) {
                for (;a.isEven(); ) a.iushrn(1);
                for (;b.isEven(); ) b.iushrn(1);
                var r = a.cmp(b);
                if (r < 0) {
                    var t = a;
                    a = b, b = t;
                } else if (0 === r || 0 === b.cmpn(1)) break;
                a.isub(b);
            }
            return b.iushln(shift);
        }, BN.prototype.invm = function(num) {
            return this.egcd(num).a.umod(num);
        }, BN.prototype.isEven = function() {
            return !(1 & this.words[0]);
        }, BN.prototype.isOdd = function() {
            return !(1 & ~this.words[0]);
        }, BN.prototype.andln = function(num) {
            return this.words[0] & num;
        }, BN.prototype.bincn = function(bit) {
            assert("number" == typeof bit);
            var r = bit % 26, s = (bit - r) / 26, q = 1 << r;
            if (this.length <= s) return this._expand(s + 1), this.words[s] |= q, this;
            for (var carry = q, i = s; 0 !== carry && i < this.length; i++) {
                var w = 0 | this.words[i];
                carry = (w += carry) >>> 26, w &= 67108863, this.words[i] = w;
            }
            return 0 !== carry && (this.words[i] = carry, this.length++), this;
        }, BN.prototype.isZero = function() {
            return 1 === this.length && 0 === this.words[0];
        }, BN.prototype.cmpn = function(num) {
            var res, negative = num < 0;
            if (0 !== this.negative && !negative) return -1;
            if (0 === this.negative && negative) return 1;
            if (this._strip(), this.length > 1) res = 1; else {
                negative && (num = -num), assert(num <= 67108863, "Number is too big");
                var w = 0 | this.words[0];
                res = w === num ? 0 : w < num ? -1 : 1;
            }
            return 0 !== this.negative ? 0 | -res : res;
        }, BN.prototype.cmp = function(num) {
            if (0 !== this.negative && 0 === num.negative) return -1;
            if (0 === this.negative && 0 !== num.negative) return 1;
            var res = this.ucmp(num);
            return 0 !== this.negative ? 0 | -res : res;
        }, BN.prototype.ucmp = function(num) {
            if (this.length > num.length) return 1;
            if (this.length < num.length) return -1;
            for (var res = 0, i = this.length - 1; i >= 0; i--) {
                var a = 0 | this.words[i], b = 0 | num.words[i];
                if (a !== b) {
                    a < b ? res = -1 : a > b && (res = 1);
                    break;
                }
            }
            return res;
        }, BN.prototype.gtn = function(num) {
            return 1 === this.cmpn(num);
        }, BN.prototype.gt = function(num) {
            return 1 === this.cmp(num);
        }, BN.prototype.gten = function(num) {
            return this.cmpn(num) >= 0;
        }, BN.prototype.gte = function(num) {
            return this.cmp(num) >= 0;
        }, BN.prototype.ltn = function(num) {
            return -1 === this.cmpn(num);
        }, BN.prototype.lt = function(num) {
            return -1 === this.cmp(num);
        }, BN.prototype.lten = function(num) {
            return this.cmpn(num) <= 0;
        }, BN.prototype.lte = function(num) {
            return this.cmp(num) <= 0;
        }, BN.prototype.eqn = function(num) {
            return 0 === this.cmpn(num);
        }, BN.prototype.eq = function(num) {
            return 0 === this.cmp(num);
        }, BN.red = function(num) {
            return new Red(num);
        }, BN.prototype.toRed = function(ctx) {
            return assert(!this.red, "Already a number in reduction context"), assert(0 === this.negative, "red works only with positives"), 
            ctx.convertTo(this)._forceRed(ctx);
        }, BN.prototype.fromRed = function() {
            return assert(this.red, "fromRed works only with numbers in reduction context"), 
            this.red.convertFrom(this);
        }, BN.prototype._forceRed = function(ctx) {
            return this.red = ctx, this;
        }, BN.prototype.forceRed = function(ctx) {
            return assert(!this.red, "Already a number in reduction context"), this._forceRed(ctx);
        }, BN.prototype.redAdd = function(num) {
            return assert(this.red, "redAdd works only with red numbers"), this.red.add(this, num);
        }, BN.prototype.redIAdd = function(num) {
            return assert(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, num);
        }, BN.prototype.redSub = function(num) {
            return assert(this.red, "redSub works only with red numbers"), this.red.sub(this, num);
        }, BN.prototype.redISub = function(num) {
            return assert(this.red, "redISub works only with red numbers"), this.red.isub(this, num);
        }, BN.prototype.redShl = function(num) {
            return assert(this.red, "redShl works only with red numbers"), this.red.shl(this, num);
        }, BN.prototype.redMul = function(num) {
            return assert(this.red, "redMul works only with red numbers"), this.red._verify2(this, num), 
            this.red.mul(this, num);
        }, BN.prototype.redIMul = function(num) {
            return assert(this.red, "redMul works only with red numbers"), this.red._verify2(this, num), 
            this.red.imul(this, num);
        }, BN.prototype.redSqr = function() {
            return assert(this.red, "redSqr works only with red numbers"), this.red._verify1(this), 
            this.red.sqr(this);
        }, BN.prototype.redISqr = function() {
            return assert(this.red, "redISqr works only with red numbers"), this.red._verify1(this), 
            this.red.isqr(this);
        }, BN.prototype.redSqrt = function() {
            return assert(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), 
            this.red.sqrt(this);
        }, BN.prototype.redInvm = function() {
            return assert(this.red, "redInvm works only with red numbers"), this.red._verify1(this), 
            this.red.invm(this);
        }, BN.prototype.redNeg = function() {
            return assert(this.red, "redNeg works only with red numbers"), this.red._verify1(this), 
            this.red.neg(this);
        }, BN.prototype.redPow = function(num) {
            return assert(this.red && !num.red, "redPow(normalNum)"), this.red._verify1(this), 
            this.red.pow(this, num);
        };
        var primes = {
            k256: null,
            p224: null,
            p192: null,
            p25519: null
        };
        function MPrime(name, p) {
            this.name = name, this.p = new BN(p, 16), this.n = this.p.bitLength(), this.k = new BN(1).iushln(this.n).isub(this.p), 
            this.tmp = this._tmp();
        }
        function K256() {
            MPrime.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
        }
        function P224() {
            MPrime.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
        }
        function P192() {
            MPrime.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
        }
        function P25519() {
            MPrime.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
        }
        function Red(m) {
            if ("string" == typeof m) {
                var prime = BN._prime(m);
                this.m = prime.p, this.prime = prime;
            } else assert(m.gtn(1), "modulus must be greater than 1"), this.m = m, this.prime = null;
        }
        function Mont(m) {
            Red.call(this, m), this.shift = this.m.bitLength(), this.shift % 26 != 0 && (this.shift += 26 - this.shift % 26), 
            this.r = new BN(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), 
            this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), 
            this.minv = this.r.sub(this.minv);
        }
        MPrime.prototype._tmp = function() {
            var tmp = new BN(null);
            return tmp.words = new Array(Math.ceil(this.n / 13)), tmp;
        }, MPrime.prototype.ireduce = function(num) {
            var rlen, r = num;
            do {
                this.split(r, this.tmp), rlen = (r = (r = this.imulK(r)).iadd(this.tmp)).bitLength();
            } while (rlen > this.n);
            var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
            return 0 === cmp ? (r.words[0] = 0, r.length = 1) : cmp > 0 ? r.isub(this.p) : void 0 !== r.strip ? r.strip() : r._strip(), 
            r;
        }, MPrime.prototype.split = function(input, out) {
            input.iushrn(this.n, 0, out);
        }, MPrime.prototype.imulK = function(num) {
            return num.imul(this.k);
        }, inherits(K256, MPrime), K256.prototype.split = function(input, output) {
            for (var outLen = Math.min(input.length, 9), i = 0; i < outLen; i++) output.words[i] = input.words[i];
            if (output.length = outLen, input.length <= 9) return input.words[0] = 0, void (input.length = 1);
            var prev = input.words[9];
            for (output.words[output.length++] = 4194303 & prev, i = 10; i < input.length; i++) {
                var next = 0 | input.words[i];
                input.words[i - 10] = (4194303 & next) << 4 | prev >>> 22, prev = next;
            }
            prev >>>= 22, input.words[i - 10] = prev, 0 === prev && input.length > 10 ? input.length -= 10 : input.length -= 9;
        }, K256.prototype.imulK = function(num) {
            num.words[num.length] = 0, num.words[num.length + 1] = 0, num.length += 2;
            for (var lo = 0, i = 0; i < num.length; i++) {
                var w = 0 | num.words[i];
                lo += 977 * w, num.words[i] = 67108863 & lo, lo = 64 * w + (lo / 67108864 | 0);
            }
            return 0 === num.words[num.length - 1] && (num.length--, 0 === num.words[num.length - 1] && num.length--), 
            num;
        }, inherits(P224, MPrime), inherits(P192, MPrime), inherits(P25519, MPrime), P25519.prototype.imulK = function(num) {
            for (var carry = 0, i = 0; i < num.length; i++) {
                var hi = 19 * (0 | num.words[i]) + carry, lo = 67108863 & hi;
                hi >>>= 26, num.words[i] = lo, carry = hi;
            }
            return 0 !== carry && (num.words[num.length++] = carry), num;
        }, BN._prime = function(name) {
            if (primes[name]) return primes[name];
            var prime;
            if ("k256" === name) prime = new K256; else if ("p224" === name) prime = new P224; else if ("p192" === name) prime = new P192; else {
                if ("p25519" !== name) throw new Error("Unknown prime " + name);
                prime = new P25519;
            }
            return primes[name] = prime, prime;
        }, Red.prototype._verify1 = function(a) {
            assert(0 === a.negative, "red works only with positives"), assert(a.red, "red works only with red numbers");
        }, Red.prototype._verify2 = function(a, b) {
            assert(!(a.negative | b.negative), "red works only with positives"), assert(a.red && a.red === b.red, "red works only with red numbers");
        }, Red.prototype.imod = function(a) {
            return this.prime ? this.prime.ireduce(a)._forceRed(this) : (move(a, a.umod(this.m)._forceRed(this)), 
            a);
        }, Red.prototype.neg = function(a) {
            return a.isZero() ? a.clone() : this.m.sub(a)._forceRed(this);
        }, Red.prototype.add = function(a, b) {
            this._verify2(a, b);
            var res = a.add(b);
            return res.cmp(this.m) >= 0 && res.isub(this.m), res._forceRed(this);
        }, Red.prototype.iadd = function(a, b) {
            this._verify2(a, b);
            var res = a.iadd(b);
            return res.cmp(this.m) >= 0 && res.isub(this.m), res;
        }, Red.prototype.sub = function(a, b) {
            this._verify2(a, b);
            var res = a.sub(b);
            return res.cmpn(0) < 0 && res.iadd(this.m), res._forceRed(this);
        }, Red.prototype.isub = function(a, b) {
            this._verify2(a, b);
            var res = a.isub(b);
            return res.cmpn(0) < 0 && res.iadd(this.m), res;
        }, Red.prototype.shl = function(a, num) {
            return this._verify1(a), this.imod(a.ushln(num));
        }, Red.prototype.imul = function(a, b) {
            return this._verify2(a, b), this.imod(a.imul(b));
        }, Red.prototype.mul = function(a, b) {
            return this._verify2(a, b), this.imod(a.mul(b));
        }, Red.prototype.isqr = function(a) {
            return this.imul(a, a.clone());
        }, Red.prototype.sqr = function(a) {
            return this.mul(a, a);
        }, Red.prototype.sqrt = function(a) {
            if (a.isZero()) return a.clone();
            var mod3 = this.m.andln(3);
            if (assert(mod3 % 2 == 1), 3 === mod3) {
                var pow = this.m.add(new BN(1)).iushrn(2);
                return this.pow(a, pow);
            }
            for (var q = this.m.subn(1), s = 0; !q.isZero() && 0 === q.andln(1); ) s++, q.iushrn(1);
            assert(!q.isZero());
            var one = new BN(1).toRed(this), nOne = one.redNeg(), lpow = this.m.subn(1).iushrn(1), z = this.m.bitLength();
            for (z = new BN(2 * z * z).toRed(this); 0 !== this.pow(z, lpow).cmp(nOne); ) z.redIAdd(nOne);
            for (var c = this.pow(z, q), r = this.pow(a, q.addn(1).iushrn(1)), t = this.pow(a, q), m = s; 0 !== t.cmp(one); ) {
                for (var tmp = t, i = 0; 0 !== tmp.cmp(one); i++) tmp = tmp.redSqr();
                assert(i < m);
                var b = this.pow(c, new BN(1).iushln(m - i - 1));
                r = r.redMul(b), c = b.redSqr(), t = t.redMul(c), m = i;
            }
            return r;
        }, Red.prototype.invm = function(a) {
            var inv = a._invmp(this.m);
            return 0 !== inv.negative ? (inv.negative = 0, this.imod(inv).redNeg()) : this.imod(inv);
        }, Red.prototype.pow = function(a, num) {
            if (num.isZero()) return new BN(1).toRed(this);
            if (0 === num.cmpn(1)) return a.clone();
            var wnd = new Array(16);
            wnd[0] = new BN(1).toRed(this), wnd[1] = a;
            for (var i = 2; i < wnd.length; i++) wnd[i] = this.mul(wnd[i - 1], a);
            var res = wnd[0], current = 0, currentLen = 0, start = num.bitLength() % 26;
            for (0 === start && (start = 26), i = num.length - 1; i >= 0; i--) {
                for (var word = num.words[i], j = start - 1; j >= 0; j--) {
                    var bit = word >> j & 1;
                    res !== wnd[0] && (res = this.sqr(res)), 0 !== bit || 0 !== current ? (current <<= 1, 
                    current |= bit, (4 == ++currentLen || 0 === i && 0 === j) && (res = this.mul(res, wnd[current]), 
                    currentLen = 0, current = 0)) : currentLen = 0;
                }
                start = 26;
            }
            return res;
        }, Red.prototype.convertTo = function(num) {
            var r = num.umod(this.m);
            return r === num ? r.clone() : r;
        }, Red.prototype.convertFrom = function(num) {
            var res = num.clone();
            return res.red = null, res;
        }, BN.mont = function(num) {
            return new Mont(num);
        }, inherits(Mont, Red), Mont.prototype.convertTo = function(num) {
            return this.imod(num.ushln(this.shift));
        }, Mont.prototype.convertFrom = function(num) {
            var r = this.imod(num.mul(this.rinv));
            return r.red = null, r;
        }, Mont.prototype.imul = function(a, b) {
            if (a.isZero() || b.isZero()) return a.words[0] = 0, a.length = 1, a;
            var t = a.imul(b), c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = t.isub(c).iushrn(this.shift), res = u;
            return u.cmp(this.m) >= 0 ? res = u.isub(this.m) : u.cmpn(0) < 0 && (res = u.iadd(this.m)), 
            res._forceRed(this);
        }, Mont.prototype.mul = function(a, b) {
            if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);
            var t = a.mul(b), c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = t.isub(c).iushrn(this.shift), res = u;
            return u.cmp(this.m) >= 0 ? res = u.isub(this.m) : u.cmpn(0) < 0 && (res = u.iadd(this.m)), 
            res._forceRed(this);
        }, Mont.prototype.invm = function(a) {
            return this.imod(a._invmp(this.m).mul(this.r2))._forceRed(this);
        };
    }(bn$1, bn)), bn$1.exports;
}

var bnExports = requireBn(), BN = getDefaultExportFromCjs(bnExports), safeBuffer = {
    exports: {}
}, hasRequiredSafeBuffer, src, hasRequiredSrc, bs58$1, hasRequiredBs58;

function requireSafeBuffer() {
    return hasRequiredSafeBuffer || (hasRequiredSafeBuffer = 1, function(module, exports) {
        var buffer = require$$0$4, Buffer = buffer.Buffer;
        function copyProps(src, dst) {
            for (var key in src) dst[key] = src[key];
        }
        function SafeBuffer(arg, encodingOrOffset, length) {
            return Buffer(arg, encodingOrOffset, length);
        }
        Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow ? module.exports = buffer : (copyProps(buffer, exports), 
        exports.Buffer = SafeBuffer), SafeBuffer.prototype = Object.create(Buffer.prototype), 
        copyProps(Buffer, SafeBuffer), SafeBuffer.from = function(arg, encodingOrOffset, length) {
            if ("number" == typeof arg) throw new TypeError("Argument must not be a number");
            return Buffer(arg, encodingOrOffset, length);
        }, SafeBuffer.alloc = function(size, fill, encoding) {
            if ("number" != typeof size) throw new TypeError("Argument must be a number");
            var buf = Buffer(size);
            return void 0 !== fill ? "string" == typeof encoding ? buf.fill(fill, encoding) : buf.fill(fill) : buf.fill(0), 
            buf;
        }, SafeBuffer.allocUnsafe = function(size) {
            if ("number" != typeof size) throw new TypeError("Argument must be a number");
            return Buffer(size);
        }, SafeBuffer.allocUnsafeSlow = function(size) {
            if ("number" != typeof size) throw new TypeError("Argument must be a number");
            return buffer.SlowBuffer(size);
        };
    }(safeBuffer, safeBuffer.exports)), safeBuffer.exports;
}

function requireSrc() {
    if (hasRequiredSrc) return src;
    hasRequiredSrc = 1;
    var _Buffer = requireSafeBuffer().Buffer;
    return src = function(ALPHABET) {
        if (ALPHABET.length >= 255) throw new TypeError("Alphabet too long");
        for (var BASE_MAP = new Uint8Array(256), j = 0; j < BASE_MAP.length; j++) BASE_MAP[j] = 255;
        for (var i = 0; i < ALPHABET.length; i++) {
            var x = ALPHABET.charAt(i), xc = x.charCodeAt(0);
            if (255 !== BASE_MAP[xc]) throw new TypeError(x + " is ambiguous");
            BASE_MAP[xc] = i;
        }
        var BASE = ALPHABET.length, LEADER = ALPHABET.charAt(0), FACTOR = Math.log(BASE) / Math.log(256), iFACTOR = Math.log(256) / Math.log(BASE);
        function decodeUnsafe(source) {
            if ("string" != typeof source) throw new TypeError("Expected String");
            if (0 === source.length) return _Buffer.alloc(0);
            for (var psz = 0, zeroes = 0, length = 0; source[psz] === LEADER; ) zeroes++, psz++;
            for (var size = (source.length - psz) * FACTOR + 1 >>> 0, b256 = new Uint8Array(size); psz < source.length; ) {
                var carry = BASE_MAP[source.charCodeAt(psz)];
                if (255 === carry) return;
                for (var i = 0, it3 = size - 1; (0 !== carry || i < length) && -1 !== it3; it3--, 
                i++) carry += BASE * b256[it3] >>> 0, b256[it3] = carry % 256 >>> 0, carry = carry / 256 >>> 0;
                if (0 !== carry) throw new Error("Non-zero carry");
                length = i, psz++;
            }
            for (var it4 = size - length; it4 !== size && 0 === b256[it4]; ) it4++;
            var vch = _Buffer.allocUnsafe(zeroes + (size - it4));
            vch.fill(0, 0, zeroes);
            for (var j = zeroes; it4 !== size; ) vch[j++] = b256[it4++];
            return vch;
        }
        return {
            encode: function(source) {
                if ((Array.isArray(source) || source instanceof Uint8Array) && (source = _Buffer.from(source)), 
                !_Buffer.isBuffer(source)) throw new TypeError("Expected Buffer");
                if (0 === source.length) return "";
                for (var zeroes = 0, length = 0, pbegin = 0, pend = source.length; pbegin !== pend && 0 === source[pbegin]; ) pbegin++, 
                zeroes++;
                for (var size = (pend - pbegin) * iFACTOR + 1 >>> 0, b58 = new Uint8Array(size); pbegin !== pend; ) {
                    for (var carry = source[pbegin], i = 0, it1 = size - 1; (0 !== carry || i < length) && -1 !== it1; it1--, 
                    i++) carry += 256 * b58[it1] >>> 0, b58[it1] = carry % BASE >>> 0, carry = carry / BASE >>> 0;
                    if (0 !== carry) throw new Error("Non-zero carry");
                    length = i, pbegin++;
                }
                for (var it2 = size - length; it2 !== size && 0 === b58[it2]; ) it2++;
                for (var str = LEADER.repeat(zeroes); it2 < size; ++it2) str += ALPHABET.charAt(b58[it2]);
                return str;
            },
            decodeUnsafe: decodeUnsafe,
            decode: function(string) {
                var buffer = decodeUnsafe(string);
                if (buffer) return buffer;
                throw new Error("Non-base" + BASE + " character");
            }
        };
    }, src;
}

function requireBs58() {
    if (hasRequiredBs58) return bs58$1;
    hasRequiredBs58 = 1;
    var basex = requireSrc();
    return bs58$1 = basex("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
}

var bs58Exports = requireBs58(), bs58 = getDefaultExportFromCjs(bs58Exports);

const SHA256_K = new Uint32Array([ 1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298 ]), SHA256_IV = new Uint32Array([ 1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225 ]), SHA256_W = new Uint32Array(64);

class SHA256 extends HashMD {
    constructor() {
        super(64, 32, 8, !1), this.A = 0 | SHA256_IV[0], this.B = 0 | SHA256_IV[1], this.C = 0 | SHA256_IV[2], 
        this.D = 0 | SHA256_IV[3], this.E = 0 | SHA256_IV[4], this.F = 0 | SHA256_IV[5], 
        this.G = 0 | SHA256_IV[6], this.H = 0 | SHA256_IV[7];
    }
    get() {
        const {A: A, B: B, C: C, D: D, E: E, F: F, G: G, H: H} = this;
        return [ A, B, C, D, E, F, G, H ];
    }
    set(A, B, C, D, E, F, G, H) {
        this.A = 0 | A, this.B = 0 | B, this.C = 0 | C, this.D = 0 | D, this.E = 0 | E, 
        this.F = 0 | F, this.G = 0 | G, this.H = 0 | H;
    }
    process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4) SHA256_W[i] = view.getUint32(offset, !1);
        for (let i = 16; i < 64; i++) {
            const W15 = SHA256_W[i - 15], W2 = SHA256_W[i - 2], s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3, s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
            SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
        }
        let {A: A, B: B, C: C, D: D, E: E, F: F, G: G, H: H} = this;
        for (let i = 0; i < 64; i++) {
            const T1 = H + (rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25)) + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0, T2 = (rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22)) + Maj(A, B, C) | 0;
            H = G, G = F, F = E, E = D + T1 | 0, D = C, C = B, B = A, A = T1 + T2 | 0;
        }
        A = A + this.A | 0, B = B + this.B | 0, C = C + this.C | 0, D = D + this.D | 0, 
        E = E + this.E | 0, F = F + this.F | 0, G = G + this.G | 0, H = H + this.H | 0, 
        this.set(A, B, C, D, E, F, G, H);
    }
    roundClean() {
        SHA256_W.fill(0);
    }
    destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
    }
}

const sha256 = wrapConstructor((() => new SHA256));

var lib$2 = {};

function inRange(a, min, max) {
    return min <= a && a <= max;
}

function ToDictionary(o) {
    if (void 0 === o) return {};
    if (o === Object(o)) return o;
    throw TypeError("Could not convert argument to dictionary");
}

function stringToCodePoints(string) {
    for (var s = String(string), n = s.length, i = 0, u = []; i < n; ) {
        var c = s.charCodeAt(i);
        if (c < 55296 || c > 57343) u.push(c); else if (56320 <= c && c <= 57343) u.push(65533); else if (55296 <= c && c <= 56319) if (i === n - 1) u.push(65533); else {
            var d = string.charCodeAt(i + 1);
            if (56320 <= d && d <= 57343) {
                var a = 1023 & c, b = 1023 & d;
                u.push(65536 + (a << 10) + b), i += 1;
            } else u.push(65533);
        }
        i += 1;
    }
    return u;
}

function codePointsToString(code_points) {
    for (var s = "", i = 0; i < code_points.length; ++i) {
        var cp = code_points[i];
        cp <= 65535 ? s += String.fromCharCode(cp) : (cp -= 65536, s += String.fromCharCode(55296 + (cp >> 10), 56320 + (1023 & cp)));
    }
    return s;
}

var end_of_stream = -1;

function Stream(tokens) {
    this.tokens = [].slice.call(tokens);
}

Stream.prototype = {
    endOfStream: function() {
        return !this.tokens.length;
    },
    read: function() {
        return this.tokens.length ? this.tokens.shift() : end_of_stream;
    },
    prepend: function(token) {
        if (Array.isArray(token)) for (var tokens = token; tokens.length; ) this.tokens.unshift(tokens.pop()); else this.tokens.unshift(token);
    },
    push: function(token) {
        if (Array.isArray(token)) for (var tokens = token; tokens.length; ) this.tokens.push(tokens.shift()); else this.tokens.push(token);
    }
};

var finished = -1;

function decoderError(fatal, opt_code_point) {
    if (fatal) throw TypeError("Decoder error");
    return opt_code_point || 65533;
}

var DEFAULT_ENCODING = "utf-8";

function TextDecoder$1(encoding, options) {
    if (!(this instanceof TextDecoder$1)) return new TextDecoder$1(encoding, options);
    if ((encoding = void 0 !== encoding ? String(encoding).toLowerCase() : DEFAULT_ENCODING) !== DEFAULT_ENCODING) throw new Error("Encoding not supported. Only utf-8 is supported");
    options = ToDictionary(options), this._streaming = !1, this._BOMseen = !1, this._decoder = null, 
    this._fatal = Boolean(options.fatal), this._ignoreBOM = Boolean(options.ignoreBOM), 
    Object.defineProperty(this, "encoding", {
        value: "utf-8"
    }), Object.defineProperty(this, "fatal", {
        value: this._fatal
    }), Object.defineProperty(this, "ignoreBOM", {
        value: this._ignoreBOM
    });
}

function TextEncoder$1(encoding, options) {
    if (!(this instanceof TextEncoder$1)) return new TextEncoder$1(encoding, options);
    if ((encoding = void 0 !== encoding ? String(encoding).toLowerCase() : DEFAULT_ENCODING) !== DEFAULT_ENCODING) throw new Error("Encoding not supported. Only utf-8 is supported");
    options = ToDictionary(options), this._streaming = !1, this._encoder = null, this._options = {
        fatal: Boolean(options.fatal)
    }, Object.defineProperty(this, "encoding", {
        value: "utf-8"
    });
}

function UTF8Decoder(options) {
    var fatal = options.fatal, utf8_code_point = 0, utf8_bytes_seen = 0, utf8_bytes_needed = 0, utf8_lower_boundary = 128, utf8_upper_boundary = 191;
    this.handler = function(stream, bite) {
        if (bite === end_of_stream && 0 !== utf8_bytes_needed) return utf8_bytes_needed = 0, 
        decoderError(fatal);
        if (bite === end_of_stream) return finished;
        if (0 === utf8_bytes_needed) {
            if (inRange(bite, 0, 127)) return bite;
            if (inRange(bite, 194, 223)) utf8_bytes_needed = 1, utf8_code_point = bite - 192; else if (inRange(bite, 224, 239)) 224 === bite && (utf8_lower_boundary = 160), 
            237 === bite && (utf8_upper_boundary = 159), utf8_bytes_needed = 2, utf8_code_point = bite - 224; else {
                if (!inRange(bite, 240, 244)) return decoderError(fatal);
                240 === bite && (utf8_lower_boundary = 144), 244 === bite && (utf8_upper_boundary = 143), 
                utf8_bytes_needed = 3, utf8_code_point = bite - 240;
            }
            return utf8_code_point <<= 6 * utf8_bytes_needed, null;
        }
        if (!inRange(bite, utf8_lower_boundary, utf8_upper_boundary)) return utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0, 
        utf8_lower_boundary = 128, utf8_upper_boundary = 191, stream.prepend(bite), decoderError(fatal);
        if (utf8_lower_boundary = 128, utf8_upper_boundary = 191, utf8_code_point += bite - 128 << 6 * (utf8_bytes_needed - (utf8_bytes_seen += 1)), 
        utf8_bytes_seen !== utf8_bytes_needed) return null;
        var code_point = utf8_code_point;
        return utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0, code_point;
    };
}

function UTF8Encoder(options) {
    options.fatal, this.handler = function(stream, code_point) {
        if (code_point === end_of_stream) return finished;
        if (inRange(code_point, 0, 127)) return code_point;
        var count, offset;
        inRange(code_point, 128, 2047) ? (count = 1, offset = 192) : inRange(code_point, 2048, 65535) ? (count = 2, 
        offset = 224) : inRange(code_point, 65536, 1114111) && (count = 3, offset = 240);
        for (var bytes = [ (code_point >> 6 * count) + offset ]; count > 0; ) {
            var temp = code_point >> 6 * (count - 1);
            bytes.push(128 | 63 & temp), count -= 1;
        }
        return bytes;
    };
}

TextDecoder$1.prototype = {
    decode: function(input, options) {
        var bytes;
        bytes = "object" == typeof input && input instanceof ArrayBuffer ? new Uint8Array(input) : "object" == typeof input && "buffer" in input && input.buffer instanceof ArrayBuffer ? new Uint8Array(input.buffer, input.byteOffset, input.byteLength) : new Uint8Array(0), 
        options = ToDictionary(options), this._streaming || (this._decoder = new UTF8Decoder({
            fatal: this._fatal
        }), this._BOMseen = !1), this._streaming = Boolean(options.stream);
        for (var result, input_stream = new Stream(bytes), code_points = []; !input_stream.endOfStream() && (result = this._decoder.handler(input_stream, input_stream.read())) !== finished; ) null !== result && (Array.isArray(result) ? code_points.push.apply(code_points, result) : code_points.push(result));
        if (!this._streaming) {
            do {
                if ((result = this._decoder.handler(input_stream, input_stream.read())) === finished) break;
                null !== result && (Array.isArray(result) ? code_points.push.apply(code_points, result) : code_points.push(result));
            } while (!input_stream.endOfStream());
            this._decoder = null;
        }
        return code_points.length && (-1 === [ "utf-8" ].indexOf(this.encoding) || this._ignoreBOM || this._BOMseen || (65279 === code_points[0] ? (this._BOMseen = !0, 
        code_points.shift()) : this._BOMseen = !0)), codePointsToString(code_points);
    }
}, TextEncoder$1.prototype = {
    encode: function(opt_string, options) {
        opt_string = opt_string ? String(opt_string) : "", options = ToDictionary(options), 
        this._streaming || (this._encoder = new UTF8Encoder(this._options)), this._streaming = Boolean(options.stream);
        for (var result, bytes = [], input_stream = new Stream(stringToCodePoints(opt_string)); !input_stream.endOfStream() && (result = this._encoder.handler(input_stream, input_stream.read())) !== finished; ) Array.isArray(result) ? bytes.push.apply(bytes, result) : bytes.push(result);
        if (!this._streaming) {
            for (;(result = this._encoder.handler(input_stream, input_stream.read())) !== finished; ) Array.isArray(result) ? bytes.push.apply(bytes, result) : bytes.push(result);
            this._encoder = null;
        }
        return new Uint8Array(bytes);
    }
};

var encoding_lib = Object.freeze({
    __proto__: null,
    TextDecoder: TextDecoder$1,
    TextEncoder: TextEncoder$1
}), require$$2 = getAugmentedNamespace(encoding_lib), hasRequiredLib$2;

function requireLib$2() {
    if (hasRequiredLib$2) return lib$2;
    hasRequiredLib$2 = 1;
    var __createBinding = lib$2 && lib$2.__createBinding || (Object.create ? function(o, m, k, k2) {
        void 0 === k2 && (k2 = k), Object.defineProperty(o, k2, {
            enumerable: !0,
            get: function() {
                return m[k];
            }
        });
    } : function(o, m, k, k2) {
        void 0 === k2 && (k2 = k), o[k2] = m[k];
    }), __setModuleDefault = lib$2 && lib$2.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", {
            enumerable: !0,
            value: v
        });
    } : function(o, v) {
        o.default = v;
    }), __decorate = lib$2 && lib$2.__decorate || function(decorators, target, key, desc) {
        var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }, __importStar = lib$2 && lib$2.__importStar || function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (null != mod) for (var k in mod) "default" !== k && Object.hasOwnProperty.call(mod, k) && __createBinding(result, mod, k);
        return __setModuleDefault(result, mod), result;
    }, __importDefault = lib$2 && lib$2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : {
            default: mod
        };
    };
    Object.defineProperty(lib$2, "__esModule", {
        value: !0
    }), lib$2.deserializeUnchecked = lib$2.deserialize = lib$2.serialize = lib$2.BinaryReader = lib$2.BinaryWriter = lib$2.BorshError = lib$2.baseDecode = lib$2.baseEncode = void 0;
    const bn_js_1 = __importDefault(requireBn()), bs58_1 = __importDefault(requireBs58()), encoding = __importStar(require$$2), textDecoder = new ("function" != typeof TextDecoder ? encoding.TextDecoder : TextDecoder)("utf-8", {
        fatal: !0
    });
    lib$2.baseEncode = function(value) {
        return "string" == typeof value && (value = Buffer.from(value, "utf8")), bs58_1.default.encode(Buffer.from(value));
    }, lib$2.baseDecode = function(value) {
        return Buffer.from(bs58_1.default.decode(value));
    };
    class BorshError extends Error {
        constructor(message) {
            super(message), this.fieldPath = [], this.originalMessage = message;
        }
        addToFieldPath(fieldName) {
            this.fieldPath.splice(0, 0, fieldName), this.message = this.originalMessage + ": " + this.fieldPath.join(".");
        }
    }
    lib$2.BorshError = BorshError;
    class BinaryWriter {
        constructor() {
            this.buf = Buffer.alloc(1024), this.length = 0;
        }
        maybeResize() {
            this.buf.length < 16 + this.length && (this.buf = Buffer.concat([ this.buf, Buffer.alloc(1024) ]));
        }
        writeU8(value) {
            this.maybeResize(), this.buf.writeUInt8(value, this.length), this.length += 1;
        }
        writeU16(value) {
            this.maybeResize(), this.buf.writeUInt16LE(value, this.length), this.length += 2;
        }
        writeU32(value) {
            this.maybeResize(), this.buf.writeUInt32LE(value, this.length), this.length += 4;
        }
        writeU64(value) {
            this.maybeResize(), this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray("le", 8)));
        }
        writeU128(value) {
            this.maybeResize(), this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray("le", 16)));
        }
        writeU256(value) {
            this.maybeResize(), this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray("le", 32)));
        }
        writeU512(value) {
            this.maybeResize(), this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray("le", 64)));
        }
        writeBuffer(buffer) {
            this.buf = Buffer.concat([ Buffer.from(this.buf.subarray(0, this.length)), buffer, Buffer.alloc(1024) ]), 
            this.length += buffer.length;
        }
        writeString(str) {
            this.maybeResize();
            const b = Buffer.from(str, "utf8");
            this.writeU32(b.length), this.writeBuffer(b);
        }
        writeFixedArray(array) {
            this.writeBuffer(Buffer.from(array));
        }
        writeArray(array, fn) {
            this.maybeResize(), this.writeU32(array.length);
            for (const elem of array) this.maybeResize(), fn(elem);
        }
        toArray() {
            return this.buf.subarray(0, this.length);
        }
    }
    function handlingRangeError(target, propertyKey, propertyDescriptor) {
        const originalMethod = propertyDescriptor.value;
        propertyDescriptor.value = function(...args) {
            try {
                return originalMethod.apply(this, args);
            } catch (e) {
                if (e instanceof RangeError) {
                    const code = e.code;
                    if ([ "ERR_BUFFER_OUT_OF_BOUNDS", "ERR_OUT_OF_RANGE" ].indexOf(code) >= 0) throw new BorshError("Reached the end of buffer when deserializing");
                }
                throw e;
            }
        };
    }
    lib$2.BinaryWriter = BinaryWriter;
    class BinaryReader {
        constructor(buf) {
            this.buf = buf, this.offset = 0;
        }
        readU8() {
            const value = this.buf.readUInt8(this.offset);
            return this.offset += 1, value;
        }
        readU16() {
            const value = this.buf.readUInt16LE(this.offset);
            return this.offset += 2, value;
        }
        readU32() {
            const value = this.buf.readUInt32LE(this.offset);
            return this.offset += 4, value;
        }
        readU64() {
            const buf = this.readBuffer(8);
            return new bn_js_1.default(buf, "le");
        }
        readU128() {
            const buf = this.readBuffer(16);
            return new bn_js_1.default(buf, "le");
        }
        readU256() {
            const buf = this.readBuffer(32);
            return new bn_js_1.default(buf, "le");
        }
        readU512() {
            const buf = this.readBuffer(64);
            return new bn_js_1.default(buf, "le");
        }
        readBuffer(len) {
            if (this.offset + len > this.buf.length) throw new BorshError(`Expected buffer length ${len} isn't within bounds`);
            const result = this.buf.slice(this.offset, this.offset + len);
            return this.offset += len, result;
        }
        readString() {
            const len = this.readU32(), buf = this.readBuffer(len);
            try {
                return textDecoder.decode(buf);
            } catch (e) {
                throw new BorshError(`Error decoding UTF-8 string: ${e}`);
            }
        }
        readFixedArray(len) {
            return new Uint8Array(this.readBuffer(len));
        }
        readArray(fn) {
            const len = this.readU32(), result = Array();
            for (let i = 0; i < len; ++i) result.push(fn());
            return result;
        }
    }
    function capitalizeFirstLetter(string) {
        return string.charAt(0).toUpperCase() + string.slice(1);
    }
    function serializeField(schema, fieldName, value, fieldType, writer) {
        try {
            if ("string" == typeof fieldType) writer[`write${capitalizeFirstLetter(fieldType)}`](value); else if (fieldType instanceof Array) if ("number" == typeof fieldType[0]) {
                if (value.length !== fieldType[0]) throw new BorshError(`Expecting byte array of length ${fieldType[0]}, but got ${value.length} bytes`);
                writer.writeFixedArray(value);
            } else if (2 === fieldType.length && "number" == typeof fieldType[1]) {
                if (value.length !== fieldType[1]) throw new BorshError(`Expecting byte array of length ${fieldType[1]}, but got ${value.length} bytes`);
                for (let i = 0; i < fieldType[1]; i++) serializeField(schema, null, value[i], fieldType[0], writer);
            } else writer.writeArray(value, (item => {
                serializeField(schema, fieldName, item, fieldType[0], writer);
            })); else if (void 0 !== fieldType.kind) switch (fieldType.kind) {
              case "option":
                null == value ? writer.writeU8(0) : (writer.writeU8(1), serializeField(schema, fieldName, value, fieldType.type, writer));
                break;

              case "map":
                writer.writeU32(value.size), value.forEach(((val, key) => {
                    serializeField(schema, fieldName, key, fieldType.key, writer), serializeField(schema, fieldName, val, fieldType.value, writer);
                }));
                break;

              default:
                throw new BorshError(`FieldType ${fieldType} unrecognized`);
            } else serializeStruct(schema, value, writer);
        } catch (error) {
            throw error instanceof BorshError && error.addToFieldPath(fieldName), error;
        }
    }
    function serializeStruct(schema, obj, writer) {
        if ("function" == typeof obj.borshSerialize) return void obj.borshSerialize(writer);
        const structSchema = schema.get(obj.constructor);
        if (!structSchema) throw new BorshError(`Class ${obj.constructor.name} is missing in schema`);
        if ("struct" === structSchema.kind) structSchema.fields.map((([fieldName, fieldType]) => {
            serializeField(schema, fieldName, obj[fieldName], fieldType, writer);
        })); else {
            if ("enum" !== structSchema.kind) throw new BorshError(`Unexpected schema kind: ${structSchema.kind} for ${obj.constructor.name}`);
            {
                const name = obj[structSchema.field];
                for (let idx = 0; idx < structSchema.values.length; ++idx) {
                    const [fieldName, fieldType] = structSchema.values[idx];
                    if (fieldName === name) {
                        writer.writeU8(idx), serializeField(schema, fieldName, obj[fieldName], fieldType, writer);
                        break;
                    }
                }
            }
        }
    }
    function deserializeField(schema, fieldName, fieldType, reader) {
        try {
            if ("string" == typeof fieldType) return reader[`read${capitalizeFirstLetter(fieldType)}`]();
            if (fieldType instanceof Array) {
                if ("number" == typeof fieldType[0]) return reader.readFixedArray(fieldType[0]);
                if ("number" == typeof fieldType[1]) {
                    const arr = [];
                    for (let i = 0; i < fieldType[1]; i++) arr.push(deserializeField(schema, null, fieldType[0], reader));
                    return arr;
                }
                return reader.readArray((() => deserializeField(schema, fieldName, fieldType[0], reader)));
            }
            if ("option" === fieldType.kind) {
                return reader.readU8() ? deserializeField(schema, fieldName, fieldType.type, reader) : void 0;
            }
            if ("map" === fieldType.kind) {
                let map = new Map;
                const length = reader.readU32();
                for (let i = 0; i < length; i++) {
                    const key = deserializeField(schema, fieldName, fieldType.key, reader), val = deserializeField(schema, fieldName, fieldType.value, reader);
                    map.set(key, val);
                }
                return map;
            }
            return deserializeStruct(schema, fieldType, reader);
        } catch (error) {
            throw error instanceof BorshError && error.addToFieldPath(fieldName), error;
        }
    }
    function deserializeStruct(schema, classType, reader) {
        if ("function" == typeof classType.borshDeserialize) return classType.borshDeserialize(reader);
        const structSchema = schema.get(classType);
        if (!structSchema) throw new BorshError(`Class ${classType.name} is missing in schema`);
        if ("struct" === structSchema.kind) {
            const result = {};
            for (const [fieldName, fieldType] of schema.get(classType).fields) result[fieldName] = deserializeField(schema, fieldName, fieldType, reader);
            return new classType(result);
        }
        if ("enum" === structSchema.kind) {
            const idx = reader.readU8();
            if (idx >= structSchema.values.length) throw new BorshError(`Enum index: ${idx} is out of range`);
            const [fieldName, fieldType] = structSchema.values[idx], fieldValue = deserializeField(schema, fieldName, fieldType, reader);
            return new classType({
                [fieldName]: fieldValue
            });
        }
        throw new BorshError(`Unexpected schema kind: ${structSchema.kind} for ${classType.constructor.name}`);
    }
    return __decorate([ handlingRangeError ], BinaryReader.prototype, "readU8", null), 
    __decorate([ handlingRangeError ], BinaryReader.prototype, "readU16", null), __decorate([ handlingRangeError ], BinaryReader.prototype, "readU32", null), 
    __decorate([ handlingRangeError ], BinaryReader.prototype, "readU64", null), __decorate([ handlingRangeError ], BinaryReader.prototype, "readU128", null), 
    __decorate([ handlingRangeError ], BinaryReader.prototype, "readU256", null), __decorate([ handlingRangeError ], BinaryReader.prototype, "readU512", null), 
    __decorate([ handlingRangeError ], BinaryReader.prototype, "readString", null), 
    __decorate([ handlingRangeError ], BinaryReader.prototype, "readFixedArray", null), 
    __decorate([ handlingRangeError ], BinaryReader.prototype, "readArray", null), lib$2.BinaryReader = BinaryReader, 
    lib$2.serialize = function(schema, obj, Writer = BinaryWriter) {
        const writer = new Writer;
        return serializeStruct(schema, obj, writer), writer.toArray();
    }, lib$2.deserialize = function(schema, classType, buffer, Reader = BinaryReader) {
        const reader = new Reader(buffer), result = deserializeStruct(schema, classType, reader);
        if (reader.offset < buffer.length) throw new BorshError(`Unexpected ${buffer.length - reader.offset} bytes after deserialized data`);
        return result;
    }, lib$2.deserializeUnchecked = function(schema, classType, buffer, Reader = BinaryReader) {
        return deserializeStruct(schema, classType, new Reader(buffer));
    }, lib$2;
}

var libExports$1 = requireLib$2(), Layout = {}, hasRequiredLayout;

function requireLayout() {
    if (hasRequiredLayout) return Layout;
    hasRequiredLayout = 1, Object.defineProperty(Layout, "__esModule", {
        value: !0
    }), Layout.s16 = Layout.s8 = Layout.nu64be = Layout.u48be = Layout.u40be = Layout.u32be = Layout.u24be = Layout.u16be = Layout.nu64 = Layout.u48 = Layout.u40 = Layout.u32 = Layout.u24 = Layout.u16 = Layout.u8 = Layout.offset = Layout.greedy = Layout.Constant = Layout.UTF8 = Layout.CString = Layout.Blob = Layout.Boolean = Layout.BitField = Layout.BitStructure = Layout.VariantLayout = Layout.Union = Layout.UnionLayoutDiscriminator = Layout.UnionDiscriminator = Layout.Structure = Layout.Sequence = Layout.DoubleBE = Layout.Double = Layout.FloatBE = Layout.Float = Layout.NearInt64BE = Layout.NearInt64 = Layout.NearUInt64BE = Layout.NearUInt64 = Layout.IntBE = Layout.Int = Layout.UIntBE = Layout.UInt = Layout.OffsetLayout = Layout.GreedyCount = Layout.ExternalLayout = Layout.bindConstructorLayout = Layout.nameWithProperty = Layout.Layout = Layout.uint8ArrayToBuffer = Layout.checkUint8Array = void 0, 
    Layout.constant = Layout.utf8 = Layout.cstr = Layout.blob = Layout.unionLayoutDiscriminator = Layout.union = Layout.seq = Layout.bits = Layout.struct = Layout.f64be = Layout.f64 = Layout.f32be = Layout.f32 = Layout.ns64be = Layout.s48be = Layout.s40be = Layout.s32be = Layout.s24be = Layout.s16be = Layout.ns64 = Layout.s48 = Layout.s40 = Layout.s32 = Layout.s24 = void 0;
    const buffer_1 = require$$0$4;
    function checkUint8Array(b) {
        if (!(b instanceof Uint8Array)) throw new TypeError("b must be a Uint8Array");
    }
    function uint8ArrayToBuffer(b) {
        return checkUint8Array(b), buffer_1.Buffer.from(b.buffer, b.byteOffset, b.length);
    }
    Layout.checkUint8Array = checkUint8Array, Layout.uint8ArrayToBuffer = uint8ArrayToBuffer;
    let Layout$1 = class {
        constructor(span, property) {
            if (!Number.isInteger(span)) throw new TypeError("span must be an integer");
            this.span = span, this.property = property;
        }
        makeDestinationObject() {
            return {};
        }
        getSpan(b, offset) {
            if (0 > this.span) throw new RangeError("indeterminate span");
            return this.span;
        }
        replicate(property) {
            const rv = Object.create(this.constructor.prototype);
            return Object.assign(rv, this), rv.property = property, rv;
        }
        fromArray(values) {}
    };
    function nameWithProperty(name, lo) {
        return lo.property ? name + "[" + lo.property + "]" : name;
    }
    Layout.Layout = Layout$1, Layout.nameWithProperty = nameWithProperty, Layout.bindConstructorLayout = function(Class, layout) {
        if ("function" != typeof Class) throw new TypeError("Class must be constructor");
        if (Object.prototype.hasOwnProperty.call(Class, "layout_")) throw new Error("Class is already bound to a layout");
        if (!(layout && layout instanceof Layout$1)) throw new TypeError("layout must be a Layout");
        if (Object.prototype.hasOwnProperty.call(layout, "boundConstructor_")) throw new Error("layout is already bound to a constructor");
        Class.layout_ = layout, layout.boundConstructor_ = Class, layout.makeDestinationObject = () => new Class, 
        Object.defineProperty(Class.prototype, "encode", {
            value(b, offset) {
                return layout.encode(this, b, offset);
            },
            writable: !0
        }), Object.defineProperty(Class, "decode", {
            value: (b, offset) => layout.decode(b, offset),
            writable: !0
        });
    };
    class ExternalLayout extends Layout$1 {
        isCount() {
            throw new Error("ExternalLayout is abstract");
        }
    }
    Layout.ExternalLayout = ExternalLayout;
    class GreedyCount extends ExternalLayout {
        constructor(elementSpan = 1, property) {
            if (!Number.isInteger(elementSpan) || 0 >= elementSpan) throw new TypeError("elementSpan must be a (positive) integer");
            super(-1, property), this.elementSpan = elementSpan;
        }
        isCount() {
            return !0;
        }
        decode(b, offset = 0) {
            checkUint8Array(b);
            const rem = b.length - offset;
            return Math.floor(rem / this.elementSpan);
        }
        encode(src, b, offset) {
            return 0;
        }
    }
    Layout.GreedyCount = GreedyCount;
    class OffsetLayout extends ExternalLayout {
        constructor(layout, offset = 0, property) {
            if (!(layout instanceof Layout$1)) throw new TypeError("layout must be a Layout");
            if (!Number.isInteger(offset)) throw new TypeError("offset must be integer or undefined");
            super(layout.span, property || layout.property), this.layout = layout, this.offset = offset;
        }
        isCount() {
            return this.layout instanceof UInt || this.layout instanceof UIntBE;
        }
        decode(b, offset = 0) {
            return this.layout.decode(b, offset + this.offset);
        }
        encode(src, b, offset = 0) {
            return this.layout.encode(src, b, offset + this.offset);
        }
    }
    Layout.OffsetLayout = OffsetLayout;
    class UInt extends Layout$1 {
        constructor(span, property) {
            if (super(span, property), 6 < this.span) throw new RangeError("span must not exceed 6 bytes");
        }
        decode(b, offset = 0) {
            return uint8ArrayToBuffer(b).readUIntLE(offset, this.span);
        }
        encode(src, b, offset = 0) {
            return uint8ArrayToBuffer(b).writeUIntLE(src, offset, this.span), this.span;
        }
    }
    Layout.UInt = UInt;
    class UIntBE extends Layout$1 {
        constructor(span, property) {
            if (super(span, property), 6 < this.span) throw new RangeError("span must not exceed 6 bytes");
        }
        decode(b, offset = 0) {
            return uint8ArrayToBuffer(b).readUIntBE(offset, this.span);
        }
        encode(src, b, offset = 0) {
            return uint8ArrayToBuffer(b).writeUIntBE(src, offset, this.span), this.span;
        }
    }
    Layout.UIntBE = UIntBE;
    class Int extends Layout$1 {
        constructor(span, property) {
            if (super(span, property), 6 < this.span) throw new RangeError("span must not exceed 6 bytes");
        }
        decode(b, offset = 0) {
            return uint8ArrayToBuffer(b).readIntLE(offset, this.span);
        }
        encode(src, b, offset = 0) {
            return uint8ArrayToBuffer(b).writeIntLE(src, offset, this.span), this.span;
        }
    }
    Layout.Int = Int;
    class IntBE extends Layout$1 {
        constructor(span, property) {
            if (super(span, property), 6 < this.span) throw new RangeError("span must not exceed 6 bytes");
        }
        decode(b, offset = 0) {
            return uint8ArrayToBuffer(b).readIntBE(offset, this.span);
        }
        encode(src, b, offset = 0) {
            return uint8ArrayToBuffer(b).writeIntBE(src, offset, this.span), this.span;
        }
    }
    Layout.IntBE = IntBE;
    const V2E32 = Math.pow(2, 32);
    function divmodInt64(src) {
        const hi32 = Math.floor(src / V2E32);
        return {
            hi32: hi32,
            lo32: src - hi32 * V2E32
        };
    }
    function roundedInt64(hi32, lo32) {
        return hi32 * V2E32 + lo32;
    }
    class NearUInt64 extends Layout$1 {
        constructor(property) {
            super(8, property);
        }
        decode(b, offset = 0) {
            const buffer = uint8ArrayToBuffer(b), lo32 = buffer.readUInt32LE(offset);
            return roundedInt64(buffer.readUInt32LE(offset + 4), lo32);
        }
        encode(src, b, offset = 0) {
            const split = divmodInt64(src), buffer = uint8ArrayToBuffer(b);
            return buffer.writeUInt32LE(split.lo32, offset), buffer.writeUInt32LE(split.hi32, offset + 4), 
            8;
        }
    }
    Layout.NearUInt64 = NearUInt64;
    class NearUInt64BE extends Layout$1 {
        constructor(property) {
            super(8, property);
        }
        decode(b, offset = 0) {
            const buffer = uint8ArrayToBuffer(b);
            return roundedInt64(buffer.readUInt32BE(offset), buffer.readUInt32BE(offset + 4));
        }
        encode(src, b, offset = 0) {
            const split = divmodInt64(src), buffer = uint8ArrayToBuffer(b);
            return buffer.writeUInt32BE(split.hi32, offset), buffer.writeUInt32BE(split.lo32, offset + 4), 
            8;
        }
    }
    Layout.NearUInt64BE = NearUInt64BE;
    class NearInt64 extends Layout$1 {
        constructor(property) {
            super(8, property);
        }
        decode(b, offset = 0) {
            const buffer = uint8ArrayToBuffer(b), lo32 = buffer.readUInt32LE(offset);
            return roundedInt64(buffer.readInt32LE(offset + 4), lo32);
        }
        encode(src, b, offset = 0) {
            const split = divmodInt64(src), buffer = uint8ArrayToBuffer(b);
            return buffer.writeUInt32LE(split.lo32, offset), buffer.writeInt32LE(split.hi32, offset + 4), 
            8;
        }
    }
    Layout.NearInt64 = NearInt64;
    class NearInt64BE extends Layout$1 {
        constructor(property) {
            super(8, property);
        }
        decode(b, offset = 0) {
            const buffer = uint8ArrayToBuffer(b);
            return roundedInt64(buffer.readInt32BE(offset), buffer.readUInt32BE(offset + 4));
        }
        encode(src, b, offset = 0) {
            const split = divmodInt64(src), buffer = uint8ArrayToBuffer(b);
            return buffer.writeInt32BE(split.hi32, offset), buffer.writeUInt32BE(split.lo32, offset + 4), 
            8;
        }
    }
    Layout.NearInt64BE = NearInt64BE;
    class Float extends Layout$1 {
        constructor(property) {
            super(4, property);
        }
        decode(b, offset = 0) {
            return uint8ArrayToBuffer(b).readFloatLE(offset);
        }
        encode(src, b, offset = 0) {
            return uint8ArrayToBuffer(b).writeFloatLE(src, offset), 4;
        }
    }
    Layout.Float = Float;
    class FloatBE extends Layout$1 {
        constructor(property) {
            super(4, property);
        }
        decode(b, offset = 0) {
            return uint8ArrayToBuffer(b).readFloatBE(offset);
        }
        encode(src, b, offset = 0) {
            return uint8ArrayToBuffer(b).writeFloatBE(src, offset), 4;
        }
    }
    Layout.FloatBE = FloatBE;
    class Double extends Layout$1 {
        constructor(property) {
            super(8, property);
        }
        decode(b, offset = 0) {
            return uint8ArrayToBuffer(b).readDoubleLE(offset);
        }
        encode(src, b, offset = 0) {
            return uint8ArrayToBuffer(b).writeDoubleLE(src, offset), 8;
        }
    }
    Layout.Double = Double;
    class DoubleBE extends Layout$1 {
        constructor(property) {
            super(8, property);
        }
        decode(b, offset = 0) {
            return uint8ArrayToBuffer(b).readDoubleBE(offset);
        }
        encode(src, b, offset = 0) {
            return uint8ArrayToBuffer(b).writeDoubleBE(src, offset), 8;
        }
    }
    Layout.DoubleBE = DoubleBE;
    class Sequence extends Layout$1 {
        constructor(elementLayout, count, property) {
            if (!(elementLayout instanceof Layout$1)) throw new TypeError("elementLayout must be a Layout");
            if (!(count instanceof ExternalLayout && count.isCount() || Number.isInteger(count) && 0 <= count)) throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");
            let span = -1;
            !(count instanceof ExternalLayout) && 0 < elementLayout.span && (span = count * elementLayout.span), 
            super(span, property), this.elementLayout = elementLayout, this.count = count;
        }
        getSpan(b, offset = 0) {
            if (0 <= this.span) return this.span;
            let span = 0, count = this.count;
            if (count instanceof ExternalLayout && (count = count.decode(b, offset)), 0 < this.elementLayout.span) span = count * this.elementLayout.span; else {
                let idx = 0;
                for (;idx < count; ) span += this.elementLayout.getSpan(b, offset + span), ++idx;
            }
            return span;
        }
        decode(b, offset = 0) {
            const rv = [];
            let i = 0, count = this.count;
            for (count instanceof ExternalLayout && (count = count.decode(b, offset)); i < count; ) rv.push(this.elementLayout.decode(b, offset)), 
            offset += this.elementLayout.getSpan(b, offset), i += 1;
            return rv;
        }
        encode(src, b, offset = 0) {
            const elo = this.elementLayout, span = src.reduce(((span, v) => span + elo.encode(v, b, offset + span)), 0);
            return this.count instanceof ExternalLayout && this.count.encode(src.length, b, offset), 
            span;
        }
    }
    Layout.Sequence = Sequence;
    class Structure extends Layout$1 {
        constructor(fields, property, decodePrefixes) {
            if (!Array.isArray(fields) || !fields.reduce(((acc, v) => acc && v instanceof Layout$1), !0)) throw new TypeError("fields must be array of Layout instances");
            "boolean" == typeof property && void 0 === decodePrefixes && (decodePrefixes = property, 
            property = void 0);
            for (const fd of fields) if (0 > fd.span && void 0 === fd.property) throw new Error("fields cannot contain unnamed variable-length layout");
            let span = -1;
            try {
                span = fields.reduce(((span, fd) => span + fd.getSpan()), 0);
            } catch (e) {}
            super(span, property), this.fields = fields, this.decodePrefixes = !!decodePrefixes;
        }
        getSpan(b, offset = 0) {
            if (0 <= this.span) return this.span;
            let span = 0;
            try {
                span = this.fields.reduce(((span, fd) => {
                    const fsp = fd.getSpan(b, offset);
                    return offset += fsp, span + fsp;
                }), 0);
            } catch (e) {
                throw new RangeError("indeterminate span");
            }
            return span;
        }
        decode(b, offset = 0) {
            checkUint8Array(b);
            const dest = this.makeDestinationObject();
            for (const fd of this.fields) if (void 0 !== fd.property && (dest[fd.property] = fd.decode(b, offset)), 
            offset += fd.getSpan(b, offset), this.decodePrefixes && b.length === offset) break;
            return dest;
        }
        encode(src, b, offset = 0) {
            const firstOffset = offset;
            let lastOffset = 0, lastWrote = 0;
            for (const fd of this.fields) {
                let span = fd.span;
                if (lastWrote = 0 < span ? span : 0, void 0 !== fd.property) {
                    const fv = src[fd.property];
                    void 0 !== fv && (lastWrote = fd.encode(fv, b, offset), 0 > span && (span = fd.getSpan(b, offset)));
                }
                lastOffset = offset, offset += span;
            }
            return lastOffset + lastWrote - firstOffset;
        }
        fromArray(values) {
            const dest = this.makeDestinationObject();
            for (const fd of this.fields) void 0 !== fd.property && 0 < values.length && (dest[fd.property] = values.shift());
            return dest;
        }
        layoutFor(property) {
            if ("string" != typeof property) throw new TypeError("property must be string");
            for (const fd of this.fields) if (fd.property === property) return fd;
        }
        offsetOf(property) {
            if ("string" != typeof property) throw new TypeError("property must be string");
            let offset = 0;
            for (const fd of this.fields) {
                if (fd.property === property) return offset;
                0 > fd.span ? offset = -1 : 0 <= offset && (offset += fd.span);
            }
        }
    }
    Layout.Structure = Structure;
    class UnionDiscriminator {
        constructor(property) {
            this.property = property;
        }
        decode(b, offset) {
            throw new Error("UnionDiscriminator is abstract");
        }
        encode(src, b, offset) {
            throw new Error("UnionDiscriminator is abstract");
        }
    }
    Layout.UnionDiscriminator = UnionDiscriminator;
    class UnionLayoutDiscriminator extends UnionDiscriminator {
        constructor(layout, property) {
            if (!(layout instanceof ExternalLayout && layout.isCount())) throw new TypeError("layout must be an unsigned integer ExternalLayout");
            super(property || layout.property || "variant"), this.layout = layout;
        }
        decode(b, offset) {
            return this.layout.decode(b, offset);
        }
        encode(src, b, offset) {
            return this.layout.encode(src, b, offset);
        }
    }
    Layout.UnionLayoutDiscriminator = UnionLayoutDiscriminator;
    class Union extends Layout$1 {
        constructor(discr, defaultLayout, property) {
            let discriminator;
            if (discr instanceof UInt || discr instanceof UIntBE) discriminator = new UnionLayoutDiscriminator(new OffsetLayout(discr)); else if (discr instanceof ExternalLayout && discr.isCount()) discriminator = new UnionLayoutDiscriminator(discr); else {
                if (!(discr instanceof UnionDiscriminator)) throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");
                discriminator = discr;
            }
            if (void 0 === defaultLayout && (defaultLayout = null), !(null === defaultLayout || defaultLayout instanceof Layout$1)) throw new TypeError("defaultLayout must be null or a Layout");
            if (null !== defaultLayout) {
                if (0 > defaultLayout.span) throw new Error("defaultLayout must have constant span");
                void 0 === defaultLayout.property && (defaultLayout = defaultLayout.replicate("content"));
            }
            let span = -1;
            defaultLayout && (span = defaultLayout.span, 0 <= span && (discr instanceof UInt || discr instanceof UIntBE) && (span += discriminator.layout.span)), 
            super(span, property), this.discriminator = discriminator, this.usesPrefixDiscriminator = discr instanceof UInt || discr instanceof UIntBE, 
            this.defaultLayout = defaultLayout, this.registry = {};
            let boundGetSourceVariant = this.defaultGetSourceVariant.bind(this);
            this.getSourceVariant = function(src) {
                return boundGetSourceVariant(src);
            }, this.configGetSourceVariant = function(gsv) {
                boundGetSourceVariant = gsv.bind(this);
            };
        }
        getSpan(b, offset = 0) {
            if (0 <= this.span) return this.span;
            const vlo = this.getVariant(b, offset);
            if (!vlo) throw new Error("unable to determine span for unrecognized variant");
            return vlo.getSpan(b, offset);
        }
        defaultGetSourceVariant(src) {
            if (Object.prototype.hasOwnProperty.call(src, this.discriminator.property)) {
                if (this.defaultLayout && this.defaultLayout.property && Object.prototype.hasOwnProperty.call(src, this.defaultLayout.property)) return;
                const vlo = this.registry[src[this.discriminator.property]];
                if (vlo && (!vlo.layout || vlo.property && Object.prototype.hasOwnProperty.call(src, vlo.property))) return vlo;
            } else for (const tag in this.registry) {
                const vlo = this.registry[tag];
                if (vlo.property && Object.prototype.hasOwnProperty.call(src, vlo.property)) return vlo;
            }
            throw new Error("unable to infer src variant");
        }
        decode(b, offset = 0) {
            let dest;
            const dlo = this.discriminator, discr = dlo.decode(b, offset), clo = this.registry[discr];
            if (void 0 === clo) {
                const defaultLayout = this.defaultLayout;
                let contentOffset = 0;
                this.usesPrefixDiscriminator && (contentOffset = dlo.layout.span), dest = this.makeDestinationObject(), 
                dest[dlo.property] = discr, dest[defaultLayout.property] = defaultLayout.decode(b, offset + contentOffset);
            } else dest = clo.decode(b, offset);
            return dest;
        }
        encode(src, b, offset = 0) {
            const vlo = this.getSourceVariant(src);
            if (void 0 === vlo) {
                const dlo = this.discriminator, clo = this.defaultLayout;
                let contentOffset = 0;
                return this.usesPrefixDiscriminator && (contentOffset = dlo.layout.span), dlo.encode(src[dlo.property], b, offset), 
                contentOffset + clo.encode(src[clo.property], b, offset + contentOffset);
            }
            return vlo.encode(src, b, offset);
        }
        addVariant(variant, layout, property) {
            const rv = new VariantLayout(this, variant, layout, property);
            return this.registry[variant] = rv, rv;
        }
        getVariant(vb, offset = 0) {
            let variant;
            return variant = vb instanceof Uint8Array ? this.discriminator.decode(vb, offset) : vb, 
            this.registry[variant];
        }
    }
    Layout.Union = Union;
    class VariantLayout extends Layout$1 {
        constructor(union, variant, layout, property) {
            if (!(union instanceof Union)) throw new TypeError("union must be a Union");
            if (!Number.isInteger(variant) || 0 > variant) throw new TypeError("variant must be a (non-negative) integer");
            if ("string" == typeof layout && void 0 === property && (property = layout, layout = null), 
            layout) {
                if (!(layout instanceof Layout$1)) throw new TypeError("layout must be a Layout");
                if (null !== union.defaultLayout && 0 <= layout.span && layout.span > union.defaultLayout.span) throw new Error("variant span exceeds span of containing union");
                if ("string" != typeof property) throw new TypeError("variant must have a String property");
            }
            let span = union.span;
            0 > union.span && (span = layout ? layout.span : 0, 0 <= span && union.usesPrefixDiscriminator && (span += union.discriminator.layout.span)), 
            super(span, property), this.union = union, this.variant = variant, this.layout = layout || null;
        }
        getSpan(b, offset = 0) {
            if (0 <= this.span) return this.span;
            let contentOffset = 0;
            this.union.usesPrefixDiscriminator && (contentOffset = this.union.discriminator.layout.span);
            let span = 0;
            return this.layout && (span = this.layout.getSpan(b, offset + contentOffset)), contentOffset + span;
        }
        decode(b, offset = 0) {
            const dest = this.makeDestinationObject();
            if (this !== this.union.getVariant(b, offset)) throw new Error("variant mismatch");
            let contentOffset = 0;
            return this.union.usesPrefixDiscriminator && (contentOffset = this.union.discriminator.layout.span), 
            this.layout ? dest[this.property] = this.layout.decode(b, offset + contentOffset) : this.property ? dest[this.property] = !0 : this.union.usesPrefixDiscriminator && (dest[this.union.discriminator.property] = this.variant), 
            dest;
        }
        encode(src, b, offset = 0) {
            let contentOffset = 0;
            if (this.union.usesPrefixDiscriminator && (contentOffset = this.union.discriminator.layout.span), 
            this.layout && !Object.prototype.hasOwnProperty.call(src, this.property)) throw new TypeError("variant lacks property " + this.property);
            this.union.discriminator.encode(this.variant, b, offset);
            let span = contentOffset;
            if (this.layout && (this.layout.encode(src[this.property], b, offset + contentOffset), 
            span += this.layout.getSpan(b, offset + contentOffset), 0 <= this.union.span && span > this.union.span)) throw new Error("encoded variant overruns containing union");
            return span;
        }
        fromArray(values) {
            if (this.layout) return this.layout.fromArray(values);
        }
    }
    function fixBitwiseResult(v) {
        return 0 > v && (v += 4294967296), v;
    }
    Layout.VariantLayout = VariantLayout;
    class BitStructure extends Layout$1 {
        constructor(word, msb, property) {
            if (!(word instanceof UInt || word instanceof UIntBE)) throw new TypeError("word must be a UInt or UIntBE layout");
            if ("string" == typeof msb && void 0 === property && (property = msb, msb = !1), 
            4 < word.span) throw new RangeError("word cannot exceed 32 bits");
            super(word.span, property), this.word = word, this.msb = !!msb, this.fields = [];
            let value = 0;
            this._packedSetValue = function(v) {
                return value = fixBitwiseResult(v), this;
            }, this._packedGetValue = function() {
                return value;
            };
        }
        decode(b, offset = 0) {
            const dest = this.makeDestinationObject(), value = this.word.decode(b, offset);
            this._packedSetValue(value);
            for (const fd of this.fields) void 0 !== fd.property && (dest[fd.property] = fd.decode(b));
            return dest;
        }
        encode(src, b, offset = 0) {
            const value = this.word.decode(b, offset);
            this._packedSetValue(value);
            for (const fd of this.fields) if (void 0 !== fd.property) {
                const fv = src[fd.property];
                void 0 !== fv && fd.encode(fv);
            }
            return this.word.encode(this._packedGetValue(), b, offset);
        }
        addField(bits, property) {
            const bf = new BitField(this, bits, property);
            return this.fields.push(bf), bf;
        }
        addBoolean(property) {
            const bf = new Boolean(this, property);
            return this.fields.push(bf), bf;
        }
        fieldFor(property) {
            if ("string" != typeof property) throw new TypeError("property must be string");
            for (const fd of this.fields) if (fd.property === property) return fd;
        }
    }
    Layout.BitStructure = BitStructure;
    class BitField {
        constructor(container, bits, property) {
            if (!(container instanceof BitStructure)) throw new TypeError("container must be a BitStructure");
            if (!Number.isInteger(bits) || 0 >= bits) throw new TypeError("bits must be positive integer");
            const totalBits = 8 * container.span, usedBits = container.fields.reduce(((sum, fd) => sum + fd.bits), 0);
            if (bits + usedBits > totalBits) throw new Error("bits too long for span remainder (" + (totalBits - usedBits) + " of " + totalBits + " remain)");
            this.container = container, this.bits = bits, this.valueMask = (1 << bits) - 1, 
            32 === bits && (this.valueMask = 4294967295), this.start = usedBits, this.container.msb && (this.start = totalBits - usedBits - bits), 
            this.wordMask = fixBitwiseResult(this.valueMask << this.start), this.property = property;
        }
        decode(b, offset) {
            return fixBitwiseResult(this.container._packedGetValue() & this.wordMask) >>> this.start;
        }
        encode(value) {
            if ("number" != typeof value || !Number.isInteger(value) || value !== fixBitwiseResult(value & this.valueMask)) throw new TypeError(nameWithProperty("BitField.encode", this) + " value must be integer not exceeding " + this.valueMask);
            const word = this.container._packedGetValue(), wordValue = fixBitwiseResult(value << this.start);
            this.container._packedSetValue(fixBitwiseResult(word & ~this.wordMask) | wordValue);
        }
    }
    Layout.BitField = BitField;
    class Boolean extends BitField {
        constructor(container, property) {
            super(container, 1, property);
        }
        decode(b, offset) {
            return !!super.decode(b, offset);
        }
        encode(value) {
            "boolean" == typeof value && (value = +value), super.encode(value);
        }
    }
    Layout.Boolean = Boolean;
    class Blob extends Layout$1 {
        constructor(length, property) {
            if (!(length instanceof ExternalLayout && length.isCount() || Number.isInteger(length) && 0 <= length)) throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");
            let span = -1;
            length instanceof ExternalLayout || (span = length), super(span, property), this.length = length;
        }
        getSpan(b, offset) {
            let span = this.span;
            return 0 > span && (span = this.length.decode(b, offset)), span;
        }
        decode(b, offset = 0) {
            let span = this.span;
            return 0 > span && (span = this.length.decode(b, offset)), uint8ArrayToBuffer(b).slice(offset, offset + span);
        }
        encode(src, b, offset) {
            let span = this.length;
            if (this.length instanceof ExternalLayout && (span = src.length), !(src instanceof Uint8Array && span === src.length)) throw new TypeError(nameWithProperty("Blob.encode", this) + " requires (length " + span + ") Uint8Array as src");
            if (offset + span > b.length) throw new RangeError("encoding overruns Uint8Array");
            const srcBuffer = uint8ArrayToBuffer(src);
            return uint8ArrayToBuffer(b).write(srcBuffer.toString("hex"), offset, span, "hex"), 
            this.length instanceof ExternalLayout && this.length.encode(span, b, offset), span;
        }
    }
    Layout.Blob = Blob;
    class CString extends Layout$1 {
        constructor(property) {
            super(-1, property);
        }
        getSpan(b, offset = 0) {
            checkUint8Array(b);
            let idx = offset;
            for (;idx < b.length && 0 !== b[idx]; ) idx += 1;
            return 1 + idx - offset;
        }
        decode(b, offset = 0) {
            const span = this.getSpan(b, offset);
            return uint8ArrayToBuffer(b).slice(offset, offset + span - 1).toString("utf-8");
        }
        encode(src, b, offset = 0) {
            "string" != typeof src && (src = String(src));
            const srcb = buffer_1.Buffer.from(src, "utf8"), span = srcb.length;
            if (offset + span > b.length) throw new RangeError("encoding overruns Buffer");
            const buffer = uint8ArrayToBuffer(b);
            return srcb.copy(buffer, offset), buffer[offset + span] = 0, span + 1;
        }
    }
    Layout.CString = CString;
    class UTF8 extends Layout$1 {
        constructor(maxSpan, property) {
            if ("string" == typeof maxSpan && void 0 === property && (property = maxSpan, maxSpan = void 0), 
            void 0 === maxSpan) maxSpan = -1; else if (!Number.isInteger(maxSpan)) throw new TypeError("maxSpan must be an integer");
            super(-1, property), this.maxSpan = maxSpan;
        }
        getSpan(b, offset = 0) {
            return checkUint8Array(b), b.length - offset;
        }
        decode(b, offset = 0) {
            const span = this.getSpan(b, offset);
            if (0 <= this.maxSpan && this.maxSpan < span) throw new RangeError("text length exceeds maxSpan");
            return uint8ArrayToBuffer(b).slice(offset, offset + span).toString("utf-8");
        }
        encode(src, b, offset = 0) {
            "string" != typeof src && (src = String(src));
            const srcb = buffer_1.Buffer.from(src, "utf8"), span = srcb.length;
            if (0 <= this.maxSpan && this.maxSpan < span) throw new RangeError("text length exceeds maxSpan");
            if (offset + span > b.length) throw new RangeError("encoding overruns Buffer");
            return srcb.copy(uint8ArrayToBuffer(b), offset), span;
        }
    }
    Layout.UTF8 = UTF8;
    class Constant extends Layout$1 {
        constructor(value, property) {
            super(0, property), this.value = value;
        }
        decode(b, offset) {
            return this.value;
        }
        encode(src, b, offset) {
            return 0;
        }
    }
    return Layout.Constant = Constant, Layout.greedy = (elementSpan, property) => new GreedyCount(elementSpan, property), 
    Layout.offset = (layout, offset, property) => new OffsetLayout(layout, offset, property), 
    Layout.u8 = property => new UInt(1, property), Layout.u16 = property => new UInt(2, property), 
    Layout.u24 = property => new UInt(3, property), Layout.u32 = property => new UInt(4, property), 
    Layout.u40 = property => new UInt(5, property), Layout.u48 = property => new UInt(6, property), 
    Layout.nu64 = property => new NearUInt64(property), Layout.u16be = property => new UIntBE(2, property), 
    Layout.u24be = property => new UIntBE(3, property), Layout.u32be = property => new UIntBE(4, property), 
    Layout.u40be = property => new UIntBE(5, property), Layout.u48be = property => new UIntBE(6, property), 
    Layout.nu64be = property => new NearUInt64BE(property), Layout.s8 = property => new Int(1, property), 
    Layout.s16 = property => new Int(2, property), Layout.s24 = property => new Int(3, property), 
    Layout.s32 = property => new Int(4, property), Layout.s40 = property => new Int(5, property), 
    Layout.s48 = property => new Int(6, property), Layout.ns64 = property => new NearInt64(property), 
    Layout.s16be = property => new IntBE(2, property), Layout.s24be = property => new IntBE(3, property), 
    Layout.s32be = property => new IntBE(4, property), Layout.s40be = property => new IntBE(5, property), 
    Layout.s48be = property => new IntBE(6, property), Layout.ns64be = property => new NearInt64BE(property), 
    Layout.f32 = property => new Float(property), Layout.f32be = property => new FloatBE(property), 
    Layout.f64 = property => new Double(property), Layout.f64be = property => new DoubleBE(property), 
    Layout.struct = (fields, property, decodePrefixes) => new Structure(fields, property, decodePrefixes), 
    Layout.bits = (word, msb, property) => new BitStructure(word, msb, property), Layout.seq = (elementLayout, count, property) => new Sequence(elementLayout, count, property), 
    Layout.union = (discr, defaultLayout, property) => new Union(discr, defaultLayout, property), 
    Layout.unionLayoutDiscriminator = (layout, property) => new UnionLayoutDiscriminator(layout, property), 
    Layout.blob = (length, property) => new Blob(length, property), Layout.cstr = property => new CString(property), 
    Layout.utf8 = (maxSpan, property) => new UTF8(maxSpan, property), Layout.constant = (value, property) => new Constant(value, property), 
    Layout;
}

var LayoutExports = requireLayout(), node = {};

function commonjsRequire(path) {
    throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}

var bindings = {
    exports: {}
}, fileUriToPath_1, hasRequiredFileUriToPath, hasRequiredBindings, hasRequiredNode;

function requireFileUriToPath() {
    if (hasRequiredFileUriToPath) return fileUriToPath_1;
    hasRequiredFileUriToPath = 1;
    var sep = path.sep || "/";
    return fileUriToPath_1 = function(uri) {
        if ("string" != typeof uri || uri.length <= 7 || "file://" != uri.substring(0, 7)) throw new TypeError("must pass in a file:// URI to convert to a file path");
        var rest = decodeURI(uri.substring(7)), firstSlash = rest.indexOf("/"), host = rest.substring(0, firstSlash), path = rest.substring(firstSlash + 1);
        "localhost" == host && (host = "");
        host && (host = sep + sep + host);
        path = path.replace(/^(.+)\|/, "$1:"), "\\" == sep && (path = path.replace(/\//g, "\\"));
        /^.+\:/.test(path) || (path = sep + path);
        return host + path;
    }, fileUriToPath_1;
}

function requireBindings() {
    return hasRequiredBindings || (hasRequiredBindings = 1, function(module, exports) {
        var fs$1 = fs, path$1 = path, fileURLToPath = requireFileUriToPath(), join = path$1.join, dirname = path$1.dirname, exists = fs$1.accessSync && function(path) {
            try {
                fs$1.accessSync(path);
            } catch (e) {
                return !1;
            }
            return !0;
        } || fs$1.existsSync || path$1.existsSync, defaults = {
            arrow: process.env.NODE_BINDINGS_ARROW || " → ",
            compiled: process.env.NODE_BINDINGS_COMPILED_DIR || "compiled",
            platform: process.platform,
            arch: process.arch,
            nodePreGyp: "node-v" + process.versions.modules + "-" + process.platform + "-" + process.arch,
            version: process.versions.node,
            bindings: "bindings.node",
            try: [ [ "module_root", "build", "bindings" ], [ "module_root", "build", "Debug", "bindings" ], [ "module_root", "build", "Release", "bindings" ], [ "module_root", "out", "Debug", "bindings" ], [ "module_root", "Debug", "bindings" ], [ "module_root", "out", "Release", "bindings" ], [ "module_root", "Release", "bindings" ], [ "module_root", "build", "default", "bindings" ], [ "module_root", "compiled", "version", "platform", "arch", "bindings" ], [ "module_root", "addon-build", "release", "install-root", "bindings" ], [ "module_root", "addon-build", "debug", "install-root", "bindings" ], [ "module_root", "addon-build", "default", "install-root", "bindings" ], [ "module_root", "lib", "binding", "nodePreGyp", "bindings" ] ]
        };
        module.exports = exports = function(opts) {
            "string" == typeof opts ? opts = {
                bindings: opts
            } : opts || (opts = {}), Object.keys(defaults).map((function(i) {
                i in opts || (opts[i] = defaults[i]);
            })), opts.module_root || (opts.module_root = exports.getRoot(exports.getFileName())), 
            ".node" != path$1.extname(opts.bindings) && (opts.bindings += ".node");
            for (var n, b, err, requireFunc = "function" == typeof __webpack_require__ ? __non_webpack_require__ : commonjsRequire, tries = [], i = 0, l = opts.try.length; i < l; i++) {
                n = join.apply(null, opts.try[i].map((function(p) {
                    return opts[p] || p;
                }))), tries.push(n);
                try {
                    return b = opts.path ? requireFunc.resolve(n) : requireFunc(n), opts.path || (b.path = n), 
                    b;
                } catch (e) {
                    if ("MODULE_NOT_FOUND" !== e.code && "QUALIFIED_PATH_RESOLUTION_FAILED" !== e.code && !/not find/i.test(e.message)) throw e;
                }
            }
            throw (err = new Error("Could not locate the bindings file. Tried:\n" + tries.map((function(a) {
                return opts.arrow + a;
            })).join("\n"))).tries = tries, err;
        }, exports.getFileName = function(calling_file) {
            var fileName, origPST = Error.prepareStackTrace, origSTL = Error.stackTraceLimit, dummy = {};
            Error.stackTraceLimit = 10, Error.prepareStackTrace = function(e, st) {
                for (var i = 0, l = st.length; i < l; i++) if ((fileName = st[i].getFileName()) !== __filename) {
                    if (!calling_file) return;
                    if (fileName !== calling_file) return;
                }
            }, Error.captureStackTrace(dummy), Error.prepareStackTrace = origPST, Error.stackTraceLimit = origSTL;
            return 0 === fileName.indexOf("file://") && (fileName = fileURLToPath(fileName)), 
            fileName;
        }, exports.getRoot = function(file) {
            for (var prev, dir = dirname(file); ;) {
                if ("." === dir && (dir = process.cwd()), exists(join(dir, "package.json")) || exists(join(dir, "node_modules"))) return dir;
                if (prev === dir) throw new Error('Could not find module root given file: "' + file + '". Do you have a `package.json` file? ');
                prev = dir, dir = join(dir, "..");
            }
        };
    }(bindings, bindings.exports)), bindings.exports;
}

function requireNode() {
    if (hasRequiredNode) return node;
    let converter;
    hasRequiredNode = 1, Object.defineProperty(node, "__esModule", {
        value: !0
    });
    try {
        converter = requireBindings()("bigint_buffer");
    } catch (e) {}
    return node.toBigIntLE = function(buf) {
        if (void 0 === converter) {
            const reversed = Buffer.from(buf);
            reversed.reverse();
            const hex = reversed.toString("hex");
            return 0 === hex.length ? BigInt(0) : BigInt(`0x${hex}`);
        }
        return converter.toBigInt(buf, !1);
    }, node.toBigIntBE = function(buf) {
        if (void 0 === converter) {
            const hex = buf.toString("hex");
            return 0 === hex.length ? BigInt(0) : BigInt(`0x${hex}`);
        }
        return converter.toBigInt(buf, !0);
    }, node.toBufferLE = function(num, width) {
        if (void 0 === converter) {
            const hex = num.toString(16), buffer = Buffer.from(hex.padStart(2 * width, "0").slice(0, 2 * width), "hex");
            return buffer.reverse(), buffer;
        }
        return converter.fromBigInt(num, Buffer.allocUnsafe(width), !1);
    }, node.toBufferBE = function(num, width) {
        if (void 0 === converter) {
            const hex = num.toString(16);
            return Buffer.from(hex.padStart(2 * width, "0").slice(0, 2 * width), "hex");
        }
        return converter.fromBigInt(num, Buffer.allocUnsafe(width), !0);
    }, node;
}

var nodeExports = requireNode();

class StructError extends TypeError {
    constructor(failure, failures) {
        let cached;
        const {message: message, explanation: explanation, ...rest} = failure, {path: path} = failure, msg = 0 === path.length ? message : `At path: ${path.join(".")} -- ${message}`;
        super(explanation ?? msg), null != explanation && (this.cause = msg), Object.assign(this, rest), 
        this.name = this.constructor.name, this.failures = () => cached ?? (cached = [ failure, ...failures() ]);
    }
}

function isIterable(x) {
    return isObject(x) && "function" == typeof x[Symbol.iterator];
}

function isObject(x) {
    return "object" == typeof x && null != x;
}

function isNonArrayObject(x) {
    return isObject(x) && !Array.isArray(x);
}

function print(value) {
    return "symbol" == typeof value ? value.toString() : "string" == typeof value ? JSON.stringify(value) : `${value}`;
}

function shiftIterator(input) {
    const {done: done, value: value} = input.next();
    return done ? void 0 : value;
}

function toFailure(result, context, struct, value) {
    if (!0 === result) return;
    !1 === result ? result = {} : "string" == typeof result && (result = {
        message: result
    });
    const {path: path, branch: branch} = context, {type: type} = struct, {refinement: refinement, message: message = `Expected a value of type \`${type}\`${refinement ? ` with refinement \`${refinement}\`` : ""}, but received: \`${print(value)}\``} = result;
    return {
        value: value,
        type: type,
        refinement: refinement,
        key: path[path.length - 1],
        path: path,
        branch: branch,
        ...result,
        message: message
    };
}

function* toFailures(result, context, struct, value) {
    isIterable(result) || (result = [ result ]);
    for (const r of result) {
        const failure = toFailure(r, context, struct, value);
        failure && (yield failure);
    }
}

function* run(value, struct, options = {}) {
    const {path: path = [], branch: branch = [ value ], coerce: coerce = !1, mask: mask = !1} = options, ctx = {
        path: path,
        branch: branch,
        mask: mask
    };
    coerce && (value = struct.coercer(value, ctx));
    let status = "valid";
    for (const failure of struct.validator(value, ctx)) failure.explanation = options.message, 
    status = "not_valid", yield [ failure, void 0 ];
    for (let [k, v, s] of struct.entries(value, ctx)) {
        const ts = run(v, s, {
            path: void 0 === k ? path : [ ...path, k ],
            branch: void 0 === k ? branch : [ ...branch, v ],
            coerce: coerce,
            mask: mask,
            message: options.message
        });
        for (const t of ts) t[0] ? (status = null != t[0].refinement ? "not_refined" : "not_valid", 
        yield [ t[0], void 0 ]) : coerce && (v = t[1], void 0 === k ? value = v : value instanceof Map ? value.set(k, v) : value instanceof Set ? value.add(v) : isObject(value) && (void 0 !== v || k in value) && (value[k] = v));
    }
    if ("not_valid" !== status) for (const failure of struct.refiner(value, ctx)) failure.explanation = options.message, 
    status = "not_refined", yield [ failure, void 0 ];
    "valid" === status && (yield [ void 0, value ]);
}

let Struct$1 = class {
    constructor(props) {
        const {type: type, schema: schema, validator: validator, refiner: refiner, coercer: coercer = value => value, entries: entries = function*() {}} = props;
        this.type = type, this.schema = schema, this.entries = entries, this.coercer = coercer, 
        this.validator = validator ? (value, context) => toFailures(validator(value, context), context, this, value) : () => [], 
        this.refiner = refiner ? (value, context) => toFailures(refiner(value, context), context, this, value) : () => [];
    }
    assert(value, message) {
        return assert(value, this, message);
    }
    create(value, message) {
        return create(value, this, message);
    }
    is(value) {
        return is(value, this);
    }
    mask(value, message) {
        return mask(value, this, message);
    }
    validate(value, options = {}) {
        return validate$1(value, this, options);
    }
};

function assert(value, struct, message) {
    const result = validate$1(value, struct, {
        message: message
    });
    if (result[0]) throw result[0];
}

function create(value, struct, message) {
    const result = validate$1(value, struct, {
        coerce: !0,
        message: message
    });
    if (result[0]) throw result[0];
    return result[1];
}

function mask(value, struct, message) {
    const result = validate$1(value, struct, {
        coerce: !0,
        mask: !0,
        message: message
    });
    if (result[0]) throw result[0];
    return result[1];
}

function is(value, struct) {
    return !validate$1(value, struct)[0];
}

function validate$1(value, struct, options = {}) {
    const tuples = run(value, struct, options), tuple = shiftIterator(tuples);
    if (tuple[0]) {
        return [ new StructError(tuple[0], (function*() {
            for (const t of tuples) t[0] && (yield t[0]);
        })), void 0 ];
    }
    return [ void 0, tuple[1] ];
}

function define(name, validator) {
    return new Struct$1({
        type: name,
        schema: null,
        validator: validator
    });
}

function any() {
    return define("any", (() => !0));
}

function array(Element) {
    return new Struct$1({
        type: "array",
        schema: Element,
        * entries(value) {
            if (Element && Array.isArray(value)) for (const [i, v] of value.entries()) yield [ i, v, Element ];
        },
        coercer: value => Array.isArray(value) ? value.slice() : value,
        validator: value => Array.isArray(value) || `Expected an array value, but received: ${print(value)}`
    });
}

function boolean() {
    return define("boolean", (value => "boolean" == typeof value));
}

function instance(Class) {
    return define("instance", (value => value instanceof Class || `Expected a \`${Class.name}\` instance, but received: ${print(value)}`));
}

function literal(constant) {
    const description = print(constant), t = typeof constant;
    return new Struct$1({
        type: "literal",
        schema: "string" === t || "number" === t || "boolean" === t ? constant : null,
        validator: value => value === constant || `Expected the literal \`${description}\`, but received: ${print(value)}`
    });
}

function never() {
    return define("never", (() => !1));
}

function nullable(struct) {
    return new Struct$1({
        ...struct,
        validator: (value, ctx) => null === value || struct.validator(value, ctx),
        refiner: (value, ctx) => null === value || struct.refiner(value, ctx)
    });
}

function number() {
    return define("number", (value => "number" == typeof value && !isNaN(value) || `Expected a number, but received: ${print(value)}`));
}

function optional(struct) {
    return new Struct$1({
        ...struct,
        validator: (value, ctx) => void 0 === value || struct.validator(value, ctx),
        refiner: (value, ctx) => void 0 === value || struct.refiner(value, ctx)
    });
}

function record(Key, Value) {
    return new Struct$1({
        type: "record",
        schema: null,
        * entries(value) {
            if (isObject(value)) for (const k in value) {
                const v = value[k];
                yield [ k, k, Key ], yield [ k, v, Value ];
            }
        },
        validator: value => isNonArrayObject(value) || `Expected an object, but received: ${print(value)}`,
        coercer: value => isNonArrayObject(value) ? {
            ...value
        } : value
    });
}

function string() {
    return define("string", (value => "string" == typeof value || `Expected a string, but received: ${print(value)}`));
}

function tuple(Structs) {
    const Never = never();
    return new Struct$1({
        type: "tuple",
        schema: null,
        * entries(value) {
            if (Array.isArray(value)) {
                const length = Math.max(Structs.length, value.length);
                for (let i = 0; i < length; i++) yield [ i, value[i], Structs[i] || Never ];
            }
        },
        validator: value => Array.isArray(value) || `Expected an array, but received: ${print(value)}`,
        coercer: value => Array.isArray(value) ? value.slice() : value
    });
}

function type(schema) {
    const keys = Object.keys(schema);
    return new Struct$1({
        type: "type",
        schema: schema,
        * entries(value) {
            if (isObject(value)) for (const k of keys) yield [ k, value[k], schema[k] ];
        },
        validator: value => isNonArrayObject(value) || `Expected an object, but received: ${print(value)}`,
        coercer: value => isNonArrayObject(value) ? {
            ...value
        } : value
    });
}

function union(Structs) {
    const description = Structs.map((s => s.type)).join(" | ");
    return new Struct$1({
        type: "union",
        schema: null,
        coercer(value, ctx) {
            for (const S of Structs) {
                const [error, coerced] = S.validate(value, {
                    coerce: !0,
                    mask: ctx.mask
                });
                if (!error) return coerced;
            }
            return value;
        },
        validator(value, ctx) {
            const failures = [];
            for (const S of Structs) {
                const [...tuples] = run(value, S, ctx), [first] = tuples;
                if (!first[0]) return [];
                for (const [failure] of tuples) failure && failures.push(failure);
            }
            return [ `Expected the value to satisfy a union of \`${description}\`, but received: ${print(value)}`, ...failures ];
        }
    });
}

function unknown() {
    return define("unknown", (() => !0));
}

function coerce(struct, condition, coercer) {
    return new Struct$1({
        ...struct,
        coercer: (value, ctx) => is(value, condition) ? struct.coercer(coercer(value, ctx), ctx) : struct.coercer(value, ctx)
    });
}

const rnds8Pool = new Uint8Array(256);

let poolPtr = rnds8Pool.length;

function rng() {
    return poolPtr > rnds8Pool.length - 16 && (crypto$1.randomFillSync(rnds8Pool), poolPtr = 0), 
    rnds8Pool.slice(poolPtr, poolPtr += 16);
}

var REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

function validate(uuid) {
    return "string" == typeof uuid && REGEX.test(uuid);
}

const byteToHex = [];

for (let i = 0; i < 256; ++i) byteToHex.push((i + 256).toString(16).substr(1));

function stringify(arr, offset = 0) {
    const uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
    if (!validate(uuid)) throw TypeError("Stringified UUID is invalid");
    return uuid;
}

let _nodeId, _clockseq, _lastMSecs = 0, _lastNSecs = 0;

function v1(options, buf, offset) {
    let i = buf && offset || 0;
    const b = buf || new Array(16);
    let node = (options = options || {}).node || _nodeId, clockseq = void 0 !== options.clockseq ? options.clockseq : _clockseq;
    if (null == node || null == clockseq) {
        const seedBytes = options.random || (options.rng || rng)();
        null == node && (node = _nodeId = [ 1 | seedBytes[0], seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5] ]), 
        null == clockseq && (clockseq = _clockseq = 16383 & (seedBytes[6] << 8 | seedBytes[7]));
    }
    let msecs = void 0 !== options.msecs ? options.msecs : Date.now(), nsecs = void 0 !== options.nsecs ? options.nsecs : _lastNSecs + 1;
    const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
    if (dt < 0 && void 0 === options.clockseq && (clockseq = clockseq + 1 & 16383), 
    (dt < 0 || msecs > _lastMSecs) && void 0 === options.nsecs && (nsecs = 0), nsecs >= 1e4) throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
    _lastMSecs = msecs, _lastNSecs = nsecs, _clockseq = clockseq, msecs += 122192928e5;
    const tl = (1e4 * (268435455 & msecs) + nsecs) % 4294967296;
    b[i++] = tl >>> 24 & 255, b[i++] = tl >>> 16 & 255, b[i++] = tl >>> 8 & 255, b[i++] = 255 & tl;
    const tmh = msecs / 4294967296 * 1e4 & 268435455;
    b[i++] = tmh >>> 8 & 255, b[i++] = 255 & tmh, b[i++] = tmh >>> 24 & 15 | 16, b[i++] = tmh >>> 16 & 255, 
    b[i++] = clockseq >>> 8 | 128, b[i++] = 255 & clockseq;
    for (let n = 0; n < 6; ++n) b[i + n] = node[n];
    return buf || stringify(b);
}

function parse$1(uuid) {
    if (!validate(uuid)) throw TypeError("Invalid UUID");
    let v;
    const arr = new Uint8Array(16);
    return arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24, arr[1] = v >>> 16 & 255, 
    arr[2] = v >>> 8 & 255, arr[3] = 255 & v, arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8, 
    arr[5] = 255 & v, arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8, arr[7] = 255 & v, 
    arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8, arr[9] = 255 & v, arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255, 
    arr[11] = v / 4294967296 & 255, arr[12] = v >>> 24 & 255, arr[13] = v >>> 16 & 255, 
    arr[14] = v >>> 8 & 255, arr[15] = 255 & v, arr;
}

function stringToBytes(str) {
    str = unescape(encodeURIComponent(str));
    const bytes = [];
    for (let i = 0; i < str.length; ++i) bytes.push(str.charCodeAt(i));
    return bytes;
}

const DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8", URL$3 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";

function v35(name, version, hashfunc) {
    function generateUUID(value, namespace, buf, offset) {
        if ("string" == typeof value && (value = stringToBytes(value)), "string" == typeof namespace && (namespace = parse$1(namespace)), 
        16 !== namespace.length) throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
        let bytes = new Uint8Array(16 + value.length);
        if (bytes.set(namespace), bytes.set(value, namespace.length), bytes = hashfunc(bytes), 
        bytes[6] = 15 & bytes[6] | version, bytes[8] = 63 & bytes[8] | 128, buf) {
            offset = offset || 0;
            for (let i = 0; i < 16; ++i) buf[offset + i] = bytes[i];
            return buf;
        }
        return stringify(bytes);
    }
    try {
        generateUUID.name = name;
    } catch (err) {}
    return generateUUID.DNS = DNS, generateUUID.URL = URL$3, generateUUID;
}

function md5(bytes) {
    return Array.isArray(bytes) ? bytes = Buffer.from(bytes) : "string" == typeof bytes && (bytes = Buffer.from(bytes, "utf8")), 
    crypto$1.createHash("md5").update(bytes).digest();
}

const v3 = v35("v3", 48, md5);

function v4(options, buf, offset) {
    const rnds = (options = options || {}).random || (options.rng || rng)();
    if (rnds[6] = 15 & rnds[6] | 64, rnds[8] = 63 & rnds[8] | 128, buf) {
        offset = offset || 0;
        for (let i = 0; i < 16; ++i) buf[offset + i] = rnds[i];
        return buf;
    }
    return stringify(rnds);
}

function sha1(bytes) {
    return Array.isArray(bytes) ? bytes = Buffer.from(bytes) : "string" == typeof bytes && (bytes = Buffer.from(bytes, "utf8")), 
    crypto$1.createHash("sha1").update(bytes).digest();
}

const v5 = v35("v5", 80, sha1);

var nil = "00000000-0000-0000-0000-000000000000";

function version(uuid) {
    if (!validate(uuid)) throw TypeError("Invalid UUID");
    return parseInt(uuid.substr(14, 1), 16);
}

var esmNode = Object.freeze({
    __proto__: null,
    NIL: nil,
    parse: parse$1,
    stringify: stringify,
    v1: v1,
    v3: v3,
    v4: v4,
    v5: v5,
    validate: validate,
    version: version
}), require$$0$1 = getAugmentedNamespace(esmNode), generateRequest_1, hasRequiredGenerateRequest, browser, hasRequiredBrowser;

function requireGenerateRequest() {
    if (hasRequiredGenerateRequest) return generateRequest_1;
    hasRequiredGenerateRequest = 1;
    const uuid = require$$0$1.v4;
    return generateRequest_1 = function(method, params, id, options) {
        if ("string" != typeof method) throw new TypeError(method + " must be a string");
        const version = "number" == typeof (options = options || {}).version ? options.version : 2;
        if (1 !== version && 2 !== version) throw new TypeError(version + " must be 1 or 2");
        const request = {
            method: method
        };
        if (2 === version && (request.jsonrpc = "2.0"), params) {
            if ("object" != typeof params && !Array.isArray(params)) throw new TypeError(params + " must be an object, array or omitted");
            request.params = params;
        }
        if (void 0 === id) {
            const generator = "function" == typeof options.generator ? options.generator : function() {
                return uuid();
            };
            request.id = generator(request, options);
        } else 2 === version && null === id ? options.notificationIdNull && (request.id = null) : request.id = id;
        return request;
    }, generateRequest_1;
}

function requireBrowser() {
    if (hasRequiredBrowser) return browser;
    hasRequiredBrowser = 1;
    const uuid = require$$0$1.v4, generateRequest = requireGenerateRequest(), ClientBrowser = function(callServer, options) {
        if (!(this instanceof ClientBrowser)) return new ClientBrowser(callServer, options);
        options || (options = {}), this.options = {
            reviver: void 0 !== options.reviver ? options.reviver : null,
            replacer: void 0 !== options.replacer ? options.replacer : null,
            generator: void 0 !== options.generator ? options.generator : function() {
                return uuid();
            },
            version: void 0 !== options.version ? options.version : 2,
            notificationIdNull: "boolean" == typeof options.notificationIdNull && options.notificationIdNull
        }, this.callServer = callServer;
    };
    return browser = ClientBrowser, ClientBrowser.prototype.request = function(method, params, id, callback) {
        const self = this;
        let request = null;
        const isBatch = Array.isArray(method) && "function" == typeof params;
        if (1 === this.options.version && isBatch) throw new TypeError("JSON-RPC 1.0 does not support batching");
        if (isBatch || !isBatch && method && "object" == typeof method && "function" == typeof params) callback = params, 
        request = method; else {
            "function" == typeof id && (callback = id, id = void 0);
            const hasCallback = "function" == typeof callback;
            try {
                request = generateRequest(method, params, id, {
                    generator: this.options.generator,
                    version: this.options.version,
                    notificationIdNull: this.options.notificationIdNull
                });
            } catch (err) {
                if (hasCallback) return callback(err);
                throw err;
            }
            if (!hasCallback) return request;
        }
        let message;
        try {
            message = JSON.stringify(request, this.options.replacer);
        } catch (err) {
            return callback(err);
        }
        return this.callServer(message, (function(err, response) {
            self._parseResponse(err, response, callback);
        })), request;
    }, ClientBrowser.prototype._parseResponse = function(err, responseText, callback) {
        if (err) return void callback(err);
        if (!responseText) return callback();
        let response;
        try {
            response = JSON.parse(responseText, this.options.reviver);
        } catch (err) {
            return callback(err);
        }
        if (3 === callback.length) {
            if (Array.isArray(response)) {
                const isError = function(res) {
                    return void 0 !== res.error;
                }, isNotError = function(res) {
                    return !isError(res);
                };
                return callback(null, response.filter(isError), response.filter(isNotError));
            }
            return callback(null, response.error, response.result);
        }
        callback(null, response);
    }, browser;
}

requireBrowser();

var publicApi = {}, URL$2 = {
    exports: {}
}, lib$1, hasRequiredLib$1;

function requireLib$1() {
    if (hasRequiredLib$1) return lib$1;
    hasRequiredLib$1 = 1;
    var conversions = {};
    function sign(x) {
        return x < 0 ? -1 : 1;
    }
    function createNumberConversion(bitLength, typeOpts) {
        typeOpts.unsigned || --bitLength;
        const lowerBound = typeOpts.unsigned ? 0 : -Math.pow(2, bitLength), upperBound = Math.pow(2, bitLength) - 1, moduloVal = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength) : Math.pow(2, bitLength), moduloBound = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength - 1) : Math.pow(2, bitLength - 1);
        return function(V, opts) {
            opts || (opts = {});
            let x = +V;
            if (opts.enforceRange) {
                if (!Number.isFinite(x)) throw new TypeError("Argument is not a finite number");
                if (x = sign(x) * Math.floor(Math.abs(x)), x < lowerBound || x > upperBound) throw new TypeError("Argument is not in byte range");
                return x;
            }
            if (!isNaN(x) && opts.clamp) return x = function(x) {
                return x % 1 != .5 || 1 & x ? Math.round(x) : Math.floor(x);
            }(x), x < lowerBound && (x = lowerBound), x > upperBound && (x = upperBound), x;
            if (!Number.isFinite(x) || 0 === x) return 0;
            if (x = sign(x) * Math.floor(Math.abs(x)), x %= moduloVal, !typeOpts.unsigned && x >= moduloBound) return x - moduloVal;
            if (typeOpts.unsigned) if (x < 0) x += moduloVal; else if (-0 === x) return 0;
            return x;
        };
    }
    return lib$1 = conversions, conversions.void = function() {}, conversions.boolean = function(val) {
        return !!val;
    }, conversions.byte = createNumberConversion(8, {
        unsigned: !1
    }), conversions.octet = createNumberConversion(8, {
        unsigned: !0
    }), conversions.short = createNumberConversion(16, {
        unsigned: !1
    }), conversions["unsigned short"] = createNumberConversion(16, {
        unsigned: !0
    }), conversions.long = createNumberConversion(32, {
        unsigned: !1
    }), conversions["unsigned long"] = createNumberConversion(32, {
        unsigned: !0
    }), conversions["long long"] = createNumberConversion(32, {
        unsigned: !1,
        moduloBitLength: 64
    }), conversions["unsigned long long"] = createNumberConversion(32, {
        unsigned: !0,
        moduloBitLength: 64
    }), conversions.double = function(V) {
        const x = +V;
        if (!Number.isFinite(x)) throw new TypeError("Argument is not a finite floating-point value");
        return x;
    }, conversions["unrestricted double"] = function(V) {
        const x = +V;
        if (isNaN(x)) throw new TypeError("Argument is NaN");
        return x;
    }, conversions.float = conversions.double, conversions["unrestricted float"] = conversions["unrestricted double"], 
    conversions.DOMString = function(V, opts) {
        return opts || (opts = {}), opts.treatNullAsEmptyString && null === V ? "" : String(V);
    }, conversions.ByteString = function(V, opts) {
        const x = String(V);
        let c;
        for (let i = 0; void 0 !== (c = x.codePointAt(i)); ++i) if (c > 255) throw new TypeError("Argument is not a valid bytestring");
        return x;
    }, conversions.USVString = function(V) {
        const S = String(V), n = S.length, U = [];
        for (let i = 0; i < n; ++i) {
            const c = S.charCodeAt(i);
            if (c < 55296 || c > 57343) U.push(String.fromCodePoint(c)); else if (56320 <= c && c <= 57343) U.push(String.fromCodePoint(65533)); else if (i === n - 1) U.push(String.fromCodePoint(65533)); else {
                const d = S.charCodeAt(i + 1);
                if (56320 <= d && d <= 57343) {
                    const a = 1023 & c, b = 1023 & d;
                    U.push(String.fromCodePoint(65536 + 1024 * a + b)), ++i;
                } else U.push(String.fromCodePoint(65533));
            }
        }
        return U.join("");
    }, conversions.Date = function(V, opts) {
        if (!(V instanceof Date)) throw new TypeError("Argument is not a Date object");
        if (!isNaN(V)) return V;
    }, conversions.RegExp = function(V, opts) {
        return V instanceof RegExp || (V = new RegExp(V)), V;
    }, lib$1;
}

var utils = {
    exports: {}
}, hasRequiredUtils;

function requireUtils() {
    return hasRequiredUtils || (hasRequiredUtils = 1, (module = utils).exports.mixin = function(target, source) {
        const keys = Object.getOwnPropertyNames(source);
        for (let i = 0; i < keys.length; ++i) Object.defineProperty(target, keys[i], Object.getOwnPropertyDescriptor(source, keys[i]));
    }, module.exports.wrapperSymbol = Symbol("wrapper"), module.exports.implSymbol = Symbol("impl"), 
    module.exports.wrapperForImpl = function(impl) {
        return impl[module.exports.wrapperSymbol];
    }, module.exports.implForWrapper = function(wrapper) {
        return wrapper[module.exports.implSymbol];
    }), utils.exports;
    var module;
}

var URLImpl = {}, urlStateMachine = {
    exports: {}
};

const maxInt = 2147483647, base = 36, tMin = 1, tMax = 26, skew = 38, damp = 700, initialBias = 72, initialN = 128, delimiter = "-", regexPunycode = /^xn--/, regexNonASCII = /[^\0-\x7F]/, regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, errors = {
    overflow: "Overflow: input needs wider integers to process",
    "not-basic": "Illegal input >= 0x80 (not a basic code point)",
    "invalid-input": "Invalid input"
}, baseMinusTMin = base - tMin, floor = Math.floor, stringFromCharCode = String.fromCharCode;

function error(type) {
    throw new RangeError(errors[type]);
}

function map(array, callback) {
    const result = [];
    let length = array.length;
    for (;length--; ) result[length] = callback(array[length]);
    return result;
}

function mapDomain(domain, callback) {
    const parts = domain.split("@");
    let result = "";
    parts.length > 1 && (result = parts[0] + "@", domain = parts[1]);
    return result + map((domain = domain.replace(regexSeparators, ".")).split("."), callback).join(".");
}

function ucs2decode(string) {
    const output = [];
    let counter = 0;
    const length = string.length;
    for (;counter < length; ) {
        const value = string.charCodeAt(counter++);
        if (value >= 55296 && value <= 56319 && counter < length) {
            const extra = string.charCodeAt(counter++);
            56320 == (64512 & extra) ? output.push(((1023 & value) << 10) + (1023 & extra) + 65536) : (output.push(value), 
            counter--);
        } else output.push(value);
    }
    return output;
}

const ucs2encode = codePoints => String.fromCodePoint(...codePoints), basicToDigit = function(codePoint) {
    return codePoint >= 48 && codePoint < 58 ? codePoint - 48 + 26 : codePoint >= 65 && codePoint < 91 ? codePoint - 65 : codePoint >= 97 && codePoint < 123 ? codePoint - 97 : base;
}, digitToBasic = function(digit, flag) {
    return digit + 22 + 75 * (digit < 26) - ((0 != flag) << 5);
}, adapt = function(delta, numPoints, firstTime) {
    let k = 0;
    for (delta = firstTime ? floor(delta / damp) : delta >> 1, delta += floor(delta / numPoints); delta > baseMinusTMin * tMax >> 1; k += base) delta = floor(delta / baseMinusTMin);
    return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
}, decode = function(input) {
    const output = [], inputLength = input.length;
    let i = 0, n = initialN, bias = initialBias, basic = input.lastIndexOf(delimiter);
    basic < 0 && (basic = 0);
    for (let j = 0; j < basic; ++j) input.charCodeAt(j) >= 128 && error("not-basic"), 
    output.push(input.charCodeAt(j));
    for (let index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
        const oldi = i;
        for (let w = 1, k = base; ;k += base) {
            index >= inputLength && error("invalid-input");
            const digit = basicToDigit(input.charCodeAt(index++));
            digit >= base && error("invalid-input"), digit > floor((maxInt - i) / w) && error("overflow"), 
            i += digit * w;
            const t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
            if (digit < t) break;
            const baseMinusT = base - t;
            w > floor(maxInt / baseMinusT) && error("overflow"), w *= baseMinusT;
        }
        const out = output.length + 1;
        bias = adapt(i - oldi, out, 0 == oldi), floor(i / out) > maxInt - n && error("overflow"), 
        n += floor(i / out), i %= out, output.splice(i++, 0, n);
    }
    return String.fromCodePoint(...output);
}, encode = function(input) {
    const output = [], inputLength = (input = ucs2decode(input)).length;
    let n = initialN, delta = 0, bias = initialBias;
    for (const currentValue of input) currentValue < 128 && output.push(stringFromCharCode(currentValue));
    const basicLength = output.length;
    let handledCPCount = basicLength;
    for (basicLength && output.push(delimiter); handledCPCount < inputLength; ) {
        let m = maxInt;
        for (const currentValue of input) currentValue >= n && currentValue < m && (m = currentValue);
        const handledCPCountPlusOne = handledCPCount + 1;
        m - n > floor((maxInt - delta) / handledCPCountPlusOne) && error("overflow"), delta += (m - n) * handledCPCountPlusOne, 
        n = m;
        for (const currentValue of input) if (currentValue < n && ++delta > maxInt && error("overflow"), 
        currentValue === n) {
            let q = delta;
            for (let k = base; ;k += base) {
                const t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                if (q < t) break;
                const qMinusT = q - t, baseMinusT = base - t;
                output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))), q = floor(qMinusT / baseMinusT);
            }
            output.push(stringFromCharCode(digitToBasic(q, 0))), bias = adapt(delta, handledCPCountPlusOne, handledCPCount === basicLength), 
            delta = 0, ++handledCPCount;
        }
        ++delta, ++n;
    }
    return output.join("");
}, toUnicode = function(input) {
    return mapDomain(input, (function(string) {
        return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
    }));
}, toASCII = function(input) {
    return mapDomain(input, (function(string) {
        return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
    }));
}, punycode = {
    version: "2.3.1",
    ucs2: {
        decode: ucs2decode,
        encode: ucs2encode
    },
    decode: decode,
    encode: encode,
    toASCII: toASCII,
    toUnicode: toUnicode
};

var punycode_es6 = Object.freeze({
    __proto__: null,
    decode: decode,
    default: punycode,
    encode: encode,
    toASCII: toASCII,
    toUnicode: toUnicode,
    ucs2decode: ucs2decode,
    ucs2encode: ucs2encode
}), require$$0 = getAugmentedNamespace(punycode_es6), tr46 = {}, require$$1 = [ [ [ 0, 44 ], "disallowed_STD3_valid" ], [ [ 45, 46 ], "valid" ], [ [ 47, 47 ], "disallowed_STD3_valid" ], [ [ 48, 57 ], "valid" ], [ [ 58, 64 ], "disallowed_STD3_valid" ], [ [ 65, 65 ], "mapped", [ 97 ] ], [ [ 66, 66 ], "mapped", [ 98 ] ], [ [ 67, 67 ], "mapped", [ 99 ] ], [ [ 68, 68 ], "mapped", [ 100 ] ], [ [ 69, 69 ], "mapped", [ 101 ] ], [ [ 70, 70 ], "mapped", [ 102 ] ], [ [ 71, 71 ], "mapped", [ 103 ] ], [ [ 72, 72 ], "mapped", [ 104 ] ], [ [ 73, 73 ], "mapped", [ 105 ] ], [ [ 74, 74 ], "mapped", [ 106 ] ], [ [ 75, 75 ], "mapped", [ 107 ] ], [ [ 76, 76 ], "mapped", [ 108 ] ], [ [ 77, 77 ], "mapped", [ 109 ] ], [ [ 78, 78 ], "mapped", [ 110 ] ], [ [ 79, 79 ], "mapped", [ 111 ] ], [ [ 80, 80 ], "mapped", [ 112 ] ], [ [ 81, 81 ], "mapped", [ 113 ] ], [ [ 82, 82 ], "mapped", [ 114 ] ], [ [ 83, 83 ], "mapped", [ 115 ] ], [ [ 84, 84 ], "mapped", [ 116 ] ], [ [ 85, 85 ], "mapped", [ 117 ] ], [ [ 86, 86 ], "mapped", [ 118 ] ], [ [ 87, 87 ], "mapped", [ 119 ] ], [ [ 88, 88 ], "mapped", [ 120 ] ], [ [ 89, 89 ], "mapped", [ 121 ] ], [ [ 90, 90 ], "mapped", [ 122 ] ], [ [ 91, 96 ], "disallowed_STD3_valid" ], [ [ 97, 122 ], "valid" ], [ [ 123, 127 ], "disallowed_STD3_valid" ], [ [ 128, 159 ], "disallowed" ], [ [ 160, 160 ], "disallowed_STD3_mapped", [ 32 ] ], [ [ 161, 167 ], "valid", [], "NV8" ], [ [ 168, 168 ], "disallowed_STD3_mapped", [ 32, 776 ] ], [ [ 169, 169 ], "valid", [], "NV8" ], [ [ 170, 170 ], "mapped", [ 97 ] ], [ [ 171, 172 ], "valid", [], "NV8" ], [ [ 173, 173 ], "ignored" ], [ [ 174, 174 ], "valid", [], "NV8" ], [ [ 175, 175 ], "disallowed_STD3_mapped", [ 32, 772 ] ], [ [ 176, 177 ], "valid", [], "NV8" ], [ [ 178, 178 ], "mapped", [ 50 ] ], [ [ 179, 179 ], "mapped", [ 51 ] ], [ [ 180, 180 ], "disallowed_STD3_mapped", [ 32, 769 ] ], [ [ 181, 181 ], "mapped", [ 956 ] ], [ [ 182, 182 ], "valid", [], "NV8" ], [ [ 183, 183 ], "valid" ], [ [ 184, 184 ], "disallowed_STD3_mapped", [ 32, 807 ] ], [ [ 185, 185 ], "mapped", [ 49 ] ], [ [ 186, 186 ], "mapped", [ 111 ] ], [ [ 187, 187 ], "valid", [], "NV8" ], [ [ 188, 188 ], "mapped", [ 49, 8260, 52 ] ], [ [ 189, 189 ], "mapped", [ 49, 8260, 50 ] ], [ [ 190, 190 ], "mapped", [ 51, 8260, 52 ] ], [ [ 191, 191 ], "valid", [], "NV8" ], [ [ 192, 192 ], "mapped", [ 224 ] ], [ [ 193, 193 ], "mapped", [ 225 ] ], [ [ 194, 194 ], "mapped", [ 226 ] ], [ [ 195, 195 ], "mapped", [ 227 ] ], [ [ 196, 196 ], "mapped", [ 228 ] ], [ [ 197, 197 ], "mapped", [ 229 ] ], [ [ 198, 198 ], "mapped", [ 230 ] ], [ [ 199, 199 ], "mapped", [ 231 ] ], [ [ 200, 200 ], "mapped", [ 232 ] ], [ [ 201, 201 ], "mapped", [ 233 ] ], [ [ 202, 202 ], "mapped", [ 234 ] ], [ [ 203, 203 ], "mapped", [ 235 ] ], [ [ 204, 204 ], "mapped", [ 236 ] ], [ [ 205, 205 ], "mapped", [ 237 ] ], [ [ 206, 206 ], "mapped", [ 238 ] ], [ [ 207, 207 ], "mapped", [ 239 ] ], [ [ 208, 208 ], "mapped", [ 240 ] ], [ [ 209, 209 ], "mapped", [ 241 ] ], [ [ 210, 210 ], "mapped", [ 242 ] ], [ [ 211, 211 ], "mapped", [ 243 ] ], [ [ 212, 212 ], "mapped", [ 244 ] ], [ [ 213, 213 ], "mapped", [ 245 ] ], [ [ 214, 214 ], "mapped", [ 246 ] ], [ [ 215, 215 ], "valid", [], "NV8" ], [ [ 216, 216 ], "mapped", [ 248 ] ], [ [ 217, 217 ], "mapped", [ 249 ] ], [ [ 218, 218 ], "mapped", [ 250 ] ], [ [ 219, 219 ], "mapped", [ 251 ] ], [ [ 220, 220 ], "mapped", [ 252 ] ], [ [ 221, 221 ], "mapped", [ 253 ] ], [ [ 222, 222 ], "mapped", [ 254 ] ], [ [ 223, 223 ], "deviation", [ 115, 115 ] ], [ [ 224, 246 ], "valid" ], [ [ 247, 247 ], "valid", [], "NV8" ], [ [ 248, 255 ], "valid" ], [ [ 256, 256 ], "mapped", [ 257 ] ], [ [ 257, 257 ], "valid" ], [ [ 258, 258 ], "mapped", [ 259 ] ], [ [ 259, 259 ], "valid" ], [ [ 260, 260 ], "mapped", [ 261 ] ], [ [ 261, 261 ], "valid" ], [ [ 262, 262 ], "mapped", [ 263 ] ], [ [ 263, 263 ], "valid" ], [ [ 264, 264 ], "mapped", [ 265 ] ], [ [ 265, 265 ], "valid" ], [ [ 266, 266 ], "mapped", [ 267 ] ], [ [ 267, 267 ], "valid" ], [ [ 268, 268 ], "mapped", [ 269 ] ], [ [ 269, 269 ], "valid" ], [ [ 270, 270 ], "mapped", [ 271 ] ], [ [ 271, 271 ], "valid" ], [ [ 272, 272 ], "mapped", [ 273 ] ], [ [ 273, 273 ], "valid" ], [ [ 274, 274 ], "mapped", [ 275 ] ], [ [ 275, 275 ], "valid" ], [ [ 276, 276 ], "mapped", [ 277 ] ], [ [ 277, 277 ], "valid" ], [ [ 278, 278 ], "mapped", [ 279 ] ], [ [ 279, 279 ], "valid" ], [ [ 280, 280 ], "mapped", [ 281 ] ], [ [ 281, 281 ], "valid" ], [ [ 282, 282 ], "mapped", [ 283 ] ], [ [ 283, 283 ], "valid" ], [ [ 284, 284 ], "mapped", [ 285 ] ], [ [ 285, 285 ], "valid" ], [ [ 286, 286 ], "mapped", [ 287 ] ], [ [ 287, 287 ], "valid" ], [ [ 288, 288 ], "mapped", [ 289 ] ], [ [ 289, 289 ], "valid" ], [ [ 290, 290 ], "mapped", [ 291 ] ], [ [ 291, 291 ], "valid" ], [ [ 292, 292 ], "mapped", [ 293 ] ], [ [ 293, 293 ], "valid" ], [ [ 294, 294 ], "mapped", [ 295 ] ], [ [ 295, 295 ], "valid" ], [ [ 296, 296 ], "mapped", [ 297 ] ], [ [ 297, 297 ], "valid" ], [ [ 298, 298 ], "mapped", [ 299 ] ], [ [ 299, 299 ], "valid" ], [ [ 300, 300 ], "mapped", [ 301 ] ], [ [ 301, 301 ], "valid" ], [ [ 302, 302 ], "mapped", [ 303 ] ], [ [ 303, 303 ], "valid" ], [ [ 304, 304 ], "mapped", [ 105, 775 ] ], [ [ 305, 305 ], "valid" ], [ [ 306, 307 ], "mapped", [ 105, 106 ] ], [ [ 308, 308 ], "mapped", [ 309 ] ], [ [ 309, 309 ], "valid" ], [ [ 310, 310 ], "mapped", [ 311 ] ], [ [ 311, 312 ], "valid" ], [ [ 313, 313 ], "mapped", [ 314 ] ], [ [ 314, 314 ], "valid" ], [ [ 315, 315 ], "mapped", [ 316 ] ], [ [ 316, 316 ], "valid" ], [ [ 317, 317 ], "mapped", [ 318 ] ], [ [ 318, 318 ], "valid" ], [ [ 319, 320 ], "mapped", [ 108, 183 ] ], [ [ 321, 321 ], "mapped", [ 322 ] ], [ [ 322, 322 ], "valid" ], [ [ 323, 323 ], "mapped", [ 324 ] ], [ [ 324, 324 ], "valid" ], [ [ 325, 325 ], "mapped", [ 326 ] ], [ [ 326, 326 ], "valid" ], [ [ 327, 327 ], "mapped", [ 328 ] ], [ [ 328, 328 ], "valid" ], [ [ 329, 329 ], "mapped", [ 700, 110 ] ], [ [ 330, 330 ], "mapped", [ 331 ] ], [ [ 331, 331 ], "valid" ], [ [ 332, 332 ], "mapped", [ 333 ] ], [ [ 333, 333 ], "valid" ], [ [ 334, 334 ], "mapped", [ 335 ] ], [ [ 335, 335 ], "valid" ], [ [ 336, 336 ], "mapped", [ 337 ] ], [ [ 337, 337 ], "valid" ], [ [ 338, 338 ], "mapped", [ 339 ] ], [ [ 339, 339 ], "valid" ], [ [ 340, 340 ], "mapped", [ 341 ] ], [ [ 341, 341 ], "valid" ], [ [ 342, 342 ], "mapped", [ 343 ] ], [ [ 343, 343 ], "valid" ], [ [ 344, 344 ], "mapped", [ 345 ] ], [ [ 345, 345 ], "valid" ], [ [ 346, 346 ], "mapped", [ 347 ] ], [ [ 347, 347 ], "valid" ], [ [ 348, 348 ], "mapped", [ 349 ] ], [ [ 349, 349 ], "valid" ], [ [ 350, 350 ], "mapped", [ 351 ] ], [ [ 351, 351 ], "valid" ], [ [ 352, 352 ], "mapped", [ 353 ] ], [ [ 353, 353 ], "valid" ], [ [ 354, 354 ], "mapped", [ 355 ] ], [ [ 355, 355 ], "valid" ], [ [ 356, 356 ], "mapped", [ 357 ] ], [ [ 357, 357 ], "valid" ], [ [ 358, 358 ], "mapped", [ 359 ] ], [ [ 359, 359 ], "valid" ], [ [ 360, 360 ], "mapped", [ 361 ] ], [ [ 361, 361 ], "valid" ], [ [ 362, 362 ], "mapped", [ 363 ] ], [ [ 363, 363 ], "valid" ], [ [ 364, 364 ], "mapped", [ 365 ] ], [ [ 365, 365 ], "valid" ], [ [ 366, 366 ], "mapped", [ 367 ] ], [ [ 367, 367 ], "valid" ], [ [ 368, 368 ], "mapped", [ 369 ] ], [ [ 369, 369 ], "valid" ], [ [ 370, 370 ], "mapped", [ 371 ] ], [ [ 371, 371 ], "valid" ], [ [ 372, 372 ], "mapped", [ 373 ] ], [ [ 373, 373 ], "valid" ], [ [ 374, 374 ], "mapped", [ 375 ] ], [ [ 375, 375 ], "valid" ], [ [ 376, 376 ], "mapped", [ 255 ] ], [ [ 377, 377 ], "mapped", [ 378 ] ], [ [ 378, 378 ], "valid" ], [ [ 379, 379 ], "mapped", [ 380 ] ], [ [ 380, 380 ], "valid" ], [ [ 381, 381 ], "mapped", [ 382 ] ], [ [ 382, 382 ], "valid" ], [ [ 383, 383 ], "mapped", [ 115 ] ], [ [ 384, 384 ], "valid" ], [ [ 385, 385 ], "mapped", [ 595 ] ], [ [ 386, 386 ], "mapped", [ 387 ] ], [ [ 387, 387 ], "valid" ], [ [ 388, 388 ], "mapped", [ 389 ] ], [ [ 389, 389 ], "valid" ], [ [ 390, 390 ], "mapped", [ 596 ] ], [ [ 391, 391 ], "mapped", [ 392 ] ], [ [ 392, 392 ], "valid" ], [ [ 393, 393 ], "mapped", [ 598 ] ], [ [ 394, 394 ], "mapped", [ 599 ] ], [ [ 395, 395 ], "mapped", [ 396 ] ], [ [ 396, 397 ], "valid" ], [ [ 398, 398 ], "mapped", [ 477 ] ], [ [ 399, 399 ], "mapped", [ 601 ] ], [ [ 400, 400 ], "mapped", [ 603 ] ], [ [ 401, 401 ], "mapped", [ 402 ] ], [ [ 402, 402 ], "valid" ], [ [ 403, 403 ], "mapped", [ 608 ] ], [ [ 404, 404 ], "mapped", [ 611 ] ], [ [ 405, 405 ], "valid" ], [ [ 406, 406 ], "mapped", [ 617 ] ], [ [ 407, 407 ], "mapped", [ 616 ] ], [ [ 408, 408 ], "mapped", [ 409 ] ], [ [ 409, 411 ], "valid" ], [ [ 412, 412 ], "mapped", [ 623 ] ], [ [ 413, 413 ], "mapped", [ 626 ] ], [ [ 414, 414 ], "valid" ], [ [ 415, 415 ], "mapped", [ 629 ] ], [ [ 416, 416 ], "mapped", [ 417 ] ], [ [ 417, 417 ], "valid" ], [ [ 418, 418 ], "mapped", [ 419 ] ], [ [ 419, 419 ], "valid" ], [ [ 420, 420 ], "mapped", [ 421 ] ], [ [ 421, 421 ], "valid" ], [ [ 422, 422 ], "mapped", [ 640 ] ], [ [ 423, 423 ], "mapped", [ 424 ] ], [ [ 424, 424 ], "valid" ], [ [ 425, 425 ], "mapped", [ 643 ] ], [ [ 426, 427 ], "valid" ], [ [ 428, 428 ], "mapped", [ 429 ] ], [ [ 429, 429 ], "valid" ], [ [ 430, 430 ], "mapped", [ 648 ] ], [ [ 431, 431 ], "mapped", [ 432 ] ], [ [ 432, 432 ], "valid" ], [ [ 433, 433 ], "mapped", [ 650 ] ], [ [ 434, 434 ], "mapped", [ 651 ] ], [ [ 435, 435 ], "mapped", [ 436 ] ], [ [ 436, 436 ], "valid" ], [ [ 437, 437 ], "mapped", [ 438 ] ], [ [ 438, 438 ], "valid" ], [ [ 439, 439 ], "mapped", [ 658 ] ], [ [ 440, 440 ], "mapped", [ 441 ] ], [ [ 441, 443 ], "valid" ], [ [ 444, 444 ], "mapped", [ 445 ] ], [ [ 445, 451 ], "valid" ], [ [ 452, 454 ], "mapped", [ 100, 382 ] ], [ [ 455, 457 ], "mapped", [ 108, 106 ] ], [ [ 458, 460 ], "mapped", [ 110, 106 ] ], [ [ 461, 461 ], "mapped", [ 462 ] ], [ [ 462, 462 ], "valid" ], [ [ 463, 463 ], "mapped", [ 464 ] ], [ [ 464, 464 ], "valid" ], [ [ 465, 465 ], "mapped", [ 466 ] ], [ [ 466, 466 ], "valid" ], [ [ 467, 467 ], "mapped", [ 468 ] ], [ [ 468, 468 ], "valid" ], [ [ 469, 469 ], "mapped", [ 470 ] ], [ [ 470, 470 ], "valid" ], [ [ 471, 471 ], "mapped", [ 472 ] ], [ [ 472, 472 ], "valid" ], [ [ 473, 473 ], "mapped", [ 474 ] ], [ [ 474, 474 ], "valid" ], [ [ 475, 475 ], "mapped", [ 476 ] ], [ [ 476, 477 ], "valid" ], [ [ 478, 478 ], "mapped", [ 479 ] ], [ [ 479, 479 ], "valid" ], [ [ 480, 480 ], "mapped", [ 481 ] ], [ [ 481, 481 ], "valid" ], [ [ 482, 482 ], "mapped", [ 483 ] ], [ [ 483, 483 ], "valid" ], [ [ 484, 484 ], "mapped", [ 485 ] ], [ [ 485, 485 ], "valid" ], [ [ 486, 486 ], "mapped", [ 487 ] ], [ [ 487, 487 ], "valid" ], [ [ 488, 488 ], "mapped", [ 489 ] ], [ [ 489, 489 ], "valid" ], [ [ 490, 490 ], "mapped", [ 491 ] ], [ [ 491, 491 ], "valid" ], [ [ 492, 492 ], "mapped", [ 493 ] ], [ [ 493, 493 ], "valid" ], [ [ 494, 494 ], "mapped", [ 495 ] ], [ [ 495, 496 ], "valid" ], [ [ 497, 499 ], "mapped", [ 100, 122 ] ], [ [ 500, 500 ], "mapped", [ 501 ] ], [ [ 501, 501 ], "valid" ], [ [ 502, 502 ], "mapped", [ 405 ] ], [ [ 503, 503 ], "mapped", [ 447 ] ], [ [ 504, 504 ], "mapped", [ 505 ] ], [ [ 505, 505 ], "valid" ], [ [ 506, 506 ], "mapped", [ 507 ] ], [ [ 507, 507 ], "valid" ], [ [ 508, 508 ], "mapped", [ 509 ] ], [ [ 509, 509 ], "valid" ], [ [ 510, 510 ], "mapped", [ 511 ] ], [ [ 511, 511 ], "valid" ], [ [ 512, 512 ], "mapped", [ 513 ] ], [ [ 513, 513 ], "valid" ], [ [ 514, 514 ], "mapped", [ 515 ] ], [ [ 515, 515 ], "valid" ], [ [ 516, 516 ], "mapped", [ 517 ] ], [ [ 517, 517 ], "valid" ], [ [ 518, 518 ], "mapped", [ 519 ] ], [ [ 519, 519 ], "valid" ], [ [ 520, 520 ], "mapped", [ 521 ] ], [ [ 521, 521 ], "valid" ], [ [ 522, 522 ], "mapped", [ 523 ] ], [ [ 523, 523 ], "valid" ], [ [ 524, 524 ], "mapped", [ 525 ] ], [ [ 525, 525 ], "valid" ], [ [ 526, 526 ], "mapped", [ 527 ] ], [ [ 527, 527 ], "valid" ], [ [ 528, 528 ], "mapped", [ 529 ] ], [ [ 529, 529 ], "valid" ], [ [ 530, 530 ], "mapped", [ 531 ] ], [ [ 531, 531 ], "valid" ], [ [ 532, 532 ], "mapped", [ 533 ] ], [ [ 533, 533 ], "valid" ], [ [ 534, 534 ], "mapped", [ 535 ] ], [ [ 535, 535 ], "valid" ], [ [ 536, 536 ], "mapped", [ 537 ] ], [ [ 537, 537 ], "valid" ], [ [ 538, 538 ], "mapped", [ 539 ] ], [ [ 539, 539 ], "valid" ], [ [ 540, 540 ], "mapped", [ 541 ] ], [ [ 541, 541 ], "valid" ], [ [ 542, 542 ], "mapped", [ 543 ] ], [ [ 543, 543 ], "valid" ], [ [ 544, 544 ], "mapped", [ 414 ] ], [ [ 545, 545 ], "valid" ], [ [ 546, 546 ], "mapped", [ 547 ] ], [ [ 547, 547 ], "valid" ], [ [ 548, 548 ], "mapped", [ 549 ] ], [ [ 549, 549 ], "valid" ], [ [ 550, 550 ], "mapped", [ 551 ] ], [ [ 551, 551 ], "valid" ], [ [ 552, 552 ], "mapped", [ 553 ] ], [ [ 553, 553 ], "valid" ], [ [ 554, 554 ], "mapped", [ 555 ] ], [ [ 555, 555 ], "valid" ], [ [ 556, 556 ], "mapped", [ 557 ] ], [ [ 557, 557 ], "valid" ], [ [ 558, 558 ], "mapped", [ 559 ] ], [ [ 559, 559 ], "valid" ], [ [ 560, 560 ], "mapped", [ 561 ] ], [ [ 561, 561 ], "valid" ], [ [ 562, 562 ], "mapped", [ 563 ] ], [ [ 563, 563 ], "valid" ], [ [ 564, 566 ], "valid" ], [ [ 567, 569 ], "valid" ], [ [ 570, 570 ], "mapped", [ 11365 ] ], [ [ 571, 571 ], "mapped", [ 572 ] ], [ [ 572, 572 ], "valid" ], [ [ 573, 573 ], "mapped", [ 410 ] ], [ [ 574, 574 ], "mapped", [ 11366 ] ], [ [ 575, 576 ], "valid" ], [ [ 577, 577 ], "mapped", [ 578 ] ], [ [ 578, 578 ], "valid" ], [ [ 579, 579 ], "mapped", [ 384 ] ], [ [ 580, 580 ], "mapped", [ 649 ] ], [ [ 581, 581 ], "mapped", [ 652 ] ], [ [ 582, 582 ], "mapped", [ 583 ] ], [ [ 583, 583 ], "valid" ], [ [ 584, 584 ], "mapped", [ 585 ] ], [ [ 585, 585 ], "valid" ], [ [ 586, 586 ], "mapped", [ 587 ] ], [ [ 587, 587 ], "valid" ], [ [ 588, 588 ], "mapped", [ 589 ] ], [ [ 589, 589 ], "valid" ], [ [ 590, 590 ], "mapped", [ 591 ] ], [ [ 591, 591 ], "valid" ], [ [ 592, 680 ], "valid" ], [ [ 681, 685 ], "valid" ], [ [ 686, 687 ], "valid" ], [ [ 688, 688 ], "mapped", [ 104 ] ], [ [ 689, 689 ], "mapped", [ 614 ] ], [ [ 690, 690 ], "mapped", [ 106 ] ], [ [ 691, 691 ], "mapped", [ 114 ] ], [ [ 692, 692 ], "mapped", [ 633 ] ], [ [ 693, 693 ], "mapped", [ 635 ] ], [ [ 694, 694 ], "mapped", [ 641 ] ], [ [ 695, 695 ], "mapped", [ 119 ] ], [ [ 696, 696 ], "mapped", [ 121 ] ], [ [ 697, 705 ], "valid" ], [ [ 706, 709 ], "valid", [], "NV8" ], [ [ 710, 721 ], "valid" ], [ [ 722, 727 ], "valid", [], "NV8" ], [ [ 728, 728 ], "disallowed_STD3_mapped", [ 32, 774 ] ], [ [ 729, 729 ], "disallowed_STD3_mapped", [ 32, 775 ] ], [ [ 730, 730 ], "disallowed_STD3_mapped", [ 32, 778 ] ], [ [ 731, 731 ], "disallowed_STD3_mapped", [ 32, 808 ] ], [ [ 732, 732 ], "disallowed_STD3_mapped", [ 32, 771 ] ], [ [ 733, 733 ], "disallowed_STD3_mapped", [ 32, 779 ] ], [ [ 734, 734 ], "valid", [], "NV8" ], [ [ 735, 735 ], "valid", [], "NV8" ], [ [ 736, 736 ], "mapped", [ 611 ] ], [ [ 737, 737 ], "mapped", [ 108 ] ], [ [ 738, 738 ], "mapped", [ 115 ] ], [ [ 739, 739 ], "mapped", [ 120 ] ], [ [ 740, 740 ], "mapped", [ 661 ] ], [ [ 741, 745 ], "valid", [], "NV8" ], [ [ 746, 747 ], "valid", [], "NV8" ], [ [ 748, 748 ], "valid" ], [ [ 749, 749 ], "valid", [], "NV8" ], [ [ 750, 750 ], "valid" ], [ [ 751, 767 ], "valid", [], "NV8" ], [ [ 768, 831 ], "valid" ], [ [ 832, 832 ], "mapped", [ 768 ] ], [ [ 833, 833 ], "mapped", [ 769 ] ], [ [ 834, 834 ], "valid" ], [ [ 835, 835 ], "mapped", [ 787 ] ], [ [ 836, 836 ], "mapped", [ 776, 769 ] ], [ [ 837, 837 ], "mapped", [ 953 ] ], [ [ 838, 846 ], "valid" ], [ [ 847, 847 ], "ignored" ], [ [ 848, 855 ], "valid" ], [ [ 856, 860 ], "valid" ], [ [ 861, 863 ], "valid" ], [ [ 864, 865 ], "valid" ], [ [ 866, 866 ], "valid" ], [ [ 867, 879 ], "valid" ], [ [ 880, 880 ], "mapped", [ 881 ] ], [ [ 881, 881 ], "valid" ], [ [ 882, 882 ], "mapped", [ 883 ] ], [ [ 883, 883 ], "valid" ], [ [ 884, 884 ], "mapped", [ 697 ] ], [ [ 885, 885 ], "valid" ], [ [ 886, 886 ], "mapped", [ 887 ] ], [ [ 887, 887 ], "valid" ], [ [ 888, 889 ], "disallowed" ], [ [ 890, 890 ], "disallowed_STD3_mapped", [ 32, 953 ] ], [ [ 891, 893 ], "valid" ], [ [ 894, 894 ], "disallowed_STD3_mapped", [ 59 ] ], [ [ 895, 895 ], "mapped", [ 1011 ] ], [ [ 896, 899 ], "disallowed" ], [ [ 900, 900 ], "disallowed_STD3_mapped", [ 32, 769 ] ], [ [ 901, 901 ], "disallowed_STD3_mapped", [ 32, 776, 769 ] ], [ [ 902, 902 ], "mapped", [ 940 ] ], [ [ 903, 903 ], "mapped", [ 183 ] ], [ [ 904, 904 ], "mapped", [ 941 ] ], [ [ 905, 905 ], "mapped", [ 942 ] ], [ [ 906, 906 ], "mapped", [ 943 ] ], [ [ 907, 907 ], "disallowed" ], [ [ 908, 908 ], "mapped", [ 972 ] ], [ [ 909, 909 ], "disallowed" ], [ [ 910, 910 ], "mapped", [ 973 ] ], [ [ 911, 911 ], "mapped", [ 974 ] ], [ [ 912, 912 ], "valid" ], [ [ 913, 913 ], "mapped", [ 945 ] ], [ [ 914, 914 ], "mapped", [ 946 ] ], [ [ 915, 915 ], "mapped", [ 947 ] ], [ [ 916, 916 ], "mapped", [ 948 ] ], [ [ 917, 917 ], "mapped", [ 949 ] ], [ [ 918, 918 ], "mapped", [ 950 ] ], [ [ 919, 919 ], "mapped", [ 951 ] ], [ [ 920, 920 ], "mapped", [ 952 ] ], [ [ 921, 921 ], "mapped", [ 953 ] ], [ [ 922, 922 ], "mapped", [ 954 ] ], [ [ 923, 923 ], "mapped", [ 955 ] ], [ [ 924, 924 ], "mapped", [ 956 ] ], [ [ 925, 925 ], "mapped", [ 957 ] ], [ [ 926, 926 ], "mapped", [ 958 ] ], [ [ 927, 927 ], "mapped", [ 959 ] ], [ [ 928, 928 ], "mapped", [ 960 ] ], [ [ 929, 929 ], "mapped", [ 961 ] ], [ [ 930, 930 ], "disallowed" ], [ [ 931, 931 ], "mapped", [ 963 ] ], [ [ 932, 932 ], "mapped", [ 964 ] ], [ [ 933, 933 ], "mapped", [ 965 ] ], [ [ 934, 934 ], "mapped", [ 966 ] ], [ [ 935, 935 ], "mapped", [ 967 ] ], [ [ 936, 936 ], "mapped", [ 968 ] ], [ [ 937, 937 ], "mapped", [ 969 ] ], [ [ 938, 938 ], "mapped", [ 970 ] ], [ [ 939, 939 ], "mapped", [ 971 ] ], [ [ 940, 961 ], "valid" ], [ [ 962, 962 ], "deviation", [ 963 ] ], [ [ 963, 974 ], "valid" ], [ [ 975, 975 ], "mapped", [ 983 ] ], [ [ 976, 976 ], "mapped", [ 946 ] ], [ [ 977, 977 ], "mapped", [ 952 ] ], [ [ 978, 978 ], "mapped", [ 965 ] ], [ [ 979, 979 ], "mapped", [ 973 ] ], [ [ 980, 980 ], "mapped", [ 971 ] ], [ [ 981, 981 ], "mapped", [ 966 ] ], [ [ 982, 982 ], "mapped", [ 960 ] ], [ [ 983, 983 ], "valid" ], [ [ 984, 984 ], "mapped", [ 985 ] ], [ [ 985, 985 ], "valid" ], [ [ 986, 986 ], "mapped", [ 987 ] ], [ [ 987, 987 ], "valid" ], [ [ 988, 988 ], "mapped", [ 989 ] ], [ [ 989, 989 ], "valid" ], [ [ 990, 990 ], "mapped", [ 991 ] ], [ [ 991, 991 ], "valid" ], [ [ 992, 992 ], "mapped", [ 993 ] ], [ [ 993, 993 ], "valid" ], [ [ 994, 994 ], "mapped", [ 995 ] ], [ [ 995, 995 ], "valid" ], [ [ 996, 996 ], "mapped", [ 997 ] ], [ [ 997, 997 ], "valid" ], [ [ 998, 998 ], "mapped", [ 999 ] ], [ [ 999, 999 ], "valid" ], [ [ 1e3, 1e3 ], "mapped", [ 1001 ] ], [ [ 1001, 1001 ], "valid" ], [ [ 1002, 1002 ], "mapped", [ 1003 ] ], [ [ 1003, 1003 ], "valid" ], [ [ 1004, 1004 ], "mapped", [ 1005 ] ], [ [ 1005, 1005 ], "valid" ], [ [ 1006, 1006 ], "mapped", [ 1007 ] ], [ [ 1007, 1007 ], "valid" ], [ [ 1008, 1008 ], "mapped", [ 954 ] ], [ [ 1009, 1009 ], "mapped", [ 961 ] ], [ [ 1010, 1010 ], "mapped", [ 963 ] ], [ [ 1011, 1011 ], "valid" ], [ [ 1012, 1012 ], "mapped", [ 952 ] ], [ [ 1013, 1013 ], "mapped", [ 949 ] ], [ [ 1014, 1014 ], "valid", [], "NV8" ], [ [ 1015, 1015 ], "mapped", [ 1016 ] ], [ [ 1016, 1016 ], "valid" ], [ [ 1017, 1017 ], "mapped", [ 963 ] ], [ [ 1018, 1018 ], "mapped", [ 1019 ] ], [ [ 1019, 1019 ], "valid" ], [ [ 1020, 1020 ], "valid" ], [ [ 1021, 1021 ], "mapped", [ 891 ] ], [ [ 1022, 1022 ], "mapped", [ 892 ] ], [ [ 1023, 1023 ], "mapped", [ 893 ] ], [ [ 1024, 1024 ], "mapped", [ 1104 ] ], [ [ 1025, 1025 ], "mapped", [ 1105 ] ], [ [ 1026, 1026 ], "mapped", [ 1106 ] ], [ [ 1027, 1027 ], "mapped", [ 1107 ] ], [ [ 1028, 1028 ], "mapped", [ 1108 ] ], [ [ 1029, 1029 ], "mapped", [ 1109 ] ], [ [ 1030, 1030 ], "mapped", [ 1110 ] ], [ [ 1031, 1031 ], "mapped", [ 1111 ] ], [ [ 1032, 1032 ], "mapped", [ 1112 ] ], [ [ 1033, 1033 ], "mapped", [ 1113 ] ], [ [ 1034, 1034 ], "mapped", [ 1114 ] ], [ [ 1035, 1035 ], "mapped", [ 1115 ] ], [ [ 1036, 1036 ], "mapped", [ 1116 ] ], [ [ 1037, 1037 ], "mapped", [ 1117 ] ], [ [ 1038, 1038 ], "mapped", [ 1118 ] ], [ [ 1039, 1039 ], "mapped", [ 1119 ] ], [ [ 1040, 1040 ], "mapped", [ 1072 ] ], [ [ 1041, 1041 ], "mapped", [ 1073 ] ], [ [ 1042, 1042 ], "mapped", [ 1074 ] ], [ [ 1043, 1043 ], "mapped", [ 1075 ] ], [ [ 1044, 1044 ], "mapped", [ 1076 ] ], [ [ 1045, 1045 ], "mapped", [ 1077 ] ], [ [ 1046, 1046 ], "mapped", [ 1078 ] ], [ [ 1047, 1047 ], "mapped", [ 1079 ] ], [ [ 1048, 1048 ], "mapped", [ 1080 ] ], [ [ 1049, 1049 ], "mapped", [ 1081 ] ], [ [ 1050, 1050 ], "mapped", [ 1082 ] ], [ [ 1051, 1051 ], "mapped", [ 1083 ] ], [ [ 1052, 1052 ], "mapped", [ 1084 ] ], [ [ 1053, 1053 ], "mapped", [ 1085 ] ], [ [ 1054, 1054 ], "mapped", [ 1086 ] ], [ [ 1055, 1055 ], "mapped", [ 1087 ] ], [ [ 1056, 1056 ], "mapped", [ 1088 ] ], [ [ 1057, 1057 ], "mapped", [ 1089 ] ], [ [ 1058, 1058 ], "mapped", [ 1090 ] ], [ [ 1059, 1059 ], "mapped", [ 1091 ] ], [ [ 1060, 1060 ], "mapped", [ 1092 ] ], [ [ 1061, 1061 ], "mapped", [ 1093 ] ], [ [ 1062, 1062 ], "mapped", [ 1094 ] ], [ [ 1063, 1063 ], "mapped", [ 1095 ] ], [ [ 1064, 1064 ], "mapped", [ 1096 ] ], [ [ 1065, 1065 ], "mapped", [ 1097 ] ], [ [ 1066, 1066 ], "mapped", [ 1098 ] ], [ [ 1067, 1067 ], "mapped", [ 1099 ] ], [ [ 1068, 1068 ], "mapped", [ 1100 ] ], [ [ 1069, 1069 ], "mapped", [ 1101 ] ], [ [ 1070, 1070 ], "mapped", [ 1102 ] ], [ [ 1071, 1071 ], "mapped", [ 1103 ] ], [ [ 1072, 1103 ], "valid" ], [ [ 1104, 1104 ], "valid" ], [ [ 1105, 1116 ], "valid" ], [ [ 1117, 1117 ], "valid" ], [ [ 1118, 1119 ], "valid" ], [ [ 1120, 1120 ], "mapped", [ 1121 ] ], [ [ 1121, 1121 ], "valid" ], [ [ 1122, 1122 ], "mapped", [ 1123 ] ], [ [ 1123, 1123 ], "valid" ], [ [ 1124, 1124 ], "mapped", [ 1125 ] ], [ [ 1125, 1125 ], "valid" ], [ [ 1126, 1126 ], "mapped", [ 1127 ] ], [ [ 1127, 1127 ], "valid" ], [ [ 1128, 1128 ], "mapped", [ 1129 ] ], [ [ 1129, 1129 ], "valid" ], [ [ 1130, 1130 ], "mapped", [ 1131 ] ], [ [ 1131, 1131 ], "valid" ], [ [ 1132, 1132 ], "mapped", [ 1133 ] ], [ [ 1133, 1133 ], "valid" ], [ [ 1134, 1134 ], "mapped", [ 1135 ] ], [ [ 1135, 1135 ], "valid" ], [ [ 1136, 1136 ], "mapped", [ 1137 ] ], [ [ 1137, 1137 ], "valid" ], [ [ 1138, 1138 ], "mapped", [ 1139 ] ], [ [ 1139, 1139 ], "valid" ], [ [ 1140, 1140 ], "mapped", [ 1141 ] ], [ [ 1141, 1141 ], "valid" ], [ [ 1142, 1142 ], "mapped", [ 1143 ] ], [ [ 1143, 1143 ], "valid" ], [ [ 1144, 1144 ], "mapped", [ 1145 ] ], [ [ 1145, 1145 ], "valid" ], [ [ 1146, 1146 ], "mapped", [ 1147 ] ], [ [ 1147, 1147 ], "valid" ], [ [ 1148, 1148 ], "mapped", [ 1149 ] ], [ [ 1149, 1149 ], "valid" ], [ [ 1150, 1150 ], "mapped", [ 1151 ] ], [ [ 1151, 1151 ], "valid" ], [ [ 1152, 1152 ], "mapped", [ 1153 ] ], [ [ 1153, 1153 ], "valid" ], [ [ 1154, 1154 ], "valid", [], "NV8" ], [ [ 1155, 1158 ], "valid" ], [ [ 1159, 1159 ], "valid" ], [ [ 1160, 1161 ], "valid", [], "NV8" ], [ [ 1162, 1162 ], "mapped", [ 1163 ] ], [ [ 1163, 1163 ], "valid" ], [ [ 1164, 1164 ], "mapped", [ 1165 ] ], [ [ 1165, 1165 ], "valid" ], [ [ 1166, 1166 ], "mapped", [ 1167 ] ], [ [ 1167, 1167 ], "valid" ], [ [ 1168, 1168 ], "mapped", [ 1169 ] ], [ [ 1169, 1169 ], "valid" ], [ [ 1170, 1170 ], "mapped", [ 1171 ] ], [ [ 1171, 1171 ], "valid" ], [ [ 1172, 1172 ], "mapped", [ 1173 ] ], [ [ 1173, 1173 ], "valid" ], [ [ 1174, 1174 ], "mapped", [ 1175 ] ], [ [ 1175, 1175 ], "valid" ], [ [ 1176, 1176 ], "mapped", [ 1177 ] ], [ [ 1177, 1177 ], "valid" ], [ [ 1178, 1178 ], "mapped", [ 1179 ] ], [ [ 1179, 1179 ], "valid" ], [ [ 1180, 1180 ], "mapped", [ 1181 ] ], [ [ 1181, 1181 ], "valid" ], [ [ 1182, 1182 ], "mapped", [ 1183 ] ], [ [ 1183, 1183 ], "valid" ], [ [ 1184, 1184 ], "mapped", [ 1185 ] ], [ [ 1185, 1185 ], "valid" ], [ [ 1186, 1186 ], "mapped", [ 1187 ] ], [ [ 1187, 1187 ], "valid" ], [ [ 1188, 1188 ], "mapped", [ 1189 ] ], [ [ 1189, 1189 ], "valid" ], [ [ 1190, 1190 ], "mapped", [ 1191 ] ], [ [ 1191, 1191 ], "valid" ], [ [ 1192, 1192 ], "mapped", [ 1193 ] ], [ [ 1193, 1193 ], "valid" ], [ [ 1194, 1194 ], "mapped", [ 1195 ] ], [ [ 1195, 1195 ], "valid" ], [ [ 1196, 1196 ], "mapped", [ 1197 ] ], [ [ 1197, 1197 ], "valid" ], [ [ 1198, 1198 ], "mapped", [ 1199 ] ], [ [ 1199, 1199 ], "valid" ], [ [ 1200, 1200 ], "mapped", [ 1201 ] ], [ [ 1201, 1201 ], "valid" ], [ [ 1202, 1202 ], "mapped", [ 1203 ] ], [ [ 1203, 1203 ], "valid" ], [ [ 1204, 1204 ], "mapped", [ 1205 ] ], [ [ 1205, 1205 ], "valid" ], [ [ 1206, 1206 ], "mapped", [ 1207 ] ], [ [ 1207, 1207 ], "valid" ], [ [ 1208, 1208 ], "mapped", [ 1209 ] ], [ [ 1209, 1209 ], "valid" ], [ [ 1210, 1210 ], "mapped", [ 1211 ] ], [ [ 1211, 1211 ], "valid" ], [ [ 1212, 1212 ], "mapped", [ 1213 ] ], [ [ 1213, 1213 ], "valid" ], [ [ 1214, 1214 ], "mapped", [ 1215 ] ], [ [ 1215, 1215 ], "valid" ], [ [ 1216, 1216 ], "disallowed" ], [ [ 1217, 1217 ], "mapped", [ 1218 ] ], [ [ 1218, 1218 ], "valid" ], [ [ 1219, 1219 ], "mapped", [ 1220 ] ], [ [ 1220, 1220 ], "valid" ], [ [ 1221, 1221 ], "mapped", [ 1222 ] ], [ [ 1222, 1222 ], "valid" ], [ [ 1223, 1223 ], "mapped", [ 1224 ] ], [ [ 1224, 1224 ], "valid" ], [ [ 1225, 1225 ], "mapped", [ 1226 ] ], [ [ 1226, 1226 ], "valid" ], [ [ 1227, 1227 ], "mapped", [ 1228 ] ], [ [ 1228, 1228 ], "valid" ], [ [ 1229, 1229 ], "mapped", [ 1230 ] ], [ [ 1230, 1230 ], "valid" ], [ [ 1231, 1231 ], "valid" ], [ [ 1232, 1232 ], "mapped", [ 1233 ] ], [ [ 1233, 1233 ], "valid" ], [ [ 1234, 1234 ], "mapped", [ 1235 ] ], [ [ 1235, 1235 ], "valid" ], [ [ 1236, 1236 ], "mapped", [ 1237 ] ], [ [ 1237, 1237 ], "valid" ], [ [ 1238, 1238 ], "mapped", [ 1239 ] ], [ [ 1239, 1239 ], "valid" ], [ [ 1240, 1240 ], "mapped", [ 1241 ] ], [ [ 1241, 1241 ], "valid" ], [ [ 1242, 1242 ], "mapped", [ 1243 ] ], [ [ 1243, 1243 ], "valid" ], [ [ 1244, 1244 ], "mapped", [ 1245 ] ], [ [ 1245, 1245 ], "valid" ], [ [ 1246, 1246 ], "mapped", [ 1247 ] ], [ [ 1247, 1247 ], "valid" ], [ [ 1248, 1248 ], "mapped", [ 1249 ] ], [ [ 1249, 1249 ], "valid" ], [ [ 1250, 1250 ], "mapped", [ 1251 ] ], [ [ 1251, 1251 ], "valid" ], [ [ 1252, 1252 ], "mapped", [ 1253 ] ], [ [ 1253, 1253 ], "valid" ], [ [ 1254, 1254 ], "mapped", [ 1255 ] ], [ [ 1255, 1255 ], "valid" ], [ [ 1256, 1256 ], "mapped", [ 1257 ] ], [ [ 1257, 1257 ], "valid" ], [ [ 1258, 1258 ], "mapped", [ 1259 ] ], [ [ 1259, 1259 ], "valid" ], [ [ 1260, 1260 ], "mapped", [ 1261 ] ], [ [ 1261, 1261 ], "valid" ], [ [ 1262, 1262 ], "mapped", [ 1263 ] ], [ [ 1263, 1263 ], "valid" ], [ [ 1264, 1264 ], "mapped", [ 1265 ] ], [ [ 1265, 1265 ], "valid" ], [ [ 1266, 1266 ], "mapped", [ 1267 ] ], [ [ 1267, 1267 ], "valid" ], [ [ 1268, 1268 ], "mapped", [ 1269 ] ], [ [ 1269, 1269 ], "valid" ], [ [ 1270, 1270 ], "mapped", [ 1271 ] ], [ [ 1271, 1271 ], "valid" ], [ [ 1272, 1272 ], "mapped", [ 1273 ] ], [ [ 1273, 1273 ], "valid" ], [ [ 1274, 1274 ], "mapped", [ 1275 ] ], [ [ 1275, 1275 ], "valid" ], [ [ 1276, 1276 ], "mapped", [ 1277 ] ], [ [ 1277, 1277 ], "valid" ], [ [ 1278, 1278 ], "mapped", [ 1279 ] ], [ [ 1279, 1279 ], "valid" ], [ [ 1280, 1280 ], "mapped", [ 1281 ] ], [ [ 1281, 1281 ], "valid" ], [ [ 1282, 1282 ], "mapped", [ 1283 ] ], [ [ 1283, 1283 ], "valid" ], [ [ 1284, 1284 ], "mapped", [ 1285 ] ], [ [ 1285, 1285 ], "valid" ], [ [ 1286, 1286 ], "mapped", [ 1287 ] ], [ [ 1287, 1287 ], "valid" ], [ [ 1288, 1288 ], "mapped", [ 1289 ] ], [ [ 1289, 1289 ], "valid" ], [ [ 1290, 1290 ], "mapped", [ 1291 ] ], [ [ 1291, 1291 ], "valid" ], [ [ 1292, 1292 ], "mapped", [ 1293 ] ], [ [ 1293, 1293 ], "valid" ], [ [ 1294, 1294 ], "mapped", [ 1295 ] ], [ [ 1295, 1295 ], "valid" ], [ [ 1296, 1296 ], "mapped", [ 1297 ] ], [ [ 1297, 1297 ], "valid" ], [ [ 1298, 1298 ], "mapped", [ 1299 ] ], [ [ 1299, 1299 ], "valid" ], [ [ 1300, 1300 ], "mapped", [ 1301 ] ], [ [ 1301, 1301 ], "valid" ], [ [ 1302, 1302 ], "mapped", [ 1303 ] ], [ [ 1303, 1303 ], "valid" ], [ [ 1304, 1304 ], "mapped", [ 1305 ] ], [ [ 1305, 1305 ], "valid" ], [ [ 1306, 1306 ], "mapped", [ 1307 ] ], [ [ 1307, 1307 ], "valid" ], [ [ 1308, 1308 ], "mapped", [ 1309 ] ], [ [ 1309, 1309 ], "valid" ], [ [ 1310, 1310 ], "mapped", [ 1311 ] ], [ [ 1311, 1311 ], "valid" ], [ [ 1312, 1312 ], "mapped", [ 1313 ] ], [ [ 1313, 1313 ], "valid" ], [ [ 1314, 1314 ], "mapped", [ 1315 ] ], [ [ 1315, 1315 ], "valid" ], [ [ 1316, 1316 ], "mapped", [ 1317 ] ], [ [ 1317, 1317 ], "valid" ], [ [ 1318, 1318 ], "mapped", [ 1319 ] ], [ [ 1319, 1319 ], "valid" ], [ [ 1320, 1320 ], "mapped", [ 1321 ] ], [ [ 1321, 1321 ], "valid" ], [ [ 1322, 1322 ], "mapped", [ 1323 ] ], [ [ 1323, 1323 ], "valid" ], [ [ 1324, 1324 ], "mapped", [ 1325 ] ], [ [ 1325, 1325 ], "valid" ], [ [ 1326, 1326 ], "mapped", [ 1327 ] ], [ [ 1327, 1327 ], "valid" ], [ [ 1328, 1328 ], "disallowed" ], [ [ 1329, 1329 ], "mapped", [ 1377 ] ], [ [ 1330, 1330 ], "mapped", [ 1378 ] ], [ [ 1331, 1331 ], "mapped", [ 1379 ] ], [ [ 1332, 1332 ], "mapped", [ 1380 ] ], [ [ 1333, 1333 ], "mapped", [ 1381 ] ], [ [ 1334, 1334 ], "mapped", [ 1382 ] ], [ [ 1335, 1335 ], "mapped", [ 1383 ] ], [ [ 1336, 1336 ], "mapped", [ 1384 ] ], [ [ 1337, 1337 ], "mapped", [ 1385 ] ], [ [ 1338, 1338 ], "mapped", [ 1386 ] ], [ [ 1339, 1339 ], "mapped", [ 1387 ] ], [ [ 1340, 1340 ], "mapped", [ 1388 ] ], [ [ 1341, 1341 ], "mapped", [ 1389 ] ], [ [ 1342, 1342 ], "mapped", [ 1390 ] ], [ [ 1343, 1343 ], "mapped", [ 1391 ] ], [ [ 1344, 1344 ], "mapped", [ 1392 ] ], [ [ 1345, 1345 ], "mapped", [ 1393 ] ], [ [ 1346, 1346 ], "mapped", [ 1394 ] ], [ [ 1347, 1347 ], "mapped", [ 1395 ] ], [ [ 1348, 1348 ], "mapped", [ 1396 ] ], [ [ 1349, 1349 ], "mapped", [ 1397 ] ], [ [ 1350, 1350 ], "mapped", [ 1398 ] ], [ [ 1351, 1351 ], "mapped", [ 1399 ] ], [ [ 1352, 1352 ], "mapped", [ 1400 ] ], [ [ 1353, 1353 ], "mapped", [ 1401 ] ], [ [ 1354, 1354 ], "mapped", [ 1402 ] ], [ [ 1355, 1355 ], "mapped", [ 1403 ] ], [ [ 1356, 1356 ], "mapped", [ 1404 ] ], [ [ 1357, 1357 ], "mapped", [ 1405 ] ], [ [ 1358, 1358 ], "mapped", [ 1406 ] ], [ [ 1359, 1359 ], "mapped", [ 1407 ] ], [ [ 1360, 1360 ], "mapped", [ 1408 ] ], [ [ 1361, 1361 ], "mapped", [ 1409 ] ], [ [ 1362, 1362 ], "mapped", [ 1410 ] ], [ [ 1363, 1363 ], "mapped", [ 1411 ] ], [ [ 1364, 1364 ], "mapped", [ 1412 ] ], [ [ 1365, 1365 ], "mapped", [ 1413 ] ], [ [ 1366, 1366 ], "mapped", [ 1414 ] ], [ [ 1367, 1368 ], "disallowed" ], [ [ 1369, 1369 ], "valid" ], [ [ 1370, 1375 ], "valid", [], "NV8" ], [ [ 1376, 1376 ], "disallowed" ], [ [ 1377, 1414 ], "valid" ], [ [ 1415, 1415 ], "mapped", [ 1381, 1410 ] ], [ [ 1416, 1416 ], "disallowed" ], [ [ 1417, 1417 ], "valid", [], "NV8" ], [ [ 1418, 1418 ], "valid", [], "NV8" ], [ [ 1419, 1420 ], "disallowed" ], [ [ 1421, 1422 ], "valid", [], "NV8" ], [ [ 1423, 1423 ], "valid", [], "NV8" ], [ [ 1424, 1424 ], "disallowed" ], [ [ 1425, 1441 ], "valid" ], [ [ 1442, 1442 ], "valid" ], [ [ 1443, 1455 ], "valid" ], [ [ 1456, 1465 ], "valid" ], [ [ 1466, 1466 ], "valid" ], [ [ 1467, 1469 ], "valid" ], [ [ 1470, 1470 ], "valid", [], "NV8" ], [ [ 1471, 1471 ], "valid" ], [ [ 1472, 1472 ], "valid", [], "NV8" ], [ [ 1473, 1474 ], "valid" ], [ [ 1475, 1475 ], "valid", [], "NV8" ], [ [ 1476, 1476 ], "valid" ], [ [ 1477, 1477 ], "valid" ], [ [ 1478, 1478 ], "valid", [], "NV8" ], [ [ 1479, 1479 ], "valid" ], [ [ 1480, 1487 ], "disallowed" ], [ [ 1488, 1514 ], "valid" ], [ [ 1515, 1519 ], "disallowed" ], [ [ 1520, 1524 ], "valid" ], [ [ 1525, 1535 ], "disallowed" ], [ [ 1536, 1539 ], "disallowed" ], [ [ 1540, 1540 ], "disallowed" ], [ [ 1541, 1541 ], "disallowed" ], [ [ 1542, 1546 ], "valid", [], "NV8" ], [ [ 1547, 1547 ], "valid", [], "NV8" ], [ [ 1548, 1548 ], "valid", [], "NV8" ], [ [ 1549, 1551 ], "valid", [], "NV8" ], [ [ 1552, 1557 ], "valid" ], [ [ 1558, 1562 ], "valid" ], [ [ 1563, 1563 ], "valid", [], "NV8" ], [ [ 1564, 1564 ], "disallowed" ], [ [ 1565, 1565 ], "disallowed" ], [ [ 1566, 1566 ], "valid", [], "NV8" ], [ [ 1567, 1567 ], "valid", [], "NV8" ], [ [ 1568, 1568 ], "valid" ], [ [ 1569, 1594 ], "valid" ], [ [ 1595, 1599 ], "valid" ], [ [ 1600, 1600 ], "valid", [], "NV8" ], [ [ 1601, 1618 ], "valid" ], [ [ 1619, 1621 ], "valid" ], [ [ 1622, 1624 ], "valid" ], [ [ 1625, 1630 ], "valid" ], [ [ 1631, 1631 ], "valid" ], [ [ 1632, 1641 ], "valid" ], [ [ 1642, 1645 ], "valid", [], "NV8" ], [ [ 1646, 1647 ], "valid" ], [ [ 1648, 1652 ], "valid" ], [ [ 1653, 1653 ], "mapped", [ 1575, 1652 ] ], [ [ 1654, 1654 ], "mapped", [ 1608, 1652 ] ], [ [ 1655, 1655 ], "mapped", [ 1735, 1652 ] ], [ [ 1656, 1656 ], "mapped", [ 1610, 1652 ] ], [ [ 1657, 1719 ], "valid" ], [ [ 1720, 1721 ], "valid" ], [ [ 1722, 1726 ], "valid" ], [ [ 1727, 1727 ], "valid" ], [ [ 1728, 1742 ], "valid" ], [ [ 1743, 1743 ], "valid" ], [ [ 1744, 1747 ], "valid" ], [ [ 1748, 1748 ], "valid", [], "NV8" ], [ [ 1749, 1756 ], "valid" ], [ [ 1757, 1757 ], "disallowed" ], [ [ 1758, 1758 ], "valid", [], "NV8" ], [ [ 1759, 1768 ], "valid" ], [ [ 1769, 1769 ], "valid", [], "NV8" ], [ [ 1770, 1773 ], "valid" ], [ [ 1774, 1775 ], "valid" ], [ [ 1776, 1785 ], "valid" ], [ [ 1786, 1790 ], "valid" ], [ [ 1791, 1791 ], "valid" ], [ [ 1792, 1805 ], "valid", [], "NV8" ], [ [ 1806, 1806 ], "disallowed" ], [ [ 1807, 1807 ], "disallowed" ], [ [ 1808, 1836 ], "valid" ], [ [ 1837, 1839 ], "valid" ], [ [ 1840, 1866 ], "valid" ], [ [ 1867, 1868 ], "disallowed" ], [ [ 1869, 1871 ], "valid" ], [ [ 1872, 1901 ], "valid" ], [ [ 1902, 1919 ], "valid" ], [ [ 1920, 1968 ], "valid" ], [ [ 1969, 1969 ], "valid" ], [ [ 1970, 1983 ], "disallowed" ], [ [ 1984, 2037 ], "valid" ], [ [ 2038, 2042 ], "valid", [], "NV8" ], [ [ 2043, 2047 ], "disallowed" ], [ [ 2048, 2093 ], "valid" ], [ [ 2094, 2095 ], "disallowed" ], [ [ 2096, 2110 ], "valid", [], "NV8" ], [ [ 2111, 2111 ], "disallowed" ], [ [ 2112, 2139 ], "valid" ], [ [ 2140, 2141 ], "disallowed" ], [ [ 2142, 2142 ], "valid", [], "NV8" ], [ [ 2143, 2207 ], "disallowed" ], [ [ 2208, 2208 ], "valid" ], [ [ 2209, 2209 ], "valid" ], [ [ 2210, 2220 ], "valid" ], [ [ 2221, 2226 ], "valid" ], [ [ 2227, 2228 ], "valid" ], [ [ 2229, 2274 ], "disallowed" ], [ [ 2275, 2275 ], "valid" ], [ [ 2276, 2302 ], "valid" ], [ [ 2303, 2303 ], "valid" ], [ [ 2304, 2304 ], "valid" ], [ [ 2305, 2307 ], "valid" ], [ [ 2308, 2308 ], "valid" ], [ [ 2309, 2361 ], "valid" ], [ [ 2362, 2363 ], "valid" ], [ [ 2364, 2381 ], "valid" ], [ [ 2382, 2382 ], "valid" ], [ [ 2383, 2383 ], "valid" ], [ [ 2384, 2388 ], "valid" ], [ [ 2389, 2389 ], "valid" ], [ [ 2390, 2391 ], "valid" ], [ [ 2392, 2392 ], "mapped", [ 2325, 2364 ] ], [ [ 2393, 2393 ], "mapped", [ 2326, 2364 ] ], [ [ 2394, 2394 ], "mapped", [ 2327, 2364 ] ], [ [ 2395, 2395 ], "mapped", [ 2332, 2364 ] ], [ [ 2396, 2396 ], "mapped", [ 2337, 2364 ] ], [ [ 2397, 2397 ], "mapped", [ 2338, 2364 ] ], [ [ 2398, 2398 ], "mapped", [ 2347, 2364 ] ], [ [ 2399, 2399 ], "mapped", [ 2351, 2364 ] ], [ [ 2400, 2403 ], "valid" ], [ [ 2404, 2405 ], "valid", [], "NV8" ], [ [ 2406, 2415 ], "valid" ], [ [ 2416, 2416 ], "valid", [], "NV8" ], [ [ 2417, 2418 ], "valid" ], [ [ 2419, 2423 ], "valid" ], [ [ 2424, 2424 ], "valid" ], [ [ 2425, 2426 ], "valid" ], [ [ 2427, 2428 ], "valid" ], [ [ 2429, 2429 ], "valid" ], [ [ 2430, 2431 ], "valid" ], [ [ 2432, 2432 ], "valid" ], [ [ 2433, 2435 ], "valid" ], [ [ 2436, 2436 ], "disallowed" ], [ [ 2437, 2444 ], "valid" ], [ [ 2445, 2446 ], "disallowed" ], [ [ 2447, 2448 ], "valid" ], [ [ 2449, 2450 ], "disallowed" ], [ [ 2451, 2472 ], "valid" ], [ [ 2473, 2473 ], "disallowed" ], [ [ 2474, 2480 ], "valid" ], [ [ 2481, 2481 ], "disallowed" ], [ [ 2482, 2482 ], "valid" ], [ [ 2483, 2485 ], "disallowed" ], [ [ 2486, 2489 ], "valid" ], [ [ 2490, 2491 ], "disallowed" ], [ [ 2492, 2492 ], "valid" ], [ [ 2493, 2493 ], "valid" ], [ [ 2494, 2500 ], "valid" ], [ [ 2501, 2502 ], "disallowed" ], [ [ 2503, 2504 ], "valid" ], [ [ 2505, 2506 ], "disallowed" ], [ [ 2507, 2509 ], "valid" ], [ [ 2510, 2510 ], "valid" ], [ [ 2511, 2518 ], "disallowed" ], [ [ 2519, 2519 ], "valid" ], [ [ 2520, 2523 ], "disallowed" ], [ [ 2524, 2524 ], "mapped", [ 2465, 2492 ] ], [ [ 2525, 2525 ], "mapped", [ 2466, 2492 ] ], [ [ 2526, 2526 ], "disallowed" ], [ [ 2527, 2527 ], "mapped", [ 2479, 2492 ] ], [ [ 2528, 2531 ], "valid" ], [ [ 2532, 2533 ], "disallowed" ], [ [ 2534, 2545 ], "valid" ], [ [ 2546, 2554 ], "valid", [], "NV8" ], [ [ 2555, 2555 ], "valid", [], "NV8" ], [ [ 2556, 2560 ], "disallowed" ], [ [ 2561, 2561 ], "valid" ], [ [ 2562, 2562 ], "valid" ], [ [ 2563, 2563 ], "valid" ], [ [ 2564, 2564 ], "disallowed" ], [ [ 2565, 2570 ], "valid" ], [ [ 2571, 2574 ], "disallowed" ], [ [ 2575, 2576 ], "valid" ], [ [ 2577, 2578 ], "disallowed" ], [ [ 2579, 2600 ], "valid" ], [ [ 2601, 2601 ], "disallowed" ], [ [ 2602, 2608 ], "valid" ], [ [ 2609, 2609 ], "disallowed" ], [ [ 2610, 2610 ], "valid" ], [ [ 2611, 2611 ], "mapped", [ 2610, 2620 ] ], [ [ 2612, 2612 ], "disallowed" ], [ [ 2613, 2613 ], "valid" ], [ [ 2614, 2614 ], "mapped", [ 2616, 2620 ] ], [ [ 2615, 2615 ], "disallowed" ], [ [ 2616, 2617 ], "valid" ], [ [ 2618, 2619 ], "disallowed" ], [ [ 2620, 2620 ], "valid" ], [ [ 2621, 2621 ], "disallowed" ], [ [ 2622, 2626 ], "valid" ], [ [ 2627, 2630 ], "disallowed" ], [ [ 2631, 2632 ], "valid" ], [ [ 2633, 2634 ], "disallowed" ], [ [ 2635, 2637 ], "valid" ], [ [ 2638, 2640 ], "disallowed" ], [ [ 2641, 2641 ], "valid" ], [ [ 2642, 2648 ], "disallowed" ], [ [ 2649, 2649 ], "mapped", [ 2582, 2620 ] ], [ [ 2650, 2650 ], "mapped", [ 2583, 2620 ] ], [ [ 2651, 2651 ], "mapped", [ 2588, 2620 ] ], [ [ 2652, 2652 ], "valid" ], [ [ 2653, 2653 ], "disallowed" ], [ [ 2654, 2654 ], "mapped", [ 2603, 2620 ] ], [ [ 2655, 2661 ], "disallowed" ], [ [ 2662, 2676 ], "valid" ], [ [ 2677, 2677 ], "valid" ], [ [ 2678, 2688 ], "disallowed" ], [ [ 2689, 2691 ], "valid" ], [ [ 2692, 2692 ], "disallowed" ], [ [ 2693, 2699 ], "valid" ], [ [ 2700, 2700 ], "valid" ], [ [ 2701, 2701 ], "valid" ], [ [ 2702, 2702 ], "disallowed" ], [ [ 2703, 2705 ], "valid" ], [ [ 2706, 2706 ], "disallowed" ], [ [ 2707, 2728 ], "valid" ], [ [ 2729, 2729 ], "disallowed" ], [ [ 2730, 2736 ], "valid" ], [ [ 2737, 2737 ], "disallowed" ], [ [ 2738, 2739 ], "valid" ], [ [ 2740, 2740 ], "disallowed" ], [ [ 2741, 2745 ], "valid" ], [ [ 2746, 2747 ], "disallowed" ], [ [ 2748, 2757 ], "valid" ], [ [ 2758, 2758 ], "disallowed" ], [ [ 2759, 2761 ], "valid" ], [ [ 2762, 2762 ], "disallowed" ], [ [ 2763, 2765 ], "valid" ], [ [ 2766, 2767 ], "disallowed" ], [ [ 2768, 2768 ], "valid" ], [ [ 2769, 2783 ], "disallowed" ], [ [ 2784, 2784 ], "valid" ], [ [ 2785, 2787 ], "valid" ], [ [ 2788, 2789 ], "disallowed" ], [ [ 2790, 2799 ], "valid" ], [ [ 2800, 2800 ], "valid", [], "NV8" ], [ [ 2801, 2801 ], "valid", [], "NV8" ], [ [ 2802, 2808 ], "disallowed" ], [ [ 2809, 2809 ], "valid" ], [ [ 2810, 2816 ], "disallowed" ], [ [ 2817, 2819 ], "valid" ], [ [ 2820, 2820 ], "disallowed" ], [ [ 2821, 2828 ], "valid" ], [ [ 2829, 2830 ], "disallowed" ], [ [ 2831, 2832 ], "valid" ], [ [ 2833, 2834 ], "disallowed" ], [ [ 2835, 2856 ], "valid" ], [ [ 2857, 2857 ], "disallowed" ], [ [ 2858, 2864 ], "valid" ], [ [ 2865, 2865 ], "disallowed" ], [ [ 2866, 2867 ], "valid" ], [ [ 2868, 2868 ], "disallowed" ], [ [ 2869, 2869 ], "valid" ], [ [ 2870, 2873 ], "valid" ], [ [ 2874, 2875 ], "disallowed" ], [ [ 2876, 2883 ], "valid" ], [ [ 2884, 2884 ], "valid" ], [ [ 2885, 2886 ], "disallowed" ], [ [ 2887, 2888 ], "valid" ], [ [ 2889, 2890 ], "disallowed" ], [ [ 2891, 2893 ], "valid" ], [ [ 2894, 2901 ], "disallowed" ], [ [ 2902, 2903 ], "valid" ], [ [ 2904, 2907 ], "disallowed" ], [ [ 2908, 2908 ], "mapped", [ 2849, 2876 ] ], [ [ 2909, 2909 ], "mapped", [ 2850, 2876 ] ], [ [ 2910, 2910 ], "disallowed" ], [ [ 2911, 2913 ], "valid" ], [ [ 2914, 2915 ], "valid" ], [ [ 2916, 2917 ], "disallowed" ], [ [ 2918, 2927 ], "valid" ], [ [ 2928, 2928 ], "valid", [], "NV8" ], [ [ 2929, 2929 ], "valid" ], [ [ 2930, 2935 ], "valid", [], "NV8" ], [ [ 2936, 2945 ], "disallowed" ], [ [ 2946, 2947 ], "valid" ], [ [ 2948, 2948 ], "disallowed" ], [ [ 2949, 2954 ], "valid" ], [ [ 2955, 2957 ], "disallowed" ], [ [ 2958, 2960 ], "valid" ], [ [ 2961, 2961 ], "disallowed" ], [ [ 2962, 2965 ], "valid" ], [ [ 2966, 2968 ], "disallowed" ], [ [ 2969, 2970 ], "valid" ], [ [ 2971, 2971 ], "disallowed" ], [ [ 2972, 2972 ], "valid" ], [ [ 2973, 2973 ], "disallowed" ], [ [ 2974, 2975 ], "valid" ], [ [ 2976, 2978 ], "disallowed" ], [ [ 2979, 2980 ], "valid" ], [ [ 2981, 2983 ], "disallowed" ], [ [ 2984, 2986 ], "valid" ], [ [ 2987, 2989 ], "disallowed" ], [ [ 2990, 2997 ], "valid" ], [ [ 2998, 2998 ], "valid" ], [ [ 2999, 3001 ], "valid" ], [ [ 3002, 3005 ], "disallowed" ], [ [ 3006, 3010 ], "valid" ], [ [ 3011, 3013 ], "disallowed" ], [ [ 3014, 3016 ], "valid" ], [ [ 3017, 3017 ], "disallowed" ], [ [ 3018, 3021 ], "valid" ], [ [ 3022, 3023 ], "disallowed" ], [ [ 3024, 3024 ], "valid" ], [ [ 3025, 3030 ], "disallowed" ], [ [ 3031, 3031 ], "valid" ], [ [ 3032, 3045 ], "disallowed" ], [ [ 3046, 3046 ], "valid" ], [ [ 3047, 3055 ], "valid" ], [ [ 3056, 3058 ], "valid", [], "NV8" ], [ [ 3059, 3066 ], "valid", [], "NV8" ], [ [ 3067, 3071 ], "disallowed" ], [ [ 3072, 3072 ], "valid" ], [ [ 3073, 3075 ], "valid" ], [ [ 3076, 3076 ], "disallowed" ], [ [ 3077, 3084 ], "valid" ], [ [ 3085, 3085 ], "disallowed" ], [ [ 3086, 3088 ], "valid" ], [ [ 3089, 3089 ], "disallowed" ], [ [ 3090, 3112 ], "valid" ], [ [ 3113, 3113 ], "disallowed" ], [ [ 3114, 3123 ], "valid" ], [ [ 3124, 3124 ], "valid" ], [ [ 3125, 3129 ], "valid" ], [ [ 3130, 3132 ], "disallowed" ], [ [ 3133, 3133 ], "valid" ], [ [ 3134, 3140 ], "valid" ], [ [ 3141, 3141 ], "disallowed" ], [ [ 3142, 3144 ], "valid" ], [ [ 3145, 3145 ], "disallowed" ], [ [ 3146, 3149 ], "valid" ], [ [ 3150, 3156 ], "disallowed" ], [ [ 3157, 3158 ], "valid" ], [ [ 3159, 3159 ], "disallowed" ], [ [ 3160, 3161 ], "valid" ], [ [ 3162, 3162 ], "valid" ], [ [ 3163, 3167 ], "disallowed" ], [ [ 3168, 3169 ], "valid" ], [ [ 3170, 3171 ], "valid" ], [ [ 3172, 3173 ], "disallowed" ], [ [ 3174, 3183 ], "valid" ], [ [ 3184, 3191 ], "disallowed" ], [ [ 3192, 3199 ], "valid", [], "NV8" ], [ [ 3200, 3200 ], "disallowed" ], [ [ 3201, 3201 ], "valid" ], [ [ 3202, 3203 ], "valid" ], [ [ 3204, 3204 ], "disallowed" ], [ [ 3205, 3212 ], "valid" ], [ [ 3213, 3213 ], "disallowed" ], [ [ 3214, 3216 ], "valid" ], [ [ 3217, 3217 ], "disallowed" ], [ [ 3218, 3240 ], "valid" ], [ [ 3241, 3241 ], "disallowed" ], [ [ 3242, 3251 ], "valid" ], [ [ 3252, 3252 ], "disallowed" ], [ [ 3253, 3257 ], "valid" ], [ [ 3258, 3259 ], "disallowed" ], [ [ 3260, 3261 ], "valid" ], [ [ 3262, 3268 ], "valid" ], [ [ 3269, 3269 ], "disallowed" ], [ [ 3270, 3272 ], "valid" ], [ [ 3273, 3273 ], "disallowed" ], [ [ 3274, 3277 ], "valid" ], [ [ 3278, 3284 ], "disallowed" ], [ [ 3285, 3286 ], "valid" ], [ [ 3287, 3293 ], "disallowed" ], [ [ 3294, 3294 ], "valid" ], [ [ 3295, 3295 ], "disallowed" ], [ [ 3296, 3297 ], "valid" ], [ [ 3298, 3299 ], "valid" ], [ [ 3300, 3301 ], "disallowed" ], [ [ 3302, 3311 ], "valid" ], [ [ 3312, 3312 ], "disallowed" ], [ [ 3313, 3314 ], "valid" ], [ [ 3315, 3328 ], "disallowed" ], [ [ 3329, 3329 ], "valid" ], [ [ 3330, 3331 ], "valid" ], [ [ 3332, 3332 ], "disallowed" ], [ [ 3333, 3340 ], "valid" ], [ [ 3341, 3341 ], "disallowed" ], [ [ 3342, 3344 ], "valid" ], [ [ 3345, 3345 ], "disallowed" ], [ [ 3346, 3368 ], "valid" ], [ [ 3369, 3369 ], "valid" ], [ [ 3370, 3385 ], "valid" ], [ [ 3386, 3386 ], "valid" ], [ [ 3387, 3388 ], "disallowed" ], [ [ 3389, 3389 ], "valid" ], [ [ 3390, 3395 ], "valid" ], [ [ 3396, 3396 ], "valid" ], [ [ 3397, 3397 ], "disallowed" ], [ [ 3398, 3400 ], "valid" ], [ [ 3401, 3401 ], "disallowed" ], [ [ 3402, 3405 ], "valid" ], [ [ 3406, 3406 ], "valid" ], [ [ 3407, 3414 ], "disallowed" ], [ [ 3415, 3415 ], "valid" ], [ [ 3416, 3422 ], "disallowed" ], [ [ 3423, 3423 ], "valid" ], [ [ 3424, 3425 ], "valid" ], [ [ 3426, 3427 ], "valid" ], [ [ 3428, 3429 ], "disallowed" ], [ [ 3430, 3439 ], "valid" ], [ [ 3440, 3445 ], "valid", [], "NV8" ], [ [ 3446, 3448 ], "disallowed" ], [ [ 3449, 3449 ], "valid", [], "NV8" ], [ [ 3450, 3455 ], "valid" ], [ [ 3456, 3457 ], "disallowed" ], [ [ 3458, 3459 ], "valid" ], [ [ 3460, 3460 ], "disallowed" ], [ [ 3461, 3478 ], "valid" ], [ [ 3479, 3481 ], "disallowed" ], [ [ 3482, 3505 ], "valid" ], [ [ 3506, 3506 ], "disallowed" ], [ [ 3507, 3515 ], "valid" ], [ [ 3516, 3516 ], "disallowed" ], [ [ 3517, 3517 ], "valid" ], [ [ 3518, 3519 ], "disallowed" ], [ [ 3520, 3526 ], "valid" ], [ [ 3527, 3529 ], "disallowed" ], [ [ 3530, 3530 ], "valid" ], [ [ 3531, 3534 ], "disallowed" ], [ [ 3535, 3540 ], "valid" ], [ [ 3541, 3541 ], "disallowed" ], [ [ 3542, 3542 ], "valid" ], [ [ 3543, 3543 ], "disallowed" ], [ [ 3544, 3551 ], "valid" ], [ [ 3552, 3557 ], "disallowed" ], [ [ 3558, 3567 ], "valid" ], [ [ 3568, 3569 ], "disallowed" ], [ [ 3570, 3571 ], "valid" ], [ [ 3572, 3572 ], "valid", [], "NV8" ], [ [ 3573, 3584 ], "disallowed" ], [ [ 3585, 3634 ], "valid" ], [ [ 3635, 3635 ], "mapped", [ 3661, 3634 ] ], [ [ 3636, 3642 ], "valid" ], [ [ 3643, 3646 ], "disallowed" ], [ [ 3647, 3647 ], "valid", [], "NV8" ], [ [ 3648, 3662 ], "valid" ], [ [ 3663, 3663 ], "valid", [], "NV8" ], [ [ 3664, 3673 ], "valid" ], [ [ 3674, 3675 ], "valid", [], "NV8" ], [ [ 3676, 3712 ], "disallowed" ], [ [ 3713, 3714 ], "valid" ], [ [ 3715, 3715 ], "disallowed" ], [ [ 3716, 3716 ], "valid" ], [ [ 3717, 3718 ], "disallowed" ], [ [ 3719, 3720 ], "valid" ], [ [ 3721, 3721 ], "disallowed" ], [ [ 3722, 3722 ], "valid" ], [ [ 3723, 3724 ], "disallowed" ], [ [ 3725, 3725 ], "valid" ], [ [ 3726, 3731 ], "disallowed" ], [ [ 3732, 3735 ], "valid" ], [ [ 3736, 3736 ], "disallowed" ], [ [ 3737, 3743 ], "valid" ], [ [ 3744, 3744 ], "disallowed" ], [ [ 3745, 3747 ], "valid" ], [ [ 3748, 3748 ], "disallowed" ], [ [ 3749, 3749 ], "valid" ], [ [ 3750, 3750 ], "disallowed" ], [ [ 3751, 3751 ], "valid" ], [ [ 3752, 3753 ], "disallowed" ], [ [ 3754, 3755 ], "valid" ], [ [ 3756, 3756 ], "disallowed" ], [ [ 3757, 3762 ], "valid" ], [ [ 3763, 3763 ], "mapped", [ 3789, 3762 ] ], [ [ 3764, 3769 ], "valid" ], [ [ 3770, 3770 ], "disallowed" ], [ [ 3771, 3773 ], "valid" ], [ [ 3774, 3775 ], "disallowed" ], [ [ 3776, 3780 ], "valid" ], [ [ 3781, 3781 ], "disallowed" ], [ [ 3782, 3782 ], "valid" ], [ [ 3783, 3783 ], "disallowed" ], [ [ 3784, 3789 ], "valid" ], [ [ 3790, 3791 ], "disallowed" ], [ [ 3792, 3801 ], "valid" ], [ [ 3802, 3803 ], "disallowed" ], [ [ 3804, 3804 ], "mapped", [ 3755, 3737 ] ], [ [ 3805, 3805 ], "mapped", [ 3755, 3745 ] ], [ [ 3806, 3807 ], "valid" ], [ [ 3808, 3839 ], "disallowed" ], [ [ 3840, 3840 ], "valid" ], [ [ 3841, 3850 ], "valid", [], "NV8" ], [ [ 3851, 3851 ], "valid" ], [ [ 3852, 3852 ], "mapped", [ 3851 ] ], [ [ 3853, 3863 ], "valid", [], "NV8" ], [ [ 3864, 3865 ], "valid" ], [ [ 3866, 3871 ], "valid", [], "NV8" ], [ [ 3872, 3881 ], "valid" ], [ [ 3882, 3892 ], "valid", [], "NV8" ], [ [ 3893, 3893 ], "valid" ], [ [ 3894, 3894 ], "valid", [], "NV8" ], [ [ 3895, 3895 ], "valid" ], [ [ 3896, 3896 ], "valid", [], "NV8" ], [ [ 3897, 3897 ], "valid" ], [ [ 3898, 3901 ], "valid", [], "NV8" ], [ [ 3902, 3906 ], "valid" ], [ [ 3907, 3907 ], "mapped", [ 3906, 4023 ] ], [ [ 3908, 3911 ], "valid" ], [ [ 3912, 3912 ], "disallowed" ], [ [ 3913, 3916 ], "valid" ], [ [ 3917, 3917 ], "mapped", [ 3916, 4023 ] ], [ [ 3918, 3921 ], "valid" ], [ [ 3922, 3922 ], "mapped", [ 3921, 4023 ] ], [ [ 3923, 3926 ], "valid" ], [ [ 3927, 3927 ], "mapped", [ 3926, 4023 ] ], [ [ 3928, 3931 ], "valid" ], [ [ 3932, 3932 ], "mapped", [ 3931, 4023 ] ], [ [ 3933, 3944 ], "valid" ], [ [ 3945, 3945 ], "mapped", [ 3904, 4021 ] ], [ [ 3946, 3946 ], "valid" ], [ [ 3947, 3948 ], "valid" ], [ [ 3949, 3952 ], "disallowed" ], [ [ 3953, 3954 ], "valid" ], [ [ 3955, 3955 ], "mapped", [ 3953, 3954 ] ], [ [ 3956, 3956 ], "valid" ], [ [ 3957, 3957 ], "mapped", [ 3953, 3956 ] ], [ [ 3958, 3958 ], "mapped", [ 4018, 3968 ] ], [ [ 3959, 3959 ], "mapped", [ 4018, 3953, 3968 ] ], [ [ 3960, 3960 ], "mapped", [ 4019, 3968 ] ], [ [ 3961, 3961 ], "mapped", [ 4019, 3953, 3968 ] ], [ [ 3962, 3968 ], "valid" ], [ [ 3969, 3969 ], "mapped", [ 3953, 3968 ] ], [ [ 3970, 3972 ], "valid" ], [ [ 3973, 3973 ], "valid", [], "NV8" ], [ [ 3974, 3979 ], "valid" ], [ [ 3980, 3983 ], "valid" ], [ [ 3984, 3986 ], "valid" ], [ [ 3987, 3987 ], "mapped", [ 3986, 4023 ] ], [ [ 3988, 3989 ], "valid" ], [ [ 3990, 3990 ], "valid" ], [ [ 3991, 3991 ], "valid" ], [ [ 3992, 3992 ], "disallowed" ], [ [ 3993, 3996 ], "valid" ], [ [ 3997, 3997 ], "mapped", [ 3996, 4023 ] ], [ [ 3998, 4001 ], "valid" ], [ [ 4002, 4002 ], "mapped", [ 4001, 4023 ] ], [ [ 4003, 4006 ], "valid" ], [ [ 4007, 4007 ], "mapped", [ 4006, 4023 ] ], [ [ 4008, 4011 ], "valid" ], [ [ 4012, 4012 ], "mapped", [ 4011, 4023 ] ], [ [ 4013, 4013 ], "valid" ], [ [ 4014, 4016 ], "valid" ], [ [ 4017, 4023 ], "valid" ], [ [ 4024, 4024 ], "valid" ], [ [ 4025, 4025 ], "mapped", [ 3984, 4021 ] ], [ [ 4026, 4028 ], "valid" ], [ [ 4029, 4029 ], "disallowed" ], [ [ 4030, 4037 ], "valid", [], "NV8" ], [ [ 4038, 4038 ], "valid" ], [ [ 4039, 4044 ], "valid", [], "NV8" ], [ [ 4045, 4045 ], "disallowed" ], [ [ 4046, 4046 ], "valid", [], "NV8" ], [ [ 4047, 4047 ], "valid", [], "NV8" ], [ [ 4048, 4049 ], "valid", [], "NV8" ], [ [ 4050, 4052 ], "valid", [], "NV8" ], [ [ 4053, 4056 ], "valid", [], "NV8" ], [ [ 4057, 4058 ], "valid", [], "NV8" ], [ [ 4059, 4095 ], "disallowed" ], [ [ 4096, 4129 ], "valid" ], [ [ 4130, 4130 ], "valid" ], [ [ 4131, 4135 ], "valid" ], [ [ 4136, 4136 ], "valid" ], [ [ 4137, 4138 ], "valid" ], [ [ 4139, 4139 ], "valid" ], [ [ 4140, 4146 ], "valid" ], [ [ 4147, 4149 ], "valid" ], [ [ 4150, 4153 ], "valid" ], [ [ 4154, 4159 ], "valid" ], [ [ 4160, 4169 ], "valid" ], [ [ 4170, 4175 ], "valid", [], "NV8" ], [ [ 4176, 4185 ], "valid" ], [ [ 4186, 4249 ], "valid" ], [ [ 4250, 4253 ], "valid" ], [ [ 4254, 4255 ], "valid", [], "NV8" ], [ [ 4256, 4293 ], "disallowed" ], [ [ 4294, 4294 ], "disallowed" ], [ [ 4295, 4295 ], "mapped", [ 11559 ] ], [ [ 4296, 4300 ], "disallowed" ], [ [ 4301, 4301 ], "mapped", [ 11565 ] ], [ [ 4302, 4303 ], "disallowed" ], [ [ 4304, 4342 ], "valid" ], [ [ 4343, 4344 ], "valid" ], [ [ 4345, 4346 ], "valid" ], [ [ 4347, 4347 ], "valid", [], "NV8" ], [ [ 4348, 4348 ], "mapped", [ 4316 ] ], [ [ 4349, 4351 ], "valid" ], [ [ 4352, 4441 ], "valid", [], "NV8" ], [ [ 4442, 4446 ], "valid", [], "NV8" ], [ [ 4447, 4448 ], "disallowed" ], [ [ 4449, 4514 ], "valid", [], "NV8" ], [ [ 4515, 4519 ], "valid", [], "NV8" ], [ [ 4520, 4601 ], "valid", [], "NV8" ], [ [ 4602, 4607 ], "valid", [], "NV8" ], [ [ 4608, 4614 ], "valid" ], [ [ 4615, 4615 ], "valid" ], [ [ 4616, 4678 ], "valid" ], [ [ 4679, 4679 ], "valid" ], [ [ 4680, 4680 ], "valid" ], [ [ 4681, 4681 ], "disallowed" ], [ [ 4682, 4685 ], "valid" ], [ [ 4686, 4687 ], "disallowed" ], [ [ 4688, 4694 ], "valid" ], [ [ 4695, 4695 ], "disallowed" ], [ [ 4696, 4696 ], "valid" ], [ [ 4697, 4697 ], "disallowed" ], [ [ 4698, 4701 ], "valid" ], [ [ 4702, 4703 ], "disallowed" ], [ [ 4704, 4742 ], "valid" ], [ [ 4743, 4743 ], "valid" ], [ [ 4744, 4744 ], "valid" ], [ [ 4745, 4745 ], "disallowed" ], [ [ 4746, 4749 ], "valid" ], [ [ 4750, 4751 ], "disallowed" ], [ [ 4752, 4782 ], "valid" ], [ [ 4783, 4783 ], "valid" ], [ [ 4784, 4784 ], "valid" ], [ [ 4785, 4785 ], "disallowed" ], [ [ 4786, 4789 ], "valid" ], [ [ 4790, 4791 ], "disallowed" ], [ [ 4792, 4798 ], "valid" ], [ [ 4799, 4799 ], "disallowed" ], [ [ 4800, 4800 ], "valid" ], [ [ 4801, 4801 ], "disallowed" ], [ [ 4802, 4805 ], "valid" ], [ [ 4806, 4807 ], "disallowed" ], [ [ 4808, 4814 ], "valid" ], [ [ 4815, 4815 ], "valid" ], [ [ 4816, 4822 ], "valid" ], [ [ 4823, 4823 ], "disallowed" ], [ [ 4824, 4846 ], "valid" ], [ [ 4847, 4847 ], "valid" ], [ [ 4848, 4878 ], "valid" ], [ [ 4879, 4879 ], "valid" ], [ [ 4880, 4880 ], "valid" ], [ [ 4881, 4881 ], "disallowed" ], [ [ 4882, 4885 ], "valid" ], [ [ 4886, 4887 ], "disallowed" ], [ [ 4888, 4894 ], "valid" ], [ [ 4895, 4895 ], "valid" ], [ [ 4896, 4934 ], "valid" ], [ [ 4935, 4935 ], "valid" ], [ [ 4936, 4954 ], "valid" ], [ [ 4955, 4956 ], "disallowed" ], [ [ 4957, 4958 ], "valid" ], [ [ 4959, 4959 ], "valid" ], [ [ 4960, 4960 ], "valid", [], "NV8" ], [ [ 4961, 4988 ], "valid", [], "NV8" ], [ [ 4989, 4991 ], "disallowed" ], [ [ 4992, 5007 ], "valid" ], [ [ 5008, 5017 ], "valid", [], "NV8" ], [ [ 5018, 5023 ], "disallowed" ], [ [ 5024, 5108 ], "valid" ], [ [ 5109, 5109 ], "valid" ], [ [ 5110, 5111 ], "disallowed" ], [ [ 5112, 5112 ], "mapped", [ 5104 ] ], [ [ 5113, 5113 ], "mapped", [ 5105 ] ], [ [ 5114, 5114 ], "mapped", [ 5106 ] ], [ [ 5115, 5115 ], "mapped", [ 5107 ] ], [ [ 5116, 5116 ], "mapped", [ 5108 ] ], [ [ 5117, 5117 ], "mapped", [ 5109 ] ], [ [ 5118, 5119 ], "disallowed" ], [ [ 5120, 5120 ], "valid", [], "NV8" ], [ [ 5121, 5740 ], "valid" ], [ [ 5741, 5742 ], "valid", [], "NV8" ], [ [ 5743, 5750 ], "valid" ], [ [ 5751, 5759 ], "valid" ], [ [ 5760, 5760 ], "disallowed" ], [ [ 5761, 5786 ], "valid" ], [ [ 5787, 5788 ], "valid", [], "NV8" ], [ [ 5789, 5791 ], "disallowed" ], [ [ 5792, 5866 ], "valid" ], [ [ 5867, 5872 ], "valid", [], "NV8" ], [ [ 5873, 5880 ], "valid" ], [ [ 5881, 5887 ], "disallowed" ], [ [ 5888, 5900 ], "valid" ], [ [ 5901, 5901 ], "disallowed" ], [ [ 5902, 5908 ], "valid" ], [ [ 5909, 5919 ], "disallowed" ], [ [ 5920, 5940 ], "valid" ], [ [ 5941, 5942 ], "valid", [], "NV8" ], [ [ 5943, 5951 ], "disallowed" ], [ [ 5952, 5971 ], "valid" ], [ [ 5972, 5983 ], "disallowed" ], [ [ 5984, 5996 ], "valid" ], [ [ 5997, 5997 ], "disallowed" ], [ [ 5998, 6e3 ], "valid" ], [ [ 6001, 6001 ], "disallowed" ], [ [ 6002, 6003 ], "valid" ], [ [ 6004, 6015 ], "disallowed" ], [ [ 6016, 6067 ], "valid" ], [ [ 6068, 6069 ], "disallowed" ], [ [ 6070, 6099 ], "valid" ], [ [ 6100, 6102 ], "valid", [], "NV8" ], [ [ 6103, 6103 ], "valid" ], [ [ 6104, 6107 ], "valid", [], "NV8" ], [ [ 6108, 6108 ], "valid" ], [ [ 6109, 6109 ], "valid" ], [ [ 6110, 6111 ], "disallowed" ], [ [ 6112, 6121 ], "valid" ], [ [ 6122, 6127 ], "disallowed" ], [ [ 6128, 6137 ], "valid", [], "NV8" ], [ [ 6138, 6143 ], "disallowed" ], [ [ 6144, 6149 ], "valid", [], "NV8" ], [ [ 6150, 6150 ], "disallowed" ], [ [ 6151, 6154 ], "valid", [], "NV8" ], [ [ 6155, 6157 ], "ignored" ], [ [ 6158, 6158 ], "disallowed" ], [ [ 6159, 6159 ], "disallowed" ], [ [ 6160, 6169 ], "valid" ], [ [ 6170, 6175 ], "disallowed" ], [ [ 6176, 6263 ], "valid" ], [ [ 6264, 6271 ], "disallowed" ], [ [ 6272, 6313 ], "valid" ], [ [ 6314, 6314 ], "valid" ], [ [ 6315, 6319 ], "disallowed" ], [ [ 6320, 6389 ], "valid" ], [ [ 6390, 6399 ], "disallowed" ], [ [ 6400, 6428 ], "valid" ], [ [ 6429, 6430 ], "valid" ], [ [ 6431, 6431 ], "disallowed" ], [ [ 6432, 6443 ], "valid" ], [ [ 6444, 6447 ], "disallowed" ], [ [ 6448, 6459 ], "valid" ], [ [ 6460, 6463 ], "disallowed" ], [ [ 6464, 6464 ], "valid", [], "NV8" ], [ [ 6465, 6467 ], "disallowed" ], [ [ 6468, 6469 ], "valid", [], "NV8" ], [ [ 6470, 6509 ], "valid" ], [ [ 6510, 6511 ], "disallowed" ], [ [ 6512, 6516 ], "valid" ], [ [ 6517, 6527 ], "disallowed" ], [ [ 6528, 6569 ], "valid" ], [ [ 6570, 6571 ], "valid" ], [ [ 6572, 6575 ], "disallowed" ], [ [ 6576, 6601 ], "valid" ], [ [ 6602, 6607 ], "disallowed" ], [ [ 6608, 6617 ], "valid" ], [ [ 6618, 6618 ], "valid", [], "XV8" ], [ [ 6619, 6621 ], "disallowed" ], [ [ 6622, 6623 ], "valid", [], "NV8" ], [ [ 6624, 6655 ], "valid", [], "NV8" ], [ [ 6656, 6683 ], "valid" ], [ [ 6684, 6685 ], "disallowed" ], [ [ 6686, 6687 ], "valid", [], "NV8" ], [ [ 6688, 6750 ], "valid" ], [ [ 6751, 6751 ], "disallowed" ], [ [ 6752, 6780 ], "valid" ], [ [ 6781, 6782 ], "disallowed" ], [ [ 6783, 6793 ], "valid" ], [ [ 6794, 6799 ], "disallowed" ], [ [ 6800, 6809 ], "valid" ], [ [ 6810, 6815 ], "disallowed" ], [ [ 6816, 6822 ], "valid", [], "NV8" ], [ [ 6823, 6823 ], "valid" ], [ [ 6824, 6829 ], "valid", [], "NV8" ], [ [ 6830, 6831 ], "disallowed" ], [ [ 6832, 6845 ], "valid" ], [ [ 6846, 6846 ], "valid", [], "NV8" ], [ [ 6847, 6911 ], "disallowed" ], [ [ 6912, 6987 ], "valid" ], [ [ 6988, 6991 ], "disallowed" ], [ [ 6992, 7001 ], "valid" ], [ [ 7002, 7018 ], "valid", [], "NV8" ], [ [ 7019, 7027 ], "valid" ], [ [ 7028, 7036 ], "valid", [], "NV8" ], [ [ 7037, 7039 ], "disallowed" ], [ [ 7040, 7082 ], "valid" ], [ [ 7083, 7085 ], "valid" ], [ [ 7086, 7097 ], "valid" ], [ [ 7098, 7103 ], "valid" ], [ [ 7104, 7155 ], "valid" ], [ [ 7156, 7163 ], "disallowed" ], [ [ 7164, 7167 ], "valid", [], "NV8" ], [ [ 7168, 7223 ], "valid" ], [ [ 7224, 7226 ], "disallowed" ], [ [ 7227, 7231 ], "valid", [], "NV8" ], [ [ 7232, 7241 ], "valid" ], [ [ 7242, 7244 ], "disallowed" ], [ [ 7245, 7293 ], "valid" ], [ [ 7294, 7295 ], "valid", [], "NV8" ], [ [ 7296, 7359 ], "disallowed" ], [ [ 7360, 7367 ], "valid", [], "NV8" ], [ [ 7368, 7375 ], "disallowed" ], [ [ 7376, 7378 ], "valid" ], [ [ 7379, 7379 ], "valid", [], "NV8" ], [ [ 7380, 7410 ], "valid" ], [ [ 7411, 7414 ], "valid" ], [ [ 7415, 7415 ], "disallowed" ], [ [ 7416, 7417 ], "valid" ], [ [ 7418, 7423 ], "disallowed" ], [ [ 7424, 7467 ], "valid" ], [ [ 7468, 7468 ], "mapped", [ 97 ] ], [ [ 7469, 7469 ], "mapped", [ 230 ] ], [ [ 7470, 7470 ], "mapped", [ 98 ] ], [ [ 7471, 7471 ], "valid" ], [ [ 7472, 7472 ], "mapped", [ 100 ] ], [ [ 7473, 7473 ], "mapped", [ 101 ] ], [ [ 7474, 7474 ], "mapped", [ 477 ] ], [ [ 7475, 7475 ], "mapped", [ 103 ] ], [ [ 7476, 7476 ], "mapped", [ 104 ] ], [ [ 7477, 7477 ], "mapped", [ 105 ] ], [ [ 7478, 7478 ], "mapped", [ 106 ] ], [ [ 7479, 7479 ], "mapped", [ 107 ] ], [ [ 7480, 7480 ], "mapped", [ 108 ] ], [ [ 7481, 7481 ], "mapped", [ 109 ] ], [ [ 7482, 7482 ], "mapped", [ 110 ] ], [ [ 7483, 7483 ], "valid" ], [ [ 7484, 7484 ], "mapped", [ 111 ] ], [ [ 7485, 7485 ], "mapped", [ 547 ] ], [ [ 7486, 7486 ], "mapped", [ 112 ] ], [ [ 7487, 7487 ], "mapped", [ 114 ] ], [ [ 7488, 7488 ], "mapped", [ 116 ] ], [ [ 7489, 7489 ], "mapped", [ 117 ] ], [ [ 7490, 7490 ], "mapped", [ 119 ] ], [ [ 7491, 7491 ], "mapped", [ 97 ] ], [ [ 7492, 7492 ], "mapped", [ 592 ] ], [ [ 7493, 7493 ], "mapped", [ 593 ] ], [ [ 7494, 7494 ], "mapped", [ 7426 ] ], [ [ 7495, 7495 ], "mapped", [ 98 ] ], [ [ 7496, 7496 ], "mapped", [ 100 ] ], [ [ 7497, 7497 ], "mapped", [ 101 ] ], [ [ 7498, 7498 ], "mapped", [ 601 ] ], [ [ 7499, 7499 ], "mapped", [ 603 ] ], [ [ 7500, 7500 ], "mapped", [ 604 ] ], [ [ 7501, 7501 ], "mapped", [ 103 ] ], [ [ 7502, 7502 ], "valid" ], [ [ 7503, 7503 ], "mapped", [ 107 ] ], [ [ 7504, 7504 ], "mapped", [ 109 ] ], [ [ 7505, 7505 ], "mapped", [ 331 ] ], [ [ 7506, 7506 ], "mapped", [ 111 ] ], [ [ 7507, 7507 ], "mapped", [ 596 ] ], [ [ 7508, 7508 ], "mapped", [ 7446 ] ], [ [ 7509, 7509 ], "mapped", [ 7447 ] ], [ [ 7510, 7510 ], "mapped", [ 112 ] ], [ [ 7511, 7511 ], "mapped", [ 116 ] ], [ [ 7512, 7512 ], "mapped", [ 117 ] ], [ [ 7513, 7513 ], "mapped", [ 7453 ] ], [ [ 7514, 7514 ], "mapped", [ 623 ] ], [ [ 7515, 7515 ], "mapped", [ 118 ] ], [ [ 7516, 7516 ], "mapped", [ 7461 ] ], [ [ 7517, 7517 ], "mapped", [ 946 ] ], [ [ 7518, 7518 ], "mapped", [ 947 ] ], [ [ 7519, 7519 ], "mapped", [ 948 ] ], [ [ 7520, 7520 ], "mapped", [ 966 ] ], [ [ 7521, 7521 ], "mapped", [ 967 ] ], [ [ 7522, 7522 ], "mapped", [ 105 ] ], [ [ 7523, 7523 ], "mapped", [ 114 ] ], [ [ 7524, 7524 ], "mapped", [ 117 ] ], [ [ 7525, 7525 ], "mapped", [ 118 ] ], [ [ 7526, 7526 ], "mapped", [ 946 ] ], [ [ 7527, 7527 ], "mapped", [ 947 ] ], [ [ 7528, 7528 ], "mapped", [ 961 ] ], [ [ 7529, 7529 ], "mapped", [ 966 ] ], [ [ 7530, 7530 ], "mapped", [ 967 ] ], [ [ 7531, 7531 ], "valid" ], [ [ 7532, 7543 ], "valid" ], [ [ 7544, 7544 ], "mapped", [ 1085 ] ], [ [ 7545, 7578 ], "valid" ], [ [ 7579, 7579 ], "mapped", [ 594 ] ], [ [ 7580, 7580 ], "mapped", [ 99 ] ], [ [ 7581, 7581 ], "mapped", [ 597 ] ], [ [ 7582, 7582 ], "mapped", [ 240 ] ], [ [ 7583, 7583 ], "mapped", [ 604 ] ], [ [ 7584, 7584 ], "mapped", [ 102 ] ], [ [ 7585, 7585 ], "mapped", [ 607 ] ], [ [ 7586, 7586 ], "mapped", [ 609 ] ], [ [ 7587, 7587 ], "mapped", [ 613 ] ], [ [ 7588, 7588 ], "mapped", [ 616 ] ], [ [ 7589, 7589 ], "mapped", [ 617 ] ], [ [ 7590, 7590 ], "mapped", [ 618 ] ], [ [ 7591, 7591 ], "mapped", [ 7547 ] ], [ [ 7592, 7592 ], "mapped", [ 669 ] ], [ [ 7593, 7593 ], "mapped", [ 621 ] ], [ [ 7594, 7594 ], "mapped", [ 7557 ] ], [ [ 7595, 7595 ], "mapped", [ 671 ] ], [ [ 7596, 7596 ], "mapped", [ 625 ] ], [ [ 7597, 7597 ], "mapped", [ 624 ] ], [ [ 7598, 7598 ], "mapped", [ 626 ] ], [ [ 7599, 7599 ], "mapped", [ 627 ] ], [ [ 7600, 7600 ], "mapped", [ 628 ] ], [ [ 7601, 7601 ], "mapped", [ 629 ] ], [ [ 7602, 7602 ], "mapped", [ 632 ] ], [ [ 7603, 7603 ], "mapped", [ 642 ] ], [ [ 7604, 7604 ], "mapped", [ 643 ] ], [ [ 7605, 7605 ], "mapped", [ 427 ] ], [ [ 7606, 7606 ], "mapped", [ 649 ] ], [ [ 7607, 7607 ], "mapped", [ 650 ] ], [ [ 7608, 7608 ], "mapped", [ 7452 ] ], [ [ 7609, 7609 ], "mapped", [ 651 ] ], [ [ 7610, 7610 ], "mapped", [ 652 ] ], [ [ 7611, 7611 ], "mapped", [ 122 ] ], [ [ 7612, 7612 ], "mapped", [ 656 ] ], [ [ 7613, 7613 ], "mapped", [ 657 ] ], [ [ 7614, 7614 ], "mapped", [ 658 ] ], [ [ 7615, 7615 ], "mapped", [ 952 ] ], [ [ 7616, 7619 ], "valid" ], [ [ 7620, 7626 ], "valid" ], [ [ 7627, 7654 ], "valid" ], [ [ 7655, 7669 ], "valid" ], [ [ 7670, 7675 ], "disallowed" ], [ [ 7676, 7676 ], "valid" ], [ [ 7677, 7677 ], "valid" ], [ [ 7678, 7679 ], "valid" ], [ [ 7680, 7680 ], "mapped", [ 7681 ] ], [ [ 7681, 7681 ], "valid" ], [ [ 7682, 7682 ], "mapped", [ 7683 ] ], [ [ 7683, 7683 ], "valid" ], [ [ 7684, 7684 ], "mapped", [ 7685 ] ], [ [ 7685, 7685 ], "valid" ], [ [ 7686, 7686 ], "mapped", [ 7687 ] ], [ [ 7687, 7687 ], "valid" ], [ [ 7688, 7688 ], "mapped", [ 7689 ] ], [ [ 7689, 7689 ], "valid" ], [ [ 7690, 7690 ], "mapped", [ 7691 ] ], [ [ 7691, 7691 ], "valid" ], [ [ 7692, 7692 ], "mapped", [ 7693 ] ], [ [ 7693, 7693 ], "valid" ], [ [ 7694, 7694 ], "mapped", [ 7695 ] ], [ [ 7695, 7695 ], "valid" ], [ [ 7696, 7696 ], "mapped", [ 7697 ] ], [ [ 7697, 7697 ], "valid" ], [ [ 7698, 7698 ], "mapped", [ 7699 ] ], [ [ 7699, 7699 ], "valid" ], [ [ 7700, 7700 ], "mapped", [ 7701 ] ], [ [ 7701, 7701 ], "valid" ], [ [ 7702, 7702 ], "mapped", [ 7703 ] ], [ [ 7703, 7703 ], "valid" ], [ [ 7704, 7704 ], "mapped", [ 7705 ] ], [ [ 7705, 7705 ], "valid" ], [ [ 7706, 7706 ], "mapped", [ 7707 ] ], [ [ 7707, 7707 ], "valid" ], [ [ 7708, 7708 ], "mapped", [ 7709 ] ], [ [ 7709, 7709 ], "valid" ], [ [ 7710, 7710 ], "mapped", [ 7711 ] ], [ [ 7711, 7711 ], "valid" ], [ [ 7712, 7712 ], "mapped", [ 7713 ] ], [ [ 7713, 7713 ], "valid" ], [ [ 7714, 7714 ], "mapped", [ 7715 ] ], [ [ 7715, 7715 ], "valid" ], [ [ 7716, 7716 ], "mapped", [ 7717 ] ], [ [ 7717, 7717 ], "valid" ], [ [ 7718, 7718 ], "mapped", [ 7719 ] ], [ [ 7719, 7719 ], "valid" ], [ [ 7720, 7720 ], "mapped", [ 7721 ] ], [ [ 7721, 7721 ], "valid" ], [ [ 7722, 7722 ], "mapped", [ 7723 ] ], [ [ 7723, 7723 ], "valid" ], [ [ 7724, 7724 ], "mapped", [ 7725 ] ], [ [ 7725, 7725 ], "valid" ], [ [ 7726, 7726 ], "mapped", [ 7727 ] ], [ [ 7727, 7727 ], "valid" ], [ [ 7728, 7728 ], "mapped", [ 7729 ] ], [ [ 7729, 7729 ], "valid" ], [ [ 7730, 7730 ], "mapped", [ 7731 ] ], [ [ 7731, 7731 ], "valid" ], [ [ 7732, 7732 ], "mapped", [ 7733 ] ], [ [ 7733, 7733 ], "valid" ], [ [ 7734, 7734 ], "mapped", [ 7735 ] ], [ [ 7735, 7735 ], "valid" ], [ [ 7736, 7736 ], "mapped", [ 7737 ] ], [ [ 7737, 7737 ], "valid" ], [ [ 7738, 7738 ], "mapped", [ 7739 ] ], [ [ 7739, 7739 ], "valid" ], [ [ 7740, 7740 ], "mapped", [ 7741 ] ], [ [ 7741, 7741 ], "valid" ], [ [ 7742, 7742 ], "mapped", [ 7743 ] ], [ [ 7743, 7743 ], "valid" ], [ [ 7744, 7744 ], "mapped", [ 7745 ] ], [ [ 7745, 7745 ], "valid" ], [ [ 7746, 7746 ], "mapped", [ 7747 ] ], [ [ 7747, 7747 ], "valid" ], [ [ 7748, 7748 ], "mapped", [ 7749 ] ], [ [ 7749, 7749 ], "valid" ], [ [ 7750, 7750 ], "mapped", [ 7751 ] ], [ [ 7751, 7751 ], "valid" ], [ [ 7752, 7752 ], "mapped", [ 7753 ] ], [ [ 7753, 7753 ], "valid" ], [ [ 7754, 7754 ], "mapped", [ 7755 ] ], [ [ 7755, 7755 ], "valid" ], [ [ 7756, 7756 ], "mapped", [ 7757 ] ], [ [ 7757, 7757 ], "valid" ], [ [ 7758, 7758 ], "mapped", [ 7759 ] ], [ [ 7759, 7759 ], "valid" ], [ [ 7760, 7760 ], "mapped", [ 7761 ] ], [ [ 7761, 7761 ], "valid" ], [ [ 7762, 7762 ], "mapped", [ 7763 ] ], [ [ 7763, 7763 ], "valid" ], [ [ 7764, 7764 ], "mapped", [ 7765 ] ], [ [ 7765, 7765 ], "valid" ], [ [ 7766, 7766 ], "mapped", [ 7767 ] ], [ [ 7767, 7767 ], "valid" ], [ [ 7768, 7768 ], "mapped", [ 7769 ] ], [ [ 7769, 7769 ], "valid" ], [ [ 7770, 7770 ], "mapped", [ 7771 ] ], [ [ 7771, 7771 ], "valid" ], [ [ 7772, 7772 ], "mapped", [ 7773 ] ], [ [ 7773, 7773 ], "valid" ], [ [ 7774, 7774 ], "mapped", [ 7775 ] ], [ [ 7775, 7775 ], "valid" ], [ [ 7776, 7776 ], "mapped", [ 7777 ] ], [ [ 7777, 7777 ], "valid" ], [ [ 7778, 7778 ], "mapped", [ 7779 ] ], [ [ 7779, 7779 ], "valid" ], [ [ 7780, 7780 ], "mapped", [ 7781 ] ], [ [ 7781, 7781 ], "valid" ], [ [ 7782, 7782 ], "mapped", [ 7783 ] ], [ [ 7783, 7783 ], "valid" ], [ [ 7784, 7784 ], "mapped", [ 7785 ] ], [ [ 7785, 7785 ], "valid" ], [ [ 7786, 7786 ], "mapped", [ 7787 ] ], [ [ 7787, 7787 ], "valid" ], [ [ 7788, 7788 ], "mapped", [ 7789 ] ], [ [ 7789, 7789 ], "valid" ], [ [ 7790, 7790 ], "mapped", [ 7791 ] ], [ [ 7791, 7791 ], "valid" ], [ [ 7792, 7792 ], "mapped", [ 7793 ] ], [ [ 7793, 7793 ], "valid" ], [ [ 7794, 7794 ], "mapped", [ 7795 ] ], [ [ 7795, 7795 ], "valid" ], [ [ 7796, 7796 ], "mapped", [ 7797 ] ], [ [ 7797, 7797 ], "valid" ], [ [ 7798, 7798 ], "mapped", [ 7799 ] ], [ [ 7799, 7799 ], "valid" ], [ [ 7800, 7800 ], "mapped", [ 7801 ] ], [ [ 7801, 7801 ], "valid" ], [ [ 7802, 7802 ], "mapped", [ 7803 ] ], [ [ 7803, 7803 ], "valid" ], [ [ 7804, 7804 ], "mapped", [ 7805 ] ], [ [ 7805, 7805 ], "valid" ], [ [ 7806, 7806 ], "mapped", [ 7807 ] ], [ [ 7807, 7807 ], "valid" ], [ [ 7808, 7808 ], "mapped", [ 7809 ] ], [ [ 7809, 7809 ], "valid" ], [ [ 7810, 7810 ], "mapped", [ 7811 ] ], [ [ 7811, 7811 ], "valid" ], [ [ 7812, 7812 ], "mapped", [ 7813 ] ], [ [ 7813, 7813 ], "valid" ], [ [ 7814, 7814 ], "mapped", [ 7815 ] ], [ [ 7815, 7815 ], "valid" ], [ [ 7816, 7816 ], "mapped", [ 7817 ] ], [ [ 7817, 7817 ], "valid" ], [ [ 7818, 7818 ], "mapped", [ 7819 ] ], [ [ 7819, 7819 ], "valid" ], [ [ 7820, 7820 ], "mapped", [ 7821 ] ], [ [ 7821, 7821 ], "valid" ], [ [ 7822, 7822 ], "mapped", [ 7823 ] ], [ [ 7823, 7823 ], "valid" ], [ [ 7824, 7824 ], "mapped", [ 7825 ] ], [ [ 7825, 7825 ], "valid" ], [ [ 7826, 7826 ], "mapped", [ 7827 ] ], [ [ 7827, 7827 ], "valid" ], [ [ 7828, 7828 ], "mapped", [ 7829 ] ], [ [ 7829, 7833 ], "valid" ], [ [ 7834, 7834 ], "mapped", [ 97, 702 ] ], [ [ 7835, 7835 ], "mapped", [ 7777 ] ], [ [ 7836, 7837 ], "valid" ], [ [ 7838, 7838 ], "mapped", [ 115, 115 ] ], [ [ 7839, 7839 ], "valid" ], [ [ 7840, 7840 ], "mapped", [ 7841 ] ], [ [ 7841, 7841 ], "valid" ], [ [ 7842, 7842 ], "mapped", [ 7843 ] ], [ [ 7843, 7843 ], "valid" ], [ [ 7844, 7844 ], "mapped", [ 7845 ] ], [ [ 7845, 7845 ], "valid" ], [ [ 7846, 7846 ], "mapped", [ 7847 ] ], [ [ 7847, 7847 ], "valid" ], [ [ 7848, 7848 ], "mapped", [ 7849 ] ], [ [ 7849, 7849 ], "valid" ], [ [ 7850, 7850 ], "mapped", [ 7851 ] ], [ [ 7851, 7851 ], "valid" ], [ [ 7852, 7852 ], "mapped", [ 7853 ] ], [ [ 7853, 7853 ], "valid" ], [ [ 7854, 7854 ], "mapped", [ 7855 ] ], [ [ 7855, 7855 ], "valid" ], [ [ 7856, 7856 ], "mapped", [ 7857 ] ], [ [ 7857, 7857 ], "valid" ], [ [ 7858, 7858 ], "mapped", [ 7859 ] ], [ [ 7859, 7859 ], "valid" ], [ [ 7860, 7860 ], "mapped", [ 7861 ] ], [ [ 7861, 7861 ], "valid" ], [ [ 7862, 7862 ], "mapped", [ 7863 ] ], [ [ 7863, 7863 ], "valid" ], [ [ 7864, 7864 ], "mapped", [ 7865 ] ], [ [ 7865, 7865 ], "valid" ], [ [ 7866, 7866 ], "mapped", [ 7867 ] ], [ [ 7867, 7867 ], "valid" ], [ [ 7868, 7868 ], "mapped", [ 7869 ] ], [ [ 7869, 7869 ], "valid" ], [ [ 7870, 7870 ], "mapped", [ 7871 ] ], [ [ 7871, 7871 ], "valid" ], [ [ 7872, 7872 ], "mapped", [ 7873 ] ], [ [ 7873, 7873 ], "valid" ], [ [ 7874, 7874 ], "mapped", [ 7875 ] ], [ [ 7875, 7875 ], "valid" ], [ [ 7876, 7876 ], "mapped", [ 7877 ] ], [ [ 7877, 7877 ], "valid" ], [ [ 7878, 7878 ], "mapped", [ 7879 ] ], [ [ 7879, 7879 ], "valid" ], [ [ 7880, 7880 ], "mapped", [ 7881 ] ], [ [ 7881, 7881 ], "valid" ], [ [ 7882, 7882 ], "mapped", [ 7883 ] ], [ [ 7883, 7883 ], "valid" ], [ [ 7884, 7884 ], "mapped", [ 7885 ] ], [ [ 7885, 7885 ], "valid" ], [ [ 7886, 7886 ], "mapped", [ 7887 ] ], [ [ 7887, 7887 ], "valid" ], [ [ 7888, 7888 ], "mapped", [ 7889 ] ], [ [ 7889, 7889 ], "valid" ], [ [ 7890, 7890 ], "mapped", [ 7891 ] ], [ [ 7891, 7891 ], "valid" ], [ [ 7892, 7892 ], "mapped", [ 7893 ] ], [ [ 7893, 7893 ], "valid" ], [ [ 7894, 7894 ], "mapped", [ 7895 ] ], [ [ 7895, 7895 ], "valid" ], [ [ 7896, 7896 ], "mapped", [ 7897 ] ], [ [ 7897, 7897 ], "valid" ], [ [ 7898, 7898 ], "mapped", [ 7899 ] ], [ [ 7899, 7899 ], "valid" ], [ [ 7900, 7900 ], "mapped", [ 7901 ] ], [ [ 7901, 7901 ], "valid" ], [ [ 7902, 7902 ], "mapped", [ 7903 ] ], [ [ 7903, 7903 ], "valid" ], [ [ 7904, 7904 ], "mapped", [ 7905 ] ], [ [ 7905, 7905 ], "valid" ], [ [ 7906, 7906 ], "mapped", [ 7907 ] ], [ [ 7907, 7907 ], "valid" ], [ [ 7908, 7908 ], "mapped", [ 7909 ] ], [ [ 7909, 7909 ], "valid" ], [ [ 7910, 7910 ], "mapped", [ 7911 ] ], [ [ 7911, 7911 ], "valid" ], [ [ 7912, 7912 ], "mapped", [ 7913 ] ], [ [ 7913, 7913 ], "valid" ], [ [ 7914, 7914 ], "mapped", [ 7915 ] ], [ [ 7915, 7915 ], "valid" ], [ [ 7916, 7916 ], "mapped", [ 7917 ] ], [ [ 7917, 7917 ], "valid" ], [ [ 7918, 7918 ], "mapped", [ 7919 ] ], [ [ 7919, 7919 ], "valid" ], [ [ 7920, 7920 ], "mapped", [ 7921 ] ], [ [ 7921, 7921 ], "valid" ], [ [ 7922, 7922 ], "mapped", [ 7923 ] ], [ [ 7923, 7923 ], "valid" ], [ [ 7924, 7924 ], "mapped", [ 7925 ] ], [ [ 7925, 7925 ], "valid" ], [ [ 7926, 7926 ], "mapped", [ 7927 ] ], [ [ 7927, 7927 ], "valid" ], [ [ 7928, 7928 ], "mapped", [ 7929 ] ], [ [ 7929, 7929 ], "valid" ], [ [ 7930, 7930 ], "mapped", [ 7931 ] ], [ [ 7931, 7931 ], "valid" ], [ [ 7932, 7932 ], "mapped", [ 7933 ] ], [ [ 7933, 7933 ], "valid" ], [ [ 7934, 7934 ], "mapped", [ 7935 ] ], [ [ 7935, 7935 ], "valid" ], [ [ 7936, 7943 ], "valid" ], [ [ 7944, 7944 ], "mapped", [ 7936 ] ], [ [ 7945, 7945 ], "mapped", [ 7937 ] ], [ [ 7946, 7946 ], "mapped", [ 7938 ] ], [ [ 7947, 7947 ], "mapped", [ 7939 ] ], [ [ 7948, 7948 ], "mapped", [ 7940 ] ], [ [ 7949, 7949 ], "mapped", [ 7941 ] ], [ [ 7950, 7950 ], "mapped", [ 7942 ] ], [ [ 7951, 7951 ], "mapped", [ 7943 ] ], [ [ 7952, 7957 ], "valid" ], [ [ 7958, 7959 ], "disallowed" ], [ [ 7960, 7960 ], "mapped", [ 7952 ] ], [ [ 7961, 7961 ], "mapped", [ 7953 ] ], [ [ 7962, 7962 ], "mapped", [ 7954 ] ], [ [ 7963, 7963 ], "mapped", [ 7955 ] ], [ [ 7964, 7964 ], "mapped", [ 7956 ] ], [ [ 7965, 7965 ], "mapped", [ 7957 ] ], [ [ 7966, 7967 ], "disallowed" ], [ [ 7968, 7975 ], "valid" ], [ [ 7976, 7976 ], "mapped", [ 7968 ] ], [ [ 7977, 7977 ], "mapped", [ 7969 ] ], [ [ 7978, 7978 ], "mapped", [ 7970 ] ], [ [ 7979, 7979 ], "mapped", [ 7971 ] ], [ [ 7980, 7980 ], "mapped", [ 7972 ] ], [ [ 7981, 7981 ], "mapped", [ 7973 ] ], [ [ 7982, 7982 ], "mapped", [ 7974 ] ], [ [ 7983, 7983 ], "mapped", [ 7975 ] ], [ [ 7984, 7991 ], "valid" ], [ [ 7992, 7992 ], "mapped", [ 7984 ] ], [ [ 7993, 7993 ], "mapped", [ 7985 ] ], [ [ 7994, 7994 ], "mapped", [ 7986 ] ], [ [ 7995, 7995 ], "mapped", [ 7987 ] ], [ [ 7996, 7996 ], "mapped", [ 7988 ] ], [ [ 7997, 7997 ], "mapped", [ 7989 ] ], [ [ 7998, 7998 ], "mapped", [ 7990 ] ], [ [ 7999, 7999 ], "mapped", [ 7991 ] ], [ [ 8e3, 8005 ], "valid" ], [ [ 8006, 8007 ], "disallowed" ], [ [ 8008, 8008 ], "mapped", [ 8e3 ] ], [ [ 8009, 8009 ], "mapped", [ 8001 ] ], [ [ 8010, 8010 ], "mapped", [ 8002 ] ], [ [ 8011, 8011 ], "mapped", [ 8003 ] ], [ [ 8012, 8012 ], "mapped", [ 8004 ] ], [ [ 8013, 8013 ], "mapped", [ 8005 ] ], [ [ 8014, 8015 ], "disallowed" ], [ [ 8016, 8023 ], "valid" ], [ [ 8024, 8024 ], "disallowed" ], [ [ 8025, 8025 ], "mapped", [ 8017 ] ], [ [ 8026, 8026 ], "disallowed" ], [ [ 8027, 8027 ], "mapped", [ 8019 ] ], [ [ 8028, 8028 ], "disallowed" ], [ [ 8029, 8029 ], "mapped", [ 8021 ] ], [ [ 8030, 8030 ], "disallowed" ], [ [ 8031, 8031 ], "mapped", [ 8023 ] ], [ [ 8032, 8039 ], "valid" ], [ [ 8040, 8040 ], "mapped", [ 8032 ] ], [ [ 8041, 8041 ], "mapped", [ 8033 ] ], [ [ 8042, 8042 ], "mapped", [ 8034 ] ], [ [ 8043, 8043 ], "mapped", [ 8035 ] ], [ [ 8044, 8044 ], "mapped", [ 8036 ] ], [ [ 8045, 8045 ], "mapped", [ 8037 ] ], [ [ 8046, 8046 ], "mapped", [ 8038 ] ], [ [ 8047, 8047 ], "mapped", [ 8039 ] ], [ [ 8048, 8048 ], "valid" ], [ [ 8049, 8049 ], "mapped", [ 940 ] ], [ [ 8050, 8050 ], "valid" ], [ [ 8051, 8051 ], "mapped", [ 941 ] ], [ [ 8052, 8052 ], "valid" ], [ [ 8053, 8053 ], "mapped", [ 942 ] ], [ [ 8054, 8054 ], "valid" ], [ [ 8055, 8055 ], "mapped", [ 943 ] ], [ [ 8056, 8056 ], "valid" ], [ [ 8057, 8057 ], "mapped", [ 972 ] ], [ [ 8058, 8058 ], "valid" ], [ [ 8059, 8059 ], "mapped", [ 973 ] ], [ [ 8060, 8060 ], "valid" ], [ [ 8061, 8061 ], "mapped", [ 974 ] ], [ [ 8062, 8063 ], "disallowed" ], [ [ 8064, 8064 ], "mapped", [ 7936, 953 ] ], [ [ 8065, 8065 ], "mapped", [ 7937, 953 ] ], [ [ 8066, 8066 ], "mapped", [ 7938, 953 ] ], [ [ 8067, 8067 ], "mapped", [ 7939, 953 ] ], [ [ 8068, 8068 ], "mapped", [ 7940, 953 ] ], [ [ 8069, 8069 ], "mapped", [ 7941, 953 ] ], [ [ 8070, 8070 ], "mapped", [ 7942, 953 ] ], [ [ 8071, 8071 ], "mapped", [ 7943, 953 ] ], [ [ 8072, 8072 ], "mapped", [ 7936, 953 ] ], [ [ 8073, 8073 ], "mapped", [ 7937, 953 ] ], [ [ 8074, 8074 ], "mapped", [ 7938, 953 ] ], [ [ 8075, 8075 ], "mapped", [ 7939, 953 ] ], [ [ 8076, 8076 ], "mapped", [ 7940, 953 ] ], [ [ 8077, 8077 ], "mapped", [ 7941, 953 ] ], [ [ 8078, 8078 ], "mapped", [ 7942, 953 ] ], [ [ 8079, 8079 ], "mapped", [ 7943, 953 ] ], [ [ 8080, 8080 ], "mapped", [ 7968, 953 ] ], [ [ 8081, 8081 ], "mapped", [ 7969, 953 ] ], [ [ 8082, 8082 ], "mapped", [ 7970, 953 ] ], [ [ 8083, 8083 ], "mapped", [ 7971, 953 ] ], [ [ 8084, 8084 ], "mapped", [ 7972, 953 ] ], [ [ 8085, 8085 ], "mapped", [ 7973, 953 ] ], [ [ 8086, 8086 ], "mapped", [ 7974, 953 ] ], [ [ 8087, 8087 ], "mapped", [ 7975, 953 ] ], [ [ 8088, 8088 ], "mapped", [ 7968, 953 ] ], [ [ 8089, 8089 ], "mapped", [ 7969, 953 ] ], [ [ 8090, 8090 ], "mapped", [ 7970, 953 ] ], [ [ 8091, 8091 ], "mapped", [ 7971, 953 ] ], [ [ 8092, 8092 ], "mapped", [ 7972, 953 ] ], [ [ 8093, 8093 ], "mapped", [ 7973, 953 ] ], [ [ 8094, 8094 ], "mapped", [ 7974, 953 ] ], [ [ 8095, 8095 ], "mapped", [ 7975, 953 ] ], [ [ 8096, 8096 ], "mapped", [ 8032, 953 ] ], [ [ 8097, 8097 ], "mapped", [ 8033, 953 ] ], [ [ 8098, 8098 ], "mapped", [ 8034, 953 ] ], [ [ 8099, 8099 ], "mapped", [ 8035, 953 ] ], [ [ 8100, 8100 ], "mapped", [ 8036, 953 ] ], [ [ 8101, 8101 ], "mapped", [ 8037, 953 ] ], [ [ 8102, 8102 ], "mapped", [ 8038, 953 ] ], [ [ 8103, 8103 ], "mapped", [ 8039, 953 ] ], [ [ 8104, 8104 ], "mapped", [ 8032, 953 ] ], [ [ 8105, 8105 ], "mapped", [ 8033, 953 ] ], [ [ 8106, 8106 ], "mapped", [ 8034, 953 ] ], [ [ 8107, 8107 ], "mapped", [ 8035, 953 ] ], [ [ 8108, 8108 ], "mapped", [ 8036, 953 ] ], [ [ 8109, 8109 ], "mapped", [ 8037, 953 ] ], [ [ 8110, 8110 ], "mapped", [ 8038, 953 ] ], [ [ 8111, 8111 ], "mapped", [ 8039, 953 ] ], [ [ 8112, 8113 ], "valid" ], [ [ 8114, 8114 ], "mapped", [ 8048, 953 ] ], [ [ 8115, 8115 ], "mapped", [ 945, 953 ] ], [ [ 8116, 8116 ], "mapped", [ 940, 953 ] ], [ [ 8117, 8117 ], "disallowed" ], [ [ 8118, 8118 ], "valid" ], [ [ 8119, 8119 ], "mapped", [ 8118, 953 ] ], [ [ 8120, 8120 ], "mapped", [ 8112 ] ], [ [ 8121, 8121 ], "mapped", [ 8113 ] ], [ [ 8122, 8122 ], "mapped", [ 8048 ] ], [ [ 8123, 8123 ], "mapped", [ 940 ] ], [ [ 8124, 8124 ], "mapped", [ 945, 953 ] ], [ [ 8125, 8125 ], "disallowed_STD3_mapped", [ 32, 787 ] ], [ [ 8126, 8126 ], "mapped", [ 953 ] ], [ [ 8127, 8127 ], "disallowed_STD3_mapped", [ 32, 787 ] ], [ [ 8128, 8128 ], "disallowed_STD3_mapped", [ 32, 834 ] ], [ [ 8129, 8129 ], "disallowed_STD3_mapped", [ 32, 776, 834 ] ], [ [ 8130, 8130 ], "mapped", [ 8052, 953 ] ], [ [ 8131, 8131 ], "mapped", [ 951, 953 ] ], [ [ 8132, 8132 ], "mapped", [ 942, 953 ] ], [ [ 8133, 8133 ], "disallowed" ], [ [ 8134, 8134 ], "valid" ], [ [ 8135, 8135 ], "mapped", [ 8134, 953 ] ], [ [ 8136, 8136 ], "mapped", [ 8050 ] ], [ [ 8137, 8137 ], "mapped", [ 941 ] ], [ [ 8138, 8138 ], "mapped", [ 8052 ] ], [ [ 8139, 8139 ], "mapped", [ 942 ] ], [ [ 8140, 8140 ], "mapped", [ 951, 953 ] ], [ [ 8141, 8141 ], "disallowed_STD3_mapped", [ 32, 787, 768 ] ], [ [ 8142, 8142 ], "disallowed_STD3_mapped", [ 32, 787, 769 ] ], [ [ 8143, 8143 ], "disallowed_STD3_mapped", [ 32, 787, 834 ] ], [ [ 8144, 8146 ], "valid" ], [ [ 8147, 8147 ], "mapped", [ 912 ] ], [ [ 8148, 8149 ], "disallowed" ], [ [ 8150, 8151 ], "valid" ], [ [ 8152, 8152 ], "mapped", [ 8144 ] ], [ [ 8153, 8153 ], "mapped", [ 8145 ] ], [ [ 8154, 8154 ], "mapped", [ 8054 ] ], [ [ 8155, 8155 ], "mapped", [ 943 ] ], [ [ 8156, 8156 ], "disallowed" ], [ [ 8157, 8157 ], "disallowed_STD3_mapped", [ 32, 788, 768 ] ], [ [ 8158, 8158 ], "disallowed_STD3_mapped", [ 32, 788, 769 ] ], [ [ 8159, 8159 ], "disallowed_STD3_mapped", [ 32, 788, 834 ] ], [ [ 8160, 8162 ], "valid" ], [ [ 8163, 8163 ], "mapped", [ 944 ] ], [ [ 8164, 8167 ], "valid" ], [ [ 8168, 8168 ], "mapped", [ 8160 ] ], [ [ 8169, 8169 ], "mapped", [ 8161 ] ], [ [ 8170, 8170 ], "mapped", [ 8058 ] ], [ [ 8171, 8171 ], "mapped", [ 973 ] ], [ [ 8172, 8172 ], "mapped", [ 8165 ] ], [ [ 8173, 8173 ], "disallowed_STD3_mapped", [ 32, 776, 768 ] ], [ [ 8174, 8174 ], "disallowed_STD3_mapped", [ 32, 776, 769 ] ], [ [ 8175, 8175 ], "disallowed_STD3_mapped", [ 96 ] ], [ [ 8176, 8177 ], "disallowed" ], [ [ 8178, 8178 ], "mapped", [ 8060, 953 ] ], [ [ 8179, 8179 ], "mapped", [ 969, 953 ] ], [ [ 8180, 8180 ], "mapped", [ 974, 953 ] ], [ [ 8181, 8181 ], "disallowed" ], [ [ 8182, 8182 ], "valid" ], [ [ 8183, 8183 ], "mapped", [ 8182, 953 ] ], [ [ 8184, 8184 ], "mapped", [ 8056 ] ], [ [ 8185, 8185 ], "mapped", [ 972 ] ], [ [ 8186, 8186 ], "mapped", [ 8060 ] ], [ [ 8187, 8187 ], "mapped", [ 974 ] ], [ [ 8188, 8188 ], "mapped", [ 969, 953 ] ], [ [ 8189, 8189 ], "disallowed_STD3_mapped", [ 32, 769 ] ], [ [ 8190, 8190 ], "disallowed_STD3_mapped", [ 32, 788 ] ], [ [ 8191, 8191 ], "disallowed" ], [ [ 8192, 8202 ], "disallowed_STD3_mapped", [ 32 ] ], [ [ 8203, 8203 ], "ignored" ], [ [ 8204, 8205 ], "deviation", [] ], [ [ 8206, 8207 ], "disallowed" ], [ [ 8208, 8208 ], "valid", [], "NV8" ], [ [ 8209, 8209 ], "mapped", [ 8208 ] ], [ [ 8210, 8214 ], "valid", [], "NV8" ], [ [ 8215, 8215 ], "disallowed_STD3_mapped", [ 32, 819 ] ], [ [ 8216, 8227 ], "valid", [], "NV8" ], [ [ 8228, 8230 ], "disallowed" ], [ [ 8231, 8231 ], "valid", [], "NV8" ], [ [ 8232, 8238 ], "disallowed" ], [ [ 8239, 8239 ], "disallowed_STD3_mapped", [ 32 ] ], [ [ 8240, 8242 ], "valid", [], "NV8" ], [ [ 8243, 8243 ], "mapped", [ 8242, 8242 ] ], [ [ 8244, 8244 ], "mapped", [ 8242, 8242, 8242 ] ], [ [ 8245, 8245 ], "valid", [], "NV8" ], [ [ 8246, 8246 ], "mapped", [ 8245, 8245 ] ], [ [ 8247, 8247 ], "mapped", [ 8245, 8245, 8245 ] ], [ [ 8248, 8251 ], "valid", [], "NV8" ], [ [ 8252, 8252 ], "disallowed_STD3_mapped", [ 33, 33 ] ], [ [ 8253, 8253 ], "valid", [], "NV8" ], [ [ 8254, 8254 ], "disallowed_STD3_mapped", [ 32, 773 ] ], [ [ 8255, 8262 ], "valid", [], "NV8" ], [ [ 8263, 8263 ], "disallowed_STD3_mapped", [ 63, 63 ] ], [ [ 8264, 8264 ], "disallowed_STD3_mapped", [ 63, 33 ] ], [ [ 8265, 8265 ], "disallowed_STD3_mapped", [ 33, 63 ] ], [ [ 8266, 8269 ], "valid", [], "NV8" ], [ [ 8270, 8274 ], "valid", [], "NV8" ], [ [ 8275, 8276 ], "valid", [], "NV8" ], [ [ 8277, 8278 ], "valid", [], "NV8" ], [ [ 8279, 8279 ], "mapped", [ 8242, 8242, 8242, 8242 ] ], [ [ 8280, 8286 ], "valid", [], "NV8" ], [ [ 8287, 8287 ], "disallowed_STD3_mapped", [ 32 ] ], [ [ 8288, 8288 ], "ignored" ], [ [ 8289, 8291 ], "disallowed" ], [ [ 8292, 8292 ], "ignored" ], [ [ 8293, 8293 ], "disallowed" ], [ [ 8294, 8297 ], "disallowed" ], [ [ 8298, 8303 ], "disallowed" ], [ [ 8304, 8304 ], "mapped", [ 48 ] ], [ [ 8305, 8305 ], "mapped", [ 105 ] ], [ [ 8306, 8307 ], "disallowed" ], [ [ 8308, 8308 ], "mapped", [ 52 ] ], [ [ 8309, 8309 ], "mapped", [ 53 ] ], [ [ 8310, 8310 ], "mapped", [ 54 ] ], [ [ 8311, 8311 ], "mapped", [ 55 ] ], [ [ 8312, 8312 ], "mapped", [ 56 ] ], [ [ 8313, 8313 ], "mapped", [ 57 ] ], [ [ 8314, 8314 ], "disallowed_STD3_mapped", [ 43 ] ], [ [ 8315, 8315 ], "mapped", [ 8722 ] ], [ [ 8316, 8316 ], "disallowed_STD3_mapped", [ 61 ] ], [ [ 8317, 8317 ], "disallowed_STD3_mapped", [ 40 ] ], [ [ 8318, 8318 ], "disallowed_STD3_mapped", [ 41 ] ], [ [ 8319, 8319 ], "mapped", [ 110 ] ], [ [ 8320, 8320 ], "mapped", [ 48 ] ], [ [ 8321, 8321 ], "mapped", [ 49 ] ], [ [ 8322, 8322 ], "mapped", [ 50 ] ], [ [ 8323, 8323 ], "mapped", [ 51 ] ], [ [ 8324, 8324 ], "mapped", [ 52 ] ], [ [ 8325, 8325 ], "mapped", [ 53 ] ], [ [ 8326, 8326 ], "mapped", [ 54 ] ], [ [ 8327, 8327 ], "mapped", [ 55 ] ], [ [ 8328, 8328 ], "mapped", [ 56 ] ], [ [ 8329, 8329 ], "mapped", [ 57 ] ], [ [ 8330, 8330 ], "disallowed_STD3_mapped", [ 43 ] ], [ [ 8331, 8331 ], "mapped", [ 8722 ] ], [ [ 8332, 8332 ], "disallowed_STD3_mapped", [ 61 ] ], [ [ 8333, 8333 ], "disallowed_STD3_mapped", [ 40 ] ], [ [ 8334, 8334 ], "disallowed_STD3_mapped", [ 41 ] ], [ [ 8335, 8335 ], "disallowed" ], [ [ 8336, 8336 ], "mapped", [ 97 ] ], [ [ 8337, 8337 ], "mapped", [ 101 ] ], [ [ 8338, 8338 ], "mapped", [ 111 ] ], [ [ 8339, 8339 ], "mapped", [ 120 ] ], [ [ 8340, 8340 ], "mapped", [ 601 ] ], [ [ 8341, 8341 ], "mapped", [ 104 ] ], [ [ 8342, 8342 ], "mapped", [ 107 ] ], [ [ 8343, 8343 ], "mapped", [ 108 ] ], [ [ 8344, 8344 ], "mapped", [ 109 ] ], [ [ 8345, 8345 ], "mapped", [ 110 ] ], [ [ 8346, 8346 ], "mapped", [ 112 ] ], [ [ 8347, 8347 ], "mapped", [ 115 ] ], [ [ 8348, 8348 ], "mapped", [ 116 ] ], [ [ 8349, 8351 ], "disallowed" ], [ [ 8352, 8359 ], "valid", [], "NV8" ], [ [ 8360, 8360 ], "mapped", [ 114, 115 ] ], [ [ 8361, 8362 ], "valid", [], "NV8" ], [ [ 8363, 8363 ], "valid", [], "NV8" ], [ [ 8364, 8364 ], "valid", [], "NV8" ], [ [ 8365, 8367 ], "valid", [], "NV8" ], [ [ 8368, 8369 ], "valid", [], "NV8" ], [ [ 8370, 8373 ], "valid", [], "NV8" ], [ [ 8374, 8376 ], "valid", [], "NV8" ], [ [ 8377, 8377 ], "valid", [], "NV8" ], [ [ 8378, 8378 ], "valid", [], "NV8" ], [ [ 8379, 8381 ], "valid", [], "NV8" ], [ [ 8382, 8382 ], "valid", [], "NV8" ], [ [ 8383, 8399 ], "disallowed" ], [ [ 8400, 8417 ], "valid", [], "NV8" ], [ [ 8418, 8419 ], "valid", [], "NV8" ], [ [ 8420, 8426 ], "valid", [], "NV8" ], [ [ 8427, 8427 ], "valid", [], "NV8" ], [ [ 8428, 8431 ], "valid", [], "NV8" ], [ [ 8432, 8432 ], "valid", [], "NV8" ], [ [ 8433, 8447 ], "disallowed" ], [ [ 8448, 8448 ], "disallowed_STD3_mapped", [ 97, 47, 99 ] ], [ [ 8449, 8449 ], "disallowed_STD3_mapped", [ 97, 47, 115 ] ], [ [ 8450, 8450 ], "mapped", [ 99 ] ], [ [ 8451, 8451 ], "mapped", [ 176, 99 ] ], [ [ 8452, 8452 ], "valid", [], "NV8" ], [ [ 8453, 8453 ], "disallowed_STD3_mapped", [ 99, 47, 111 ] ], [ [ 8454, 8454 ], "disallowed_STD3_mapped", [ 99, 47, 117 ] ], [ [ 8455, 8455 ], "mapped", [ 603 ] ], [ [ 8456, 8456 ], "valid", [], "NV8" ], [ [ 8457, 8457 ], "mapped", [ 176, 102 ] ], [ [ 8458, 8458 ], "mapped", [ 103 ] ], [ [ 8459, 8462 ], "mapped", [ 104 ] ], [ [ 8463, 8463 ], "mapped", [ 295 ] ], [ [ 8464, 8465 ], "mapped", [ 105 ] ], [ [ 8466, 8467 ], "mapped", [ 108 ] ], [ [ 8468, 8468 ], "valid", [], "NV8" ], [ [ 8469, 8469 ], "mapped", [ 110 ] ], [ [ 8470, 8470 ], "mapped", [ 110, 111 ] ], [ [ 8471, 8472 ], "valid", [], "NV8" ], [ [ 8473, 8473 ], "mapped", [ 112 ] ], [ [ 8474, 8474 ], "mapped", [ 113 ] ], [ [ 8475, 8477 ], "mapped", [ 114 ] ], [ [ 8478, 8479 ], "valid", [], "NV8" ], [ [ 8480, 8480 ], "mapped", [ 115, 109 ] ], [ [ 8481, 8481 ], "mapped", [ 116, 101, 108 ] ], [ [ 8482, 8482 ], "mapped", [ 116, 109 ] ], [ [ 8483, 8483 ], "valid", [], "NV8" ], [ [ 8484, 8484 ], "mapped", [ 122 ] ], [ [ 8485, 8485 ], "valid", [], "NV8" ], [ [ 8486, 8486 ], "mapped", [ 969 ] ], [ [ 8487, 8487 ], "valid", [], "NV8" ], [ [ 8488, 8488 ], "mapped", [ 122 ] ], [ [ 8489, 8489 ], "valid", [], "NV8" ], [ [ 8490, 8490 ], "mapped", [ 107 ] ], [ [ 8491, 8491 ], "mapped", [ 229 ] ], [ [ 8492, 8492 ], "mapped", [ 98 ] ], [ [ 8493, 8493 ], "mapped", [ 99 ] ], [ [ 8494, 8494 ], "valid", [], "NV8" ], [ [ 8495, 8496 ], "mapped", [ 101 ] ], [ [ 8497, 8497 ], "mapped", [ 102 ] ], [ [ 8498, 8498 ], "disallowed" ], [ [ 8499, 8499 ], "mapped", [ 109 ] ], [ [ 8500, 8500 ], "mapped", [ 111 ] ], [ [ 8501, 8501 ], "mapped", [ 1488 ] ], [ [ 8502, 8502 ], "mapped", [ 1489 ] ], [ [ 8503, 8503 ], "mapped", [ 1490 ] ], [ [ 8504, 8504 ], "mapped", [ 1491 ] ], [ [ 8505, 8505 ], "mapped", [ 105 ] ], [ [ 8506, 8506 ], "valid", [], "NV8" ], [ [ 8507, 8507 ], "mapped", [ 102, 97, 120 ] ], [ [ 8508, 8508 ], "mapped", [ 960 ] ], [ [ 8509, 8510 ], "mapped", [ 947 ] ], [ [ 8511, 8511 ], "mapped", [ 960 ] ], [ [ 8512, 8512 ], "mapped", [ 8721 ] ], [ [ 8513, 8516 ], "valid", [], "NV8" ], [ [ 8517, 8518 ], "mapped", [ 100 ] ], [ [ 8519, 8519 ], "mapped", [ 101 ] ], [ [ 8520, 8520 ], "mapped", [ 105 ] ], [ [ 8521, 8521 ], "mapped", [ 106 ] ], [ [ 8522, 8523 ], "valid", [], "NV8" ], [ [ 8524, 8524 ], "valid", [], "NV8" ], [ [ 8525, 8525 ], "valid", [], "NV8" ], [ [ 8526, 8526 ], "valid" ], [ [ 8527, 8527 ], "valid", [], "NV8" ], [ [ 8528, 8528 ], "mapped", [ 49, 8260, 55 ] ], [ [ 8529, 8529 ], "mapped", [ 49, 8260, 57 ] ], [ [ 8530, 8530 ], "mapped", [ 49, 8260, 49, 48 ] ], [ [ 8531, 8531 ], "mapped", [ 49, 8260, 51 ] ], [ [ 8532, 8532 ], "mapped", [ 50, 8260, 51 ] ], [ [ 8533, 8533 ], "mapped", [ 49, 8260, 53 ] ], [ [ 8534, 8534 ], "mapped", [ 50, 8260, 53 ] ], [ [ 8535, 8535 ], "mapped", [ 51, 8260, 53 ] ], [ [ 8536, 8536 ], "mapped", [ 52, 8260, 53 ] ], [ [ 8537, 8537 ], "mapped", [ 49, 8260, 54 ] ], [ [ 8538, 8538 ], "mapped", [ 53, 8260, 54 ] ], [ [ 8539, 8539 ], "mapped", [ 49, 8260, 56 ] ], [ [ 8540, 8540 ], "mapped", [ 51, 8260, 56 ] ], [ [ 8541, 8541 ], "mapped", [ 53, 8260, 56 ] ], [ [ 8542, 8542 ], "mapped", [ 55, 8260, 56 ] ], [ [ 8543, 8543 ], "mapped", [ 49, 8260 ] ], [ [ 8544, 8544 ], "mapped", [ 105 ] ], [ [ 8545, 8545 ], "mapped", [ 105, 105 ] ], [ [ 8546, 8546 ], "mapped", [ 105, 105, 105 ] ], [ [ 8547, 8547 ], "mapped", [ 105, 118 ] ], [ [ 8548, 8548 ], "mapped", [ 118 ] ], [ [ 8549, 8549 ], "mapped", [ 118, 105 ] ], [ [ 8550, 8550 ], "mapped", [ 118, 105, 105 ] ], [ [ 8551, 8551 ], "mapped", [ 118, 105, 105, 105 ] ], [ [ 8552, 8552 ], "mapped", [ 105, 120 ] ], [ [ 8553, 8553 ], "mapped", [ 120 ] ], [ [ 8554, 8554 ], "mapped", [ 120, 105 ] ], [ [ 8555, 8555 ], "mapped", [ 120, 105, 105 ] ], [ [ 8556, 8556 ], "mapped", [ 108 ] ], [ [ 8557, 8557 ], "mapped", [ 99 ] ], [ [ 8558, 8558 ], "mapped", [ 100 ] ], [ [ 8559, 8559 ], "mapped", [ 109 ] ], [ [ 8560, 8560 ], "mapped", [ 105 ] ], [ [ 8561, 8561 ], "mapped", [ 105, 105 ] ], [ [ 8562, 8562 ], "mapped", [ 105, 105, 105 ] ], [ [ 8563, 8563 ], "mapped", [ 105, 118 ] ], [ [ 8564, 8564 ], "mapped", [ 118 ] ], [ [ 8565, 8565 ], "mapped", [ 118, 105 ] ], [ [ 8566, 8566 ], "mapped", [ 118, 105, 105 ] ], [ [ 8567, 8567 ], "mapped", [ 118, 105, 105, 105 ] ], [ [ 8568, 8568 ], "mapped", [ 105, 120 ] ], [ [ 8569, 8569 ], "mapped", [ 120 ] ], [ [ 8570, 8570 ], "mapped", [ 120, 105 ] ], [ [ 8571, 8571 ], "mapped", [ 120, 105, 105 ] ], [ [ 8572, 8572 ], "mapped", [ 108 ] ], [ [ 8573, 8573 ], "mapped", [ 99 ] ], [ [ 8574, 8574 ], "mapped", [ 100 ] ], [ [ 8575, 8575 ], "mapped", [ 109 ] ], [ [ 8576, 8578 ], "valid", [], "NV8" ], [ [ 8579, 8579 ], "disallowed" ], [ [ 8580, 8580 ], "valid" ], [ [ 8581, 8584 ], "valid", [], "NV8" ], [ [ 8585, 8585 ], "mapped", [ 48, 8260, 51 ] ], [ [ 8586, 8587 ], "valid", [], "NV8" ], [ [ 8588, 8591 ], "disallowed" ], [ [ 8592, 8682 ], "valid", [], "NV8" ], [ [ 8683, 8691 ], "valid", [], "NV8" ], [ [ 8692, 8703 ], "valid", [], "NV8" ], [ [ 8704, 8747 ], "valid", [], "NV8" ], [ [ 8748, 8748 ], "mapped", [ 8747, 8747 ] ], [ [ 8749, 8749 ], "mapped", [ 8747, 8747, 8747 ] ], [ [ 8750, 8750 ], "valid", [], "NV8" ], [ [ 8751, 8751 ], "mapped", [ 8750, 8750 ] ], [ [ 8752, 8752 ], "mapped", [ 8750, 8750, 8750 ] ], [ [ 8753, 8799 ], "valid", [], "NV8" ], [ [ 8800, 8800 ], "disallowed_STD3_valid" ], [ [ 8801, 8813 ], "valid", [], "NV8" ], [ [ 8814, 8815 ], "disallowed_STD3_valid" ], [ [ 8816, 8945 ], "valid", [], "NV8" ], [ [ 8946, 8959 ], "valid", [], "NV8" ], [ [ 8960, 8960 ], "valid", [], "NV8" ], [ [ 8961, 8961 ], "valid", [], "NV8" ], [ [ 8962, 9e3 ], "valid", [], "NV8" ], [ [ 9001, 9001 ], "mapped", [ 12296 ] ], [ [ 9002, 9002 ], "mapped", [ 12297 ] ], [ [ 9003, 9082 ], "valid", [], "NV8" ], [ [ 9083, 9083 ], "valid", [], "NV8" ], [ [ 9084, 9084 ], "valid", [], "NV8" ], [ [ 9085, 9114 ], "valid", [], "NV8" ], [ [ 9115, 9166 ], "valid", [], "NV8" ], [ [ 9167, 9168 ], "valid", [], "NV8" ], [ [ 9169, 9179 ], "valid", [], "NV8" ], [ [ 9180, 9191 ], "valid", [], "NV8" ], [ [ 9192, 9192 ], "valid", [], "NV8" ], [ [ 9193, 9203 ], "valid", [], "NV8" ], [ [ 9204, 9210 ], "valid", [], "NV8" ], [ [ 9211, 9215 ], "disallowed" ], [ [ 9216, 9252 ], "valid", [], "NV8" ], [ [ 9253, 9254 ], "valid", [], "NV8" ], [ [ 9255, 9279 ], "disallowed" ], [ [ 9280, 9290 ], "valid", [], "NV8" ], [ [ 9291, 9311 ], "disallowed" ], [ [ 9312, 9312 ], "mapped", [ 49 ] ], [ [ 9313, 9313 ], "mapped", [ 50 ] ], [ [ 9314, 9314 ], "mapped", [ 51 ] ], [ [ 9315, 9315 ], "mapped", [ 52 ] ], [ [ 9316, 9316 ], "mapped", [ 53 ] ], [ [ 9317, 9317 ], "mapped", [ 54 ] ], [ [ 9318, 9318 ], "mapped", [ 55 ] ], [ [ 9319, 9319 ], "mapped", [ 56 ] ], [ [ 9320, 9320 ], "mapped", [ 57 ] ], [ [ 9321, 9321 ], "mapped", [ 49, 48 ] ], [ [ 9322, 9322 ], "mapped", [ 49, 49 ] ], [ [ 9323, 9323 ], "mapped", [ 49, 50 ] ], [ [ 9324, 9324 ], "mapped", [ 49, 51 ] ], [ [ 9325, 9325 ], "mapped", [ 49, 52 ] ], [ [ 9326, 9326 ], "mapped", [ 49, 53 ] ], [ [ 9327, 9327 ], "mapped", [ 49, 54 ] ], [ [ 9328, 9328 ], "mapped", [ 49, 55 ] ], [ [ 9329, 9329 ], "mapped", [ 49, 56 ] ], [ [ 9330, 9330 ], "mapped", [ 49, 57 ] ], [ [ 9331, 9331 ], "mapped", [ 50, 48 ] ], [ [ 9332, 9332 ], "disallowed_STD3_mapped", [ 40, 49, 41 ] ], [ [ 9333, 9333 ], "disallowed_STD3_mapped", [ 40, 50, 41 ] ], [ [ 9334, 9334 ], "disallowed_STD3_mapped", [ 40, 51, 41 ] ], [ [ 9335, 9335 ], "disallowed_STD3_mapped", [ 40, 52, 41 ] ], [ [ 9336, 9336 ], "disallowed_STD3_mapped", [ 40, 53, 41 ] ], [ [ 9337, 9337 ], "disallowed_STD3_mapped", [ 40, 54, 41 ] ], [ [ 9338, 9338 ], "disallowed_STD3_mapped", [ 40, 55, 41 ] ], [ [ 9339, 9339 ], "disallowed_STD3_mapped", [ 40, 56, 41 ] ], [ [ 9340, 9340 ], "disallowed_STD3_mapped", [ 40, 57, 41 ] ], [ [ 9341, 9341 ], "disallowed_STD3_mapped", [ 40, 49, 48, 41 ] ], [ [ 9342, 9342 ], "disallowed_STD3_mapped", [ 40, 49, 49, 41 ] ], [ [ 9343, 9343 ], "disallowed_STD3_mapped", [ 40, 49, 50, 41 ] ], [ [ 9344, 9344 ], "disallowed_STD3_mapped", [ 40, 49, 51, 41 ] ], [ [ 9345, 9345 ], "disallowed_STD3_mapped", [ 40, 49, 52, 41 ] ], [ [ 9346, 9346 ], "disallowed_STD3_mapped", [ 40, 49, 53, 41 ] ], [ [ 9347, 9347 ], "disallowed_STD3_mapped", [ 40, 49, 54, 41 ] ], [ [ 9348, 9348 ], "disallowed_STD3_mapped", [ 40, 49, 55, 41 ] ], [ [ 9349, 9349 ], "disallowed_STD3_mapped", [ 40, 49, 56, 41 ] ], [ [ 9350, 9350 ], "disallowed_STD3_mapped", [ 40, 49, 57, 41 ] ], [ [ 9351, 9351 ], "disallowed_STD3_mapped", [ 40, 50, 48, 41 ] ], [ [ 9352, 9371 ], "disallowed" ], [ [ 9372, 9372 ], "disallowed_STD3_mapped", [ 40, 97, 41 ] ], [ [ 9373, 9373 ], "disallowed_STD3_mapped", [ 40, 98, 41 ] ], [ [ 9374, 9374 ], "disallowed_STD3_mapped", [ 40, 99, 41 ] ], [ [ 9375, 9375 ], "disallowed_STD3_mapped", [ 40, 100, 41 ] ], [ [ 9376, 9376 ], "disallowed_STD3_mapped", [ 40, 101, 41 ] ], [ [ 9377, 9377 ], "disallowed_STD3_mapped", [ 40, 102, 41 ] ], [ [ 9378, 9378 ], "disallowed_STD3_mapped", [ 40, 103, 41 ] ], [ [ 9379, 9379 ], "disallowed_STD3_mapped", [ 40, 104, 41 ] ], [ [ 9380, 9380 ], "disallowed_STD3_mapped", [ 40, 105, 41 ] ], [ [ 9381, 9381 ], "disallowed_STD3_mapped", [ 40, 106, 41 ] ], [ [ 9382, 9382 ], "disallowed_STD3_mapped", [ 40, 107, 41 ] ], [ [ 9383, 9383 ], "disallowed_STD3_mapped", [ 40, 108, 41 ] ], [ [ 9384, 9384 ], "disallowed_STD3_mapped", [ 40, 109, 41 ] ], [ [ 9385, 9385 ], "disallowed_STD3_mapped", [ 40, 110, 41 ] ], [ [ 9386, 9386 ], "disallowed_STD3_mapped", [ 40, 111, 41 ] ], [ [ 9387, 9387 ], "disallowed_STD3_mapped", [ 40, 112, 41 ] ], [ [ 9388, 9388 ], "disallowed_STD3_mapped", [ 40, 113, 41 ] ], [ [ 9389, 9389 ], "disallowed_STD3_mapped", [ 40, 114, 41 ] ], [ [ 9390, 9390 ], "disallowed_STD3_mapped", [ 40, 115, 41 ] ], [ [ 9391, 9391 ], "disallowed_STD3_mapped", [ 40, 116, 41 ] ], [ [ 9392, 9392 ], "disallowed_STD3_mapped", [ 40, 117, 41 ] ], [ [ 9393, 9393 ], "disallowed_STD3_mapped", [ 40, 118, 41 ] ], [ [ 9394, 9394 ], "disallowed_STD3_mapped", [ 40, 119, 41 ] ], [ [ 9395, 9395 ], "disallowed_STD3_mapped", [ 40, 120, 41 ] ], [ [ 9396, 9396 ], "disallowed_STD3_mapped", [ 40, 121, 41 ] ], [ [ 9397, 9397 ], "disallowed_STD3_mapped", [ 40, 122, 41 ] ], [ [ 9398, 9398 ], "mapped", [ 97 ] ], [ [ 9399, 9399 ], "mapped", [ 98 ] ], [ [ 9400, 9400 ], "mapped", [ 99 ] ], [ [ 9401, 9401 ], "mapped", [ 100 ] ], [ [ 9402, 9402 ], "mapped", [ 101 ] ], [ [ 9403, 9403 ], "mapped", [ 102 ] ], [ [ 9404, 9404 ], "mapped", [ 103 ] ], [ [ 9405, 9405 ], "mapped", [ 104 ] ], [ [ 9406, 9406 ], "mapped", [ 105 ] ], [ [ 9407, 9407 ], "mapped", [ 106 ] ], [ [ 9408, 9408 ], "mapped", [ 107 ] ], [ [ 9409, 9409 ], "mapped", [ 108 ] ], [ [ 9410, 9410 ], "mapped", [ 109 ] ], [ [ 9411, 9411 ], "mapped", [ 110 ] ], [ [ 9412, 9412 ], "mapped", [ 111 ] ], [ [ 9413, 9413 ], "mapped", [ 112 ] ], [ [ 9414, 9414 ], "mapped", [ 113 ] ], [ [ 9415, 9415 ], "mapped", [ 114 ] ], [ [ 9416, 9416 ], "mapped", [ 115 ] ], [ [ 9417, 9417 ], "mapped", [ 116 ] ], [ [ 9418, 9418 ], "mapped", [ 117 ] ], [ [ 9419, 9419 ], "mapped", [ 118 ] ], [ [ 9420, 9420 ], "mapped", [ 119 ] ], [ [ 9421, 9421 ], "mapped", [ 120 ] ], [ [ 9422, 9422 ], "mapped", [ 121 ] ], [ [ 9423, 9423 ], "mapped", [ 122 ] ], [ [ 9424, 9424 ], "mapped", [ 97 ] ], [ [ 9425, 9425 ], "mapped", [ 98 ] ], [ [ 9426, 9426 ], "mapped", [ 99 ] ], [ [ 9427, 9427 ], "mapped", [ 100 ] ], [ [ 9428, 9428 ], "mapped", [ 101 ] ], [ [ 9429, 9429 ], "mapped", [ 102 ] ], [ [ 9430, 9430 ], "mapped", [ 103 ] ], [ [ 9431, 9431 ], "mapped", [ 104 ] ], [ [ 9432, 9432 ], "mapped", [ 105 ] ], [ [ 9433, 9433 ], "mapped", [ 106 ] ], [ [ 9434, 9434 ], "mapped", [ 107 ] ], [ [ 9435, 9435 ], "mapped", [ 108 ] ], [ [ 9436, 9436 ], "mapped", [ 109 ] ], [ [ 9437, 9437 ], "mapped", [ 110 ] ], [ [ 9438, 9438 ], "mapped", [ 111 ] ], [ [ 9439, 9439 ], "mapped", [ 112 ] ], [ [ 9440, 9440 ], "mapped", [ 113 ] ], [ [ 9441, 9441 ], "mapped", [ 114 ] ], [ [ 9442, 9442 ], "mapped", [ 115 ] ], [ [ 9443, 9443 ], "mapped", [ 116 ] ], [ [ 9444, 9444 ], "mapped", [ 117 ] ], [ [ 9445, 9445 ], "mapped", [ 118 ] ], [ [ 9446, 9446 ], "mapped", [ 119 ] ], [ [ 9447, 9447 ], "mapped", [ 120 ] ], [ [ 9448, 9448 ], "mapped", [ 121 ] ], [ [ 9449, 9449 ], "mapped", [ 122 ] ], [ [ 9450, 9450 ], "mapped", [ 48 ] ], [ [ 9451, 9470 ], "valid", [], "NV8" ], [ [ 9471, 9471 ], "valid", [], "NV8" ], [ [ 9472, 9621 ], "valid", [], "NV8" ], [ [ 9622, 9631 ], "valid", [], "NV8" ], [ [ 9632, 9711 ], "valid", [], "NV8" ], [ [ 9712, 9719 ], "valid", [], "NV8" ], [ [ 9720, 9727 ], "valid", [], "NV8" ], [ [ 9728, 9747 ], "valid", [], "NV8" ], [ [ 9748, 9749 ], "valid", [], "NV8" ], [ [ 9750, 9751 ], "valid", [], "NV8" ], [ [ 9752, 9752 ], "valid", [], "NV8" ], [ [ 9753, 9753 ], "valid", [], "NV8" ], [ [ 9754, 9839 ], "valid", [], "NV8" ], [ [ 9840, 9841 ], "valid", [], "NV8" ], [ [ 9842, 9853 ], "valid", [], "NV8" ], [ [ 9854, 9855 ], "valid", [], "NV8" ], [ [ 9856, 9865 ], "valid", [], "NV8" ], [ [ 9866, 9873 ], "valid", [], "NV8" ], [ [ 9874, 9884 ], "valid", [], "NV8" ], [ [ 9885, 9885 ], "valid", [], "NV8" ], [ [ 9886, 9887 ], "valid", [], "NV8" ], [ [ 9888, 9889 ], "valid", [], "NV8" ], [ [ 9890, 9905 ], "valid", [], "NV8" ], [ [ 9906, 9906 ], "valid", [], "NV8" ], [ [ 9907, 9916 ], "valid", [], "NV8" ], [ [ 9917, 9919 ], "valid", [], "NV8" ], [ [ 9920, 9923 ], "valid", [], "NV8" ], [ [ 9924, 9933 ], "valid", [], "NV8" ], [ [ 9934, 9934 ], "valid", [], "NV8" ], [ [ 9935, 9953 ], "valid", [], "NV8" ], [ [ 9954, 9954 ], "valid", [], "NV8" ], [ [ 9955, 9955 ], "valid", [], "NV8" ], [ [ 9956, 9959 ], "valid", [], "NV8" ], [ [ 9960, 9983 ], "valid", [], "NV8" ], [ [ 9984, 9984 ], "valid", [], "NV8" ], [ [ 9985, 9988 ], "valid", [], "NV8" ], [ [ 9989, 9989 ], "valid", [], "NV8" ], [ [ 9990, 9993 ], "valid", [], "NV8" ], [ [ 9994, 9995 ], "valid", [], "NV8" ], [ [ 9996, 10023 ], "valid", [], "NV8" ], [ [ 10024, 10024 ], "valid", [], "NV8" ], [ [ 10025, 10059 ], "valid", [], "NV8" ], [ [ 10060, 10060 ], "valid", [], "NV8" ], [ [ 10061, 10061 ], "valid", [], "NV8" ], [ [ 10062, 10062 ], "valid", [], "NV8" ], [ [ 10063, 10066 ], "valid", [], "NV8" ], [ [ 10067, 10069 ], "valid", [], "NV8" ], [ [ 10070, 10070 ], "valid", [], "NV8" ], [ [ 10071, 10071 ], "valid", [], "NV8" ], [ [ 10072, 10078 ], "valid", [], "NV8" ], [ [ 10079, 10080 ], "valid", [], "NV8" ], [ [ 10081, 10087 ], "valid", [], "NV8" ], [ [ 10088, 10101 ], "valid", [], "NV8" ], [ [ 10102, 10132 ], "valid", [], "NV8" ], [ [ 10133, 10135 ], "valid", [], "NV8" ], [ [ 10136, 10159 ], "valid", [], "NV8" ], [ [ 10160, 10160 ], "valid", [], "NV8" ], [ [ 10161, 10174 ], "valid", [], "NV8" ], [ [ 10175, 10175 ], "valid", [], "NV8" ], [ [ 10176, 10182 ], "valid", [], "NV8" ], [ [ 10183, 10186 ], "valid", [], "NV8" ], [ [ 10187, 10187 ], "valid", [], "NV8" ], [ [ 10188, 10188 ], "valid", [], "NV8" ], [ [ 10189, 10189 ], "valid", [], "NV8" ], [ [ 10190, 10191 ], "valid", [], "NV8" ], [ [ 10192, 10219 ], "valid", [], "NV8" ], [ [ 10220, 10223 ], "valid", [], "NV8" ], [ [ 10224, 10239 ], "valid", [], "NV8" ], [ [ 10240, 10495 ], "valid", [], "NV8" ], [ [ 10496, 10763 ], "valid", [], "NV8" ], [ [ 10764, 10764 ], "mapped", [ 8747, 8747, 8747, 8747 ] ], [ [ 10765, 10867 ], "valid", [], "NV8" ], [ [ 10868, 10868 ], "disallowed_STD3_mapped", [ 58, 58, 61 ] ], [ [ 10869, 10869 ], "disallowed_STD3_mapped", [ 61, 61 ] ], [ [ 10870, 10870 ], "disallowed_STD3_mapped", [ 61, 61, 61 ] ], [ [ 10871, 10971 ], "valid", [], "NV8" ], [ [ 10972, 10972 ], "mapped", [ 10973, 824 ] ], [ [ 10973, 11007 ], "valid", [], "NV8" ], [ [ 11008, 11021 ], "valid", [], "NV8" ], [ [ 11022, 11027 ], "valid", [], "NV8" ], [ [ 11028, 11034 ], "valid", [], "NV8" ], [ [ 11035, 11039 ], "valid", [], "NV8" ], [ [ 11040, 11043 ], "valid", [], "NV8" ], [ [ 11044, 11084 ], "valid", [], "NV8" ], [ [ 11085, 11087 ], "valid", [], "NV8" ], [ [ 11088, 11092 ], "valid", [], "NV8" ], [ [ 11093, 11097 ], "valid", [], "NV8" ], [ [ 11098, 11123 ], "valid", [], "NV8" ], [ [ 11124, 11125 ], "disallowed" ], [ [ 11126, 11157 ], "valid", [], "NV8" ], [ [ 11158, 11159 ], "disallowed" ], [ [ 11160, 11193 ], "valid", [], "NV8" ], [ [ 11194, 11196 ], "disallowed" ], [ [ 11197, 11208 ], "valid", [], "NV8" ], [ [ 11209, 11209 ], "disallowed" ], [ [ 11210, 11217 ], "valid", [], "NV8" ], [ [ 11218, 11243 ], "disallowed" ], [ [ 11244, 11247 ], "valid", [], "NV8" ], [ [ 11248, 11263 ], "disallowed" ], [ [ 11264, 11264 ], "mapped", [ 11312 ] ], [ [ 11265, 11265 ], "mapped", [ 11313 ] ], [ [ 11266, 11266 ], "mapped", [ 11314 ] ], [ [ 11267, 11267 ], "mapped", [ 11315 ] ], [ [ 11268, 11268 ], "mapped", [ 11316 ] ], [ [ 11269, 11269 ], "mapped", [ 11317 ] ], [ [ 11270, 11270 ], "mapped", [ 11318 ] ], [ [ 11271, 11271 ], "mapped", [ 11319 ] ], [ [ 11272, 11272 ], "mapped", [ 11320 ] ], [ [ 11273, 11273 ], "mapped", [ 11321 ] ], [ [ 11274, 11274 ], "mapped", [ 11322 ] ], [ [ 11275, 11275 ], "mapped", [ 11323 ] ], [ [ 11276, 11276 ], "mapped", [ 11324 ] ], [ [ 11277, 11277 ], "mapped", [ 11325 ] ], [ [ 11278, 11278 ], "mapped", [ 11326 ] ], [ [ 11279, 11279 ], "mapped", [ 11327 ] ], [ [ 11280, 11280 ], "mapped", [ 11328 ] ], [ [ 11281, 11281 ], "mapped", [ 11329 ] ], [ [ 11282, 11282 ], "mapped", [ 11330 ] ], [ [ 11283, 11283 ], "mapped", [ 11331 ] ], [ [ 11284, 11284 ], "mapped", [ 11332 ] ], [ [ 11285, 11285 ], "mapped", [ 11333 ] ], [ [ 11286, 11286 ], "mapped", [ 11334 ] ], [ [ 11287, 11287 ], "mapped", [ 11335 ] ], [ [ 11288, 11288 ], "mapped", [ 11336 ] ], [ [ 11289, 11289 ], "mapped", [ 11337 ] ], [ [ 11290, 11290 ], "mapped", [ 11338 ] ], [ [ 11291, 11291 ], "mapped", [ 11339 ] ], [ [ 11292, 11292 ], "mapped", [ 11340 ] ], [ [ 11293, 11293 ], "mapped", [ 11341 ] ], [ [ 11294, 11294 ], "mapped", [ 11342 ] ], [ [ 11295, 11295 ], "mapped", [ 11343 ] ], [ [ 11296, 11296 ], "mapped", [ 11344 ] ], [ [ 11297, 11297 ], "mapped", [ 11345 ] ], [ [ 11298, 11298 ], "mapped", [ 11346 ] ], [ [ 11299, 11299 ], "mapped", [ 11347 ] ], [ [ 11300, 11300 ], "mapped", [ 11348 ] ], [ [ 11301, 11301 ], "mapped", [ 11349 ] ], [ [ 11302, 11302 ], "mapped", [ 11350 ] ], [ [ 11303, 11303 ], "mapped", [ 11351 ] ], [ [ 11304, 11304 ], "mapped", [ 11352 ] ], [ [ 11305, 11305 ], "mapped", [ 11353 ] ], [ [ 11306, 11306 ], "mapped", [ 11354 ] ], [ [ 11307, 11307 ], "mapped", [ 11355 ] ], [ [ 11308, 11308 ], "mapped", [ 11356 ] ], [ [ 11309, 11309 ], "mapped", [ 11357 ] ], [ [ 11310, 11310 ], "mapped", [ 11358 ] ], [ [ 11311, 11311 ], "disallowed" ], [ [ 11312, 11358 ], "valid" ], [ [ 11359, 11359 ], "disallowed" ], [ [ 11360, 11360 ], "mapped", [ 11361 ] ], [ [ 11361, 11361 ], "valid" ], [ [ 11362, 11362 ], "mapped", [ 619 ] ], [ [ 11363, 11363 ], "mapped", [ 7549 ] ], [ [ 11364, 11364 ], "mapped", [ 637 ] ], [ [ 11365, 11366 ], "valid" ], [ [ 11367, 11367 ], "mapped", [ 11368 ] ], [ [ 11368, 11368 ], "valid" ], [ [ 11369, 11369 ], "mapped", [ 11370 ] ], [ [ 11370, 11370 ], "valid" ], [ [ 11371, 11371 ], "mapped", [ 11372 ] ], [ [ 11372, 11372 ], "valid" ], [ [ 11373, 11373 ], "mapped", [ 593 ] ], [ [ 11374, 11374 ], "mapped", [ 625 ] ], [ [ 11375, 11375 ], "mapped", [ 592 ] ], [ [ 11376, 11376 ], "mapped", [ 594 ] ], [ [ 11377, 11377 ], "valid" ], [ [ 11378, 11378 ], "mapped", [ 11379 ] ], [ [ 11379, 11379 ], "valid" ], [ [ 11380, 11380 ], "valid" ], [ [ 11381, 11381 ], "mapped", [ 11382 ] ], [ [ 11382, 11383 ], "valid" ], [ [ 11384, 11387 ], "valid" ], [ [ 11388, 11388 ], "mapped", [ 106 ] ], [ [ 11389, 11389 ], "mapped", [ 118 ] ], [ [ 11390, 11390 ], "mapped", [ 575 ] ], [ [ 11391, 11391 ], "mapped", [ 576 ] ], [ [ 11392, 11392 ], "mapped", [ 11393 ] ], [ [ 11393, 11393 ], "valid" ], [ [ 11394, 11394 ], "mapped", [ 11395 ] ], [ [ 11395, 11395 ], "valid" ], [ [ 11396, 11396 ], "mapped", [ 11397 ] ], [ [ 11397, 11397 ], "valid" ], [ [ 11398, 11398 ], "mapped", [ 11399 ] ], [ [ 11399, 11399 ], "valid" ], [ [ 11400, 11400 ], "mapped", [ 11401 ] ], [ [ 11401, 11401 ], "valid" ], [ [ 11402, 11402 ], "mapped", [ 11403 ] ], [ [ 11403, 11403 ], "valid" ], [ [ 11404, 11404 ], "mapped", [ 11405 ] ], [ [ 11405, 11405 ], "valid" ], [ [ 11406, 11406 ], "mapped", [ 11407 ] ], [ [ 11407, 11407 ], "valid" ], [ [ 11408, 11408 ], "mapped", [ 11409 ] ], [ [ 11409, 11409 ], "valid" ], [ [ 11410, 11410 ], "mapped", [ 11411 ] ], [ [ 11411, 11411 ], "valid" ], [ [ 11412, 11412 ], "mapped", [ 11413 ] ], [ [ 11413, 11413 ], "valid" ], [ [ 11414, 11414 ], "mapped", [ 11415 ] ], [ [ 11415, 11415 ], "valid" ], [ [ 11416, 11416 ], "mapped", [ 11417 ] ], [ [ 11417, 11417 ], "valid" ], [ [ 11418, 11418 ], "mapped", [ 11419 ] ], [ [ 11419, 11419 ], "valid" ], [ [ 11420, 11420 ], "mapped", [ 11421 ] ], [ [ 11421, 11421 ], "valid" ], [ [ 11422, 11422 ], "mapped", [ 11423 ] ], [ [ 11423, 11423 ], "valid" ], [ [ 11424, 11424 ], "mapped", [ 11425 ] ], [ [ 11425, 11425 ], "valid" ], [ [ 11426, 11426 ], "mapped", [ 11427 ] ], [ [ 11427, 11427 ], "valid" ], [ [ 11428, 11428 ], "mapped", [ 11429 ] ], [ [ 11429, 11429 ], "valid" ], [ [ 11430, 11430 ], "mapped", [ 11431 ] ], [ [ 11431, 11431 ], "valid" ], [ [ 11432, 11432 ], "mapped", [ 11433 ] ], [ [ 11433, 11433 ], "valid" ], [ [ 11434, 11434 ], "mapped", [ 11435 ] ], [ [ 11435, 11435 ], "valid" ], [ [ 11436, 11436 ], "mapped", [ 11437 ] ], [ [ 11437, 11437 ], "valid" ], [ [ 11438, 11438 ], "mapped", [ 11439 ] ], [ [ 11439, 11439 ], "valid" ], [ [ 11440, 11440 ], "mapped", [ 11441 ] ], [ [ 11441, 11441 ], "valid" ], [ [ 11442, 11442 ], "mapped", [ 11443 ] ], [ [ 11443, 11443 ], "valid" ], [ [ 11444, 11444 ], "mapped", [ 11445 ] ], [ [ 11445, 11445 ], "valid" ], [ [ 11446, 11446 ], "mapped", [ 11447 ] ], [ [ 11447, 11447 ], "valid" ], [ [ 11448, 11448 ], "mapped", [ 11449 ] ], [ [ 11449, 11449 ], "valid" ], [ [ 11450, 11450 ], "mapped", [ 11451 ] ], [ [ 11451, 11451 ], "valid" ], [ [ 11452, 11452 ], "mapped", [ 11453 ] ], [ [ 11453, 11453 ], "valid" ], [ [ 11454, 11454 ], "mapped", [ 11455 ] ], [ [ 11455, 11455 ], "valid" ], [ [ 11456, 11456 ], "mapped", [ 11457 ] ], [ [ 11457, 11457 ], "valid" ], [ [ 11458, 11458 ], "mapped", [ 11459 ] ], [ [ 11459, 11459 ], "valid" ], [ [ 11460, 11460 ], "mapped", [ 11461 ] ], [ [ 11461, 11461 ], "valid" ], [ [ 11462, 11462 ], "mapped", [ 11463 ] ], [ [ 11463, 11463 ], "valid" ], [ [ 11464, 11464 ], "mapped", [ 11465 ] ], [ [ 11465, 11465 ], "valid" ], [ [ 11466, 11466 ], "mapped", [ 11467 ] ], [ [ 11467, 11467 ], "valid" ], [ [ 11468, 11468 ], "mapped", [ 11469 ] ], [ [ 11469, 11469 ], "valid" ], [ [ 11470, 11470 ], "mapped", [ 11471 ] ], [ [ 11471, 11471 ], "valid" ], [ [ 11472, 11472 ], "mapped", [ 11473 ] ], [ [ 11473, 11473 ], "valid" ], [ [ 11474, 11474 ], "mapped", [ 11475 ] ], [ [ 11475, 11475 ], "valid" ], [ [ 11476, 11476 ], "mapped", [ 11477 ] ], [ [ 11477, 11477 ], "valid" ], [ [ 11478, 11478 ], "mapped", [ 11479 ] ], [ [ 11479, 11479 ], "valid" ], [ [ 11480, 11480 ], "mapped", [ 11481 ] ], [ [ 11481, 11481 ], "valid" ], [ [ 11482, 11482 ], "mapped", [ 11483 ] ], [ [ 11483, 11483 ], "valid" ], [ [ 11484, 11484 ], "mapped", [ 11485 ] ], [ [ 11485, 11485 ], "valid" ], [ [ 11486, 11486 ], "mapped", [ 11487 ] ], [ [ 11487, 11487 ], "valid" ], [ [ 11488, 11488 ], "mapped", [ 11489 ] ], [ [ 11489, 11489 ], "valid" ], [ [ 11490, 11490 ], "mapped", [ 11491 ] ], [ [ 11491, 11492 ], "valid" ], [ [ 11493, 11498 ], "valid", [], "NV8" ], [ [ 11499, 11499 ], "mapped", [ 11500 ] ], [ [ 11500, 11500 ], "valid" ], [ [ 11501, 11501 ], "mapped", [ 11502 ] ], [ [ 11502, 11505 ], "valid" ], [ [ 11506, 11506 ], "mapped", [ 11507 ] ], [ [ 11507, 11507 ], "valid" ], [ [ 11508, 11512 ], "disallowed" ], [ [ 11513, 11519 ], "valid", [], "NV8" ], [ [ 11520, 11557 ], "valid" ], [ [ 11558, 11558 ], "disallowed" ], [ [ 11559, 11559 ], "valid" ], [ [ 11560, 11564 ], "disallowed" ], [ [ 11565, 11565 ], "valid" ], [ [ 11566, 11567 ], "disallowed" ], [ [ 11568, 11621 ], "valid" ], [ [ 11622, 11623 ], "valid" ], [ [ 11624, 11630 ], "disallowed" ], [ [ 11631, 11631 ], "mapped", [ 11617 ] ], [ [ 11632, 11632 ], "valid", [], "NV8" ], [ [ 11633, 11646 ], "disallowed" ], [ [ 11647, 11647 ], "valid" ], [ [ 11648, 11670 ], "valid" ], [ [ 11671, 11679 ], "disallowed" ], [ [ 11680, 11686 ], "valid" ], [ [ 11687, 11687 ], "disallowed" ], [ [ 11688, 11694 ], "valid" ], [ [ 11695, 11695 ], "disallowed" ], [ [ 11696, 11702 ], "valid" ], [ [ 11703, 11703 ], "disallowed" ], [ [ 11704, 11710 ], "valid" ], [ [ 11711, 11711 ], "disallowed" ], [ [ 11712, 11718 ], "valid" ], [ [ 11719, 11719 ], "disallowed" ], [ [ 11720, 11726 ], "valid" ], [ [ 11727, 11727 ], "disallowed" ], [ [ 11728, 11734 ], "valid" ], [ [ 11735, 11735 ], "disallowed" ], [ [ 11736, 11742 ], "valid" ], [ [ 11743, 11743 ], "disallowed" ], [ [ 11744, 11775 ], "valid" ], [ [ 11776, 11799 ], "valid", [], "NV8" ], [ [ 11800, 11803 ], "valid", [], "NV8" ], [ [ 11804, 11805 ], "valid", [], "NV8" ], [ [ 11806, 11822 ], "valid", [], "NV8" ], [ [ 11823, 11823 ], "valid" ], [ [ 11824, 11824 ], "valid", [], "NV8" ], [ [ 11825, 11825 ], "valid", [], "NV8" ], [ [ 11826, 11835 ], "valid", [], "NV8" ], [ [ 11836, 11842 ], "valid", [], "NV8" ], [ [ 11843, 11903 ], "disallowed" ], [ [ 11904, 11929 ], "valid", [], "NV8" ], [ [ 11930, 11930 ], "disallowed" ], [ [ 11931, 11934 ], "valid", [], "NV8" ], [ [ 11935, 11935 ], "mapped", [ 27597 ] ], [ [ 11936, 12018 ], "valid", [], "NV8" ], [ [ 12019, 12019 ], "mapped", [ 40863 ] ], [ [ 12020, 12031 ], "disallowed" ], [ [ 12032, 12032 ], "mapped", [ 19968 ] ], [ [ 12033, 12033 ], "mapped", [ 20008 ] ], [ [ 12034, 12034 ], "mapped", [ 20022 ] ], [ [ 12035, 12035 ], "mapped", [ 20031 ] ], [ [ 12036, 12036 ], "mapped", [ 20057 ] ], [ [ 12037, 12037 ], "mapped", [ 20101 ] ], [ [ 12038, 12038 ], "mapped", [ 20108 ] ], [ [ 12039, 12039 ], "mapped", [ 20128 ] ], [ [ 12040, 12040 ], "mapped", [ 20154 ] ], [ [ 12041, 12041 ], "mapped", [ 20799 ] ], [ [ 12042, 12042 ], "mapped", [ 20837 ] ], [ [ 12043, 12043 ], "mapped", [ 20843 ] ], [ [ 12044, 12044 ], "mapped", [ 20866 ] ], [ [ 12045, 12045 ], "mapped", [ 20886 ] ], [ [ 12046, 12046 ], "mapped", [ 20907 ] ], [ [ 12047, 12047 ], "mapped", [ 20960 ] ], [ [ 12048, 12048 ], "mapped", [ 20981 ] ], [ [ 12049, 12049 ], "mapped", [ 20992 ] ], [ [ 12050, 12050 ], "mapped", [ 21147 ] ], [ [ 12051, 12051 ], "mapped", [ 21241 ] ], [ [ 12052, 12052 ], "mapped", [ 21269 ] ], [ [ 12053, 12053 ], "mapped", [ 21274 ] ], [ [ 12054, 12054 ], "mapped", [ 21304 ] ], [ [ 12055, 12055 ], "mapped", [ 21313 ] ], [ [ 12056, 12056 ], "mapped", [ 21340 ] ], [ [ 12057, 12057 ], "mapped", [ 21353 ] ], [ [ 12058, 12058 ], "mapped", [ 21378 ] ], [ [ 12059, 12059 ], "mapped", [ 21430 ] ], [ [ 12060, 12060 ], "mapped", [ 21448 ] ], [ [ 12061, 12061 ], "mapped", [ 21475 ] ], [ [ 12062, 12062 ], "mapped", [ 22231 ] ], [ [ 12063, 12063 ], "mapped", [ 22303 ] ], [ [ 12064, 12064 ], "mapped", [ 22763 ] ], [ [ 12065, 12065 ], "mapped", [ 22786 ] ], [ [ 12066, 12066 ], "mapped", [ 22794 ] ], [ [ 12067, 12067 ], "mapped", [ 22805 ] ], [ [ 12068, 12068 ], "mapped", [ 22823 ] ], [ [ 12069, 12069 ], "mapped", [ 22899 ] ], [ [ 12070, 12070 ], "mapped", [ 23376 ] ], [ [ 12071, 12071 ], "mapped", [ 23424 ] ], [ [ 12072, 12072 ], "mapped", [ 23544 ] ], [ [ 12073, 12073 ], "mapped", [ 23567 ] ], [ [ 12074, 12074 ], "mapped", [ 23586 ] ], [ [ 12075, 12075 ], "mapped", [ 23608 ] ], [ [ 12076, 12076 ], "mapped", [ 23662 ] ], [ [ 12077, 12077 ], "mapped", [ 23665 ] ], [ [ 12078, 12078 ], "mapped", [ 24027 ] ], [ [ 12079, 12079 ], "mapped", [ 24037 ] ], [ [ 12080, 12080 ], "mapped", [ 24049 ] ], [ [ 12081, 12081 ], "mapped", [ 24062 ] ], [ [ 12082, 12082 ], "mapped", [ 24178 ] ], [ [ 12083, 12083 ], "mapped", [ 24186 ] ], [ [ 12084, 12084 ], "mapped", [ 24191 ] ], [ [ 12085, 12085 ], "mapped", [ 24308 ] ], [ [ 12086, 12086 ], "mapped", [ 24318 ] ], [ [ 12087, 12087 ], "mapped", [ 24331 ] ], [ [ 12088, 12088 ], "mapped", [ 24339 ] ], [ [ 12089, 12089 ], "mapped", [ 24400 ] ], [ [ 12090, 12090 ], "mapped", [ 24417 ] ], [ [ 12091, 12091 ], "mapped", [ 24435 ] ], [ [ 12092, 12092 ], "mapped", [ 24515 ] ], [ [ 12093, 12093 ], "mapped", [ 25096 ] ], [ [ 12094, 12094 ], "mapped", [ 25142 ] ], [ [ 12095, 12095 ], "mapped", [ 25163 ] ], [ [ 12096, 12096 ], "mapped", [ 25903 ] ], [ [ 12097, 12097 ], "mapped", [ 25908 ] ], [ [ 12098, 12098 ], "mapped", [ 25991 ] ], [ [ 12099, 12099 ], "mapped", [ 26007 ] ], [ [ 12100, 12100 ], "mapped", [ 26020 ] ], [ [ 12101, 12101 ], "mapped", [ 26041 ] ], [ [ 12102, 12102 ], "mapped", [ 26080 ] ], [ [ 12103, 12103 ], "mapped", [ 26085 ] ], [ [ 12104, 12104 ], "mapped", [ 26352 ] ], [ [ 12105, 12105 ], "mapped", [ 26376 ] ], [ [ 12106, 12106 ], "mapped", [ 26408 ] ], [ [ 12107, 12107 ], "mapped", [ 27424 ] ], [ [ 12108, 12108 ], "mapped", [ 27490 ] ], [ [ 12109, 12109 ], "mapped", [ 27513 ] ], [ [ 12110, 12110 ], "mapped", [ 27571 ] ], [ [ 12111, 12111 ], "mapped", [ 27595 ] ], [ [ 12112, 12112 ], "mapped", [ 27604 ] ], [ [ 12113, 12113 ], "mapped", [ 27611 ] ], [ [ 12114, 12114 ], "mapped", [ 27663 ] ], [ [ 12115, 12115 ], "mapped", [ 27668 ] ], [ [ 12116, 12116 ], "mapped", [ 27700 ] ], [ [ 12117, 12117 ], "mapped", [ 28779 ] ], [ [ 12118, 12118 ], "mapped", [ 29226 ] ], [ [ 12119, 12119 ], "mapped", [ 29238 ] ], [ [ 12120, 12120 ], "mapped", [ 29243 ] ], [ [ 12121, 12121 ], "mapped", [ 29247 ] ], [ [ 12122, 12122 ], "mapped", [ 29255 ] ], [ [ 12123, 12123 ], "mapped", [ 29273 ] ], [ [ 12124, 12124 ], "mapped", [ 29275 ] ], [ [ 12125, 12125 ], "mapped", [ 29356 ] ], [ [ 12126, 12126 ], "mapped", [ 29572 ] ], [ [ 12127, 12127 ], "mapped", [ 29577 ] ], [ [ 12128, 12128 ], "mapped", [ 29916 ] ], [ [ 12129, 12129 ], "mapped", [ 29926 ] ], [ [ 12130, 12130 ], "mapped", [ 29976 ] ], [ [ 12131, 12131 ], "mapped", [ 29983 ] ], [ [ 12132, 12132 ], "mapped", [ 29992 ] ], [ [ 12133, 12133 ], "mapped", [ 3e4 ] ], [ [ 12134, 12134 ], "mapped", [ 30091 ] ], [ [ 12135, 12135 ], "mapped", [ 30098 ] ], [ [ 12136, 12136 ], "mapped", [ 30326 ] ], [ [ 12137, 12137 ], "mapped", [ 30333 ] ], [ [ 12138, 12138 ], "mapped", [ 30382 ] ], [ [ 12139, 12139 ], "mapped", [ 30399 ] ], [ [ 12140, 12140 ], "mapped", [ 30446 ] ], [ [ 12141, 12141 ], "mapped", [ 30683 ] ], [ [ 12142, 12142 ], "mapped", [ 30690 ] ], [ [ 12143, 12143 ], "mapped", [ 30707 ] ], [ [ 12144, 12144 ], "mapped", [ 31034 ] ], [ [ 12145, 12145 ], "mapped", [ 31160 ] ], [ [ 12146, 12146 ], "mapped", [ 31166 ] ], [ [ 12147, 12147 ], "mapped", [ 31348 ] ], [ [ 12148, 12148 ], "mapped", [ 31435 ] ], [ [ 12149, 12149 ], "mapped", [ 31481 ] ], [ [ 12150, 12150 ], "mapped", [ 31859 ] ], [ [ 12151, 12151 ], "mapped", [ 31992 ] ], [ [ 12152, 12152 ], "mapped", [ 32566 ] ], [ [ 12153, 12153 ], "mapped", [ 32593 ] ], [ [ 12154, 12154 ], "mapped", [ 32650 ] ], [ [ 12155, 12155 ], "mapped", [ 32701 ] ], [ [ 12156, 12156 ], "mapped", [ 32769 ] ], [ [ 12157, 12157 ], "mapped", [ 32780 ] ], [ [ 12158, 12158 ], "mapped", [ 32786 ] ], [ [ 12159, 12159 ], "mapped", [ 32819 ] ], [ [ 12160, 12160 ], "mapped", [ 32895 ] ], [ [ 12161, 12161 ], "mapped", [ 32905 ] ], [ [ 12162, 12162 ], "mapped", [ 33251 ] ], [ [ 12163, 12163 ], "mapped", [ 33258 ] ], [ [ 12164, 12164 ], "mapped", [ 33267 ] ], [ [ 12165, 12165 ], "mapped", [ 33276 ] ], [ [ 12166, 12166 ], "mapped", [ 33292 ] ], [ [ 12167, 12167 ], "mapped", [ 33307 ] ], [ [ 12168, 12168 ], "mapped", [ 33311 ] ], [ [ 12169, 12169 ], "mapped", [ 33390 ] ], [ [ 12170, 12170 ], "mapped", [ 33394 ] ], [ [ 12171, 12171 ], "mapped", [ 33400 ] ], [ [ 12172, 12172 ], "mapped", [ 34381 ] ], [ [ 12173, 12173 ], "mapped", [ 34411 ] ], [ [ 12174, 12174 ], "mapped", [ 34880 ] ], [ [ 12175, 12175 ], "mapped", [ 34892 ] ], [ [ 12176, 12176 ], "mapped", [ 34915 ] ], [ [ 12177, 12177 ], "mapped", [ 35198 ] ], [ [ 12178, 12178 ], "mapped", [ 35211 ] ], [ [ 12179, 12179 ], "mapped", [ 35282 ] ], [ [ 12180, 12180 ], "mapped", [ 35328 ] ], [ [ 12181, 12181 ], "mapped", [ 35895 ] ], [ [ 12182, 12182 ], "mapped", [ 35910 ] ], [ [ 12183, 12183 ], "mapped", [ 35925 ] ], [ [ 12184, 12184 ], "mapped", [ 35960 ] ], [ [ 12185, 12185 ], "mapped", [ 35997 ] ], [ [ 12186, 12186 ], "mapped", [ 36196 ] ], [ [ 12187, 12187 ], "mapped", [ 36208 ] ], [ [ 12188, 12188 ], "mapped", [ 36275 ] ], [ [ 12189, 12189 ], "mapped", [ 36523 ] ], [ [ 12190, 12190 ], "mapped", [ 36554 ] ], [ [ 12191, 12191 ], "mapped", [ 36763 ] ], [ [ 12192, 12192 ], "mapped", [ 36784 ] ], [ [ 12193, 12193 ], "mapped", [ 36789 ] ], [ [ 12194, 12194 ], "mapped", [ 37009 ] ], [ [ 12195, 12195 ], "mapped", [ 37193 ] ], [ [ 12196, 12196 ], "mapped", [ 37318 ] ], [ [ 12197, 12197 ], "mapped", [ 37324 ] ], [ [ 12198, 12198 ], "mapped", [ 37329 ] ], [ [ 12199, 12199 ], "mapped", [ 38263 ] ], [ [ 12200, 12200 ], "mapped", [ 38272 ] ], [ [ 12201, 12201 ], "mapped", [ 38428 ] ], [ [ 12202, 12202 ], "mapped", [ 38582 ] ], [ [ 12203, 12203 ], "mapped", [ 38585 ] ], [ [ 12204, 12204 ], "mapped", [ 38632 ] ], [ [ 12205, 12205 ], "mapped", [ 38737 ] ], [ [ 12206, 12206 ], "mapped", [ 38750 ] ], [ [ 12207, 12207 ], "mapped", [ 38754 ] ], [ [ 12208, 12208 ], "mapped", [ 38761 ] ], [ [ 12209, 12209 ], "mapped", [ 38859 ] ], [ [ 12210, 12210 ], "mapped", [ 38893 ] ], [ [ 12211, 12211 ], "mapped", [ 38899 ] ], [ [ 12212, 12212 ], "mapped", [ 38913 ] ], [ [ 12213, 12213 ], "mapped", [ 39080 ] ], [ [ 12214, 12214 ], "mapped", [ 39131 ] ], [ [ 12215, 12215 ], "mapped", [ 39135 ] ], [ [ 12216, 12216 ], "mapped", [ 39318 ] ], [ [ 12217, 12217 ], "mapped", [ 39321 ] ], [ [ 12218, 12218 ], "mapped", [ 39340 ] ], [ [ 12219, 12219 ], "mapped", [ 39592 ] ], [ [ 12220, 12220 ], "mapped", [ 39640 ] ], [ [ 12221, 12221 ], "mapped", [ 39647 ] ], [ [ 12222, 12222 ], "mapped", [ 39717 ] ], [ [ 12223, 12223 ], "mapped", [ 39727 ] ], [ [ 12224, 12224 ], "mapped", [ 39730 ] ], [ [ 12225, 12225 ], "mapped", [ 39740 ] ], [ [ 12226, 12226 ], "mapped", [ 39770 ] ], [ [ 12227, 12227 ], "mapped", [ 40165 ] ], [ [ 12228, 12228 ], "mapped", [ 40565 ] ], [ [ 12229, 12229 ], "mapped", [ 40575 ] ], [ [ 12230, 12230 ], "mapped", [ 40613 ] ], [ [ 12231, 12231 ], "mapped", [ 40635 ] ], [ [ 12232, 12232 ], "mapped", [ 40643 ] ], [ [ 12233, 12233 ], "mapped", [ 40653 ] ], [ [ 12234, 12234 ], "mapped", [ 40657 ] ], [ [ 12235, 12235 ], "mapped", [ 40697 ] ], [ [ 12236, 12236 ], "mapped", [ 40701 ] ], [ [ 12237, 12237 ], "mapped", [ 40718 ] ], [ [ 12238, 12238 ], "mapped", [ 40723 ] ], [ [ 12239, 12239 ], "mapped", [ 40736 ] ], [ [ 12240, 12240 ], "mapped", [ 40763 ] ], [ [ 12241, 12241 ], "mapped", [ 40778 ] ], [ [ 12242, 12242 ], "mapped", [ 40786 ] ], [ [ 12243, 12243 ], "mapped", [ 40845 ] ], [ [ 12244, 12244 ], "mapped", [ 40860 ] ], [ [ 12245, 12245 ], "mapped", [ 40864 ] ], [ [ 12246, 12271 ], "disallowed" ], [ [ 12272, 12283 ], "disallowed" ], [ [ 12284, 12287 ], "disallowed" ], [ [ 12288, 12288 ], "disallowed_STD3_mapped", [ 32 ] ], [ [ 12289, 12289 ], "valid", [], "NV8" ], [ [ 12290, 12290 ], "mapped", [ 46 ] ], [ [ 12291, 12292 ], "valid", [], "NV8" ], [ [ 12293, 12295 ], "valid" ], [ [ 12296, 12329 ], "valid", [], "NV8" ], [ [ 12330, 12333 ], "valid" ], [ [ 12334, 12341 ], "valid", [], "NV8" ], [ [ 12342, 12342 ], "mapped", [ 12306 ] ], [ [ 12343, 12343 ], "valid", [], "NV8" ], [ [ 12344, 12344 ], "mapped", [ 21313 ] ], [ [ 12345, 12345 ], "mapped", [ 21316 ] ], [ [ 12346, 12346 ], "mapped", [ 21317 ] ], [ [ 12347, 12347 ], "valid", [], "NV8" ], [ [ 12348, 12348 ], "valid" ], [ [ 12349, 12349 ], "valid", [], "NV8" ], [ [ 12350, 12350 ], "valid", [], "NV8" ], [ [ 12351, 12351 ], "valid", [], "NV8" ], [ [ 12352, 12352 ], "disallowed" ], [ [ 12353, 12436 ], "valid" ], [ [ 12437, 12438 ], "valid" ], [ [ 12439, 12440 ], "disallowed" ], [ [ 12441, 12442 ], "valid" ], [ [ 12443, 12443 ], "disallowed_STD3_mapped", [ 32, 12441 ] ], [ [ 12444, 12444 ], "disallowed_STD3_mapped", [ 32, 12442 ] ], [ [ 12445, 12446 ], "valid" ], [ [ 12447, 12447 ], "mapped", [ 12424, 12426 ] ], [ [ 12448, 12448 ], "valid", [], "NV8" ], [ [ 12449, 12542 ], "valid" ], [ [ 12543, 12543 ], "mapped", [ 12467, 12488 ] ], [ [ 12544, 12548 ], "disallowed" ], [ [ 12549, 12588 ], "valid" ], [ [ 12589, 12589 ], "valid" ], [ [ 12590, 12592 ], "disallowed" ], [ [ 12593, 12593 ], "mapped", [ 4352 ] ], [ [ 12594, 12594 ], "mapped", [ 4353 ] ], [ [ 12595, 12595 ], "mapped", [ 4522 ] ], [ [ 12596, 12596 ], "mapped", [ 4354 ] ], [ [ 12597, 12597 ], "mapped", [ 4524 ] ], [ [ 12598, 12598 ], "mapped", [ 4525 ] ], [ [ 12599, 12599 ], "mapped", [ 4355 ] ], [ [ 12600, 12600 ], "mapped", [ 4356 ] ], [ [ 12601, 12601 ], "mapped", [ 4357 ] ], [ [ 12602, 12602 ], "mapped", [ 4528 ] ], [ [ 12603, 12603 ], "mapped", [ 4529 ] ], [ [ 12604, 12604 ], "mapped", [ 4530 ] ], [ [ 12605, 12605 ], "mapped", [ 4531 ] ], [ [ 12606, 12606 ], "mapped", [ 4532 ] ], [ [ 12607, 12607 ], "mapped", [ 4533 ] ], [ [ 12608, 12608 ], "mapped", [ 4378 ] ], [ [ 12609, 12609 ], "mapped", [ 4358 ] ], [ [ 12610, 12610 ], "mapped", [ 4359 ] ], [ [ 12611, 12611 ], "mapped", [ 4360 ] ], [ [ 12612, 12612 ], "mapped", [ 4385 ] ], [ [ 12613, 12613 ], "mapped", [ 4361 ] ], [ [ 12614, 12614 ], "mapped", [ 4362 ] ], [ [ 12615, 12615 ], "mapped", [ 4363 ] ], [ [ 12616, 12616 ], "mapped", [ 4364 ] ], [ [ 12617, 12617 ], "mapped", [ 4365 ] ], [ [ 12618, 12618 ], "mapped", [ 4366 ] ], [ [ 12619, 12619 ], "mapped", [ 4367 ] ], [ [ 12620, 12620 ], "mapped", [ 4368 ] ], [ [ 12621, 12621 ], "mapped", [ 4369 ] ], [ [ 12622, 12622 ], "mapped", [ 4370 ] ], [ [ 12623, 12623 ], "mapped", [ 4449 ] ], [ [ 12624, 12624 ], "mapped", [ 4450 ] ], [ [ 12625, 12625 ], "mapped", [ 4451 ] ], [ [ 12626, 12626 ], "mapped", [ 4452 ] ], [ [ 12627, 12627 ], "mapped", [ 4453 ] ], [ [ 12628, 12628 ], "mapped", [ 4454 ] ], [ [ 12629, 12629 ], "mapped", [ 4455 ] ], [ [ 12630, 12630 ], "mapped", [ 4456 ] ], [ [ 12631, 12631 ], "mapped", [ 4457 ] ], [ [ 12632, 12632 ], "mapped", [ 4458 ] ], [ [ 12633, 12633 ], "mapped", [ 4459 ] ], [ [ 12634, 12634 ], "mapped", [ 4460 ] ], [ [ 12635, 12635 ], "mapped", [ 4461 ] ], [ [ 12636, 12636 ], "mapped", [ 4462 ] ], [ [ 12637, 12637 ], "mapped", [ 4463 ] ], [ [ 12638, 12638 ], "mapped", [ 4464 ] ], [ [ 12639, 12639 ], "mapped", [ 4465 ] ], [ [ 12640, 12640 ], "mapped", [ 4466 ] ], [ [ 12641, 12641 ], "mapped", [ 4467 ] ], [ [ 12642, 12642 ], "mapped", [ 4468 ] ], [ [ 12643, 12643 ], "mapped", [ 4469 ] ], [ [ 12644, 12644 ], "disallowed" ], [ [ 12645, 12645 ], "mapped", [ 4372 ] ], [ [ 12646, 12646 ], "mapped", [ 4373 ] ], [ [ 12647, 12647 ], "mapped", [ 4551 ] ], [ [ 12648, 12648 ], "mapped", [ 4552 ] ], [ [ 12649, 12649 ], "mapped", [ 4556 ] ], [ [ 12650, 12650 ], "mapped", [ 4558 ] ], [ [ 12651, 12651 ], "mapped", [ 4563 ] ], [ [ 12652, 12652 ], "mapped", [ 4567 ] ], [ [ 12653, 12653 ], "mapped", [ 4569 ] ], [ [ 12654, 12654 ], "mapped", [ 4380 ] ], [ [ 12655, 12655 ], "mapped", [ 4573 ] ], [ [ 12656, 12656 ], "mapped", [ 4575 ] ], [ [ 12657, 12657 ], "mapped", [ 4381 ] ], [ [ 12658, 12658 ], "mapped", [ 4382 ] ], [ [ 12659, 12659 ], "mapped", [ 4384 ] ], [ [ 12660, 12660 ], "mapped", [ 4386 ] ], [ [ 12661, 12661 ], "mapped", [ 4387 ] ], [ [ 12662, 12662 ], "mapped", [ 4391 ] ], [ [ 12663, 12663 ], "mapped", [ 4393 ] ], [ [ 12664, 12664 ], "mapped", [ 4395 ] ], [ [ 12665, 12665 ], "mapped", [ 4396 ] ], [ [ 12666, 12666 ], "mapped", [ 4397 ] ], [ [ 12667, 12667 ], "mapped", [ 4398 ] ], [ [ 12668, 12668 ], "mapped", [ 4399 ] ], [ [ 12669, 12669 ], "mapped", [ 4402 ] ], [ [ 12670, 12670 ], "mapped", [ 4406 ] ], [ [ 12671, 12671 ], "mapped", [ 4416 ] ], [ [ 12672, 12672 ], "mapped", [ 4423 ] ], [ [ 12673, 12673 ], "mapped", [ 4428 ] ], [ [ 12674, 12674 ], "mapped", [ 4593 ] ], [ [ 12675, 12675 ], "mapped", [ 4594 ] ], [ [ 12676, 12676 ], "mapped", [ 4439 ] ], [ [ 12677, 12677 ], "mapped", [ 4440 ] ], [ [ 12678, 12678 ], "mapped", [ 4441 ] ], [ [ 12679, 12679 ], "mapped", [ 4484 ] ], [ [ 12680, 12680 ], "mapped", [ 4485 ] ], [ [ 12681, 12681 ], "mapped", [ 4488 ] ], [ [ 12682, 12682 ], "mapped", [ 4497 ] ], [ [ 12683, 12683 ], "mapped", [ 4498 ] ], [ [ 12684, 12684 ], "mapped", [ 4500 ] ], [ [ 12685, 12685 ], "mapped", [ 4510 ] ], [ [ 12686, 12686 ], "mapped", [ 4513 ] ], [ [ 12687, 12687 ], "disallowed" ], [ [ 12688, 12689 ], "valid", [], "NV8" ], [ [ 12690, 12690 ], "mapped", [ 19968 ] ], [ [ 12691, 12691 ], "mapped", [ 20108 ] ], [ [ 12692, 12692 ], "mapped", [ 19977 ] ], [ [ 12693, 12693 ], "mapped", [ 22235 ] ], [ [ 12694, 12694 ], "mapped", [ 19978 ] ], [ [ 12695, 12695 ], "mapped", [ 20013 ] ], [ [ 12696, 12696 ], "mapped", [ 19979 ] ], [ [ 12697, 12697 ], "mapped", [ 30002 ] ], [ [ 12698, 12698 ], "mapped", [ 20057 ] ], [ [ 12699, 12699 ], "mapped", [ 19993 ] ], [ [ 12700, 12700 ], "mapped", [ 19969 ] ], [ [ 12701, 12701 ], "mapped", [ 22825 ] ], [ [ 12702, 12702 ], "mapped", [ 22320 ] ], [ [ 12703, 12703 ], "mapped", [ 20154 ] ], [ [ 12704, 12727 ], "valid" ], [ [ 12728, 12730 ], "valid" ], [ [ 12731, 12735 ], "disallowed" ], [ [ 12736, 12751 ], "valid", [], "NV8" ], [ [ 12752, 12771 ], "valid", [], "NV8" ], [ [ 12772, 12783 ], "disallowed" ], [ [ 12784, 12799 ], "valid" ], [ [ 12800, 12800 ], "disallowed_STD3_mapped", [ 40, 4352, 41 ] ], [ [ 12801, 12801 ], "disallowed_STD3_mapped", [ 40, 4354, 41 ] ], [ [ 12802, 12802 ], "disallowed_STD3_mapped", [ 40, 4355, 41 ] ], [ [ 12803, 12803 ], "disallowed_STD3_mapped", [ 40, 4357, 41 ] ], [ [ 12804, 12804 ], "disallowed_STD3_mapped", [ 40, 4358, 41 ] ], [ [ 12805, 12805 ], "disallowed_STD3_mapped", [ 40, 4359, 41 ] ], [ [ 12806, 12806 ], "disallowed_STD3_mapped", [ 40, 4361, 41 ] ], [ [ 12807, 12807 ], "disallowed_STD3_mapped", [ 40, 4363, 41 ] ], [ [ 12808, 12808 ], "disallowed_STD3_mapped", [ 40, 4364, 41 ] ], [ [ 12809, 12809 ], "disallowed_STD3_mapped", [ 40, 4366, 41 ] ], [ [ 12810, 12810 ], "disallowed_STD3_mapped", [ 40, 4367, 41 ] ], [ [ 12811, 12811 ], "disallowed_STD3_mapped", [ 40, 4368, 41 ] ], [ [ 12812, 12812 ], "disallowed_STD3_mapped", [ 40, 4369, 41 ] ], [ [ 12813, 12813 ], "disallowed_STD3_mapped", [ 40, 4370, 41 ] ], [ [ 12814, 12814 ], "disallowed_STD3_mapped", [ 40, 44032, 41 ] ], [ [ 12815, 12815 ], "disallowed_STD3_mapped", [ 40, 45208, 41 ] ], [ [ 12816, 12816 ], "disallowed_STD3_mapped", [ 40, 45796, 41 ] ], [ [ 12817, 12817 ], "disallowed_STD3_mapped", [ 40, 46972, 41 ] ], [ [ 12818, 12818 ], "disallowed_STD3_mapped", [ 40, 47560, 41 ] ], [ [ 12819, 12819 ], "disallowed_STD3_mapped", [ 40, 48148, 41 ] ], [ [ 12820, 12820 ], "disallowed_STD3_mapped", [ 40, 49324, 41 ] ], [ [ 12821, 12821 ], "disallowed_STD3_mapped", [ 40, 50500, 41 ] ], [ [ 12822, 12822 ], "disallowed_STD3_mapped", [ 40, 51088, 41 ] ], [ [ 12823, 12823 ], "disallowed_STD3_mapped", [ 40, 52264, 41 ] ], [ [ 12824, 12824 ], "disallowed_STD3_mapped", [ 40, 52852, 41 ] ], [ [ 12825, 12825 ], "disallowed_STD3_mapped", [ 40, 53440, 41 ] ], [ [ 12826, 12826 ], "disallowed_STD3_mapped", [ 40, 54028, 41 ] ], [ [ 12827, 12827 ], "disallowed_STD3_mapped", [ 40, 54616, 41 ] ], [ [ 12828, 12828 ], "disallowed_STD3_mapped", [ 40, 51452, 41 ] ], [ [ 12829, 12829 ], "disallowed_STD3_mapped", [ 40, 50724, 51204, 41 ] ], [ [ 12830, 12830 ], "disallowed_STD3_mapped", [ 40, 50724, 54980, 41 ] ], [ [ 12831, 12831 ], "disallowed" ], [ [ 12832, 12832 ], "disallowed_STD3_mapped", [ 40, 19968, 41 ] ], [ [ 12833, 12833 ], "disallowed_STD3_mapped", [ 40, 20108, 41 ] ], [ [ 12834, 12834 ], "disallowed_STD3_mapped", [ 40, 19977, 41 ] ], [ [ 12835, 12835 ], "disallowed_STD3_mapped", [ 40, 22235, 41 ] ], [ [ 12836, 12836 ], "disallowed_STD3_mapped", [ 40, 20116, 41 ] ], [ [ 12837, 12837 ], "disallowed_STD3_mapped", [ 40, 20845, 41 ] ], [ [ 12838, 12838 ], "disallowed_STD3_mapped", [ 40, 19971, 41 ] ], [ [ 12839, 12839 ], "disallowed_STD3_mapped", [ 40, 20843, 41 ] ], [ [ 12840, 12840 ], "disallowed_STD3_mapped", [ 40, 20061, 41 ] ], [ [ 12841, 12841 ], "disallowed_STD3_mapped", [ 40, 21313, 41 ] ], [ [ 12842, 12842 ], "disallowed_STD3_mapped", [ 40, 26376, 41 ] ], [ [ 12843, 12843 ], "disallowed_STD3_mapped", [ 40, 28779, 41 ] ], [ [ 12844, 12844 ], "disallowed_STD3_mapped", [ 40, 27700, 41 ] ], [ [ 12845, 12845 ], "disallowed_STD3_mapped", [ 40, 26408, 41 ] ], [ [ 12846, 12846 ], "disallowed_STD3_mapped", [ 40, 37329, 41 ] ], [ [ 12847, 12847 ], "disallowed_STD3_mapped", [ 40, 22303, 41 ] ], [ [ 12848, 12848 ], "disallowed_STD3_mapped", [ 40, 26085, 41 ] ], [ [ 12849, 12849 ], "disallowed_STD3_mapped", [ 40, 26666, 41 ] ], [ [ 12850, 12850 ], "disallowed_STD3_mapped", [ 40, 26377, 41 ] ], [ [ 12851, 12851 ], "disallowed_STD3_mapped", [ 40, 31038, 41 ] ], [ [ 12852, 12852 ], "disallowed_STD3_mapped", [ 40, 21517, 41 ] ], [ [ 12853, 12853 ], "disallowed_STD3_mapped", [ 40, 29305, 41 ] ], [ [ 12854, 12854 ], "disallowed_STD3_mapped", [ 40, 36001, 41 ] ], [ [ 12855, 12855 ], "disallowed_STD3_mapped", [ 40, 31069, 41 ] ], [ [ 12856, 12856 ], "disallowed_STD3_mapped", [ 40, 21172, 41 ] ], [ [ 12857, 12857 ], "disallowed_STD3_mapped", [ 40, 20195, 41 ] ], [ [ 12858, 12858 ], "disallowed_STD3_mapped", [ 40, 21628, 41 ] ], [ [ 12859, 12859 ], "disallowed_STD3_mapped", [ 40, 23398, 41 ] ], [ [ 12860, 12860 ], "disallowed_STD3_mapped", [ 40, 30435, 41 ] ], [ [ 12861, 12861 ], "disallowed_STD3_mapped", [ 40, 20225, 41 ] ], [ [ 12862, 12862 ], "disallowed_STD3_mapped", [ 40, 36039, 41 ] ], [ [ 12863, 12863 ], "disallowed_STD3_mapped", [ 40, 21332, 41 ] ], [ [ 12864, 12864 ], "disallowed_STD3_mapped", [ 40, 31085, 41 ] ], [ [ 12865, 12865 ], "disallowed_STD3_mapped", [ 40, 20241, 41 ] ], [ [ 12866, 12866 ], "disallowed_STD3_mapped", [ 40, 33258, 41 ] ], [ [ 12867, 12867 ], "disallowed_STD3_mapped", [ 40, 33267, 41 ] ], [ [ 12868, 12868 ], "mapped", [ 21839 ] ], [ [ 12869, 12869 ], "mapped", [ 24188 ] ], [ [ 12870, 12870 ], "mapped", [ 25991 ] ], [ [ 12871, 12871 ], "mapped", [ 31631 ] ], [ [ 12872, 12879 ], "valid", [], "NV8" ], [ [ 12880, 12880 ], "mapped", [ 112, 116, 101 ] ], [ [ 12881, 12881 ], "mapped", [ 50, 49 ] ], [ [ 12882, 12882 ], "mapped", [ 50, 50 ] ], [ [ 12883, 12883 ], "mapped", [ 50, 51 ] ], [ [ 12884, 12884 ], "mapped", [ 50, 52 ] ], [ [ 12885, 12885 ], "mapped", [ 50, 53 ] ], [ [ 12886, 12886 ], "mapped", [ 50, 54 ] ], [ [ 12887, 12887 ], "mapped", [ 50, 55 ] ], [ [ 12888, 12888 ], "mapped", [ 50, 56 ] ], [ [ 12889, 12889 ], "mapped", [ 50, 57 ] ], [ [ 12890, 12890 ], "mapped", [ 51, 48 ] ], [ [ 12891, 12891 ], "mapped", [ 51, 49 ] ], [ [ 12892, 12892 ], "mapped", [ 51, 50 ] ], [ [ 12893, 12893 ], "mapped", [ 51, 51 ] ], [ [ 12894, 12894 ], "mapped", [ 51, 52 ] ], [ [ 12895, 12895 ], "mapped", [ 51, 53 ] ], [ [ 12896, 12896 ], "mapped", [ 4352 ] ], [ [ 12897, 12897 ], "mapped", [ 4354 ] ], [ [ 12898, 12898 ], "mapped", [ 4355 ] ], [ [ 12899, 12899 ], "mapped", [ 4357 ] ], [ [ 12900, 12900 ], "mapped", [ 4358 ] ], [ [ 12901, 12901 ], "mapped", [ 4359 ] ], [ [ 12902, 12902 ], "mapped", [ 4361 ] ], [ [ 12903, 12903 ], "mapped", [ 4363 ] ], [ [ 12904, 12904 ], "mapped", [ 4364 ] ], [ [ 12905, 12905 ], "mapped", [ 4366 ] ], [ [ 12906, 12906 ], "mapped", [ 4367 ] ], [ [ 12907, 12907 ], "mapped", [ 4368 ] ], [ [ 12908, 12908 ], "mapped", [ 4369 ] ], [ [ 12909, 12909 ], "mapped", [ 4370 ] ], [ [ 12910, 12910 ], "mapped", [ 44032 ] ], [ [ 12911, 12911 ], "mapped", [ 45208 ] ], [ [ 12912, 12912 ], "mapped", [ 45796 ] ], [ [ 12913, 12913 ], "mapped", [ 46972 ] ], [ [ 12914, 12914 ], "mapped", [ 47560 ] ], [ [ 12915, 12915 ], "mapped", [ 48148 ] ], [ [ 12916, 12916 ], "mapped", [ 49324 ] ], [ [ 12917, 12917 ], "mapped", [ 50500 ] ], [ [ 12918, 12918 ], "mapped", [ 51088 ] ], [ [ 12919, 12919 ], "mapped", [ 52264 ] ], [ [ 12920, 12920 ], "mapped", [ 52852 ] ], [ [ 12921, 12921 ], "mapped", [ 53440 ] ], [ [ 12922, 12922 ], "mapped", [ 54028 ] ], [ [ 12923, 12923 ], "mapped", [ 54616 ] ], [ [ 12924, 12924 ], "mapped", [ 52280, 44256 ] ], [ [ 12925, 12925 ], "mapped", [ 51452, 51032 ] ], [ [ 12926, 12926 ], "mapped", [ 50864 ] ], [ [ 12927, 12927 ], "valid", [], "NV8" ], [ [ 12928, 12928 ], "mapped", [ 19968 ] ], [ [ 12929, 12929 ], "mapped", [ 20108 ] ], [ [ 12930, 12930 ], "mapped", [ 19977 ] ], [ [ 12931, 12931 ], "mapped", [ 22235 ] ], [ [ 12932, 12932 ], "mapped", [ 20116 ] ], [ [ 12933, 12933 ], "mapped", [ 20845 ] ], [ [ 12934, 12934 ], "mapped", [ 19971 ] ], [ [ 12935, 12935 ], "mapped", [ 20843 ] ], [ [ 12936, 12936 ], "mapped", [ 20061 ] ], [ [ 12937, 12937 ], "mapped", [ 21313 ] ], [ [ 12938, 12938 ], "mapped", [ 26376 ] ], [ [ 12939, 12939 ], "mapped", [ 28779 ] ], [ [ 12940, 12940 ], "mapped", [ 27700 ] ], [ [ 12941, 12941 ], "mapped", [ 26408 ] ], [ [ 12942, 12942 ], "mapped", [ 37329 ] ], [ [ 12943, 12943 ], "mapped", [ 22303 ] ], [ [ 12944, 12944 ], "mapped", [ 26085 ] ], [ [ 12945, 12945 ], "mapped", [ 26666 ] ], [ [ 12946, 12946 ], "mapped", [ 26377 ] ], [ [ 12947, 12947 ], "mapped", [ 31038 ] ], [ [ 12948, 12948 ], "mapped", [ 21517 ] ], [ [ 12949, 12949 ], "mapped", [ 29305 ] ], [ [ 12950, 12950 ], "mapped", [ 36001 ] ], [ [ 12951, 12951 ], "mapped", [ 31069 ] ], [ [ 12952, 12952 ], "mapped", [ 21172 ] ], [ [ 12953, 12953 ], "mapped", [ 31192 ] ], [ [ 12954, 12954 ], "mapped", [ 30007 ] ], [ [ 12955, 12955 ], "mapped", [ 22899 ] ], [ [ 12956, 12956 ], "mapped", [ 36969 ] ], [ [ 12957, 12957 ], "mapped", [ 20778 ] ], [ [ 12958, 12958 ], "mapped", [ 21360 ] ], [ [ 12959, 12959 ], "mapped", [ 27880 ] ], [ [ 12960, 12960 ], "mapped", [ 38917 ] ], [ [ 12961, 12961 ], "mapped", [ 20241 ] ], [ [ 12962, 12962 ], "mapped", [ 20889 ] ], [ [ 12963, 12963 ], "mapped", [ 27491 ] ], [ [ 12964, 12964 ], "mapped", [ 19978 ] ], [ [ 12965, 12965 ], "mapped", [ 20013 ] ], [ [ 12966, 12966 ], "mapped", [ 19979 ] ], [ [ 12967, 12967 ], "mapped", [ 24038 ] ], [ [ 12968, 12968 ], "mapped", [ 21491 ] ], [ [ 12969, 12969 ], "mapped", [ 21307 ] ], [ [ 12970, 12970 ], "mapped", [ 23447 ] ], [ [ 12971, 12971 ], "mapped", [ 23398 ] ], [ [ 12972, 12972 ], "mapped", [ 30435 ] ], [ [ 12973, 12973 ], "mapped", [ 20225 ] ], [ [ 12974, 12974 ], "mapped", [ 36039 ] ], [ [ 12975, 12975 ], "mapped", [ 21332 ] ], [ [ 12976, 12976 ], "mapped", [ 22812 ] ], [ [ 12977, 12977 ], "mapped", [ 51, 54 ] ], [ [ 12978, 12978 ], "mapped", [ 51, 55 ] ], [ [ 12979, 12979 ], "mapped", [ 51, 56 ] ], [ [ 12980, 12980 ], "mapped", [ 51, 57 ] ], [ [ 12981, 12981 ], "mapped", [ 52, 48 ] ], [ [ 12982, 12982 ], "mapped", [ 52, 49 ] ], [ [ 12983, 12983 ], "mapped", [ 52, 50 ] ], [ [ 12984, 12984 ], "mapped", [ 52, 51 ] ], [ [ 12985, 12985 ], "mapped", [ 52, 52 ] ], [ [ 12986, 12986 ], "mapped", [ 52, 53 ] ], [ [ 12987, 12987 ], "mapped", [ 52, 54 ] ], [ [ 12988, 12988 ], "mapped", [ 52, 55 ] ], [ [ 12989, 12989 ], "mapped", [ 52, 56 ] ], [ [ 12990, 12990 ], "mapped", [ 52, 57 ] ], [ [ 12991, 12991 ], "mapped", [ 53, 48 ] ], [ [ 12992, 12992 ], "mapped", [ 49, 26376 ] ], [ [ 12993, 12993 ], "mapped", [ 50, 26376 ] ], [ [ 12994, 12994 ], "mapped", [ 51, 26376 ] ], [ [ 12995, 12995 ], "mapped", [ 52, 26376 ] ], [ [ 12996, 12996 ], "mapped", [ 53, 26376 ] ], [ [ 12997, 12997 ], "mapped", [ 54, 26376 ] ], [ [ 12998, 12998 ], "mapped", [ 55, 26376 ] ], [ [ 12999, 12999 ], "mapped", [ 56, 26376 ] ], [ [ 13e3, 13e3 ], "mapped", [ 57, 26376 ] ], [ [ 13001, 13001 ], "mapped", [ 49, 48, 26376 ] ], [ [ 13002, 13002 ], "mapped", [ 49, 49, 26376 ] ], [ [ 13003, 13003 ], "mapped", [ 49, 50, 26376 ] ], [ [ 13004, 13004 ], "mapped", [ 104, 103 ] ], [ [ 13005, 13005 ], "mapped", [ 101, 114, 103 ] ], [ [ 13006, 13006 ], "mapped", [ 101, 118 ] ], [ [ 13007, 13007 ], "mapped", [ 108, 116, 100 ] ], [ [ 13008, 13008 ], "mapped", [ 12450 ] ], [ [ 13009, 13009 ], "mapped", [ 12452 ] ], [ [ 13010, 13010 ], "mapped", [ 12454 ] ], [ [ 13011, 13011 ], "mapped", [ 12456 ] ], [ [ 13012, 13012 ], "mapped", [ 12458 ] ], [ [ 13013, 13013 ], "mapped", [ 12459 ] ], [ [ 13014, 13014 ], "mapped", [ 12461 ] ], [ [ 13015, 13015 ], "mapped", [ 12463 ] ], [ [ 13016, 13016 ], "mapped", [ 12465 ] ], [ [ 13017, 13017 ], "mapped", [ 12467 ] ], [ [ 13018, 13018 ], "mapped", [ 12469 ] ], [ [ 13019, 13019 ], "mapped", [ 12471 ] ], [ [ 13020, 13020 ], "mapped", [ 12473 ] ], [ [ 13021, 13021 ], "mapped", [ 12475 ] ], [ [ 13022, 13022 ], "mapped", [ 12477 ] ], [ [ 13023, 13023 ], "mapped", [ 12479 ] ], [ [ 13024, 13024 ], "mapped", [ 12481 ] ], [ [ 13025, 13025 ], "mapped", [ 12484 ] ], [ [ 13026, 13026 ], "mapped", [ 12486 ] ], [ [ 13027, 13027 ], "mapped", [ 12488 ] ], [ [ 13028, 13028 ], "mapped", [ 12490 ] ], [ [ 13029, 13029 ], "mapped", [ 12491 ] ], [ [ 13030, 13030 ], "mapped", [ 12492 ] ], [ [ 13031, 13031 ], "mapped", [ 12493 ] ], [ [ 13032, 13032 ], "mapped", [ 12494 ] ], [ [ 13033, 13033 ], "mapped", [ 12495 ] ], [ [ 13034, 13034 ], "mapped", [ 12498 ] ], [ [ 13035, 13035 ], "mapped", [ 12501 ] ], [ [ 13036, 13036 ], "mapped", [ 12504 ] ], [ [ 13037, 13037 ], "mapped", [ 12507 ] ], [ [ 13038, 13038 ], "mapped", [ 12510 ] ], [ [ 13039, 13039 ], "mapped", [ 12511 ] ], [ [ 13040, 13040 ], "mapped", [ 12512 ] ], [ [ 13041, 13041 ], "mapped", [ 12513 ] ], [ [ 13042, 13042 ], "mapped", [ 12514 ] ], [ [ 13043, 13043 ], "mapped", [ 12516 ] ], [ [ 13044, 13044 ], "mapped", [ 12518 ] ], [ [ 13045, 13045 ], "mapped", [ 12520 ] ], [ [ 13046, 13046 ], "mapped", [ 12521 ] ], [ [ 13047, 13047 ], "mapped", [ 12522 ] ], [ [ 13048, 13048 ], "mapped", [ 12523 ] ], [ [ 13049, 13049 ], "mapped", [ 12524 ] ], [ [ 13050, 13050 ], "mapped", [ 12525 ] ], [ [ 13051, 13051 ], "mapped", [ 12527 ] ], [ [ 13052, 13052 ], "mapped", [ 12528 ] ], [ [ 13053, 13053 ], "mapped", [ 12529 ] ], [ [ 13054, 13054 ], "mapped", [ 12530 ] ], [ [ 13055, 13055 ], "disallowed" ], [ [ 13056, 13056 ], "mapped", [ 12450, 12497, 12540, 12488 ] ], [ [ 13057, 13057 ], "mapped", [ 12450, 12523, 12501, 12449 ] ], [ [ 13058, 13058 ], "mapped", [ 12450, 12531, 12506, 12450 ] ], [ [ 13059, 13059 ], "mapped", [ 12450, 12540, 12523 ] ], [ [ 13060, 13060 ], "mapped", [ 12452, 12491, 12531, 12464 ] ], [ [ 13061, 13061 ], "mapped", [ 12452, 12531, 12481 ] ], [ [ 13062, 13062 ], "mapped", [ 12454, 12457, 12531 ] ], [ [ 13063, 13063 ], "mapped", [ 12456, 12473, 12463, 12540, 12489 ] ], [ [ 13064, 13064 ], "mapped", [ 12456, 12540, 12459, 12540 ] ], [ [ 13065, 13065 ], "mapped", [ 12458, 12531, 12473 ] ], [ [ 13066, 13066 ], "mapped", [ 12458, 12540, 12512 ] ], [ [ 13067, 13067 ], "mapped", [ 12459, 12452, 12522 ] ], [ [ 13068, 13068 ], "mapped", [ 12459, 12521, 12483, 12488 ] ], [ [ 13069, 13069 ], "mapped", [ 12459, 12525, 12522, 12540 ] ], [ [ 13070, 13070 ], "mapped", [ 12460, 12525, 12531 ] ], [ [ 13071, 13071 ], "mapped", [ 12460, 12531, 12510 ] ], [ [ 13072, 13072 ], "mapped", [ 12462, 12460 ] ], [ [ 13073, 13073 ], "mapped", [ 12462, 12491, 12540 ] ], [ [ 13074, 13074 ], "mapped", [ 12461, 12517, 12522, 12540 ] ], [ [ 13075, 13075 ], "mapped", [ 12462, 12523, 12480, 12540 ] ], [ [ 13076, 13076 ], "mapped", [ 12461, 12525 ] ], [ [ 13077, 13077 ], "mapped", [ 12461, 12525, 12464, 12521, 12512 ] ], [ [ 13078, 13078 ], "mapped", [ 12461, 12525, 12513, 12540, 12488, 12523 ] ], [ [ 13079, 13079 ], "mapped", [ 12461, 12525, 12527, 12483, 12488 ] ], [ [ 13080, 13080 ], "mapped", [ 12464, 12521, 12512 ] ], [ [ 13081, 13081 ], "mapped", [ 12464, 12521, 12512, 12488, 12531 ] ], [ [ 13082, 13082 ], "mapped", [ 12463, 12523, 12476, 12452, 12525 ] ], [ [ 13083, 13083 ], "mapped", [ 12463, 12525, 12540, 12493 ] ], [ [ 13084, 13084 ], "mapped", [ 12465, 12540, 12473 ] ], [ [ 13085, 13085 ], "mapped", [ 12467, 12523, 12490 ] ], [ [ 13086, 13086 ], "mapped", [ 12467, 12540, 12509 ] ], [ [ 13087, 13087 ], "mapped", [ 12469, 12452, 12463, 12523 ] ], [ [ 13088, 13088 ], "mapped", [ 12469, 12531, 12481, 12540, 12512 ] ], [ [ 13089, 13089 ], "mapped", [ 12471, 12522, 12531, 12464 ] ], [ [ 13090, 13090 ], "mapped", [ 12475, 12531, 12481 ] ], [ [ 13091, 13091 ], "mapped", [ 12475, 12531, 12488 ] ], [ [ 13092, 13092 ], "mapped", [ 12480, 12540, 12473 ] ], [ [ 13093, 13093 ], "mapped", [ 12487, 12471 ] ], [ [ 13094, 13094 ], "mapped", [ 12489, 12523 ] ], [ [ 13095, 13095 ], "mapped", [ 12488, 12531 ] ], [ [ 13096, 13096 ], "mapped", [ 12490, 12494 ] ], [ [ 13097, 13097 ], "mapped", [ 12494, 12483, 12488 ] ], [ [ 13098, 13098 ], "mapped", [ 12495, 12452, 12484 ] ], [ [ 13099, 13099 ], "mapped", [ 12497, 12540, 12475, 12531, 12488 ] ], [ [ 13100, 13100 ], "mapped", [ 12497, 12540, 12484 ] ], [ [ 13101, 13101 ], "mapped", [ 12496, 12540, 12524, 12523 ] ], [ [ 13102, 13102 ], "mapped", [ 12500, 12450, 12473, 12488, 12523 ] ], [ [ 13103, 13103 ], "mapped", [ 12500, 12463, 12523 ] ], [ [ 13104, 13104 ], "mapped", [ 12500, 12467 ] ], [ [ 13105, 13105 ], "mapped", [ 12499, 12523 ] ], [ [ 13106, 13106 ], "mapped", [ 12501, 12449, 12521, 12483, 12489 ] ], [ [ 13107, 13107 ], "mapped", [ 12501, 12451, 12540, 12488 ] ], [ [ 13108, 13108 ], "mapped", [ 12502, 12483, 12471, 12455, 12523 ] ], [ [ 13109, 13109 ], "mapped", [ 12501, 12521, 12531 ] ], [ [ 13110, 13110 ], "mapped", [ 12504, 12463, 12479, 12540, 12523 ] ], [ [ 13111, 13111 ], "mapped", [ 12506, 12477 ] ], [ [ 13112, 13112 ], "mapped", [ 12506, 12491, 12498 ] ], [ [ 13113, 13113 ], "mapped", [ 12504, 12523, 12484 ] ], [ [ 13114, 13114 ], "mapped", [ 12506, 12531, 12473 ] ], [ [ 13115, 13115 ], "mapped", [ 12506, 12540, 12472 ] ], [ [ 13116, 13116 ], "mapped", [ 12505, 12540, 12479 ] ], [ [ 13117, 13117 ], "mapped", [ 12509, 12452, 12531, 12488 ] ], [ [ 13118, 13118 ], "mapped", [ 12508, 12523, 12488 ] ], [ [ 13119, 13119 ], "mapped", [ 12507, 12531 ] ], [ [ 13120, 13120 ], "mapped", [ 12509, 12531, 12489 ] ], [ [ 13121, 13121 ], "mapped", [ 12507, 12540, 12523 ] ], [ [ 13122, 13122 ], "mapped", [ 12507, 12540, 12531 ] ], [ [ 13123, 13123 ], "mapped", [ 12510, 12452, 12463, 12525 ] ], [ [ 13124, 13124 ], "mapped", [ 12510, 12452, 12523 ] ], [ [ 13125, 13125 ], "mapped", [ 12510, 12483, 12495 ] ], [ [ 13126, 13126 ], "mapped", [ 12510, 12523, 12463 ] ], [ [ 13127, 13127 ], "mapped", [ 12510, 12531, 12471, 12519, 12531 ] ], [ [ 13128, 13128 ], "mapped", [ 12511, 12463, 12525, 12531 ] ], [ [ 13129, 13129 ], "mapped", [ 12511, 12522 ] ], [ [ 13130, 13130 ], "mapped", [ 12511, 12522, 12496, 12540, 12523 ] ], [ [ 13131, 13131 ], "mapped", [ 12513, 12460 ] ], [ [ 13132, 13132 ], "mapped", [ 12513, 12460, 12488, 12531 ] ], [ [ 13133, 13133 ], "mapped", [ 12513, 12540, 12488, 12523 ] ], [ [ 13134, 13134 ], "mapped", [ 12516, 12540, 12489 ] ], [ [ 13135, 13135 ], "mapped", [ 12516, 12540, 12523 ] ], [ [ 13136, 13136 ], "mapped", [ 12518, 12450, 12531 ] ], [ [ 13137, 13137 ], "mapped", [ 12522, 12483, 12488, 12523 ] ], [ [ 13138, 13138 ], "mapped", [ 12522, 12521 ] ], [ [ 13139, 13139 ], "mapped", [ 12523, 12500, 12540 ] ], [ [ 13140, 13140 ], "mapped", [ 12523, 12540, 12502, 12523 ] ], [ [ 13141, 13141 ], "mapped", [ 12524, 12512 ] ], [ [ 13142, 13142 ], "mapped", [ 12524, 12531, 12488, 12466, 12531 ] ], [ [ 13143, 13143 ], "mapped", [ 12527, 12483, 12488 ] ], [ [ 13144, 13144 ], "mapped", [ 48, 28857 ] ], [ [ 13145, 13145 ], "mapped", [ 49, 28857 ] ], [ [ 13146, 13146 ], "mapped", [ 50, 28857 ] ], [ [ 13147, 13147 ], "mapped", [ 51, 28857 ] ], [ [ 13148, 13148 ], "mapped", [ 52, 28857 ] ], [ [ 13149, 13149 ], "mapped", [ 53, 28857 ] ], [ [ 13150, 13150 ], "mapped", [ 54, 28857 ] ], [ [ 13151, 13151 ], "mapped", [ 55, 28857 ] ], [ [ 13152, 13152 ], "mapped", [ 56, 28857 ] ], [ [ 13153, 13153 ], "mapped", [ 57, 28857 ] ], [ [ 13154, 13154 ], "mapped", [ 49, 48, 28857 ] ], [ [ 13155, 13155 ], "mapped", [ 49, 49, 28857 ] ], [ [ 13156, 13156 ], "mapped", [ 49, 50, 28857 ] ], [ [ 13157, 13157 ], "mapped", [ 49, 51, 28857 ] ], [ [ 13158, 13158 ], "mapped", [ 49, 52, 28857 ] ], [ [ 13159, 13159 ], "mapped", [ 49, 53, 28857 ] ], [ [ 13160, 13160 ], "mapped", [ 49, 54, 28857 ] ], [ [ 13161, 13161 ], "mapped", [ 49, 55, 28857 ] ], [ [ 13162, 13162 ], "mapped", [ 49, 56, 28857 ] ], [ [ 13163, 13163 ], "mapped", [ 49, 57, 28857 ] ], [ [ 13164, 13164 ], "mapped", [ 50, 48, 28857 ] ], [ [ 13165, 13165 ], "mapped", [ 50, 49, 28857 ] ], [ [ 13166, 13166 ], "mapped", [ 50, 50, 28857 ] ], [ [ 13167, 13167 ], "mapped", [ 50, 51, 28857 ] ], [ [ 13168, 13168 ], "mapped", [ 50, 52, 28857 ] ], [ [ 13169, 13169 ], "mapped", [ 104, 112, 97 ] ], [ [ 13170, 13170 ], "mapped", [ 100, 97 ] ], [ [ 13171, 13171 ], "mapped", [ 97, 117 ] ], [ [ 13172, 13172 ], "mapped", [ 98, 97, 114 ] ], [ [ 13173, 13173 ], "mapped", [ 111, 118 ] ], [ [ 13174, 13174 ], "mapped", [ 112, 99 ] ], [ [ 13175, 13175 ], "mapped", [ 100, 109 ] ], [ [ 13176, 13176 ], "mapped", [ 100, 109, 50 ] ], [ [ 13177, 13177 ], "mapped", [ 100, 109, 51 ] ], [ [ 13178, 13178 ], "mapped", [ 105, 117 ] ], [ [ 13179, 13179 ], "mapped", [ 24179, 25104 ] ], [ [ 13180, 13180 ], "mapped", [ 26157, 21644 ] ], [ [ 13181, 13181 ], "mapped", [ 22823, 27491 ] ], [ [ 13182, 13182 ], "mapped", [ 26126, 27835 ] ], [ [ 13183, 13183 ], "mapped", [ 26666, 24335, 20250, 31038 ] ], [ [ 13184, 13184 ], "mapped", [ 112, 97 ] ], [ [ 13185, 13185 ], "mapped", [ 110, 97 ] ], [ [ 13186, 13186 ], "mapped", [ 956, 97 ] ], [ [ 13187, 13187 ], "mapped", [ 109, 97 ] ], [ [ 13188, 13188 ], "mapped", [ 107, 97 ] ], [ [ 13189, 13189 ], "mapped", [ 107, 98 ] ], [ [ 13190, 13190 ], "mapped", [ 109, 98 ] ], [ [ 13191, 13191 ], "mapped", [ 103, 98 ] ], [ [ 13192, 13192 ], "mapped", [ 99, 97, 108 ] ], [ [ 13193, 13193 ], "mapped", [ 107, 99, 97, 108 ] ], [ [ 13194, 13194 ], "mapped", [ 112, 102 ] ], [ [ 13195, 13195 ], "mapped", [ 110, 102 ] ], [ [ 13196, 13196 ], "mapped", [ 956, 102 ] ], [ [ 13197, 13197 ], "mapped", [ 956, 103 ] ], [ [ 13198, 13198 ], "mapped", [ 109, 103 ] ], [ [ 13199, 13199 ], "mapped", [ 107, 103 ] ], [ [ 13200, 13200 ], "mapped", [ 104, 122 ] ], [ [ 13201, 13201 ], "mapped", [ 107, 104, 122 ] ], [ [ 13202, 13202 ], "mapped", [ 109, 104, 122 ] ], [ [ 13203, 13203 ], "mapped", [ 103, 104, 122 ] ], [ [ 13204, 13204 ], "mapped", [ 116, 104, 122 ] ], [ [ 13205, 13205 ], "mapped", [ 956, 108 ] ], [ [ 13206, 13206 ], "mapped", [ 109, 108 ] ], [ [ 13207, 13207 ], "mapped", [ 100, 108 ] ], [ [ 13208, 13208 ], "mapped", [ 107, 108 ] ], [ [ 13209, 13209 ], "mapped", [ 102, 109 ] ], [ [ 13210, 13210 ], "mapped", [ 110, 109 ] ], [ [ 13211, 13211 ], "mapped", [ 956, 109 ] ], [ [ 13212, 13212 ], "mapped", [ 109, 109 ] ], [ [ 13213, 13213 ], "mapped", [ 99, 109 ] ], [ [ 13214, 13214 ], "mapped", [ 107, 109 ] ], [ [ 13215, 13215 ], "mapped", [ 109, 109, 50 ] ], [ [ 13216, 13216 ], "mapped", [ 99, 109, 50 ] ], [ [ 13217, 13217 ], "mapped", [ 109, 50 ] ], [ [ 13218, 13218 ], "mapped", [ 107, 109, 50 ] ], [ [ 13219, 13219 ], "mapped", [ 109, 109, 51 ] ], [ [ 13220, 13220 ], "mapped", [ 99, 109, 51 ] ], [ [ 13221, 13221 ], "mapped", [ 109, 51 ] ], [ [ 13222, 13222 ], "mapped", [ 107, 109, 51 ] ], [ [ 13223, 13223 ], "mapped", [ 109, 8725, 115 ] ], [ [ 13224, 13224 ], "mapped", [ 109, 8725, 115, 50 ] ], [ [ 13225, 13225 ], "mapped", [ 112, 97 ] ], [ [ 13226, 13226 ], "mapped", [ 107, 112, 97 ] ], [ [ 13227, 13227 ], "mapped", [ 109, 112, 97 ] ], [ [ 13228, 13228 ], "mapped", [ 103, 112, 97 ] ], [ [ 13229, 13229 ], "mapped", [ 114, 97, 100 ] ], [ [ 13230, 13230 ], "mapped", [ 114, 97, 100, 8725, 115 ] ], [ [ 13231, 13231 ], "mapped", [ 114, 97, 100, 8725, 115, 50 ] ], [ [ 13232, 13232 ], "mapped", [ 112, 115 ] ], [ [ 13233, 13233 ], "mapped", [ 110, 115 ] ], [ [ 13234, 13234 ], "mapped", [ 956, 115 ] ], [ [ 13235, 13235 ], "mapped", [ 109, 115 ] ], [ [ 13236, 13236 ], "mapped", [ 112, 118 ] ], [ [ 13237, 13237 ], "mapped", [ 110, 118 ] ], [ [ 13238, 13238 ], "mapped", [ 956, 118 ] ], [ [ 13239, 13239 ], "mapped", [ 109, 118 ] ], [ [ 13240, 13240 ], "mapped", [ 107, 118 ] ], [ [ 13241, 13241 ], "mapped", [ 109, 118 ] ], [ [ 13242, 13242 ], "mapped", [ 112, 119 ] ], [ [ 13243, 13243 ], "mapped", [ 110, 119 ] ], [ [ 13244, 13244 ], "mapped", [ 956, 119 ] ], [ [ 13245, 13245 ], "mapped", [ 109, 119 ] ], [ [ 13246, 13246 ], "mapped", [ 107, 119 ] ], [ [ 13247, 13247 ], "mapped", [ 109, 119 ] ], [ [ 13248, 13248 ], "mapped", [ 107, 969 ] ], [ [ 13249, 13249 ], "mapped", [ 109, 969 ] ], [ [ 13250, 13250 ], "disallowed" ], [ [ 13251, 13251 ], "mapped", [ 98, 113 ] ], [ [ 13252, 13252 ], "mapped", [ 99, 99 ] ], [ [ 13253, 13253 ], "mapped", [ 99, 100 ] ], [ [ 13254, 13254 ], "mapped", [ 99, 8725, 107, 103 ] ], [ [ 13255, 13255 ], "disallowed" ], [ [ 13256, 13256 ], "mapped", [ 100, 98 ] ], [ [ 13257, 13257 ], "mapped", [ 103, 121 ] ], [ [ 13258, 13258 ], "mapped", [ 104, 97 ] ], [ [ 13259, 13259 ], "mapped", [ 104, 112 ] ], [ [ 13260, 13260 ], "mapped", [ 105, 110 ] ], [ [ 13261, 13261 ], "mapped", [ 107, 107 ] ], [ [ 13262, 13262 ], "mapped", [ 107, 109 ] ], [ [ 13263, 13263 ], "mapped", [ 107, 116 ] ], [ [ 13264, 13264 ], "mapped", [ 108, 109 ] ], [ [ 13265, 13265 ], "mapped", [ 108, 110 ] ], [ [ 13266, 13266 ], "mapped", [ 108, 111, 103 ] ], [ [ 13267, 13267 ], "mapped", [ 108, 120 ] ], [ [ 13268, 13268 ], "mapped", [ 109, 98 ] ], [ [ 13269, 13269 ], "mapped", [ 109, 105, 108 ] ], [ [ 13270, 13270 ], "mapped", [ 109, 111, 108 ] ], [ [ 13271, 13271 ], "mapped", [ 112, 104 ] ], [ [ 13272, 13272 ], "disallowed" ], [ [ 13273, 13273 ], "mapped", [ 112, 112, 109 ] ], [ [ 13274, 13274 ], "mapped", [ 112, 114 ] ], [ [ 13275, 13275 ], "mapped", [ 115, 114 ] ], [ [ 13276, 13276 ], "mapped", [ 115, 118 ] ], [ [ 13277, 13277 ], "mapped", [ 119, 98 ] ], [ [ 13278, 13278 ], "mapped", [ 118, 8725, 109 ] ], [ [ 13279, 13279 ], "mapped", [ 97, 8725, 109 ] ], [ [ 13280, 13280 ], "mapped", [ 49, 26085 ] ], [ [ 13281, 13281 ], "mapped", [ 50, 26085 ] ], [ [ 13282, 13282 ], "mapped", [ 51, 26085 ] ], [ [ 13283, 13283 ], "mapped", [ 52, 26085 ] ], [ [ 13284, 13284 ], "mapped", [ 53, 26085 ] ], [ [ 13285, 13285 ], "mapped", [ 54, 26085 ] ], [ [ 13286, 13286 ], "mapped", [ 55, 26085 ] ], [ [ 13287, 13287 ], "mapped", [ 56, 26085 ] ], [ [ 13288, 13288 ], "mapped", [ 57, 26085 ] ], [ [ 13289, 13289 ], "mapped", [ 49, 48, 26085 ] ], [ [ 13290, 13290 ], "mapped", [ 49, 49, 26085 ] ], [ [ 13291, 13291 ], "mapped", [ 49, 50, 26085 ] ], [ [ 13292, 13292 ], "mapped", [ 49, 51, 26085 ] ], [ [ 13293, 13293 ], "mapped", [ 49, 52, 26085 ] ], [ [ 13294, 13294 ], "mapped", [ 49, 53, 26085 ] ], [ [ 13295, 13295 ], "mapped", [ 49, 54, 26085 ] ], [ [ 13296, 13296 ], "mapped", [ 49, 55, 26085 ] ], [ [ 13297, 13297 ], "mapped", [ 49, 56, 26085 ] ], [ [ 13298, 13298 ], "mapped", [ 49, 57, 26085 ] ], [ [ 13299, 13299 ], "mapped", [ 50, 48, 26085 ] ], [ [ 13300, 13300 ], "mapped", [ 50, 49, 26085 ] ], [ [ 13301, 13301 ], "mapped", [ 50, 50, 26085 ] ], [ [ 13302, 13302 ], "mapped", [ 50, 51, 26085 ] ], [ [ 13303, 13303 ], "mapped", [ 50, 52, 26085 ] ], [ [ 13304, 13304 ], "mapped", [ 50, 53, 26085 ] ], [ [ 13305, 13305 ], "mapped", [ 50, 54, 26085 ] ], [ [ 13306, 13306 ], "mapped", [ 50, 55, 26085 ] ], [ [ 13307, 13307 ], "mapped", [ 50, 56, 26085 ] ], [ [ 13308, 13308 ], "mapped", [ 50, 57, 26085 ] ], [ [ 13309, 13309 ], "mapped", [ 51, 48, 26085 ] ], [ [ 13310, 13310 ], "mapped", [ 51, 49, 26085 ] ], [ [ 13311, 13311 ], "mapped", [ 103, 97, 108 ] ], [ [ 13312, 19893 ], "valid" ], [ [ 19894, 19903 ], "disallowed" ], [ [ 19904, 19967 ], "valid", [], "NV8" ], [ [ 19968, 40869 ], "valid" ], [ [ 40870, 40891 ], "valid" ], [ [ 40892, 40899 ], "valid" ], [ [ 40900, 40907 ], "valid" ], [ [ 40908, 40908 ], "valid" ], [ [ 40909, 40917 ], "valid" ], [ [ 40918, 40959 ], "disallowed" ], [ [ 40960, 42124 ], "valid" ], [ [ 42125, 42127 ], "disallowed" ], [ [ 42128, 42145 ], "valid", [], "NV8" ], [ [ 42146, 42147 ], "valid", [], "NV8" ], [ [ 42148, 42163 ], "valid", [], "NV8" ], [ [ 42164, 42164 ], "valid", [], "NV8" ], [ [ 42165, 42176 ], "valid", [], "NV8" ], [ [ 42177, 42177 ], "valid", [], "NV8" ], [ [ 42178, 42180 ], "valid", [], "NV8" ], [ [ 42181, 42181 ], "valid", [], "NV8" ], [ [ 42182, 42182 ], "valid", [], "NV8" ], [ [ 42183, 42191 ], "disallowed" ], [ [ 42192, 42237 ], "valid" ], [ [ 42238, 42239 ], "valid", [], "NV8" ], [ [ 42240, 42508 ], "valid" ], [ [ 42509, 42511 ], "valid", [], "NV8" ], [ [ 42512, 42539 ], "valid" ], [ [ 42540, 42559 ], "disallowed" ], [ [ 42560, 42560 ], "mapped", [ 42561 ] ], [ [ 42561, 42561 ], "valid" ], [ [ 42562, 42562 ], "mapped", [ 42563 ] ], [ [ 42563, 42563 ], "valid" ], [ [ 42564, 42564 ], "mapped", [ 42565 ] ], [ [ 42565, 42565 ], "valid" ], [ [ 42566, 42566 ], "mapped", [ 42567 ] ], [ [ 42567, 42567 ], "valid" ], [ [ 42568, 42568 ], "mapped", [ 42569 ] ], [ [ 42569, 42569 ], "valid" ], [ [ 42570, 42570 ], "mapped", [ 42571 ] ], [ [ 42571, 42571 ], "valid" ], [ [ 42572, 42572 ], "mapped", [ 42573 ] ], [ [ 42573, 42573 ], "valid" ], [ [ 42574, 42574 ], "mapped", [ 42575 ] ], [ [ 42575, 42575 ], "valid" ], [ [ 42576, 42576 ], "mapped", [ 42577 ] ], [ [ 42577, 42577 ], "valid" ], [ [ 42578, 42578 ], "mapped", [ 42579 ] ], [ [ 42579, 42579 ], "valid" ], [ [ 42580, 42580 ], "mapped", [ 42581 ] ], [ [ 42581, 42581 ], "valid" ], [ [ 42582, 42582 ], "mapped", [ 42583 ] ], [ [ 42583, 42583 ], "valid" ], [ [ 42584, 42584 ], "mapped", [ 42585 ] ], [ [ 42585, 42585 ], "valid" ], [ [ 42586, 42586 ], "mapped", [ 42587 ] ], [ [ 42587, 42587 ], "valid" ], [ [ 42588, 42588 ], "mapped", [ 42589 ] ], [ [ 42589, 42589 ], "valid" ], [ [ 42590, 42590 ], "mapped", [ 42591 ] ], [ [ 42591, 42591 ], "valid" ], [ [ 42592, 42592 ], "mapped", [ 42593 ] ], [ [ 42593, 42593 ], "valid" ], [ [ 42594, 42594 ], "mapped", [ 42595 ] ], [ [ 42595, 42595 ], "valid" ], [ [ 42596, 42596 ], "mapped", [ 42597 ] ], [ [ 42597, 42597 ], "valid" ], [ [ 42598, 42598 ], "mapped", [ 42599 ] ], [ [ 42599, 42599 ], "valid" ], [ [ 42600, 42600 ], "mapped", [ 42601 ] ], [ [ 42601, 42601 ], "valid" ], [ [ 42602, 42602 ], "mapped", [ 42603 ] ], [ [ 42603, 42603 ], "valid" ], [ [ 42604, 42604 ], "mapped", [ 42605 ] ], [ [ 42605, 42607 ], "valid" ], [ [ 42608, 42611 ], "valid", [], "NV8" ], [ [ 42612, 42619 ], "valid" ], [ [ 42620, 42621 ], "valid" ], [ [ 42622, 42622 ], "valid", [], "NV8" ], [ [ 42623, 42623 ], "valid" ], [ [ 42624, 42624 ], "mapped", [ 42625 ] ], [ [ 42625, 42625 ], "valid" ], [ [ 42626, 42626 ], "mapped", [ 42627 ] ], [ [ 42627, 42627 ], "valid" ], [ [ 42628, 42628 ], "mapped", [ 42629 ] ], [ [ 42629, 42629 ], "valid" ], [ [ 42630, 42630 ], "mapped", [ 42631 ] ], [ [ 42631, 42631 ], "valid" ], [ [ 42632, 42632 ], "mapped", [ 42633 ] ], [ [ 42633, 42633 ], "valid" ], [ [ 42634, 42634 ], "mapped", [ 42635 ] ], [ [ 42635, 42635 ], "valid" ], [ [ 42636, 42636 ], "mapped", [ 42637 ] ], [ [ 42637, 42637 ], "valid" ], [ [ 42638, 42638 ], "mapped", [ 42639 ] ], [ [ 42639, 42639 ], "valid" ], [ [ 42640, 42640 ], "mapped", [ 42641 ] ], [ [ 42641, 42641 ], "valid" ], [ [ 42642, 42642 ], "mapped", [ 42643 ] ], [ [ 42643, 42643 ], "valid" ], [ [ 42644, 42644 ], "mapped", [ 42645 ] ], [ [ 42645, 42645 ], "valid" ], [ [ 42646, 42646 ], "mapped", [ 42647 ] ], [ [ 42647, 42647 ], "valid" ], [ [ 42648, 42648 ], "mapped", [ 42649 ] ], [ [ 42649, 42649 ], "valid" ], [ [ 42650, 42650 ], "mapped", [ 42651 ] ], [ [ 42651, 42651 ], "valid" ], [ [ 42652, 42652 ], "mapped", [ 1098 ] ], [ [ 42653, 42653 ], "mapped", [ 1100 ] ], [ [ 42654, 42654 ], "valid" ], [ [ 42655, 42655 ], "valid" ], [ [ 42656, 42725 ], "valid" ], [ [ 42726, 42735 ], "valid", [], "NV8" ], [ [ 42736, 42737 ], "valid" ], [ [ 42738, 42743 ], "valid", [], "NV8" ], [ [ 42744, 42751 ], "disallowed" ], [ [ 42752, 42774 ], "valid", [], "NV8" ], [ [ 42775, 42778 ], "valid" ], [ [ 42779, 42783 ], "valid" ], [ [ 42784, 42785 ], "valid", [], "NV8" ], [ [ 42786, 42786 ], "mapped", [ 42787 ] ], [ [ 42787, 42787 ], "valid" ], [ [ 42788, 42788 ], "mapped", [ 42789 ] ], [ [ 42789, 42789 ], "valid" ], [ [ 42790, 42790 ], "mapped", [ 42791 ] ], [ [ 42791, 42791 ], "valid" ], [ [ 42792, 42792 ], "mapped", [ 42793 ] ], [ [ 42793, 42793 ], "valid" ], [ [ 42794, 42794 ], "mapped", [ 42795 ] ], [ [ 42795, 42795 ], "valid" ], [ [ 42796, 42796 ], "mapped", [ 42797 ] ], [ [ 42797, 42797 ], "valid" ], [ [ 42798, 42798 ], "mapped", [ 42799 ] ], [ [ 42799, 42801 ], "valid" ], [ [ 42802, 42802 ], "mapped", [ 42803 ] ], [ [ 42803, 42803 ], "valid" ], [ [ 42804, 42804 ], "mapped", [ 42805 ] ], [ [ 42805, 42805 ], "valid" ], [ [ 42806, 42806 ], "mapped", [ 42807 ] ], [ [ 42807, 42807 ], "valid" ], [ [ 42808, 42808 ], "mapped", [ 42809 ] ], [ [ 42809, 42809 ], "valid" ], [ [ 42810, 42810 ], "mapped", [ 42811 ] ], [ [ 42811, 42811 ], "valid" ], [ [ 42812, 42812 ], "mapped", [ 42813 ] ], [ [ 42813, 42813 ], "valid" ], [ [ 42814, 42814 ], "mapped", [ 42815 ] ], [ [ 42815, 42815 ], "valid" ], [ [ 42816, 42816 ], "mapped", [ 42817 ] ], [ [ 42817, 42817 ], "valid" ], [ [ 42818, 42818 ], "mapped", [ 42819 ] ], [ [ 42819, 42819 ], "valid" ], [ [ 42820, 42820 ], "mapped", [ 42821 ] ], [ [ 42821, 42821 ], "valid" ], [ [ 42822, 42822 ], "mapped", [ 42823 ] ], [ [ 42823, 42823 ], "valid" ], [ [ 42824, 42824 ], "mapped", [ 42825 ] ], [ [ 42825, 42825 ], "valid" ], [ [ 42826, 42826 ], "mapped", [ 42827 ] ], [ [ 42827, 42827 ], "valid" ], [ [ 42828, 42828 ], "mapped", [ 42829 ] ], [ [ 42829, 42829 ], "valid" ], [ [ 42830, 42830 ], "mapped", [ 42831 ] ], [ [ 42831, 42831 ], "valid" ], [ [ 42832, 42832 ], "mapped", [ 42833 ] ], [ [ 42833, 42833 ], "valid" ], [ [ 42834, 42834 ], "mapped", [ 42835 ] ], [ [ 42835, 42835 ], "valid" ], [ [ 42836, 42836 ], "mapped", [ 42837 ] ], [ [ 42837, 42837 ], "valid" ], [ [ 42838, 42838 ], "mapped", [ 42839 ] ], [ [ 42839, 42839 ], "valid" ], [ [ 42840, 42840 ], "mapped", [ 42841 ] ], [ [ 42841, 42841 ], "valid" ], [ [ 42842, 42842 ], "mapped", [ 42843 ] ], [ [ 42843, 42843 ], "valid" ], [ [ 42844, 42844 ], "mapped", [ 42845 ] ], [ [ 42845, 42845 ], "valid" ], [ [ 42846, 42846 ], "mapped", [ 42847 ] ], [ [ 42847, 42847 ], "valid" ], [ [ 42848, 42848 ], "mapped", [ 42849 ] ], [ [ 42849, 42849 ], "valid" ], [ [ 42850, 42850 ], "mapped", [ 42851 ] ], [ [ 42851, 42851 ], "valid" ], [ [ 42852, 42852 ], "mapped", [ 42853 ] ], [ [ 42853, 42853 ], "valid" ], [ [ 42854, 42854 ], "mapped", [ 42855 ] ], [ [ 42855, 42855 ], "valid" ], [ [ 42856, 42856 ], "mapped", [ 42857 ] ], [ [ 42857, 42857 ], "valid" ], [ [ 42858, 42858 ], "mapped", [ 42859 ] ], [ [ 42859, 42859 ], "valid" ], [ [ 42860, 42860 ], "mapped", [ 42861 ] ], [ [ 42861, 42861 ], "valid" ], [ [ 42862, 42862 ], "mapped", [ 42863 ] ], [ [ 42863, 42863 ], "valid" ], [ [ 42864, 42864 ], "mapped", [ 42863 ] ], [ [ 42865, 42872 ], "valid" ], [ [ 42873, 42873 ], "mapped", [ 42874 ] ], [ [ 42874, 42874 ], "valid" ], [ [ 42875, 42875 ], "mapped", [ 42876 ] ], [ [ 42876, 42876 ], "valid" ], [ [ 42877, 42877 ], "mapped", [ 7545 ] ], [ [ 42878, 42878 ], "mapped", [ 42879 ] ], [ [ 42879, 42879 ], "valid" ], [ [ 42880, 42880 ], "mapped", [ 42881 ] ], [ [ 42881, 42881 ], "valid" ], [ [ 42882, 42882 ], "mapped", [ 42883 ] ], [ [ 42883, 42883 ], "valid" ], [ [ 42884, 42884 ], "mapped", [ 42885 ] ], [ [ 42885, 42885 ], "valid" ], [ [ 42886, 42886 ], "mapped", [ 42887 ] ], [ [ 42887, 42888 ], "valid" ], [ [ 42889, 42890 ], "valid", [], "NV8" ], [ [ 42891, 42891 ], "mapped", [ 42892 ] ], [ [ 42892, 42892 ], "valid" ], [ [ 42893, 42893 ], "mapped", [ 613 ] ], [ [ 42894, 42894 ], "valid" ], [ [ 42895, 42895 ], "valid" ], [ [ 42896, 42896 ], "mapped", [ 42897 ] ], [ [ 42897, 42897 ], "valid" ], [ [ 42898, 42898 ], "mapped", [ 42899 ] ], [ [ 42899, 42899 ], "valid" ], [ [ 42900, 42901 ], "valid" ], [ [ 42902, 42902 ], "mapped", [ 42903 ] ], [ [ 42903, 42903 ], "valid" ], [ [ 42904, 42904 ], "mapped", [ 42905 ] ], [ [ 42905, 42905 ], "valid" ], [ [ 42906, 42906 ], "mapped", [ 42907 ] ], [ [ 42907, 42907 ], "valid" ], [ [ 42908, 42908 ], "mapped", [ 42909 ] ], [ [ 42909, 42909 ], "valid" ], [ [ 42910, 42910 ], "mapped", [ 42911 ] ], [ [ 42911, 42911 ], "valid" ], [ [ 42912, 42912 ], "mapped", [ 42913 ] ], [ [ 42913, 42913 ], "valid" ], [ [ 42914, 42914 ], "mapped", [ 42915 ] ], [ [ 42915, 42915 ], "valid" ], [ [ 42916, 42916 ], "mapped", [ 42917 ] ], [ [ 42917, 42917 ], "valid" ], [ [ 42918, 42918 ], "mapped", [ 42919 ] ], [ [ 42919, 42919 ], "valid" ], [ [ 42920, 42920 ], "mapped", [ 42921 ] ], [ [ 42921, 42921 ], "valid" ], [ [ 42922, 42922 ], "mapped", [ 614 ] ], [ [ 42923, 42923 ], "mapped", [ 604 ] ], [ [ 42924, 42924 ], "mapped", [ 609 ] ], [ [ 42925, 42925 ], "mapped", [ 620 ] ], [ [ 42926, 42927 ], "disallowed" ], [ [ 42928, 42928 ], "mapped", [ 670 ] ], [ [ 42929, 42929 ], "mapped", [ 647 ] ], [ [ 42930, 42930 ], "mapped", [ 669 ] ], [ [ 42931, 42931 ], "mapped", [ 43859 ] ], [ [ 42932, 42932 ], "mapped", [ 42933 ] ], [ [ 42933, 42933 ], "valid" ], [ [ 42934, 42934 ], "mapped", [ 42935 ] ], [ [ 42935, 42935 ], "valid" ], [ [ 42936, 42998 ], "disallowed" ], [ [ 42999, 42999 ], "valid" ], [ [ 43e3, 43e3 ], "mapped", [ 295 ] ], [ [ 43001, 43001 ], "mapped", [ 339 ] ], [ [ 43002, 43002 ], "valid" ], [ [ 43003, 43007 ], "valid" ], [ [ 43008, 43047 ], "valid" ], [ [ 43048, 43051 ], "valid", [], "NV8" ], [ [ 43052, 43055 ], "disallowed" ], [ [ 43056, 43065 ], "valid", [], "NV8" ], [ [ 43066, 43071 ], "disallowed" ], [ [ 43072, 43123 ], "valid" ], [ [ 43124, 43127 ], "valid", [], "NV8" ], [ [ 43128, 43135 ], "disallowed" ], [ [ 43136, 43204 ], "valid" ], [ [ 43205, 43213 ], "disallowed" ], [ [ 43214, 43215 ], "valid", [], "NV8" ], [ [ 43216, 43225 ], "valid" ], [ [ 43226, 43231 ], "disallowed" ], [ [ 43232, 43255 ], "valid" ], [ [ 43256, 43258 ], "valid", [], "NV8" ], [ [ 43259, 43259 ], "valid" ], [ [ 43260, 43260 ], "valid", [], "NV8" ], [ [ 43261, 43261 ], "valid" ], [ [ 43262, 43263 ], "disallowed" ], [ [ 43264, 43309 ], "valid" ], [ [ 43310, 43311 ], "valid", [], "NV8" ], [ [ 43312, 43347 ], "valid" ], [ [ 43348, 43358 ], "disallowed" ], [ [ 43359, 43359 ], "valid", [], "NV8" ], [ [ 43360, 43388 ], "valid", [], "NV8" ], [ [ 43389, 43391 ], "disallowed" ], [ [ 43392, 43456 ], "valid" ], [ [ 43457, 43469 ], "valid", [], "NV8" ], [ [ 43470, 43470 ], "disallowed" ], [ [ 43471, 43481 ], "valid" ], [ [ 43482, 43485 ], "disallowed" ], [ [ 43486, 43487 ], "valid", [], "NV8" ], [ [ 43488, 43518 ], "valid" ], [ [ 43519, 43519 ], "disallowed" ], [ [ 43520, 43574 ], "valid" ], [ [ 43575, 43583 ], "disallowed" ], [ [ 43584, 43597 ], "valid" ], [ [ 43598, 43599 ], "disallowed" ], [ [ 43600, 43609 ], "valid" ], [ [ 43610, 43611 ], "disallowed" ], [ [ 43612, 43615 ], "valid", [], "NV8" ], [ [ 43616, 43638 ], "valid" ], [ [ 43639, 43641 ], "valid", [], "NV8" ], [ [ 43642, 43643 ], "valid" ], [ [ 43644, 43647 ], "valid" ], [ [ 43648, 43714 ], "valid" ], [ [ 43715, 43738 ], "disallowed" ], [ [ 43739, 43741 ], "valid" ], [ [ 43742, 43743 ], "valid", [], "NV8" ], [ [ 43744, 43759 ], "valid" ], [ [ 43760, 43761 ], "valid", [], "NV8" ], [ [ 43762, 43766 ], "valid" ], [ [ 43767, 43776 ], "disallowed" ], [ [ 43777, 43782 ], "valid" ], [ [ 43783, 43784 ], "disallowed" ], [ [ 43785, 43790 ], "valid" ], [ [ 43791, 43792 ], "disallowed" ], [ [ 43793, 43798 ], "valid" ], [ [ 43799, 43807 ], "disallowed" ], [ [ 43808, 43814 ], "valid" ], [ [ 43815, 43815 ], "disallowed" ], [ [ 43816, 43822 ], "valid" ], [ [ 43823, 43823 ], "disallowed" ], [ [ 43824, 43866 ], "valid" ], [ [ 43867, 43867 ], "valid", [], "NV8" ], [ [ 43868, 43868 ], "mapped", [ 42791 ] ], [ [ 43869, 43869 ], "mapped", [ 43831 ] ], [ [ 43870, 43870 ], "mapped", [ 619 ] ], [ [ 43871, 43871 ], "mapped", [ 43858 ] ], [ [ 43872, 43875 ], "valid" ], [ [ 43876, 43877 ], "valid" ], [ [ 43878, 43887 ], "disallowed" ], [ [ 43888, 43888 ], "mapped", [ 5024 ] ], [ [ 43889, 43889 ], "mapped", [ 5025 ] ], [ [ 43890, 43890 ], "mapped", [ 5026 ] ], [ [ 43891, 43891 ], "mapped", [ 5027 ] ], [ [ 43892, 43892 ], "mapped", [ 5028 ] ], [ [ 43893, 43893 ], "mapped", [ 5029 ] ], [ [ 43894, 43894 ], "mapped", [ 5030 ] ], [ [ 43895, 43895 ], "mapped", [ 5031 ] ], [ [ 43896, 43896 ], "mapped", [ 5032 ] ], [ [ 43897, 43897 ], "mapped", [ 5033 ] ], [ [ 43898, 43898 ], "mapped", [ 5034 ] ], [ [ 43899, 43899 ], "mapped", [ 5035 ] ], [ [ 43900, 43900 ], "mapped", [ 5036 ] ], [ [ 43901, 43901 ], "mapped", [ 5037 ] ], [ [ 43902, 43902 ], "mapped", [ 5038 ] ], [ [ 43903, 43903 ], "mapped", [ 5039 ] ], [ [ 43904, 43904 ], "mapped", [ 5040 ] ], [ [ 43905, 43905 ], "mapped", [ 5041 ] ], [ [ 43906, 43906 ], "mapped", [ 5042 ] ], [ [ 43907, 43907 ], "mapped", [ 5043 ] ], [ [ 43908, 43908 ], "mapped", [ 5044 ] ], [ [ 43909, 43909 ], "mapped", [ 5045 ] ], [ [ 43910, 43910 ], "mapped", [ 5046 ] ], [ [ 43911, 43911 ], "mapped", [ 5047 ] ], [ [ 43912, 43912 ], "mapped", [ 5048 ] ], [ [ 43913, 43913 ], "mapped", [ 5049 ] ], [ [ 43914, 43914 ], "mapped", [ 5050 ] ], [ [ 43915, 43915 ], "mapped", [ 5051 ] ], [ [ 43916, 43916 ], "mapped", [ 5052 ] ], [ [ 43917, 43917 ], "mapped", [ 5053 ] ], [ [ 43918, 43918 ], "mapped", [ 5054 ] ], [ [ 43919, 43919 ], "mapped", [ 5055 ] ], [ [ 43920, 43920 ], "mapped", [ 5056 ] ], [ [ 43921, 43921 ], "mapped", [ 5057 ] ], [ [ 43922, 43922 ], "mapped", [ 5058 ] ], [ [ 43923, 43923 ], "mapped", [ 5059 ] ], [ [ 43924, 43924 ], "mapped", [ 5060 ] ], [ [ 43925, 43925 ], "mapped", [ 5061 ] ], [ [ 43926, 43926 ], "mapped", [ 5062 ] ], [ [ 43927, 43927 ], "mapped", [ 5063 ] ], [ [ 43928, 43928 ], "mapped", [ 5064 ] ], [ [ 43929, 43929 ], "mapped", [ 5065 ] ], [ [ 43930, 43930 ], "mapped", [ 5066 ] ], [ [ 43931, 43931 ], "mapped", [ 5067 ] ], [ [ 43932, 43932 ], "mapped", [ 5068 ] ], [ [ 43933, 43933 ], "mapped", [ 5069 ] ], [ [ 43934, 43934 ], "mapped", [ 5070 ] ], [ [ 43935, 43935 ], "mapped", [ 5071 ] ], [ [ 43936, 43936 ], "mapped", [ 5072 ] ], [ [ 43937, 43937 ], "mapped", [ 5073 ] ], [ [ 43938, 43938 ], "mapped", [ 5074 ] ], [ [ 43939, 43939 ], "mapped", [ 5075 ] ], [ [ 43940, 43940 ], "mapped", [ 5076 ] ], [ [ 43941, 43941 ], "mapped", [ 5077 ] ], [ [ 43942, 43942 ], "mapped", [ 5078 ] ], [ [ 43943, 43943 ], "mapped", [ 5079 ] ], [ [ 43944, 43944 ], "mapped", [ 5080 ] ], [ [ 43945, 43945 ], "mapped", [ 5081 ] ], [ [ 43946, 43946 ], "mapped", [ 5082 ] ], [ [ 43947, 43947 ], "mapped", [ 5083 ] ], [ [ 43948, 43948 ], "mapped", [ 5084 ] ], [ [ 43949, 43949 ], "mapped", [ 5085 ] ], [ [ 43950, 43950 ], "mapped", [ 5086 ] ], [ [ 43951, 43951 ], "mapped", [ 5087 ] ], [ [ 43952, 43952 ], "mapped", [ 5088 ] ], [ [ 43953, 43953 ], "mapped", [ 5089 ] ], [ [ 43954, 43954 ], "mapped", [ 5090 ] ], [ [ 43955, 43955 ], "mapped", [ 5091 ] ], [ [ 43956, 43956 ], "mapped", [ 5092 ] ], [ [ 43957, 43957 ], "mapped", [ 5093 ] ], [ [ 43958, 43958 ], "mapped", [ 5094 ] ], [ [ 43959, 43959 ], "mapped", [ 5095 ] ], [ [ 43960, 43960 ], "mapped", [ 5096 ] ], [ [ 43961, 43961 ], "mapped", [ 5097 ] ], [ [ 43962, 43962 ], "mapped", [ 5098 ] ], [ [ 43963, 43963 ], "mapped", [ 5099 ] ], [ [ 43964, 43964 ], "mapped", [ 5100 ] ], [ [ 43965, 43965 ], "mapped", [ 5101 ] ], [ [ 43966, 43966 ], "mapped", [ 5102 ] ], [ [ 43967, 43967 ], "mapped", [ 5103 ] ], [ [ 43968, 44010 ], "valid" ], [ [ 44011, 44011 ], "valid", [], "NV8" ], [ [ 44012, 44013 ], "valid" ], [ [ 44014, 44015 ], "disallowed" ], [ [ 44016, 44025 ], "valid" ], [ [ 44026, 44031 ], "disallowed" ], [ [ 44032, 55203 ], "valid" ], [ [ 55204, 55215 ], "disallowed" ], [ [ 55216, 55238 ], "valid", [], "NV8" ], [ [ 55239, 55242 ], "disallowed" ], [ [ 55243, 55291 ], "valid", [], "NV8" ], [ [ 55292, 55295 ], "disallowed" ], [ [ 55296, 57343 ], "disallowed" ], [ [ 57344, 63743 ], "disallowed" ], [ [ 63744, 63744 ], "mapped", [ 35912 ] ], [ [ 63745, 63745 ], "mapped", [ 26356 ] ], [ [ 63746, 63746 ], "mapped", [ 36554 ] ], [ [ 63747, 63747 ], "mapped", [ 36040 ] ], [ [ 63748, 63748 ], "mapped", [ 28369 ] ], [ [ 63749, 63749 ], "mapped", [ 20018 ] ], [ [ 63750, 63750 ], "mapped", [ 21477 ] ], [ [ 63751, 63752 ], "mapped", [ 40860 ] ], [ [ 63753, 63753 ], "mapped", [ 22865 ] ], [ [ 63754, 63754 ], "mapped", [ 37329 ] ], [ [ 63755, 63755 ], "mapped", [ 21895 ] ], [ [ 63756, 63756 ], "mapped", [ 22856 ] ], [ [ 63757, 63757 ], "mapped", [ 25078 ] ], [ [ 63758, 63758 ], "mapped", [ 30313 ] ], [ [ 63759, 63759 ], "mapped", [ 32645 ] ], [ [ 63760, 63760 ], "mapped", [ 34367 ] ], [ [ 63761, 63761 ], "mapped", [ 34746 ] ], [ [ 63762, 63762 ], "mapped", [ 35064 ] ], [ [ 63763, 63763 ], "mapped", [ 37007 ] ], [ [ 63764, 63764 ], "mapped", [ 27138 ] ], [ [ 63765, 63765 ], "mapped", [ 27931 ] ], [ [ 63766, 63766 ], "mapped", [ 28889 ] ], [ [ 63767, 63767 ], "mapped", [ 29662 ] ], [ [ 63768, 63768 ], "mapped", [ 33853 ] ], [ [ 63769, 63769 ], "mapped", [ 37226 ] ], [ [ 63770, 63770 ], "mapped", [ 39409 ] ], [ [ 63771, 63771 ], "mapped", [ 20098 ] ], [ [ 63772, 63772 ], "mapped", [ 21365 ] ], [ [ 63773, 63773 ], "mapped", [ 27396 ] ], [ [ 63774, 63774 ], "mapped", [ 29211 ] ], [ [ 63775, 63775 ], "mapped", [ 34349 ] ], [ [ 63776, 63776 ], "mapped", [ 40478 ] ], [ [ 63777, 63777 ], "mapped", [ 23888 ] ], [ [ 63778, 63778 ], "mapped", [ 28651 ] ], [ [ 63779, 63779 ], "mapped", [ 34253 ] ], [ [ 63780, 63780 ], "mapped", [ 35172 ] ], [ [ 63781, 63781 ], "mapped", [ 25289 ] ], [ [ 63782, 63782 ], "mapped", [ 33240 ] ], [ [ 63783, 63783 ], "mapped", [ 34847 ] ], [ [ 63784, 63784 ], "mapped", [ 24266 ] ], [ [ 63785, 63785 ], "mapped", [ 26391 ] ], [ [ 63786, 63786 ], "mapped", [ 28010 ] ], [ [ 63787, 63787 ], "mapped", [ 29436 ] ], [ [ 63788, 63788 ], "mapped", [ 37070 ] ], [ [ 63789, 63789 ], "mapped", [ 20358 ] ], [ [ 63790, 63790 ], "mapped", [ 20919 ] ], [ [ 63791, 63791 ], "mapped", [ 21214 ] ], [ [ 63792, 63792 ], "mapped", [ 25796 ] ], [ [ 63793, 63793 ], "mapped", [ 27347 ] ], [ [ 63794, 63794 ], "mapped", [ 29200 ] ], [ [ 63795, 63795 ], "mapped", [ 30439 ] ], [ [ 63796, 63796 ], "mapped", [ 32769 ] ], [ [ 63797, 63797 ], "mapped", [ 34310 ] ], [ [ 63798, 63798 ], "mapped", [ 34396 ] ], [ [ 63799, 63799 ], "mapped", [ 36335 ] ], [ [ 63800, 63800 ], "mapped", [ 38706 ] ], [ [ 63801, 63801 ], "mapped", [ 39791 ] ], [ [ 63802, 63802 ], "mapped", [ 40442 ] ], [ [ 63803, 63803 ], "mapped", [ 30860 ] ], [ [ 63804, 63804 ], "mapped", [ 31103 ] ], [ [ 63805, 63805 ], "mapped", [ 32160 ] ], [ [ 63806, 63806 ], "mapped", [ 33737 ] ], [ [ 63807, 63807 ], "mapped", [ 37636 ] ], [ [ 63808, 63808 ], "mapped", [ 40575 ] ], [ [ 63809, 63809 ], "mapped", [ 35542 ] ], [ [ 63810, 63810 ], "mapped", [ 22751 ] ], [ [ 63811, 63811 ], "mapped", [ 24324 ] ], [ [ 63812, 63812 ], "mapped", [ 31840 ] ], [ [ 63813, 63813 ], "mapped", [ 32894 ] ], [ [ 63814, 63814 ], "mapped", [ 29282 ] ], [ [ 63815, 63815 ], "mapped", [ 30922 ] ], [ [ 63816, 63816 ], "mapped", [ 36034 ] ], [ [ 63817, 63817 ], "mapped", [ 38647 ] ], [ [ 63818, 63818 ], "mapped", [ 22744 ] ], [ [ 63819, 63819 ], "mapped", [ 23650 ] ], [ [ 63820, 63820 ], "mapped", [ 27155 ] ], [ [ 63821, 63821 ], "mapped", [ 28122 ] ], [ [ 63822, 63822 ], "mapped", [ 28431 ] ], [ [ 63823, 63823 ], "mapped", [ 32047 ] ], [ [ 63824, 63824 ], "mapped", [ 32311 ] ], [ [ 63825, 63825 ], "mapped", [ 38475 ] ], [ [ 63826, 63826 ], "mapped", [ 21202 ] ], [ [ 63827, 63827 ], "mapped", [ 32907 ] ], [ [ 63828, 63828 ], "mapped", [ 20956 ] ], [ [ 63829, 63829 ], "mapped", [ 20940 ] ], [ [ 63830, 63830 ], "mapped", [ 31260 ] ], [ [ 63831, 63831 ], "mapped", [ 32190 ] ], [ [ 63832, 63832 ], "mapped", [ 33777 ] ], [ [ 63833, 63833 ], "mapped", [ 38517 ] ], [ [ 63834, 63834 ], "mapped", [ 35712 ] ], [ [ 63835, 63835 ], "mapped", [ 25295 ] ], [ [ 63836, 63836 ], "mapped", [ 27138 ] ], [ [ 63837, 63837 ], "mapped", [ 35582 ] ], [ [ 63838, 63838 ], "mapped", [ 20025 ] ], [ [ 63839, 63839 ], "mapped", [ 23527 ] ], [ [ 63840, 63840 ], "mapped", [ 24594 ] ], [ [ 63841, 63841 ], "mapped", [ 29575 ] ], [ [ 63842, 63842 ], "mapped", [ 30064 ] ], [ [ 63843, 63843 ], "mapped", [ 21271 ] ], [ [ 63844, 63844 ], "mapped", [ 30971 ] ], [ [ 63845, 63845 ], "mapped", [ 20415 ] ], [ [ 63846, 63846 ], "mapped", [ 24489 ] ], [ [ 63847, 63847 ], "mapped", [ 19981 ] ], [ [ 63848, 63848 ], "mapped", [ 27852 ] ], [ [ 63849, 63849 ], "mapped", [ 25976 ] ], [ [ 63850, 63850 ], "mapped", [ 32034 ] ], [ [ 63851, 63851 ], "mapped", [ 21443 ] ], [ [ 63852, 63852 ], "mapped", [ 22622 ] ], [ [ 63853, 63853 ], "mapped", [ 30465 ] ], [ [ 63854, 63854 ], "mapped", [ 33865 ] ], [ [ 63855, 63855 ], "mapped", [ 35498 ] ], [ [ 63856, 63856 ], "mapped", [ 27578 ] ], [ [ 63857, 63857 ], "mapped", [ 36784 ] ], [ [ 63858, 63858 ], "mapped", [ 27784 ] ], [ [ 63859, 63859 ], "mapped", [ 25342 ] ], [ [ 63860, 63860 ], "mapped", [ 33509 ] ], [ [ 63861, 63861 ], "mapped", [ 25504 ] ], [ [ 63862, 63862 ], "mapped", [ 30053 ] ], [ [ 63863, 63863 ], "mapped", [ 20142 ] ], [ [ 63864, 63864 ], "mapped", [ 20841 ] ], [ [ 63865, 63865 ], "mapped", [ 20937 ] ], [ [ 63866, 63866 ], "mapped", [ 26753 ] ], [ [ 63867, 63867 ], "mapped", [ 31975 ] ], [ [ 63868, 63868 ], "mapped", [ 33391 ] ], [ [ 63869, 63869 ], "mapped", [ 35538 ] ], [ [ 63870, 63870 ], "mapped", [ 37327 ] ], [ [ 63871, 63871 ], "mapped", [ 21237 ] ], [ [ 63872, 63872 ], "mapped", [ 21570 ] ], [ [ 63873, 63873 ], "mapped", [ 22899 ] ], [ [ 63874, 63874 ], "mapped", [ 24300 ] ], [ [ 63875, 63875 ], "mapped", [ 26053 ] ], [ [ 63876, 63876 ], "mapped", [ 28670 ] ], [ [ 63877, 63877 ], "mapped", [ 31018 ] ], [ [ 63878, 63878 ], "mapped", [ 38317 ] ], [ [ 63879, 63879 ], "mapped", [ 39530 ] ], [ [ 63880, 63880 ], "mapped", [ 40599 ] ], [ [ 63881, 63881 ], "mapped", [ 40654 ] ], [ [ 63882, 63882 ], "mapped", [ 21147 ] ], [ [ 63883, 63883 ], "mapped", [ 26310 ] ], [ [ 63884, 63884 ], "mapped", [ 27511 ] ], [ [ 63885, 63885 ], "mapped", [ 36706 ] ], [ [ 63886, 63886 ], "mapped", [ 24180 ] ], [ [ 63887, 63887 ], "mapped", [ 24976 ] ], [ [ 63888, 63888 ], "mapped", [ 25088 ] ], [ [ 63889, 63889 ], "mapped", [ 25754 ] ], [ [ 63890, 63890 ], "mapped", [ 28451 ] ], [ [ 63891, 63891 ], "mapped", [ 29001 ] ], [ [ 63892, 63892 ], "mapped", [ 29833 ] ], [ [ 63893, 63893 ], "mapped", [ 31178 ] ], [ [ 63894, 63894 ], "mapped", [ 32244 ] ], [ [ 63895, 63895 ], "mapped", [ 32879 ] ], [ [ 63896, 63896 ], "mapped", [ 36646 ] ], [ [ 63897, 63897 ], "mapped", [ 34030 ] ], [ [ 63898, 63898 ], "mapped", [ 36899 ] ], [ [ 63899, 63899 ], "mapped", [ 37706 ] ], [ [ 63900, 63900 ], "mapped", [ 21015 ] ], [ [ 63901, 63901 ], "mapped", [ 21155 ] ], [ [ 63902, 63902 ], "mapped", [ 21693 ] ], [ [ 63903, 63903 ], "mapped", [ 28872 ] ], [ [ 63904, 63904 ], "mapped", [ 35010 ] ], [ [ 63905, 63905 ], "mapped", [ 35498 ] ], [ [ 63906, 63906 ], "mapped", [ 24265 ] ], [ [ 63907, 63907 ], "mapped", [ 24565 ] ], [ [ 63908, 63908 ], "mapped", [ 25467 ] ], [ [ 63909, 63909 ], "mapped", [ 27566 ] ], [ [ 63910, 63910 ], "mapped", [ 31806 ] ], [ [ 63911, 63911 ], "mapped", [ 29557 ] ], [ [ 63912, 63912 ], "mapped", [ 20196 ] ], [ [ 63913, 63913 ], "mapped", [ 22265 ] ], [ [ 63914, 63914 ], "mapped", [ 23527 ] ], [ [ 63915, 63915 ], "mapped", [ 23994 ] ], [ [ 63916, 63916 ], "mapped", [ 24604 ] ], [ [ 63917, 63917 ], "mapped", [ 29618 ] ], [ [ 63918, 63918 ], "mapped", [ 29801 ] ], [ [ 63919, 63919 ], "mapped", [ 32666 ] ], [ [ 63920, 63920 ], "mapped", [ 32838 ] ], [ [ 63921, 63921 ], "mapped", [ 37428 ] ], [ [ 63922, 63922 ], "mapped", [ 38646 ] ], [ [ 63923, 63923 ], "mapped", [ 38728 ] ], [ [ 63924, 63924 ], "mapped", [ 38936 ] ], [ [ 63925, 63925 ], "mapped", [ 20363 ] ], [ [ 63926, 63926 ], "mapped", [ 31150 ] ], [ [ 63927, 63927 ], "mapped", [ 37300 ] ], [ [ 63928, 63928 ], "mapped", [ 38584 ] ], [ [ 63929, 63929 ], "mapped", [ 24801 ] ], [ [ 63930, 63930 ], "mapped", [ 20102 ] ], [ [ 63931, 63931 ], "mapped", [ 20698 ] ], [ [ 63932, 63932 ], "mapped", [ 23534 ] ], [ [ 63933, 63933 ], "mapped", [ 23615 ] ], [ [ 63934, 63934 ], "mapped", [ 26009 ] ], [ [ 63935, 63935 ], "mapped", [ 27138 ] ], [ [ 63936, 63936 ], "mapped", [ 29134 ] ], [ [ 63937, 63937 ], "mapped", [ 30274 ] ], [ [ 63938, 63938 ], "mapped", [ 34044 ] ], [ [ 63939, 63939 ], "mapped", [ 36988 ] ], [ [ 63940, 63940 ], "mapped", [ 40845 ] ], [ [ 63941, 63941 ], "mapped", [ 26248 ] ], [ [ 63942, 63942 ], "mapped", [ 38446 ] ], [ [ 63943, 63943 ], "mapped", [ 21129 ] ], [ [ 63944, 63944 ], "mapped", [ 26491 ] ], [ [ 63945, 63945 ], "mapped", [ 26611 ] ], [ [ 63946, 63946 ], "mapped", [ 27969 ] ], [ [ 63947, 63947 ], "mapped", [ 28316 ] ], [ [ 63948, 63948 ], "mapped", [ 29705 ] ], [ [ 63949, 63949 ], "mapped", [ 30041 ] ], [ [ 63950, 63950 ], "mapped", [ 30827 ] ], [ [ 63951, 63951 ], "mapped", [ 32016 ] ], [ [ 63952, 63952 ], "mapped", [ 39006 ] ], [ [ 63953, 63953 ], "mapped", [ 20845 ] ], [ [ 63954, 63954 ], "mapped", [ 25134 ] ], [ [ 63955, 63955 ], "mapped", [ 38520 ] ], [ [ 63956, 63956 ], "mapped", [ 20523 ] ], [ [ 63957, 63957 ], "mapped", [ 23833 ] ], [ [ 63958, 63958 ], "mapped", [ 28138 ] ], [ [ 63959, 63959 ], "mapped", [ 36650 ] ], [ [ 63960, 63960 ], "mapped", [ 24459 ] ], [ [ 63961, 63961 ], "mapped", [ 24900 ] ], [ [ 63962, 63962 ], "mapped", [ 26647 ] ], [ [ 63963, 63963 ], "mapped", [ 29575 ] ], [ [ 63964, 63964 ], "mapped", [ 38534 ] ], [ [ 63965, 63965 ], "mapped", [ 21033 ] ], [ [ 63966, 63966 ], "mapped", [ 21519 ] ], [ [ 63967, 63967 ], "mapped", [ 23653 ] ], [ [ 63968, 63968 ], "mapped", [ 26131 ] ], [ [ 63969, 63969 ], "mapped", [ 26446 ] ], [ [ 63970, 63970 ], "mapped", [ 26792 ] ], [ [ 63971, 63971 ], "mapped", [ 27877 ] ], [ [ 63972, 63972 ], "mapped", [ 29702 ] ], [ [ 63973, 63973 ], "mapped", [ 30178 ] ], [ [ 63974, 63974 ], "mapped", [ 32633 ] ], [ [ 63975, 63975 ], "mapped", [ 35023 ] ], [ [ 63976, 63976 ], "mapped", [ 35041 ] ], [ [ 63977, 63977 ], "mapped", [ 37324 ] ], [ [ 63978, 63978 ], "mapped", [ 38626 ] ], [ [ 63979, 63979 ], "mapped", [ 21311 ] ], [ [ 63980, 63980 ], "mapped", [ 28346 ] ], [ [ 63981, 63981 ], "mapped", [ 21533 ] ], [ [ 63982, 63982 ], "mapped", [ 29136 ] ], [ [ 63983, 63983 ], "mapped", [ 29848 ] ], [ [ 63984, 63984 ], "mapped", [ 34298 ] ], [ [ 63985, 63985 ], "mapped", [ 38563 ] ], [ [ 63986, 63986 ], "mapped", [ 40023 ] ], [ [ 63987, 63987 ], "mapped", [ 40607 ] ], [ [ 63988, 63988 ], "mapped", [ 26519 ] ], [ [ 63989, 63989 ], "mapped", [ 28107 ] ], [ [ 63990, 63990 ], "mapped", [ 33256 ] ], [ [ 63991, 63991 ], "mapped", [ 31435 ] ], [ [ 63992, 63992 ], "mapped", [ 31520 ] ], [ [ 63993, 63993 ], "mapped", [ 31890 ] ], [ [ 63994, 63994 ], "mapped", [ 29376 ] ], [ [ 63995, 63995 ], "mapped", [ 28825 ] ], [ [ 63996, 63996 ], "mapped", [ 35672 ] ], [ [ 63997, 63997 ], "mapped", [ 20160 ] ], [ [ 63998, 63998 ], "mapped", [ 33590 ] ], [ [ 63999, 63999 ], "mapped", [ 21050 ] ], [ [ 64e3, 64e3 ], "mapped", [ 20999 ] ], [ [ 64001, 64001 ], "mapped", [ 24230 ] ], [ [ 64002, 64002 ], "mapped", [ 25299 ] ], [ [ 64003, 64003 ], "mapped", [ 31958 ] ], [ [ 64004, 64004 ], "mapped", [ 23429 ] ], [ [ 64005, 64005 ], "mapped", [ 27934 ] ], [ [ 64006, 64006 ], "mapped", [ 26292 ] ], [ [ 64007, 64007 ], "mapped", [ 36667 ] ], [ [ 64008, 64008 ], "mapped", [ 34892 ] ], [ [ 64009, 64009 ], "mapped", [ 38477 ] ], [ [ 64010, 64010 ], "mapped", [ 35211 ] ], [ [ 64011, 64011 ], "mapped", [ 24275 ] ], [ [ 64012, 64012 ], "mapped", [ 20800 ] ], [ [ 64013, 64013 ], "mapped", [ 21952 ] ], [ [ 64014, 64015 ], "valid" ], [ [ 64016, 64016 ], "mapped", [ 22618 ] ], [ [ 64017, 64017 ], "valid" ], [ [ 64018, 64018 ], "mapped", [ 26228 ] ], [ [ 64019, 64020 ], "valid" ], [ [ 64021, 64021 ], "mapped", [ 20958 ] ], [ [ 64022, 64022 ], "mapped", [ 29482 ] ], [ [ 64023, 64023 ], "mapped", [ 30410 ] ], [ [ 64024, 64024 ], "mapped", [ 31036 ] ], [ [ 64025, 64025 ], "mapped", [ 31070 ] ], [ [ 64026, 64026 ], "mapped", [ 31077 ] ], [ [ 64027, 64027 ], "mapped", [ 31119 ] ], [ [ 64028, 64028 ], "mapped", [ 38742 ] ], [ [ 64029, 64029 ], "mapped", [ 31934 ] ], [ [ 64030, 64030 ], "mapped", [ 32701 ] ], [ [ 64031, 64031 ], "valid" ], [ [ 64032, 64032 ], "mapped", [ 34322 ] ], [ [ 64033, 64033 ], "valid" ], [ [ 64034, 64034 ], "mapped", [ 35576 ] ], [ [ 64035, 64036 ], "valid" ], [ [ 64037, 64037 ], "mapped", [ 36920 ] ], [ [ 64038, 64038 ], "mapped", [ 37117 ] ], [ [ 64039, 64041 ], "valid" ], [ [ 64042, 64042 ], "mapped", [ 39151 ] ], [ [ 64043, 64043 ], "mapped", [ 39164 ] ], [ [ 64044, 64044 ], "mapped", [ 39208 ] ], [ [ 64045, 64045 ], "mapped", [ 40372 ] ], [ [ 64046, 64046 ], "mapped", [ 37086 ] ], [ [ 64047, 64047 ], "mapped", [ 38583 ] ], [ [ 64048, 64048 ], "mapped", [ 20398 ] ], [ [ 64049, 64049 ], "mapped", [ 20711 ] ], [ [ 64050, 64050 ], "mapped", [ 20813 ] ], [ [ 64051, 64051 ], "mapped", [ 21193 ] ], [ [ 64052, 64052 ], "mapped", [ 21220 ] ], [ [ 64053, 64053 ], "mapped", [ 21329 ] ], [ [ 64054, 64054 ], "mapped", [ 21917 ] ], [ [ 64055, 64055 ], "mapped", [ 22022 ] ], [ [ 64056, 64056 ], "mapped", [ 22120 ] ], [ [ 64057, 64057 ], "mapped", [ 22592 ] ], [ [ 64058, 64058 ], "mapped", [ 22696 ] ], [ [ 64059, 64059 ], "mapped", [ 23652 ] ], [ [ 64060, 64060 ], "mapped", [ 23662 ] ], [ [ 64061, 64061 ], "mapped", [ 24724 ] ], [ [ 64062, 64062 ], "mapped", [ 24936 ] ], [ [ 64063, 64063 ], "mapped", [ 24974 ] ], [ [ 64064, 64064 ], "mapped", [ 25074 ] ], [ [ 64065, 64065 ], "mapped", [ 25935 ] ], [ [ 64066, 64066 ], "mapped", [ 26082 ] ], [ [ 64067, 64067 ], "mapped", [ 26257 ] ], [ [ 64068, 64068 ], "mapped", [ 26757 ] ], [ [ 64069, 64069 ], "mapped", [ 28023 ] ], [ [ 64070, 64070 ], "mapped", [ 28186 ] ], [ [ 64071, 64071 ], "mapped", [ 28450 ] ], [ [ 64072, 64072 ], "mapped", [ 29038 ] ], [ [ 64073, 64073 ], "mapped", [ 29227 ] ], [ [ 64074, 64074 ], "mapped", [ 29730 ] ], [ [ 64075, 64075 ], "mapped", [ 30865 ] ], [ [ 64076, 64076 ], "mapped", [ 31038 ] ], [ [ 64077, 64077 ], "mapped", [ 31049 ] ], [ [ 64078, 64078 ], "mapped", [ 31048 ] ], [ [ 64079, 64079 ], "mapped", [ 31056 ] ], [ [ 64080, 64080 ], "mapped", [ 31062 ] ], [ [ 64081, 64081 ], "mapped", [ 31069 ] ], [ [ 64082, 64082 ], "mapped", [ 31117 ] ], [ [ 64083, 64083 ], "mapped", [ 31118 ] ], [ [ 64084, 64084 ], "mapped", [ 31296 ] ], [ [ 64085, 64085 ], "mapped", [ 31361 ] ], [ [ 64086, 64086 ], "mapped", [ 31680 ] ], [ [ 64087, 64087 ], "mapped", [ 32244 ] ], [ [ 64088, 64088 ], "mapped", [ 32265 ] ], [ [ 64089, 64089 ], "mapped", [ 32321 ] ], [ [ 64090, 64090 ], "mapped", [ 32626 ] ], [ [ 64091, 64091 ], "mapped", [ 32773 ] ], [ [ 64092, 64092 ], "mapped", [ 33261 ] ], [ [ 64093, 64094 ], "mapped", [ 33401 ] ], [ [ 64095, 64095 ], "mapped", [ 33879 ] ], [ [ 64096, 64096 ], "mapped", [ 35088 ] ], [ [ 64097, 64097 ], "mapped", [ 35222 ] ], [ [ 64098, 64098 ], "mapped", [ 35585 ] ], [ [ 64099, 64099 ], "mapped", [ 35641 ] ], [ [ 64100, 64100 ], "mapped", [ 36051 ] ], [ [ 64101, 64101 ], "mapped", [ 36104 ] ], [ [ 64102, 64102 ], "mapped", [ 36790 ] ], [ [ 64103, 64103 ], "mapped", [ 36920 ] ], [ [ 64104, 64104 ], "mapped", [ 38627 ] ], [ [ 64105, 64105 ], "mapped", [ 38911 ] ], [ [ 64106, 64106 ], "mapped", [ 38971 ] ], [ [ 64107, 64107 ], "mapped", [ 24693 ] ], [ [ 64108, 64108 ], "mapped", [ 148206 ] ], [ [ 64109, 64109 ], "mapped", [ 33304 ] ], [ [ 64110, 64111 ], "disallowed" ], [ [ 64112, 64112 ], "mapped", [ 20006 ] ], [ [ 64113, 64113 ], "mapped", [ 20917 ] ], [ [ 64114, 64114 ], "mapped", [ 20840 ] ], [ [ 64115, 64115 ], "mapped", [ 20352 ] ], [ [ 64116, 64116 ], "mapped", [ 20805 ] ], [ [ 64117, 64117 ], "mapped", [ 20864 ] ], [ [ 64118, 64118 ], "mapped", [ 21191 ] ], [ [ 64119, 64119 ], "mapped", [ 21242 ] ], [ [ 64120, 64120 ], "mapped", [ 21917 ] ], [ [ 64121, 64121 ], "mapped", [ 21845 ] ], [ [ 64122, 64122 ], "mapped", [ 21913 ] ], [ [ 64123, 64123 ], "mapped", [ 21986 ] ], [ [ 64124, 64124 ], "mapped", [ 22618 ] ], [ [ 64125, 64125 ], "mapped", [ 22707 ] ], [ [ 64126, 64126 ], "mapped", [ 22852 ] ], [ [ 64127, 64127 ], "mapped", [ 22868 ] ], [ [ 64128, 64128 ], "mapped", [ 23138 ] ], [ [ 64129, 64129 ], "mapped", [ 23336 ] ], [ [ 64130, 64130 ], "mapped", [ 24274 ] ], [ [ 64131, 64131 ], "mapped", [ 24281 ] ], [ [ 64132, 64132 ], "mapped", [ 24425 ] ], [ [ 64133, 64133 ], "mapped", [ 24493 ] ], [ [ 64134, 64134 ], "mapped", [ 24792 ] ], [ [ 64135, 64135 ], "mapped", [ 24910 ] ], [ [ 64136, 64136 ], "mapped", [ 24840 ] ], [ [ 64137, 64137 ], "mapped", [ 24974 ] ], [ [ 64138, 64138 ], "mapped", [ 24928 ] ], [ [ 64139, 64139 ], "mapped", [ 25074 ] ], [ [ 64140, 64140 ], "mapped", [ 25140 ] ], [ [ 64141, 64141 ], "mapped", [ 25540 ] ], [ [ 64142, 64142 ], "mapped", [ 25628 ] ], [ [ 64143, 64143 ], "mapped", [ 25682 ] ], [ [ 64144, 64144 ], "mapped", [ 25942 ] ], [ [ 64145, 64145 ], "mapped", [ 26228 ] ], [ [ 64146, 64146 ], "mapped", [ 26391 ] ], [ [ 64147, 64147 ], "mapped", [ 26395 ] ], [ [ 64148, 64148 ], "mapped", [ 26454 ] ], [ [ 64149, 64149 ], "mapped", [ 27513 ] ], [ [ 64150, 64150 ], "mapped", [ 27578 ] ], [ [ 64151, 64151 ], "mapped", [ 27969 ] ], [ [ 64152, 64152 ], "mapped", [ 28379 ] ], [ [ 64153, 64153 ], "mapped", [ 28363 ] ], [ [ 64154, 64154 ], "mapped", [ 28450 ] ], [ [ 64155, 64155 ], "mapped", [ 28702 ] ], [ [ 64156, 64156 ], "mapped", [ 29038 ] ], [ [ 64157, 64157 ], "mapped", [ 30631 ] ], [ [ 64158, 64158 ], "mapped", [ 29237 ] ], [ [ 64159, 64159 ], "mapped", [ 29359 ] ], [ [ 64160, 64160 ], "mapped", [ 29482 ] ], [ [ 64161, 64161 ], "mapped", [ 29809 ] ], [ [ 64162, 64162 ], "mapped", [ 29958 ] ], [ [ 64163, 64163 ], "mapped", [ 30011 ] ], [ [ 64164, 64164 ], "mapped", [ 30237 ] ], [ [ 64165, 64165 ], "mapped", [ 30239 ] ], [ [ 64166, 64166 ], "mapped", [ 30410 ] ], [ [ 64167, 64167 ], "mapped", [ 30427 ] ], [ [ 64168, 64168 ], "mapped", [ 30452 ] ], [ [ 64169, 64169 ], "mapped", [ 30538 ] ], [ [ 64170, 64170 ], "mapped", [ 30528 ] ], [ [ 64171, 64171 ], "mapped", [ 30924 ] ], [ [ 64172, 64172 ], "mapped", [ 31409 ] ], [ [ 64173, 64173 ], "mapped", [ 31680 ] ], [ [ 64174, 64174 ], "mapped", [ 31867 ] ], [ [ 64175, 64175 ], "mapped", [ 32091 ] ], [ [ 64176, 64176 ], "mapped", [ 32244 ] ], [ [ 64177, 64177 ], "mapped", [ 32574 ] ], [ [ 64178, 64178 ], "mapped", [ 32773 ] ], [ [ 64179, 64179 ], "mapped", [ 33618 ] ], [ [ 64180, 64180 ], "mapped", [ 33775 ] ], [ [ 64181, 64181 ], "mapped", [ 34681 ] ], [ [ 64182, 64182 ], "mapped", [ 35137 ] ], [ [ 64183, 64183 ], "mapped", [ 35206 ] ], [ [ 64184, 64184 ], "mapped", [ 35222 ] ], [ [ 64185, 64185 ], "mapped", [ 35519 ] ], [ [ 64186, 64186 ], "mapped", [ 35576 ] ], [ [ 64187, 64187 ], "mapped", [ 35531 ] ], [ [ 64188, 64188 ], "mapped", [ 35585 ] ], [ [ 64189, 64189 ], "mapped", [ 35582 ] ], [ [ 64190, 64190 ], "mapped", [ 35565 ] ], [ [ 64191, 64191 ], "mapped", [ 35641 ] ], [ [ 64192, 64192 ], "mapped", [ 35722 ] ], [ [ 64193, 64193 ], "mapped", [ 36104 ] ], [ [ 64194, 64194 ], "mapped", [ 36664 ] ], [ [ 64195, 64195 ], "mapped", [ 36978 ] ], [ [ 64196, 64196 ], "mapped", [ 37273 ] ], [ [ 64197, 64197 ], "mapped", [ 37494 ] ], [ [ 64198, 64198 ], "mapped", [ 38524 ] ], [ [ 64199, 64199 ], "mapped", [ 38627 ] ], [ [ 64200, 64200 ], "mapped", [ 38742 ] ], [ [ 64201, 64201 ], "mapped", [ 38875 ] ], [ [ 64202, 64202 ], "mapped", [ 38911 ] ], [ [ 64203, 64203 ], "mapped", [ 38923 ] ], [ [ 64204, 64204 ], "mapped", [ 38971 ] ], [ [ 64205, 64205 ], "mapped", [ 39698 ] ], [ [ 64206, 64206 ], "mapped", [ 40860 ] ], [ [ 64207, 64207 ], "mapped", [ 141386 ] ], [ [ 64208, 64208 ], "mapped", [ 141380 ] ], [ [ 64209, 64209 ], "mapped", [ 144341 ] ], [ [ 64210, 64210 ], "mapped", [ 15261 ] ], [ [ 64211, 64211 ], "mapped", [ 16408 ] ], [ [ 64212, 64212 ], "mapped", [ 16441 ] ], [ [ 64213, 64213 ], "mapped", [ 152137 ] ], [ [ 64214, 64214 ], "mapped", [ 154832 ] ], [ [ 64215, 64215 ], "mapped", [ 163539 ] ], [ [ 64216, 64216 ], "mapped", [ 40771 ] ], [ [ 64217, 64217 ], "mapped", [ 40846 ] ], [ [ 64218, 64255 ], "disallowed" ], [ [ 64256, 64256 ], "mapped", [ 102, 102 ] ], [ [ 64257, 64257 ], "mapped", [ 102, 105 ] ], [ [ 64258, 64258 ], "mapped", [ 102, 108 ] ], [ [ 64259, 64259 ], "mapped", [ 102, 102, 105 ] ], [ [ 64260, 64260 ], "mapped", [ 102, 102, 108 ] ], [ [ 64261, 64262 ], "mapped", [ 115, 116 ] ], [ [ 64263, 64274 ], "disallowed" ], [ [ 64275, 64275 ], "mapped", [ 1396, 1398 ] ], [ [ 64276, 64276 ], "mapped", [ 1396, 1381 ] ], [ [ 64277, 64277 ], "mapped", [ 1396, 1387 ] ], [ [ 64278, 64278 ], "mapped", [ 1406, 1398 ] ], [ [ 64279, 64279 ], "mapped", [ 1396, 1389 ] ], [ [ 64280, 64284 ], "disallowed" ], [ [ 64285, 64285 ], "mapped", [ 1497, 1460 ] ], [ [ 64286, 64286 ], "valid" ], [ [ 64287, 64287 ], "mapped", [ 1522, 1463 ] ], [ [ 64288, 64288 ], "mapped", [ 1506 ] ], [ [ 64289, 64289 ], "mapped", [ 1488 ] ], [ [ 64290, 64290 ], "mapped", [ 1491 ] ], [ [ 64291, 64291 ], "mapped", [ 1492 ] ], [ [ 64292, 64292 ], "mapped", [ 1499 ] ], [ [ 64293, 64293 ], "mapped", [ 1500 ] ], [ [ 64294, 64294 ], "mapped", [ 1501 ] ], [ [ 64295, 64295 ], "mapped", [ 1512 ] ], [ [ 64296, 64296 ], "mapped", [ 1514 ] ], [ [ 64297, 64297 ], "disallowed_STD3_mapped", [ 43 ] ], [ [ 64298, 64298 ], "mapped", [ 1513, 1473 ] ], [ [ 64299, 64299 ], "mapped", [ 1513, 1474 ] ], [ [ 64300, 64300 ], "mapped", [ 1513, 1468, 1473 ] ], [ [ 64301, 64301 ], "mapped", [ 1513, 1468, 1474 ] ], [ [ 64302, 64302 ], "mapped", [ 1488, 1463 ] ], [ [ 64303, 64303 ], "mapped", [ 1488, 1464 ] ], [ [ 64304, 64304 ], "mapped", [ 1488, 1468 ] ], [ [ 64305, 64305 ], "mapped", [ 1489, 1468 ] ], [ [ 64306, 64306 ], "mapped", [ 1490, 1468 ] ], [ [ 64307, 64307 ], "mapped", [ 1491, 1468 ] ], [ [ 64308, 64308 ], "mapped", [ 1492, 1468 ] ], [ [ 64309, 64309 ], "mapped", [ 1493, 1468 ] ], [ [ 64310, 64310 ], "mapped", [ 1494, 1468 ] ], [ [ 64311, 64311 ], "disallowed" ], [ [ 64312, 64312 ], "mapped", [ 1496, 1468 ] ], [ [ 64313, 64313 ], "mapped", [ 1497, 1468 ] ], [ [ 64314, 64314 ], "mapped", [ 1498, 1468 ] ], [ [ 64315, 64315 ], "mapped", [ 1499, 1468 ] ], [ [ 64316, 64316 ], "mapped", [ 1500, 1468 ] ], [ [ 64317, 64317 ], "disallowed" ], [ [ 64318, 64318 ], "mapped", [ 1502, 1468 ] ], [ [ 64319, 64319 ], "disallowed" ], [ [ 64320, 64320 ], "mapped", [ 1504, 1468 ] ], [ [ 64321, 64321 ], "mapped", [ 1505, 1468 ] ], [ [ 64322, 64322 ], "disallowed" ], [ [ 64323, 64323 ], "mapped", [ 1507, 1468 ] ], [ [ 64324, 64324 ], "mapped", [ 1508, 1468 ] ], [ [ 64325, 64325 ], "disallowed" ], [ [ 64326, 64326 ], "mapped", [ 1510, 1468 ] ], [ [ 64327, 64327 ], "mapped", [ 1511, 1468 ] ], [ [ 64328, 64328 ], "mapped", [ 1512, 1468 ] ], [ [ 64329, 64329 ], "mapped", [ 1513, 1468 ] ], [ [ 64330, 64330 ], "mapped", [ 1514, 1468 ] ], [ [ 64331, 64331 ], "mapped", [ 1493, 1465 ] ], [ [ 64332, 64332 ], "mapped", [ 1489, 1471 ] ], [ [ 64333, 64333 ], "mapped", [ 1499, 1471 ] ], [ [ 64334, 64334 ], "mapped", [ 1508, 1471 ] ], [ [ 64335, 64335 ], "mapped", [ 1488, 1500 ] ], [ [ 64336, 64337 ], "mapped", [ 1649 ] ], [ [ 64338, 64341 ], "mapped", [ 1659 ] ], [ [ 64342, 64345 ], "mapped", [ 1662 ] ], [ [ 64346, 64349 ], "mapped", [ 1664 ] ], [ [ 64350, 64353 ], "mapped", [ 1658 ] ], [ [ 64354, 64357 ], "mapped", [ 1663 ] ], [ [ 64358, 64361 ], "mapped", [ 1657 ] ], [ [ 64362, 64365 ], "mapped", [ 1700 ] ], [ [ 64366, 64369 ], "mapped", [ 1702 ] ], [ [ 64370, 64373 ], "mapped", [ 1668 ] ], [ [ 64374, 64377 ], "mapped", [ 1667 ] ], [ [ 64378, 64381 ], "mapped", [ 1670 ] ], [ [ 64382, 64385 ], "mapped", [ 1671 ] ], [ [ 64386, 64387 ], "mapped", [ 1677 ] ], [ [ 64388, 64389 ], "mapped", [ 1676 ] ], [ [ 64390, 64391 ], "mapped", [ 1678 ] ], [ [ 64392, 64393 ], "mapped", [ 1672 ] ], [ [ 64394, 64395 ], "mapped", [ 1688 ] ], [ [ 64396, 64397 ], "mapped", [ 1681 ] ], [ [ 64398, 64401 ], "mapped", [ 1705 ] ], [ [ 64402, 64405 ], "mapped", [ 1711 ] ], [ [ 64406, 64409 ], "mapped", [ 1715 ] ], [ [ 64410, 64413 ], "mapped", [ 1713 ] ], [ [ 64414, 64415 ], "mapped", [ 1722 ] ], [ [ 64416, 64419 ], "mapped", [ 1723 ] ], [ [ 64420, 64421 ], "mapped", [ 1728 ] ], [ [ 64422, 64425 ], "mapped", [ 1729 ] ], [ [ 64426, 64429 ], "mapped", [ 1726 ] ], [ [ 64430, 64431 ], "mapped", [ 1746 ] ], [ [ 64432, 64433 ], "mapped", [ 1747 ] ], [ [ 64434, 64449 ], "valid", [], "NV8" ], [ [ 64450, 64466 ], "disallowed" ], [ [ 64467, 64470 ], "mapped", [ 1709 ] ], [ [ 64471, 64472 ], "mapped", [ 1735 ] ], [ [ 64473, 64474 ], "mapped", [ 1734 ] ], [ [ 64475, 64476 ], "mapped", [ 1736 ] ], [ [ 64477, 64477 ], "mapped", [ 1735, 1652 ] ], [ [ 64478, 64479 ], "mapped", [ 1739 ] ], [ [ 64480, 64481 ], "mapped", [ 1733 ] ], [ [ 64482, 64483 ], "mapped", [ 1737 ] ], [ [ 64484, 64487 ], "mapped", [ 1744 ] ], [ [ 64488, 64489 ], "mapped", [ 1609 ] ], [ [ 64490, 64491 ], "mapped", [ 1574, 1575 ] ], [ [ 64492, 64493 ], "mapped", [ 1574, 1749 ] ], [ [ 64494, 64495 ], "mapped", [ 1574, 1608 ] ], [ [ 64496, 64497 ], "mapped", [ 1574, 1735 ] ], [ [ 64498, 64499 ], "mapped", [ 1574, 1734 ] ], [ [ 64500, 64501 ], "mapped", [ 1574, 1736 ] ], [ [ 64502, 64504 ], "mapped", [ 1574, 1744 ] ], [ [ 64505, 64507 ], "mapped", [ 1574, 1609 ] ], [ [ 64508, 64511 ], "mapped", [ 1740 ] ], [ [ 64512, 64512 ], "mapped", [ 1574, 1580 ] ], [ [ 64513, 64513 ], "mapped", [ 1574, 1581 ] ], [ [ 64514, 64514 ], "mapped", [ 1574, 1605 ] ], [ [ 64515, 64515 ], "mapped", [ 1574, 1609 ] ], [ [ 64516, 64516 ], "mapped", [ 1574, 1610 ] ], [ [ 64517, 64517 ], "mapped", [ 1576, 1580 ] ], [ [ 64518, 64518 ], "mapped", [ 1576, 1581 ] ], [ [ 64519, 64519 ], "mapped", [ 1576, 1582 ] ], [ [ 64520, 64520 ], "mapped", [ 1576, 1605 ] ], [ [ 64521, 64521 ], "mapped", [ 1576, 1609 ] ], [ [ 64522, 64522 ], "mapped", [ 1576, 1610 ] ], [ [ 64523, 64523 ], "mapped", [ 1578, 1580 ] ], [ [ 64524, 64524 ], "mapped", [ 1578, 1581 ] ], [ [ 64525, 64525 ], "mapped", [ 1578, 1582 ] ], [ [ 64526, 64526 ], "mapped", [ 1578, 1605 ] ], [ [ 64527, 64527 ], "mapped", [ 1578, 1609 ] ], [ [ 64528, 64528 ], "mapped", [ 1578, 1610 ] ], [ [ 64529, 64529 ], "mapped", [ 1579, 1580 ] ], [ [ 64530, 64530 ], "mapped", [ 1579, 1605 ] ], [ [ 64531, 64531 ], "mapped", [ 1579, 1609 ] ], [ [ 64532, 64532 ], "mapped", [ 1579, 1610 ] ], [ [ 64533, 64533 ], "mapped", [ 1580, 1581 ] ], [ [ 64534, 64534 ], "mapped", [ 1580, 1605 ] ], [ [ 64535, 64535 ], "mapped", [ 1581, 1580 ] ], [ [ 64536, 64536 ], "mapped", [ 1581, 1605 ] ], [ [ 64537, 64537 ], "mapped", [ 1582, 1580 ] ], [ [ 64538, 64538 ], "mapped", [ 1582, 1581 ] ], [ [ 64539, 64539 ], "mapped", [ 1582, 1605 ] ], [ [ 64540, 64540 ], "mapped", [ 1587, 1580 ] ], [ [ 64541, 64541 ], "mapped", [ 1587, 1581 ] ], [ [ 64542, 64542 ], "mapped", [ 1587, 1582 ] ], [ [ 64543, 64543 ], "mapped", [ 1587, 1605 ] ], [ [ 64544, 64544 ], "mapped", [ 1589, 1581 ] ], [ [ 64545, 64545 ], "mapped", [ 1589, 1605 ] ], [ [ 64546, 64546 ], "mapped", [ 1590, 1580 ] ], [ [ 64547, 64547 ], "mapped", [ 1590, 1581 ] ], [ [ 64548, 64548 ], "mapped", [ 1590, 1582 ] ], [ [ 64549, 64549 ], "mapped", [ 1590, 1605 ] ], [ [ 64550, 64550 ], "mapped", [ 1591, 1581 ] ], [ [ 64551, 64551 ], "mapped", [ 1591, 1605 ] ], [ [ 64552, 64552 ], "mapped", [ 1592, 1605 ] ], [ [ 64553, 64553 ], "mapped", [ 1593, 1580 ] ], [ [ 64554, 64554 ], "mapped", [ 1593, 1605 ] ], [ [ 64555, 64555 ], "mapped", [ 1594, 1580 ] ], [ [ 64556, 64556 ], "mapped", [ 1594, 1605 ] ], [ [ 64557, 64557 ], "mapped", [ 1601, 1580 ] ], [ [ 64558, 64558 ], "mapped", [ 1601, 1581 ] ], [ [ 64559, 64559 ], "mapped", [ 1601, 1582 ] ], [ [ 64560, 64560 ], "mapped", [ 1601, 1605 ] ], [ [ 64561, 64561 ], "mapped", [ 1601, 1609 ] ], [ [ 64562, 64562 ], "mapped", [ 1601, 1610 ] ], [ [ 64563, 64563 ], "mapped", [ 1602, 1581 ] ], [ [ 64564, 64564 ], "mapped", [ 1602, 1605 ] ], [ [ 64565, 64565 ], "mapped", [ 1602, 1609 ] ], [ [ 64566, 64566 ], "mapped", [ 1602, 1610 ] ], [ [ 64567, 64567 ], "mapped", [ 1603, 1575 ] ], [ [ 64568, 64568 ], "mapped", [ 1603, 1580 ] ], [ [ 64569, 64569 ], "mapped", [ 1603, 1581 ] ], [ [ 64570, 64570 ], "mapped", [ 1603, 1582 ] ], [ [ 64571, 64571 ], "mapped", [ 1603, 1604 ] ], [ [ 64572, 64572 ], "mapped", [ 1603, 1605 ] ], [ [ 64573, 64573 ], "mapped", [ 1603, 1609 ] ], [ [ 64574, 64574 ], "mapped", [ 1603, 1610 ] ], [ [ 64575, 64575 ], "mapped", [ 1604, 1580 ] ], [ [ 64576, 64576 ], "mapped", [ 1604, 1581 ] ], [ [ 64577, 64577 ], "mapped", [ 1604, 1582 ] ], [ [ 64578, 64578 ], "mapped", [ 1604, 1605 ] ], [ [ 64579, 64579 ], "mapped", [ 1604, 1609 ] ], [ [ 64580, 64580 ], "mapped", [ 1604, 1610 ] ], [ [ 64581, 64581 ], "mapped", [ 1605, 1580 ] ], [ [ 64582, 64582 ], "mapped", [ 1605, 1581 ] ], [ [ 64583, 64583 ], "mapped", [ 1605, 1582 ] ], [ [ 64584, 64584 ], "mapped", [ 1605, 1605 ] ], [ [ 64585, 64585 ], "mapped", [ 1605, 1609 ] ], [ [ 64586, 64586 ], "mapped", [ 1605, 1610 ] ], [ [ 64587, 64587 ], "mapped", [ 1606, 1580 ] ], [ [ 64588, 64588 ], "mapped", [ 1606, 1581 ] ], [ [ 64589, 64589 ], "mapped", [ 1606, 1582 ] ], [ [ 64590, 64590 ], "mapped", [ 1606, 1605 ] ], [ [ 64591, 64591 ], "mapped", [ 1606, 1609 ] ], [ [ 64592, 64592 ], "mapped", [ 1606, 1610 ] ], [ [ 64593, 64593 ], "mapped", [ 1607, 1580 ] ], [ [ 64594, 64594 ], "mapped", [ 1607, 1605 ] ], [ [ 64595, 64595 ], "mapped", [ 1607, 1609 ] ], [ [ 64596, 64596 ], "mapped", [ 1607, 1610 ] ], [ [ 64597, 64597 ], "mapped", [ 1610, 1580 ] ], [ [ 64598, 64598 ], "mapped", [ 1610, 1581 ] ], [ [ 64599, 64599 ], "mapped", [ 1610, 1582 ] ], [ [ 64600, 64600 ], "mapped", [ 1610, 1605 ] ], [ [ 64601, 64601 ], "mapped", [ 1610, 1609 ] ], [ [ 64602, 64602 ], "mapped", [ 1610, 1610 ] ], [ [ 64603, 64603 ], "mapped", [ 1584, 1648 ] ], [ [ 64604, 64604 ], "mapped", [ 1585, 1648 ] ], [ [ 64605, 64605 ], "mapped", [ 1609, 1648 ] ], [ [ 64606, 64606 ], "disallowed_STD3_mapped", [ 32, 1612, 1617 ] ], [ [ 64607, 64607 ], "disallowed_STD3_mapped", [ 32, 1613, 1617 ] ], [ [ 64608, 64608 ], "disallowed_STD3_mapped", [ 32, 1614, 1617 ] ], [ [ 64609, 64609 ], "disallowed_STD3_mapped", [ 32, 1615, 1617 ] ], [ [ 64610, 64610 ], "disallowed_STD3_mapped", [ 32, 1616, 1617 ] ], [ [ 64611, 64611 ], "disallowed_STD3_mapped", [ 32, 1617, 1648 ] ], [ [ 64612, 64612 ], "mapped", [ 1574, 1585 ] ], [ [ 64613, 64613 ], "mapped", [ 1574, 1586 ] ], [ [ 64614, 64614 ], "mapped", [ 1574, 1605 ] ], [ [ 64615, 64615 ], "mapped", [ 1574, 1606 ] ], [ [ 64616, 64616 ], "mapped", [ 1574, 1609 ] ], [ [ 64617, 64617 ], "mapped", [ 1574, 1610 ] ], [ [ 64618, 64618 ], "mapped", [ 1576, 1585 ] ], [ [ 64619, 64619 ], "mapped", [ 1576, 1586 ] ], [ [ 64620, 64620 ], "mapped", [ 1576, 1605 ] ], [ [ 64621, 64621 ], "mapped", [ 1576, 1606 ] ], [ [ 64622, 64622 ], "mapped", [ 1576, 1609 ] ], [ [ 64623, 64623 ], "mapped", [ 1576, 1610 ] ], [ [ 64624, 64624 ], "mapped", [ 1578, 1585 ] ], [ [ 64625, 64625 ], "mapped", [ 1578, 1586 ] ], [ [ 64626, 64626 ], "mapped", [ 1578, 1605 ] ], [ [ 64627, 64627 ], "mapped", [ 1578, 1606 ] ], [ [ 64628, 64628 ], "mapped", [ 1578, 1609 ] ], [ [ 64629, 64629 ], "mapped", [ 1578, 1610 ] ], [ [ 64630, 64630 ], "mapped", [ 1579, 1585 ] ], [ [ 64631, 64631 ], "mapped", [ 1579, 1586 ] ], [ [ 64632, 64632 ], "mapped", [ 1579, 1605 ] ], [ [ 64633, 64633 ], "mapped", [ 1579, 1606 ] ], [ [ 64634, 64634 ], "mapped", [ 1579, 1609 ] ], [ [ 64635, 64635 ], "mapped", [ 1579, 1610 ] ], [ [ 64636, 64636 ], "mapped", [ 1601, 1609 ] ], [ [ 64637, 64637 ], "mapped", [ 1601, 1610 ] ], [ [ 64638, 64638 ], "mapped", [ 1602, 1609 ] ], [ [ 64639, 64639 ], "mapped", [ 1602, 1610 ] ], [ [ 64640, 64640 ], "mapped", [ 1603, 1575 ] ], [ [ 64641, 64641 ], "mapped", [ 1603, 1604 ] ], [ [ 64642, 64642 ], "mapped", [ 1603, 1605 ] ], [ [ 64643, 64643 ], "mapped", [ 1603, 1609 ] ], [ [ 64644, 64644 ], "mapped", [ 1603, 1610 ] ], [ [ 64645, 64645 ], "mapped", [ 1604, 1605 ] ], [ [ 64646, 64646 ], "mapped", [ 1604, 1609 ] ], [ [ 64647, 64647 ], "mapped", [ 1604, 1610 ] ], [ [ 64648, 64648 ], "mapped", [ 1605, 1575 ] ], [ [ 64649, 64649 ], "mapped", [ 1605, 1605 ] ], [ [ 64650, 64650 ], "mapped", [ 1606, 1585 ] ], [ [ 64651, 64651 ], "mapped", [ 1606, 1586 ] ], [ [ 64652, 64652 ], "mapped", [ 1606, 1605 ] ], [ [ 64653, 64653 ], "mapped", [ 1606, 1606 ] ], [ [ 64654, 64654 ], "mapped", [ 1606, 1609 ] ], [ [ 64655, 64655 ], "mapped", [ 1606, 1610 ] ], [ [ 64656, 64656 ], "mapped", [ 1609, 1648 ] ], [ [ 64657, 64657 ], "mapped", [ 1610, 1585 ] ], [ [ 64658, 64658 ], "mapped", [ 1610, 1586 ] ], [ [ 64659, 64659 ], "mapped", [ 1610, 1605 ] ], [ [ 64660, 64660 ], "mapped", [ 1610, 1606 ] ], [ [ 64661, 64661 ], "mapped", [ 1610, 1609 ] ], [ [ 64662, 64662 ], "mapped", [ 1610, 1610 ] ], [ [ 64663, 64663 ], "mapped", [ 1574, 1580 ] ], [ [ 64664, 64664 ], "mapped", [ 1574, 1581 ] ], [ [ 64665, 64665 ], "mapped", [ 1574, 1582 ] ], [ [ 64666, 64666 ], "mapped", [ 1574, 1605 ] ], [ [ 64667, 64667 ], "mapped", [ 1574, 1607 ] ], [ [ 64668, 64668 ], "mapped", [ 1576, 1580 ] ], [ [ 64669, 64669 ], "mapped", [ 1576, 1581 ] ], [ [ 64670, 64670 ], "mapped", [ 1576, 1582 ] ], [ [ 64671, 64671 ], "mapped", [ 1576, 1605 ] ], [ [ 64672, 64672 ], "mapped", [ 1576, 1607 ] ], [ [ 64673, 64673 ], "mapped", [ 1578, 1580 ] ], [ [ 64674, 64674 ], "mapped", [ 1578, 1581 ] ], [ [ 64675, 64675 ], "mapped", [ 1578, 1582 ] ], [ [ 64676, 64676 ], "mapped", [ 1578, 1605 ] ], [ [ 64677, 64677 ], "mapped", [ 1578, 1607 ] ], [ [ 64678, 64678 ], "mapped", [ 1579, 1605 ] ], [ [ 64679, 64679 ], "mapped", [ 1580, 1581 ] ], [ [ 64680, 64680 ], "mapped", [ 1580, 1605 ] ], [ [ 64681, 64681 ], "mapped", [ 1581, 1580 ] ], [ [ 64682, 64682 ], "mapped", [ 1581, 1605 ] ], [ [ 64683, 64683 ], "mapped", [ 1582, 1580 ] ], [ [ 64684, 64684 ], "mapped", [ 1582, 1605 ] ], [ [ 64685, 64685 ], "mapped", [ 1587, 1580 ] ], [ [ 64686, 64686 ], "mapped", [ 1587, 1581 ] ], [ [ 64687, 64687 ], "mapped", [ 1587, 1582 ] ], [ [ 64688, 64688 ], "mapped", [ 1587, 1605 ] ], [ [ 64689, 64689 ], "mapped", [ 1589, 1581 ] ], [ [ 64690, 64690 ], "mapped", [ 1589, 1582 ] ], [ [ 64691, 64691 ], "mapped", [ 1589, 1605 ] ], [ [ 64692, 64692 ], "mapped", [ 1590, 1580 ] ], [ [ 64693, 64693 ], "mapped", [ 1590, 1581 ] ], [ [ 64694, 64694 ], "mapped", [ 1590, 1582 ] ], [ [ 64695, 64695 ], "mapped", [ 1590, 1605 ] ], [ [ 64696, 64696 ], "mapped", [ 1591, 1581 ] ], [ [ 64697, 64697 ], "mapped", [ 1592, 1605 ] ], [ [ 64698, 64698 ], "mapped", [ 1593, 1580 ] ], [ [ 64699, 64699 ], "mapped", [ 1593, 1605 ] ], [ [ 64700, 64700 ], "mapped", [ 1594, 1580 ] ], [ [ 64701, 64701 ], "mapped", [ 1594, 1605 ] ], [ [ 64702, 64702 ], "mapped", [ 1601, 1580 ] ], [ [ 64703, 64703 ], "mapped", [ 1601, 1581 ] ], [ [ 64704, 64704 ], "mapped", [ 1601, 1582 ] ], [ [ 64705, 64705 ], "mapped", [ 1601, 1605 ] ], [ [ 64706, 64706 ], "mapped", [ 1602, 1581 ] ], [ [ 64707, 64707 ], "mapped", [ 1602, 1605 ] ], [ [ 64708, 64708 ], "mapped", [ 1603, 1580 ] ], [ [ 64709, 64709 ], "mapped", [ 1603, 1581 ] ], [ [ 64710, 64710 ], "mapped", [ 1603, 1582 ] ], [ [ 64711, 64711 ], "mapped", [ 1603, 1604 ] ], [ [ 64712, 64712 ], "mapped", [ 1603, 1605 ] ], [ [ 64713, 64713 ], "mapped", [ 1604, 1580 ] ], [ [ 64714, 64714 ], "mapped", [ 1604, 1581 ] ], [ [ 64715, 64715 ], "mapped", [ 1604, 1582 ] ], [ [ 64716, 64716 ], "mapped", [ 1604, 1605 ] ], [ [ 64717, 64717 ], "mapped", [ 1604, 1607 ] ], [ [ 64718, 64718 ], "mapped", [ 1605, 1580 ] ], [ [ 64719, 64719 ], "mapped", [ 1605, 1581 ] ], [ [ 64720, 64720 ], "mapped", [ 1605, 1582 ] ], [ [ 64721, 64721 ], "mapped", [ 1605, 1605 ] ], [ [ 64722, 64722 ], "mapped", [ 1606, 1580 ] ], [ [ 64723, 64723 ], "mapped", [ 1606, 1581 ] ], [ [ 64724, 64724 ], "mapped", [ 1606, 1582 ] ], [ [ 64725, 64725 ], "mapped", [ 1606, 1605 ] ], [ [ 64726, 64726 ], "mapped", [ 1606, 1607 ] ], [ [ 64727, 64727 ], "mapped", [ 1607, 1580 ] ], [ [ 64728, 64728 ], "mapped", [ 1607, 1605 ] ], [ [ 64729, 64729 ], "mapped", [ 1607, 1648 ] ], [ [ 64730, 64730 ], "mapped", [ 1610, 1580 ] ], [ [ 64731, 64731 ], "mapped", [ 1610, 1581 ] ], [ [ 64732, 64732 ], "mapped", [ 1610, 1582 ] ], [ [ 64733, 64733 ], "mapped", [ 1610, 1605 ] ], [ [ 64734, 64734 ], "mapped", [ 1610, 1607 ] ], [ [ 64735, 64735 ], "mapped", [ 1574, 1605 ] ], [ [ 64736, 64736 ], "mapped", [ 1574, 1607 ] ], [ [ 64737, 64737 ], "mapped", [ 1576, 1605 ] ], [ [ 64738, 64738 ], "mapped", [ 1576, 1607 ] ], [ [ 64739, 64739 ], "mapped", [ 1578, 1605 ] ], [ [ 64740, 64740 ], "mapped", [ 1578, 1607 ] ], [ [ 64741, 64741 ], "mapped", [ 1579, 1605 ] ], [ [ 64742, 64742 ], "mapped", [ 1579, 1607 ] ], [ [ 64743, 64743 ], "mapped", [ 1587, 1605 ] ], [ [ 64744, 64744 ], "mapped", [ 1587, 1607 ] ], [ [ 64745, 64745 ], "mapped", [ 1588, 1605 ] ], [ [ 64746, 64746 ], "mapped", [ 1588, 1607 ] ], [ [ 64747, 64747 ], "mapped", [ 1603, 1604 ] ], [ [ 64748, 64748 ], "mapped", [ 1603, 1605 ] ], [ [ 64749, 64749 ], "mapped", [ 1604, 1605 ] ], [ [ 64750, 64750 ], "mapped", [ 1606, 1605 ] ], [ [ 64751, 64751 ], "mapped", [ 1606, 1607 ] ], [ [ 64752, 64752 ], "mapped", [ 1610, 1605 ] ], [ [ 64753, 64753 ], "mapped", [ 1610, 1607 ] ], [ [ 64754, 64754 ], "mapped", [ 1600, 1614, 1617 ] ], [ [ 64755, 64755 ], "mapped", [ 1600, 1615, 1617 ] ], [ [ 64756, 64756 ], "mapped", [ 1600, 1616, 1617 ] ], [ [ 64757, 64757 ], "mapped", [ 1591, 1609 ] ], [ [ 64758, 64758 ], "mapped", [ 1591, 1610 ] ], [ [ 64759, 64759 ], "mapped", [ 1593, 1609 ] ], [ [ 64760, 64760 ], "mapped", [ 1593, 1610 ] ], [ [ 64761, 64761 ], "mapped", [ 1594, 1609 ] ], [ [ 64762, 64762 ], "mapped", [ 1594, 1610 ] ], [ [ 64763, 64763 ], "mapped", [ 1587, 1609 ] ], [ [ 64764, 64764 ], "mapped", [ 1587, 1610 ] ], [ [ 64765, 64765 ], "mapped", [ 1588, 1609 ] ], [ [ 64766, 64766 ], "mapped", [ 1588, 1610 ] ], [ [ 64767, 64767 ], "mapped", [ 1581, 1609 ] ], [ [ 64768, 64768 ], "mapped", [ 1581, 1610 ] ], [ [ 64769, 64769 ], "mapped", [ 1580, 1609 ] ], [ [ 64770, 64770 ], "mapped", [ 1580, 1610 ] ], [ [ 64771, 64771 ], "mapped", [ 1582, 1609 ] ], [ [ 64772, 64772 ], "mapped", [ 1582, 1610 ] ], [ [ 64773, 64773 ], "mapped", [ 1589, 1609 ] ], [ [ 64774, 64774 ], "mapped", [ 1589, 1610 ] ], [ [ 64775, 64775 ], "mapped", [ 1590, 1609 ] ], [ [ 64776, 64776 ], "mapped", [ 1590, 1610 ] ], [ [ 64777, 64777 ], "mapped", [ 1588, 1580 ] ], [ [ 64778, 64778 ], "mapped", [ 1588, 1581 ] ], [ [ 64779, 64779 ], "mapped", [ 1588, 1582 ] ], [ [ 64780, 64780 ], "mapped", [ 1588, 1605 ] ], [ [ 64781, 64781 ], "mapped", [ 1588, 1585 ] ], [ [ 64782, 64782 ], "mapped", [ 1587, 1585 ] ], [ [ 64783, 64783 ], "mapped", [ 1589, 1585 ] ], [ [ 64784, 64784 ], "mapped", [ 1590, 1585 ] ], [ [ 64785, 64785 ], "mapped", [ 1591, 1609 ] ], [ [ 64786, 64786 ], "mapped", [ 1591, 1610 ] ], [ [ 64787, 64787 ], "mapped", [ 1593, 1609 ] ], [ [ 64788, 64788 ], "mapped", [ 1593, 1610 ] ], [ [ 64789, 64789 ], "mapped", [ 1594, 1609 ] ], [ [ 64790, 64790 ], "mapped", [ 1594, 1610 ] ], [ [ 64791, 64791 ], "mapped", [ 1587, 1609 ] ], [ [ 64792, 64792 ], "mapped", [ 1587, 1610 ] ], [ [ 64793, 64793 ], "mapped", [ 1588, 1609 ] ], [ [ 64794, 64794 ], "mapped", [ 1588, 1610 ] ], [ [ 64795, 64795 ], "mapped", [ 1581, 1609 ] ], [ [ 64796, 64796 ], "mapped", [ 1581, 1610 ] ], [ [ 64797, 64797 ], "mapped", [ 1580, 1609 ] ], [ [ 64798, 64798 ], "mapped", [ 1580, 1610 ] ], [ [ 64799, 64799 ], "mapped", [ 1582, 1609 ] ], [ [ 64800, 64800 ], "mapped", [ 1582, 1610 ] ], [ [ 64801, 64801 ], "mapped", [ 1589, 1609 ] ], [ [ 64802, 64802 ], "mapped", [ 1589, 1610 ] ], [ [ 64803, 64803 ], "mapped", [ 1590, 1609 ] ], [ [ 64804, 64804 ], "mapped", [ 1590, 1610 ] ], [ [ 64805, 64805 ], "mapped", [ 1588, 1580 ] ], [ [ 64806, 64806 ], "mapped", [ 1588, 1581 ] ], [ [ 64807, 64807 ], "mapped", [ 1588, 1582 ] ], [ [ 64808, 64808 ], "mapped", [ 1588, 1605 ] ], [ [ 64809, 64809 ], "mapped", [ 1588, 1585 ] ], [ [ 64810, 64810 ], "mapped", [ 1587, 1585 ] ], [ [ 64811, 64811 ], "mapped", [ 1589, 1585 ] ], [ [ 64812, 64812 ], "mapped", [ 1590, 1585 ] ], [ [ 64813, 64813 ], "mapped", [ 1588, 1580 ] ], [ [ 64814, 64814 ], "mapped", [ 1588, 1581 ] ], [ [ 64815, 64815 ], "mapped", [ 1588, 1582 ] ], [ [ 64816, 64816 ], "mapped", [ 1588, 1605 ] ], [ [ 64817, 64817 ], "mapped", [ 1587, 1607 ] ], [ [ 64818, 64818 ], "mapped", [ 1588, 1607 ] ], [ [ 64819, 64819 ], "mapped", [ 1591, 1605 ] ], [ [ 64820, 64820 ], "mapped", [ 1587, 1580 ] ], [ [ 64821, 64821 ], "mapped", [ 1587, 1581 ] ], [ [ 64822, 64822 ], "mapped", [ 1587, 1582 ] ], [ [ 64823, 64823 ], "mapped", [ 1588, 1580 ] ], [ [ 64824, 64824 ], "mapped", [ 1588, 1581 ] ], [ [ 64825, 64825 ], "mapped", [ 1588, 1582 ] ], [ [ 64826, 64826 ], "mapped", [ 1591, 1605 ] ], [ [ 64827, 64827 ], "mapped", [ 1592, 1605 ] ], [ [ 64828, 64829 ], "mapped", [ 1575, 1611 ] ], [ [ 64830, 64831 ], "valid", [], "NV8" ], [ [ 64832, 64847 ], "disallowed" ], [ [ 64848, 64848 ], "mapped", [ 1578, 1580, 1605 ] ], [ [ 64849, 64850 ], "mapped", [ 1578, 1581, 1580 ] ], [ [ 64851, 64851 ], "mapped", [ 1578, 1581, 1605 ] ], [ [ 64852, 64852 ], "mapped", [ 1578, 1582, 1605 ] ], [ [ 64853, 64853 ], "mapped", [ 1578, 1605, 1580 ] ], [ [ 64854, 64854 ], "mapped", [ 1578, 1605, 1581 ] ], [ [ 64855, 64855 ], "mapped", [ 1578, 1605, 1582 ] ], [ [ 64856, 64857 ], "mapped", [ 1580, 1605, 1581 ] ], [ [ 64858, 64858 ], "mapped", [ 1581, 1605, 1610 ] ], [ [ 64859, 64859 ], "mapped", [ 1581, 1605, 1609 ] ], [ [ 64860, 64860 ], "mapped", [ 1587, 1581, 1580 ] ], [ [ 64861, 64861 ], "mapped", [ 1587, 1580, 1581 ] ], [ [ 64862, 64862 ], "mapped", [ 1587, 1580, 1609 ] ], [ [ 64863, 64864 ], "mapped", [ 1587, 1605, 1581 ] ], [ [ 64865, 64865 ], "mapped", [ 1587, 1605, 1580 ] ], [ [ 64866, 64867 ], "mapped", [ 1587, 1605, 1605 ] ], [ [ 64868, 64869 ], "mapped", [ 1589, 1581, 1581 ] ], [ [ 64870, 64870 ], "mapped", [ 1589, 1605, 1605 ] ], [ [ 64871, 64872 ], "mapped", [ 1588, 1581, 1605 ] ], [ [ 64873, 64873 ], "mapped", [ 1588, 1580, 1610 ] ], [ [ 64874, 64875 ], "mapped", [ 1588, 1605, 1582 ] ], [ [ 64876, 64877 ], "mapped", [ 1588, 1605, 1605 ] ], [ [ 64878, 64878 ], "mapped", [ 1590, 1581, 1609 ] ], [ [ 64879, 64880 ], "mapped", [ 1590, 1582, 1605 ] ], [ [ 64881, 64882 ], "mapped", [ 1591, 1605, 1581 ] ], [ [ 64883, 64883 ], "mapped", [ 1591, 1605, 1605 ] ], [ [ 64884, 64884 ], "mapped", [ 1591, 1605, 1610 ] ], [ [ 64885, 64885 ], "mapped", [ 1593, 1580, 1605 ] ], [ [ 64886, 64887 ], "mapped", [ 1593, 1605, 1605 ] ], [ [ 64888, 64888 ], "mapped", [ 1593, 1605, 1609 ] ], [ [ 64889, 64889 ], "mapped", [ 1594, 1605, 1605 ] ], [ [ 64890, 64890 ], "mapped", [ 1594, 1605, 1610 ] ], [ [ 64891, 64891 ], "mapped", [ 1594, 1605, 1609 ] ], [ [ 64892, 64893 ], "mapped", [ 1601, 1582, 1605 ] ], [ [ 64894, 64894 ], "mapped", [ 1602, 1605, 1581 ] ], [ [ 64895, 64895 ], "mapped", [ 1602, 1605, 1605 ] ], [ [ 64896, 64896 ], "mapped", [ 1604, 1581, 1605 ] ], [ [ 64897, 64897 ], "mapped", [ 1604, 1581, 1610 ] ], [ [ 64898, 64898 ], "mapped", [ 1604, 1581, 1609 ] ], [ [ 64899, 64900 ], "mapped", [ 1604, 1580, 1580 ] ], [ [ 64901, 64902 ], "mapped", [ 1604, 1582, 1605 ] ], [ [ 64903, 64904 ], "mapped", [ 1604, 1605, 1581 ] ], [ [ 64905, 64905 ], "mapped", [ 1605, 1581, 1580 ] ], [ [ 64906, 64906 ], "mapped", [ 1605, 1581, 1605 ] ], [ [ 64907, 64907 ], "mapped", [ 1605, 1581, 1610 ] ], [ [ 64908, 64908 ], "mapped", [ 1605, 1580, 1581 ] ], [ [ 64909, 64909 ], "mapped", [ 1605, 1580, 1605 ] ], [ [ 64910, 64910 ], "mapped", [ 1605, 1582, 1580 ] ], [ [ 64911, 64911 ], "mapped", [ 1605, 1582, 1605 ] ], [ [ 64912, 64913 ], "disallowed" ], [ [ 64914, 64914 ], "mapped", [ 1605, 1580, 1582 ] ], [ [ 64915, 64915 ], "mapped", [ 1607, 1605, 1580 ] ], [ [ 64916, 64916 ], "mapped", [ 1607, 1605, 1605 ] ], [ [ 64917, 64917 ], "mapped", [ 1606, 1581, 1605 ] ], [ [ 64918, 64918 ], "mapped", [ 1606, 1581, 1609 ] ], [ [ 64919, 64920 ], "mapped", [ 1606, 1580, 1605 ] ], [ [ 64921, 64921 ], "mapped", [ 1606, 1580, 1609 ] ], [ [ 64922, 64922 ], "mapped", [ 1606, 1605, 1610 ] ], [ [ 64923, 64923 ], "mapped", [ 1606, 1605, 1609 ] ], [ [ 64924, 64925 ], "mapped", [ 1610, 1605, 1605 ] ], [ [ 64926, 64926 ], "mapped", [ 1576, 1582, 1610 ] ], [ [ 64927, 64927 ], "mapped", [ 1578, 1580, 1610 ] ], [ [ 64928, 64928 ], "mapped", [ 1578, 1580, 1609 ] ], [ [ 64929, 64929 ], "mapped", [ 1578, 1582, 1610 ] ], [ [ 64930, 64930 ], "mapped", [ 1578, 1582, 1609 ] ], [ [ 64931, 64931 ], "mapped", [ 1578, 1605, 1610 ] ], [ [ 64932, 64932 ], "mapped", [ 1578, 1605, 1609 ] ], [ [ 64933, 64933 ], "mapped", [ 1580, 1605, 1610 ] ], [ [ 64934, 64934 ], "mapped", [ 1580, 1581, 1609 ] ], [ [ 64935, 64935 ], "mapped", [ 1580, 1605, 1609 ] ], [ [ 64936, 64936 ], "mapped", [ 1587, 1582, 1609 ] ], [ [ 64937, 64937 ], "mapped", [ 1589, 1581, 1610 ] ], [ [ 64938, 64938 ], "mapped", [ 1588, 1581, 1610 ] ], [ [ 64939, 64939 ], "mapped", [ 1590, 1581, 1610 ] ], [ [ 64940, 64940 ], "mapped", [ 1604, 1580, 1610 ] ], [ [ 64941, 64941 ], "mapped", [ 1604, 1605, 1610 ] ], [ [ 64942, 64942 ], "mapped", [ 1610, 1581, 1610 ] ], [ [ 64943, 64943 ], "mapped", [ 1610, 1580, 1610 ] ], [ [ 64944, 64944 ], "mapped", [ 1610, 1605, 1610 ] ], [ [ 64945, 64945 ], "mapped", [ 1605, 1605, 1610 ] ], [ [ 64946, 64946 ], "mapped", [ 1602, 1605, 1610 ] ], [ [ 64947, 64947 ], "mapped", [ 1606, 1581, 1610 ] ], [ [ 64948, 64948 ], "mapped", [ 1602, 1605, 1581 ] ], [ [ 64949, 64949 ], "mapped", [ 1604, 1581, 1605 ] ], [ [ 64950, 64950 ], "mapped", [ 1593, 1605, 1610 ] ], [ [ 64951, 64951 ], "mapped", [ 1603, 1605, 1610 ] ], [ [ 64952, 64952 ], "mapped", [ 1606, 1580, 1581 ] ], [ [ 64953, 64953 ], "mapped", [ 1605, 1582, 1610 ] ], [ [ 64954, 64954 ], "mapped", [ 1604, 1580, 1605 ] ], [ [ 64955, 64955 ], "mapped", [ 1603, 1605, 1605 ] ], [ [ 64956, 64956 ], "mapped", [ 1604, 1580, 1605 ] ], [ [ 64957, 64957 ], "mapped", [ 1606, 1580, 1581 ] ], [ [ 64958, 64958 ], "mapped", [ 1580, 1581, 1610 ] ], [ [ 64959, 64959 ], "mapped", [ 1581, 1580, 1610 ] ], [ [ 64960, 64960 ], "mapped", [ 1605, 1580, 1610 ] ], [ [ 64961, 64961 ], "mapped", [ 1601, 1605, 1610 ] ], [ [ 64962, 64962 ], "mapped", [ 1576, 1581, 1610 ] ], [ [ 64963, 64963 ], "mapped", [ 1603, 1605, 1605 ] ], [ [ 64964, 64964 ], "mapped", [ 1593, 1580, 1605 ] ], [ [ 64965, 64965 ], "mapped", [ 1589, 1605, 1605 ] ], [ [ 64966, 64966 ], "mapped", [ 1587, 1582, 1610 ] ], [ [ 64967, 64967 ], "mapped", [ 1606, 1580, 1610 ] ], [ [ 64968, 64975 ], "disallowed" ], [ [ 64976, 65007 ], "disallowed" ], [ [ 65008, 65008 ], "mapped", [ 1589, 1604, 1746 ] ], [ [ 65009, 65009 ], "mapped", [ 1602, 1604, 1746 ] ], [ [ 65010, 65010 ], "mapped", [ 1575, 1604, 1604, 1607 ] ], [ [ 65011, 65011 ], "mapped", [ 1575, 1603, 1576, 1585 ] ], [ [ 65012, 65012 ], "mapped", [ 1605, 1581, 1605, 1583 ] ], [ [ 65013, 65013 ], "mapped", [ 1589, 1604, 1593, 1605 ] ], [ [ 65014, 65014 ], "mapped", [ 1585, 1587, 1608, 1604 ] ], [ [ 65015, 65015 ], "mapped", [ 1593, 1604, 1610, 1607 ] ], [ [ 65016, 65016 ], "mapped", [ 1608, 1587, 1604, 1605 ] ], [ [ 65017, 65017 ], "mapped", [ 1589, 1604, 1609 ] ], [ [ 65018, 65018 ], "disallowed_STD3_mapped", [ 1589, 1604, 1609, 32, 1575, 1604, 1604, 1607, 32, 1593, 1604, 1610, 1607, 32, 1608, 1587, 1604, 1605 ] ], [ [ 65019, 65019 ], "disallowed_STD3_mapped", [ 1580, 1604, 32, 1580, 1604, 1575, 1604, 1607 ] ], [ [ 65020, 65020 ], "mapped", [ 1585, 1740, 1575, 1604 ] ], [ [ 65021, 65021 ], "valid", [], "NV8" ], [ [ 65022, 65023 ], "disallowed" ], [ [ 65024, 65039 ], "ignored" ], [ [ 65040, 65040 ], "disallowed_STD3_mapped", [ 44 ] ], [ [ 65041, 65041 ], "mapped", [ 12289 ] ], [ [ 65042, 65042 ], "disallowed" ], [ [ 65043, 65043 ], "disallowed_STD3_mapped", [ 58 ] ], [ [ 65044, 65044 ], "disallowed_STD3_mapped", [ 59 ] ], [ [ 65045, 65045 ], "disallowed_STD3_mapped", [ 33 ] ], [ [ 65046, 65046 ], "disallowed_STD3_mapped", [ 63 ] ], [ [ 65047, 65047 ], "mapped", [ 12310 ] ], [ [ 65048, 65048 ], "mapped", [ 12311 ] ], [ [ 65049, 65049 ], "disallowed" ], [ [ 65050, 65055 ], "disallowed" ], [ [ 65056, 65059 ], "valid" ], [ [ 65060, 65062 ], "valid" ], [ [ 65063, 65069 ], "valid" ], [ [ 65070, 65071 ], "valid" ], [ [ 65072, 65072 ], "disallowed" ], [ [ 65073, 65073 ], "mapped", [ 8212 ] ], [ [ 65074, 65074 ], "mapped", [ 8211 ] ], [ [ 65075, 65076 ], "disallowed_STD3_mapped", [ 95 ] ], [ [ 65077, 65077 ], "disallowed_STD3_mapped", [ 40 ] ], [ [ 65078, 65078 ], "disallowed_STD3_mapped", [ 41 ] ], [ [ 65079, 65079 ], "disallowed_STD3_mapped", [ 123 ] ], [ [ 65080, 65080 ], "disallowed_STD3_mapped", [ 125 ] ], [ [ 65081, 65081 ], "mapped", [ 12308 ] ], [ [ 65082, 65082 ], "mapped", [ 12309 ] ], [ [ 65083, 65083 ], "mapped", [ 12304 ] ], [ [ 65084, 65084 ], "mapped", [ 12305 ] ], [ [ 65085, 65085 ], "mapped", [ 12298 ] ], [ [ 65086, 65086 ], "mapped", [ 12299 ] ], [ [ 65087, 65087 ], "mapped", [ 12296 ] ], [ [ 65088, 65088 ], "mapped", [ 12297 ] ], [ [ 65089, 65089 ], "mapped", [ 12300 ] ], [ [ 65090, 65090 ], "mapped", [ 12301 ] ], [ [ 65091, 65091 ], "mapped", [ 12302 ] ], [ [ 65092, 65092 ], "mapped", [ 12303 ] ], [ [ 65093, 65094 ], "valid", [], "NV8" ], [ [ 65095, 65095 ], "disallowed_STD3_mapped", [ 91 ] ], [ [ 65096, 65096 ], "disallowed_STD3_mapped", [ 93 ] ], [ [ 65097, 65100 ], "disallowed_STD3_mapped", [ 32, 773 ] ], [ [ 65101, 65103 ], "disallowed_STD3_mapped", [ 95 ] ], [ [ 65104, 65104 ], "disallowed_STD3_mapped", [ 44 ] ], [ [ 65105, 65105 ], "mapped", [ 12289 ] ], [ [ 65106, 65106 ], "disallowed" ], [ [ 65107, 65107 ], "disallowed" ], [ [ 65108, 65108 ], "disallowed_STD3_mapped", [ 59 ] ], [ [ 65109, 65109 ], "disallowed_STD3_mapped", [ 58 ] ], [ [ 65110, 65110 ], "disallowed_STD3_mapped", [ 63 ] ], [ [ 65111, 65111 ], "disallowed_STD3_mapped", [ 33 ] ], [ [ 65112, 65112 ], "mapped", [ 8212 ] ], [ [ 65113, 65113 ], "disallowed_STD3_mapped", [ 40 ] ], [ [ 65114, 65114 ], "disallowed_STD3_mapped", [ 41 ] ], [ [ 65115, 65115 ], "disallowed_STD3_mapped", [ 123 ] ], [ [ 65116, 65116 ], "disallowed_STD3_mapped", [ 125 ] ], [ [ 65117, 65117 ], "mapped", [ 12308 ] ], [ [ 65118, 65118 ], "mapped", [ 12309 ] ], [ [ 65119, 65119 ], "disallowed_STD3_mapped", [ 35 ] ], [ [ 65120, 65120 ], "disallowed_STD3_mapped", [ 38 ] ], [ [ 65121, 65121 ], "disallowed_STD3_mapped", [ 42 ] ], [ [ 65122, 65122 ], "disallowed_STD3_mapped", [ 43 ] ], [ [ 65123, 65123 ], "mapped", [ 45 ] ], [ [ 65124, 65124 ], "disallowed_STD3_mapped", [ 60 ] ], [ [ 65125, 65125 ], "disallowed_STD3_mapped", [ 62 ] ], [ [ 65126, 65126 ], "disallowed_STD3_mapped", [ 61 ] ], [ [ 65127, 65127 ], "disallowed" ], [ [ 65128, 65128 ], "disallowed_STD3_mapped", [ 92 ] ], [ [ 65129, 65129 ], "disallowed_STD3_mapped", [ 36 ] ], [ [ 65130, 65130 ], "disallowed_STD3_mapped", [ 37 ] ], [ [ 65131, 65131 ], "disallowed_STD3_mapped", [ 64 ] ], [ [ 65132, 65135 ], "disallowed" ], [ [ 65136, 65136 ], "disallowed_STD3_mapped", [ 32, 1611 ] ], [ [ 65137, 65137 ], "mapped", [ 1600, 1611 ] ], [ [ 65138, 65138 ], "disallowed_STD3_mapped", [ 32, 1612 ] ], [ [ 65139, 65139 ], "valid" ], [ [ 65140, 65140 ], "disallowed_STD3_mapped", [ 32, 1613 ] ], [ [ 65141, 65141 ], "disallowed" ], [ [ 65142, 65142 ], "disallowed_STD3_mapped", [ 32, 1614 ] ], [ [ 65143, 65143 ], "mapped", [ 1600, 1614 ] ], [ [ 65144, 65144 ], "disallowed_STD3_mapped", [ 32, 1615 ] ], [ [ 65145, 65145 ], "mapped", [ 1600, 1615 ] ], [ [ 65146, 65146 ], "disallowed_STD3_mapped", [ 32, 1616 ] ], [ [ 65147, 65147 ], "mapped", [ 1600, 1616 ] ], [ [ 65148, 65148 ], "disallowed_STD3_mapped", [ 32, 1617 ] ], [ [ 65149, 65149 ], "mapped", [ 1600, 1617 ] ], [ [ 65150, 65150 ], "disallowed_STD3_mapped", [ 32, 1618 ] ], [ [ 65151, 65151 ], "mapped", [ 1600, 1618 ] ], [ [ 65152, 65152 ], "mapped", [ 1569 ] ], [ [ 65153, 65154 ], "mapped", [ 1570 ] ], [ [ 65155, 65156 ], "mapped", [ 1571 ] ], [ [ 65157, 65158 ], "mapped", [ 1572 ] ], [ [ 65159, 65160 ], "mapped", [ 1573 ] ], [ [ 65161, 65164 ], "mapped", [ 1574 ] ], [ [ 65165, 65166 ], "mapped", [ 1575 ] ], [ [ 65167, 65170 ], "mapped", [ 1576 ] ], [ [ 65171, 65172 ], "mapped", [ 1577 ] ], [ [ 65173, 65176 ], "mapped", [ 1578 ] ], [ [ 65177, 65180 ], "mapped", [ 1579 ] ], [ [ 65181, 65184 ], "mapped", [ 1580 ] ], [ [ 65185, 65188 ], "mapped", [ 1581 ] ], [ [ 65189, 65192 ], "mapped", [ 1582 ] ], [ [ 65193, 65194 ], "mapped", [ 1583 ] ], [ [ 65195, 65196 ], "mapped", [ 1584 ] ], [ [ 65197, 65198 ], "mapped", [ 1585 ] ], [ [ 65199, 65200 ], "mapped", [ 1586 ] ], [ [ 65201, 65204 ], "mapped", [ 1587 ] ], [ [ 65205, 65208 ], "mapped", [ 1588 ] ], [ [ 65209, 65212 ], "mapped", [ 1589 ] ], [ [ 65213, 65216 ], "mapped", [ 1590 ] ], [ [ 65217, 65220 ], "mapped", [ 1591 ] ], [ [ 65221, 65224 ], "mapped", [ 1592 ] ], [ [ 65225, 65228 ], "mapped", [ 1593 ] ], [ [ 65229, 65232 ], "mapped", [ 1594 ] ], [ [ 65233, 65236 ], "mapped", [ 1601 ] ], [ [ 65237, 65240 ], "mapped", [ 1602 ] ], [ [ 65241, 65244 ], "mapped", [ 1603 ] ], [ [ 65245, 65248 ], "mapped", [ 1604 ] ], [ [ 65249, 65252 ], "mapped", [ 1605 ] ], [ [ 65253, 65256 ], "mapped", [ 1606 ] ], [ [ 65257, 65260 ], "mapped", [ 1607 ] ], [ [ 65261, 65262 ], "mapped", [ 1608 ] ], [ [ 65263, 65264 ], "mapped", [ 1609 ] ], [ [ 65265, 65268 ], "mapped", [ 1610 ] ], [ [ 65269, 65270 ], "mapped", [ 1604, 1570 ] ], [ [ 65271, 65272 ], "mapped", [ 1604, 1571 ] ], [ [ 65273, 65274 ], "mapped", [ 1604, 1573 ] ], [ [ 65275, 65276 ], "mapped", [ 1604, 1575 ] ], [ [ 65277, 65278 ], "disallowed" ], [ [ 65279, 65279 ], "ignored" ], [ [ 65280, 65280 ], "disallowed" ], [ [ 65281, 65281 ], "disallowed_STD3_mapped", [ 33 ] ], [ [ 65282, 65282 ], "disallowed_STD3_mapped", [ 34 ] ], [ [ 65283, 65283 ], "disallowed_STD3_mapped", [ 35 ] ], [ [ 65284, 65284 ], "disallowed_STD3_mapped", [ 36 ] ], [ [ 65285, 65285 ], "disallowed_STD3_mapped", [ 37 ] ], [ [ 65286, 65286 ], "disallowed_STD3_mapped", [ 38 ] ], [ [ 65287, 65287 ], "disallowed_STD3_mapped", [ 39 ] ], [ [ 65288, 65288 ], "disallowed_STD3_mapped", [ 40 ] ], [ [ 65289, 65289 ], "disallowed_STD3_mapped", [ 41 ] ], [ [ 65290, 65290 ], "disallowed_STD3_mapped", [ 42 ] ], [ [ 65291, 65291 ], "disallowed_STD3_mapped", [ 43 ] ], [ [ 65292, 65292 ], "disallowed_STD3_mapped", [ 44 ] ], [ [ 65293, 65293 ], "mapped", [ 45 ] ], [ [ 65294, 65294 ], "mapped", [ 46 ] ], [ [ 65295, 65295 ], "disallowed_STD3_mapped", [ 47 ] ], [ [ 65296, 65296 ], "mapped", [ 48 ] ], [ [ 65297, 65297 ], "mapped", [ 49 ] ], [ [ 65298, 65298 ], "mapped", [ 50 ] ], [ [ 65299, 65299 ], "mapped", [ 51 ] ], [ [ 65300, 65300 ], "mapped", [ 52 ] ], [ [ 65301, 65301 ], "mapped", [ 53 ] ], [ [ 65302, 65302 ], "mapped", [ 54 ] ], [ [ 65303, 65303 ], "mapped", [ 55 ] ], [ [ 65304, 65304 ], "mapped", [ 56 ] ], [ [ 65305, 65305 ], "mapped", [ 57 ] ], [ [ 65306, 65306 ], "disallowed_STD3_mapped", [ 58 ] ], [ [ 65307, 65307 ], "disallowed_STD3_mapped", [ 59 ] ], [ [ 65308, 65308 ], "disallowed_STD3_mapped", [ 60 ] ], [ [ 65309, 65309 ], "disallowed_STD3_mapped", [ 61 ] ], [ [ 65310, 65310 ], "disallowed_STD3_mapped", [ 62 ] ], [ [ 65311, 65311 ], "disallowed_STD3_mapped", [ 63 ] ], [ [ 65312, 65312 ], "disallowed_STD3_mapped", [ 64 ] ], [ [ 65313, 65313 ], "mapped", [ 97 ] ], [ [ 65314, 65314 ], "mapped", [ 98 ] ], [ [ 65315, 65315 ], "mapped", [ 99 ] ], [ [ 65316, 65316 ], "mapped", [ 100 ] ], [ [ 65317, 65317 ], "mapped", [ 101 ] ], [ [ 65318, 65318 ], "mapped", [ 102 ] ], [ [ 65319, 65319 ], "mapped", [ 103 ] ], [ [ 65320, 65320 ], "mapped", [ 104 ] ], [ [ 65321, 65321 ], "mapped", [ 105 ] ], [ [ 65322, 65322 ], "mapped", [ 106 ] ], [ [ 65323, 65323 ], "mapped", [ 107 ] ], [ [ 65324, 65324 ], "mapped", [ 108 ] ], [ [ 65325, 65325 ], "mapped", [ 109 ] ], [ [ 65326, 65326 ], "mapped", [ 110 ] ], [ [ 65327, 65327 ], "mapped", [ 111 ] ], [ [ 65328, 65328 ], "mapped", [ 112 ] ], [ [ 65329, 65329 ], "mapped", [ 113 ] ], [ [ 65330, 65330 ], "mapped", [ 114 ] ], [ [ 65331, 65331 ], "mapped", [ 115 ] ], [ [ 65332, 65332 ], "mapped", [ 116 ] ], [ [ 65333, 65333 ], "mapped", [ 117 ] ], [ [ 65334, 65334 ], "mapped", [ 118 ] ], [ [ 65335, 65335 ], "mapped", [ 119 ] ], [ [ 65336, 65336 ], "mapped", [ 120 ] ], [ [ 65337, 65337 ], "mapped", [ 121 ] ], [ [ 65338, 65338 ], "mapped", [ 122 ] ], [ [ 65339, 65339 ], "disallowed_STD3_mapped", [ 91 ] ], [ [ 65340, 65340 ], "disallowed_STD3_mapped", [ 92 ] ], [ [ 65341, 65341 ], "disallowed_STD3_mapped", [ 93 ] ], [ [ 65342, 65342 ], "disallowed_STD3_mapped", [ 94 ] ], [ [ 65343, 65343 ], "disallowed_STD3_mapped", [ 95 ] ], [ [ 65344, 65344 ], "disallowed_STD3_mapped", [ 96 ] ], [ [ 65345, 65345 ], "mapped", [ 97 ] ], [ [ 65346, 65346 ], "mapped", [ 98 ] ], [ [ 65347, 65347 ], "mapped", [ 99 ] ], [ [ 65348, 65348 ], "mapped", [ 100 ] ], [ [ 65349, 65349 ], "mapped", [ 101 ] ], [ [ 65350, 65350 ], "mapped", [ 102 ] ], [ [ 65351, 65351 ], "mapped", [ 103 ] ], [ [ 65352, 65352 ], "mapped", [ 104 ] ], [ [ 65353, 65353 ], "mapped", [ 105 ] ], [ [ 65354, 65354 ], "mapped", [ 106 ] ], [ [ 65355, 65355 ], "mapped", [ 107 ] ], [ [ 65356, 65356 ], "mapped", [ 108 ] ], [ [ 65357, 65357 ], "mapped", [ 109 ] ], [ [ 65358, 65358 ], "mapped", [ 110 ] ], [ [ 65359, 65359 ], "mapped", [ 111 ] ], [ [ 65360, 65360 ], "mapped", [ 112 ] ], [ [ 65361, 65361 ], "mapped", [ 113 ] ], [ [ 65362, 65362 ], "mapped", [ 114 ] ], [ [ 65363, 65363 ], "mapped", [ 115 ] ], [ [ 65364, 65364 ], "mapped", [ 116 ] ], [ [ 65365, 65365 ], "mapped", [ 117 ] ], [ [ 65366, 65366 ], "mapped", [ 118 ] ], [ [ 65367, 65367 ], "mapped", [ 119 ] ], [ [ 65368, 65368 ], "mapped", [ 120 ] ], [ [ 65369, 65369 ], "mapped", [ 121 ] ], [ [ 65370, 65370 ], "mapped", [ 122 ] ], [ [ 65371, 65371 ], "disallowed_STD3_mapped", [ 123 ] ], [ [ 65372, 65372 ], "disallowed_STD3_mapped", [ 124 ] ], [ [ 65373, 65373 ], "disallowed_STD3_mapped", [ 125 ] ], [ [ 65374, 65374 ], "disallowed_STD3_mapped", [ 126 ] ], [ [ 65375, 65375 ], "mapped", [ 10629 ] ], [ [ 65376, 65376 ], "mapped", [ 10630 ] ], [ [ 65377, 65377 ], "mapped", [ 46 ] ], [ [ 65378, 65378 ], "mapped", [ 12300 ] ], [ [ 65379, 65379 ], "mapped", [ 12301 ] ], [ [ 65380, 65380 ], "mapped", [ 12289 ] ], [ [ 65381, 65381 ], "mapped", [ 12539 ] ], [ [ 65382, 65382 ], "mapped", [ 12530 ] ], [ [ 65383, 65383 ], "mapped", [ 12449 ] ], [ [ 65384, 65384 ], "mapped", [ 12451 ] ], [ [ 65385, 65385 ], "mapped", [ 12453 ] ], [ [ 65386, 65386 ], "mapped", [ 12455 ] ], [ [ 65387, 65387 ], "mapped", [ 12457 ] ], [ [ 65388, 65388 ], "mapped", [ 12515 ] ], [ [ 65389, 65389 ], "mapped", [ 12517 ] ], [ [ 65390, 65390 ], "mapped", [ 12519 ] ], [ [ 65391, 65391 ], "mapped", [ 12483 ] ], [ [ 65392, 65392 ], "mapped", [ 12540 ] ], [ [ 65393, 65393 ], "mapped", [ 12450 ] ], [ [ 65394, 65394 ], "mapped", [ 12452 ] ], [ [ 65395, 65395 ], "mapped", [ 12454 ] ], [ [ 65396, 65396 ], "mapped", [ 12456 ] ], [ [ 65397, 65397 ], "mapped", [ 12458 ] ], [ [ 65398, 65398 ], "mapped", [ 12459 ] ], [ [ 65399, 65399 ], "mapped", [ 12461 ] ], [ [ 65400, 65400 ], "mapped", [ 12463 ] ], [ [ 65401, 65401 ], "mapped", [ 12465 ] ], [ [ 65402, 65402 ], "mapped", [ 12467 ] ], [ [ 65403, 65403 ], "mapped", [ 12469 ] ], [ [ 65404, 65404 ], "mapped", [ 12471 ] ], [ [ 65405, 65405 ], "mapped", [ 12473 ] ], [ [ 65406, 65406 ], "mapped", [ 12475 ] ], [ [ 65407, 65407 ], "mapped", [ 12477 ] ], [ [ 65408, 65408 ], "mapped", [ 12479 ] ], [ [ 65409, 65409 ], "mapped", [ 12481 ] ], [ [ 65410, 65410 ], "mapped", [ 12484 ] ], [ [ 65411, 65411 ], "mapped", [ 12486 ] ], [ [ 65412, 65412 ], "mapped", [ 12488 ] ], [ [ 65413, 65413 ], "mapped", [ 12490 ] ], [ [ 65414, 65414 ], "mapped", [ 12491 ] ], [ [ 65415, 65415 ], "mapped", [ 12492 ] ], [ [ 65416, 65416 ], "mapped", [ 12493 ] ], [ [ 65417, 65417 ], "mapped", [ 12494 ] ], [ [ 65418, 65418 ], "mapped", [ 12495 ] ], [ [ 65419, 65419 ], "mapped", [ 12498 ] ], [ [ 65420, 65420 ], "mapped", [ 12501 ] ], [ [ 65421, 65421 ], "mapped", [ 12504 ] ], [ [ 65422, 65422 ], "mapped", [ 12507 ] ], [ [ 65423, 65423 ], "mapped", [ 12510 ] ], [ [ 65424, 65424 ], "mapped", [ 12511 ] ], [ [ 65425, 65425 ], "mapped", [ 12512 ] ], [ [ 65426, 65426 ], "mapped", [ 12513 ] ], [ [ 65427, 65427 ], "mapped", [ 12514 ] ], [ [ 65428, 65428 ], "mapped", [ 12516 ] ], [ [ 65429, 65429 ], "mapped", [ 12518 ] ], [ [ 65430, 65430 ], "mapped", [ 12520 ] ], [ [ 65431, 65431 ], "mapped", [ 12521 ] ], [ [ 65432, 65432 ], "mapped", [ 12522 ] ], [ [ 65433, 65433 ], "mapped", [ 12523 ] ], [ [ 65434, 65434 ], "mapped", [ 12524 ] ], [ [ 65435, 65435 ], "mapped", [ 12525 ] ], [ [ 65436, 65436 ], "mapped", [ 12527 ] ], [ [ 65437, 65437 ], "mapped", [ 12531 ] ], [ [ 65438, 65438 ], "mapped", [ 12441 ] ], [ [ 65439, 65439 ], "mapped", [ 12442 ] ], [ [ 65440, 65440 ], "disallowed" ], [ [ 65441, 65441 ], "mapped", [ 4352 ] ], [ [ 65442, 65442 ], "mapped", [ 4353 ] ], [ [ 65443, 65443 ], "mapped", [ 4522 ] ], [ [ 65444, 65444 ], "mapped", [ 4354 ] ], [ [ 65445, 65445 ], "mapped", [ 4524 ] ], [ [ 65446, 65446 ], "mapped", [ 4525 ] ], [ [ 65447, 65447 ], "mapped", [ 4355 ] ], [ [ 65448, 65448 ], "mapped", [ 4356 ] ], [ [ 65449, 65449 ], "mapped", [ 4357 ] ], [ [ 65450, 65450 ], "mapped", [ 4528 ] ], [ [ 65451, 65451 ], "mapped", [ 4529 ] ], [ [ 65452, 65452 ], "mapped", [ 4530 ] ], [ [ 65453, 65453 ], "mapped", [ 4531 ] ], [ [ 65454, 65454 ], "mapped", [ 4532 ] ], [ [ 65455, 65455 ], "mapped", [ 4533 ] ], [ [ 65456, 65456 ], "mapped", [ 4378 ] ], [ [ 65457, 65457 ], "mapped", [ 4358 ] ], [ [ 65458, 65458 ], "mapped", [ 4359 ] ], [ [ 65459, 65459 ], "mapped", [ 4360 ] ], [ [ 65460, 65460 ], "mapped", [ 4385 ] ], [ [ 65461, 65461 ], "mapped", [ 4361 ] ], [ [ 65462, 65462 ], "mapped", [ 4362 ] ], [ [ 65463, 65463 ], "mapped", [ 4363 ] ], [ [ 65464, 65464 ], "mapped", [ 4364 ] ], [ [ 65465, 65465 ], "mapped", [ 4365 ] ], [ [ 65466, 65466 ], "mapped", [ 4366 ] ], [ [ 65467, 65467 ], "mapped", [ 4367 ] ], [ [ 65468, 65468 ], "mapped", [ 4368 ] ], [ [ 65469, 65469 ], "mapped", [ 4369 ] ], [ [ 65470, 65470 ], "mapped", [ 4370 ] ], [ [ 65471, 65473 ], "disallowed" ], [ [ 65474, 65474 ], "mapped", [ 4449 ] ], [ [ 65475, 65475 ], "mapped", [ 4450 ] ], [ [ 65476, 65476 ], "mapped", [ 4451 ] ], [ [ 65477, 65477 ], "mapped", [ 4452 ] ], [ [ 65478, 65478 ], "mapped", [ 4453 ] ], [ [ 65479, 65479 ], "mapped", [ 4454 ] ], [ [ 65480, 65481 ], "disallowed" ], [ [ 65482, 65482 ], "mapped", [ 4455 ] ], [ [ 65483, 65483 ], "mapped", [ 4456 ] ], [ [ 65484, 65484 ], "mapped", [ 4457 ] ], [ [ 65485, 65485 ], "mapped", [ 4458 ] ], [ [ 65486, 65486 ], "mapped", [ 4459 ] ], [ [ 65487, 65487 ], "mapped", [ 4460 ] ], [ [ 65488, 65489 ], "disallowed" ], [ [ 65490, 65490 ], "mapped", [ 4461 ] ], [ [ 65491, 65491 ], "mapped", [ 4462 ] ], [ [ 65492, 65492 ], "mapped", [ 4463 ] ], [ [ 65493, 65493 ], "mapped", [ 4464 ] ], [ [ 65494, 65494 ], "mapped", [ 4465 ] ], [ [ 65495, 65495 ], "mapped", [ 4466 ] ], [ [ 65496, 65497 ], "disallowed" ], [ [ 65498, 65498 ], "mapped", [ 4467 ] ], [ [ 65499, 65499 ], "mapped", [ 4468 ] ], [ [ 65500, 65500 ], "mapped", [ 4469 ] ], [ [ 65501, 65503 ], "disallowed" ], [ [ 65504, 65504 ], "mapped", [ 162 ] ], [ [ 65505, 65505 ], "mapped", [ 163 ] ], [ [ 65506, 65506 ], "mapped", [ 172 ] ], [ [ 65507, 65507 ], "disallowed_STD3_mapped", [ 32, 772 ] ], [ [ 65508, 65508 ], "mapped", [ 166 ] ], [ [ 65509, 65509 ], "mapped", [ 165 ] ], [ [ 65510, 65510 ], "mapped", [ 8361 ] ], [ [ 65511, 65511 ], "disallowed" ], [ [ 65512, 65512 ], "mapped", [ 9474 ] ], [ [ 65513, 65513 ], "mapped", [ 8592 ] ], [ [ 65514, 65514 ], "mapped", [ 8593 ] ], [ [ 65515, 65515 ], "mapped", [ 8594 ] ], [ [ 65516, 65516 ], "mapped", [ 8595 ] ], [ [ 65517, 65517 ], "mapped", [ 9632 ] ], [ [ 65518, 65518 ], "mapped", [ 9675 ] ], [ [ 65519, 65528 ], "disallowed" ], [ [ 65529, 65531 ], "disallowed" ], [ [ 65532, 65532 ], "disallowed" ], [ [ 65533, 65533 ], "disallowed" ], [ [ 65534, 65535 ], "disallowed" ], [ [ 65536, 65547 ], "valid" ], [ [ 65548, 65548 ], "disallowed" ], [ [ 65549, 65574 ], "valid" ], [ [ 65575, 65575 ], "disallowed" ], [ [ 65576, 65594 ], "valid" ], [ [ 65595, 65595 ], "disallowed" ], [ [ 65596, 65597 ], "valid" ], [ [ 65598, 65598 ], "disallowed" ], [ [ 65599, 65613 ], "valid" ], [ [ 65614, 65615 ], "disallowed" ], [ [ 65616, 65629 ], "valid" ], [ [ 65630, 65663 ], "disallowed" ], [ [ 65664, 65786 ], "valid" ], [ [ 65787, 65791 ], "disallowed" ], [ [ 65792, 65794 ], "valid", [], "NV8" ], [ [ 65795, 65798 ], "disallowed" ], [ [ 65799, 65843 ], "valid", [], "NV8" ], [ [ 65844, 65846 ], "disallowed" ], [ [ 65847, 65855 ], "valid", [], "NV8" ], [ [ 65856, 65930 ], "valid", [], "NV8" ], [ [ 65931, 65932 ], "valid", [], "NV8" ], [ [ 65933, 65935 ], "disallowed" ], [ [ 65936, 65947 ], "valid", [], "NV8" ], [ [ 65948, 65951 ], "disallowed" ], [ [ 65952, 65952 ], "valid", [], "NV8" ], [ [ 65953, 65999 ], "disallowed" ], [ [ 66e3, 66044 ], "valid", [], "NV8" ], [ [ 66045, 66045 ], "valid" ], [ [ 66046, 66175 ], "disallowed" ], [ [ 66176, 66204 ], "valid" ], [ [ 66205, 66207 ], "disallowed" ], [ [ 66208, 66256 ], "valid" ], [ [ 66257, 66271 ], "disallowed" ], [ [ 66272, 66272 ], "valid" ], [ [ 66273, 66299 ], "valid", [], "NV8" ], [ [ 66300, 66303 ], "disallowed" ], [ [ 66304, 66334 ], "valid" ], [ [ 66335, 66335 ], "valid" ], [ [ 66336, 66339 ], "valid", [], "NV8" ], [ [ 66340, 66351 ], "disallowed" ], [ [ 66352, 66368 ], "valid" ], [ [ 66369, 66369 ], "valid", [], "NV8" ], [ [ 66370, 66377 ], "valid" ], [ [ 66378, 66378 ], "valid", [], "NV8" ], [ [ 66379, 66383 ], "disallowed" ], [ [ 66384, 66426 ], "valid" ], [ [ 66427, 66431 ], "disallowed" ], [ [ 66432, 66461 ], "valid" ], [ [ 66462, 66462 ], "disallowed" ], [ [ 66463, 66463 ], "valid", [], "NV8" ], [ [ 66464, 66499 ], "valid" ], [ [ 66500, 66503 ], "disallowed" ], [ [ 66504, 66511 ], "valid" ], [ [ 66512, 66517 ], "valid", [], "NV8" ], [ [ 66518, 66559 ], "disallowed" ], [ [ 66560, 66560 ], "mapped", [ 66600 ] ], [ [ 66561, 66561 ], "mapped", [ 66601 ] ], [ [ 66562, 66562 ], "mapped", [ 66602 ] ], [ [ 66563, 66563 ], "mapped", [ 66603 ] ], [ [ 66564, 66564 ], "mapped", [ 66604 ] ], [ [ 66565, 66565 ], "mapped", [ 66605 ] ], [ [ 66566, 66566 ], "mapped", [ 66606 ] ], [ [ 66567, 66567 ], "mapped", [ 66607 ] ], [ [ 66568, 66568 ], "mapped", [ 66608 ] ], [ [ 66569, 66569 ], "mapped", [ 66609 ] ], [ [ 66570, 66570 ], "mapped", [ 66610 ] ], [ [ 66571, 66571 ], "mapped", [ 66611 ] ], [ [ 66572, 66572 ], "mapped", [ 66612 ] ], [ [ 66573, 66573 ], "mapped", [ 66613 ] ], [ [ 66574, 66574 ], "mapped", [ 66614 ] ], [ [ 66575, 66575 ], "mapped", [ 66615 ] ], [ [ 66576, 66576 ], "mapped", [ 66616 ] ], [ [ 66577, 66577 ], "mapped", [ 66617 ] ], [ [ 66578, 66578 ], "mapped", [ 66618 ] ], [ [ 66579, 66579 ], "mapped", [ 66619 ] ], [ [ 66580, 66580 ], "mapped", [ 66620 ] ], [ [ 66581, 66581 ], "mapped", [ 66621 ] ], [ [ 66582, 66582 ], "mapped", [ 66622 ] ], [ [ 66583, 66583 ], "mapped", [ 66623 ] ], [ [ 66584, 66584 ], "mapped", [ 66624 ] ], [ [ 66585, 66585 ], "mapped", [ 66625 ] ], [ [ 66586, 66586 ], "mapped", [ 66626 ] ], [ [ 66587, 66587 ], "mapped", [ 66627 ] ], [ [ 66588, 66588 ], "mapped", [ 66628 ] ], [ [ 66589, 66589 ], "mapped", [ 66629 ] ], [ [ 66590, 66590 ], "mapped", [ 66630 ] ], [ [ 66591, 66591 ], "mapped", [ 66631 ] ], [ [ 66592, 66592 ], "mapped", [ 66632 ] ], [ [ 66593, 66593 ], "mapped", [ 66633 ] ], [ [ 66594, 66594 ], "mapped", [ 66634 ] ], [ [ 66595, 66595 ], "mapped", [ 66635 ] ], [ [ 66596, 66596 ], "mapped", [ 66636 ] ], [ [ 66597, 66597 ], "mapped", [ 66637 ] ], [ [ 66598, 66598 ], "mapped", [ 66638 ] ], [ [ 66599, 66599 ], "mapped", [ 66639 ] ], [ [ 66600, 66637 ], "valid" ], [ [ 66638, 66717 ], "valid" ], [ [ 66718, 66719 ], "disallowed" ], [ [ 66720, 66729 ], "valid" ], [ [ 66730, 66815 ], "disallowed" ], [ [ 66816, 66855 ], "valid" ], [ [ 66856, 66863 ], "disallowed" ], [ [ 66864, 66915 ], "valid" ], [ [ 66916, 66926 ], "disallowed" ], [ [ 66927, 66927 ], "valid", [], "NV8" ], [ [ 66928, 67071 ], "disallowed" ], [ [ 67072, 67382 ], "valid" ], [ [ 67383, 67391 ], "disallowed" ], [ [ 67392, 67413 ], "valid" ], [ [ 67414, 67423 ], "disallowed" ], [ [ 67424, 67431 ], "valid" ], [ [ 67432, 67583 ], "disallowed" ], [ [ 67584, 67589 ], "valid" ], [ [ 67590, 67591 ], "disallowed" ], [ [ 67592, 67592 ], "valid" ], [ [ 67593, 67593 ], "disallowed" ], [ [ 67594, 67637 ], "valid" ], [ [ 67638, 67638 ], "disallowed" ], [ [ 67639, 67640 ], "valid" ], [ [ 67641, 67643 ], "disallowed" ], [ [ 67644, 67644 ], "valid" ], [ [ 67645, 67646 ], "disallowed" ], [ [ 67647, 67647 ], "valid" ], [ [ 67648, 67669 ], "valid" ], [ [ 67670, 67670 ], "disallowed" ], [ [ 67671, 67679 ], "valid", [], "NV8" ], [ [ 67680, 67702 ], "valid" ], [ [ 67703, 67711 ], "valid", [], "NV8" ], [ [ 67712, 67742 ], "valid" ], [ [ 67743, 67750 ], "disallowed" ], [ [ 67751, 67759 ], "valid", [], "NV8" ], [ [ 67760, 67807 ], "disallowed" ], [ [ 67808, 67826 ], "valid" ], [ [ 67827, 67827 ], "disallowed" ], [ [ 67828, 67829 ], "valid" ], [ [ 67830, 67834 ], "disallowed" ], [ [ 67835, 67839 ], "valid", [], "NV8" ], [ [ 67840, 67861 ], "valid" ], [ [ 67862, 67865 ], "valid", [], "NV8" ], [ [ 67866, 67867 ], "valid", [], "NV8" ], [ [ 67868, 67870 ], "disallowed" ], [ [ 67871, 67871 ], "valid", [], "NV8" ], [ [ 67872, 67897 ], "valid" ], [ [ 67898, 67902 ], "disallowed" ], [ [ 67903, 67903 ], "valid", [], "NV8" ], [ [ 67904, 67967 ], "disallowed" ], [ [ 67968, 68023 ], "valid" ], [ [ 68024, 68027 ], "disallowed" ], [ [ 68028, 68029 ], "valid", [], "NV8" ], [ [ 68030, 68031 ], "valid" ], [ [ 68032, 68047 ], "valid", [], "NV8" ], [ [ 68048, 68049 ], "disallowed" ], [ [ 68050, 68095 ], "valid", [], "NV8" ], [ [ 68096, 68099 ], "valid" ], [ [ 68100, 68100 ], "disallowed" ], [ [ 68101, 68102 ], "valid" ], [ [ 68103, 68107 ], "disallowed" ], [ [ 68108, 68115 ], "valid" ], [ [ 68116, 68116 ], "disallowed" ], [ [ 68117, 68119 ], "valid" ], [ [ 68120, 68120 ], "disallowed" ], [ [ 68121, 68147 ], "valid" ], [ [ 68148, 68151 ], "disallowed" ], [ [ 68152, 68154 ], "valid" ], [ [ 68155, 68158 ], "disallowed" ], [ [ 68159, 68159 ], "valid" ], [ [ 68160, 68167 ], "valid", [], "NV8" ], [ [ 68168, 68175 ], "disallowed" ], [ [ 68176, 68184 ], "valid", [], "NV8" ], [ [ 68185, 68191 ], "disallowed" ], [ [ 68192, 68220 ], "valid" ], [ [ 68221, 68223 ], "valid", [], "NV8" ], [ [ 68224, 68252 ], "valid" ], [ [ 68253, 68255 ], "valid", [], "NV8" ], [ [ 68256, 68287 ], "disallowed" ], [ [ 68288, 68295 ], "valid" ], [ [ 68296, 68296 ], "valid", [], "NV8" ], [ [ 68297, 68326 ], "valid" ], [ [ 68327, 68330 ], "disallowed" ], [ [ 68331, 68342 ], "valid", [], "NV8" ], [ [ 68343, 68351 ], "disallowed" ], [ [ 68352, 68405 ], "valid" ], [ [ 68406, 68408 ], "disallowed" ], [ [ 68409, 68415 ], "valid", [], "NV8" ], [ [ 68416, 68437 ], "valid" ], [ [ 68438, 68439 ], "disallowed" ], [ [ 68440, 68447 ], "valid", [], "NV8" ], [ [ 68448, 68466 ], "valid" ], [ [ 68467, 68471 ], "disallowed" ], [ [ 68472, 68479 ], "valid", [], "NV8" ], [ [ 68480, 68497 ], "valid" ], [ [ 68498, 68504 ], "disallowed" ], [ [ 68505, 68508 ], "valid", [], "NV8" ], [ [ 68509, 68520 ], "disallowed" ], [ [ 68521, 68527 ], "valid", [], "NV8" ], [ [ 68528, 68607 ], "disallowed" ], [ [ 68608, 68680 ], "valid" ], [ [ 68681, 68735 ], "disallowed" ], [ [ 68736, 68736 ], "mapped", [ 68800 ] ], [ [ 68737, 68737 ], "mapped", [ 68801 ] ], [ [ 68738, 68738 ], "mapped", [ 68802 ] ], [ [ 68739, 68739 ], "mapped", [ 68803 ] ], [ [ 68740, 68740 ], "mapped", [ 68804 ] ], [ [ 68741, 68741 ], "mapped", [ 68805 ] ], [ [ 68742, 68742 ], "mapped", [ 68806 ] ], [ [ 68743, 68743 ], "mapped", [ 68807 ] ], [ [ 68744, 68744 ], "mapped", [ 68808 ] ], [ [ 68745, 68745 ], "mapped", [ 68809 ] ], [ [ 68746, 68746 ], "mapped", [ 68810 ] ], [ [ 68747, 68747 ], "mapped", [ 68811 ] ], [ [ 68748, 68748 ], "mapped", [ 68812 ] ], [ [ 68749, 68749 ], "mapped", [ 68813 ] ], [ [ 68750, 68750 ], "mapped", [ 68814 ] ], [ [ 68751, 68751 ], "mapped", [ 68815 ] ], [ [ 68752, 68752 ], "mapped", [ 68816 ] ], [ [ 68753, 68753 ], "mapped", [ 68817 ] ], [ [ 68754, 68754 ], "mapped", [ 68818 ] ], [ [ 68755, 68755 ], "mapped", [ 68819 ] ], [ [ 68756, 68756 ], "mapped", [ 68820 ] ], [ [ 68757, 68757 ], "mapped", [ 68821 ] ], [ [ 68758, 68758 ], "mapped", [ 68822 ] ], [ [ 68759, 68759 ], "mapped", [ 68823 ] ], [ [ 68760, 68760 ], "mapped", [ 68824 ] ], [ [ 68761, 68761 ], "mapped", [ 68825 ] ], [ [ 68762, 68762 ], "mapped", [ 68826 ] ], [ [ 68763, 68763 ], "mapped", [ 68827 ] ], [ [ 68764, 68764 ], "mapped", [ 68828 ] ], [ [ 68765, 68765 ], "mapped", [ 68829 ] ], [ [ 68766, 68766 ], "mapped", [ 68830 ] ], [ [ 68767, 68767 ], "mapped", [ 68831 ] ], [ [ 68768, 68768 ], "mapped", [ 68832 ] ], [ [ 68769, 68769 ], "mapped", [ 68833 ] ], [ [ 68770, 68770 ], "mapped", [ 68834 ] ], [ [ 68771, 68771 ], "mapped", [ 68835 ] ], [ [ 68772, 68772 ], "mapped", [ 68836 ] ], [ [ 68773, 68773 ], "mapped", [ 68837 ] ], [ [ 68774, 68774 ], "mapped", [ 68838 ] ], [ [ 68775, 68775 ], "mapped", [ 68839 ] ], [ [ 68776, 68776 ], "mapped", [ 68840 ] ], [ [ 68777, 68777 ], "mapped", [ 68841 ] ], [ [ 68778, 68778 ], "mapped", [ 68842 ] ], [ [ 68779, 68779 ], "mapped", [ 68843 ] ], [ [ 68780, 68780 ], "mapped", [ 68844 ] ], [ [ 68781, 68781 ], "mapped", [ 68845 ] ], [ [ 68782, 68782 ], "mapped", [ 68846 ] ], [ [ 68783, 68783 ], "mapped", [ 68847 ] ], [ [ 68784, 68784 ], "mapped", [ 68848 ] ], [ [ 68785, 68785 ], "mapped", [ 68849 ] ], [ [ 68786, 68786 ], "mapped", [ 68850 ] ], [ [ 68787, 68799 ], "disallowed" ], [ [ 68800, 68850 ], "valid" ], [ [ 68851, 68857 ], "disallowed" ], [ [ 68858, 68863 ], "valid", [], "NV8" ], [ [ 68864, 69215 ], "disallowed" ], [ [ 69216, 69246 ], "valid", [], "NV8" ], [ [ 69247, 69631 ], "disallowed" ], [ [ 69632, 69702 ], "valid" ], [ [ 69703, 69709 ], "valid", [], "NV8" ], [ [ 69710, 69713 ], "disallowed" ], [ [ 69714, 69733 ], "valid", [], "NV8" ], [ [ 69734, 69743 ], "valid" ], [ [ 69744, 69758 ], "disallowed" ], [ [ 69759, 69759 ], "valid" ], [ [ 69760, 69818 ], "valid" ], [ [ 69819, 69820 ], "valid", [], "NV8" ], [ [ 69821, 69821 ], "disallowed" ], [ [ 69822, 69825 ], "valid", [], "NV8" ], [ [ 69826, 69839 ], "disallowed" ], [ [ 69840, 69864 ], "valid" ], [ [ 69865, 69871 ], "disallowed" ], [ [ 69872, 69881 ], "valid" ], [ [ 69882, 69887 ], "disallowed" ], [ [ 69888, 69940 ], "valid" ], [ [ 69941, 69941 ], "disallowed" ], [ [ 69942, 69951 ], "valid" ], [ [ 69952, 69955 ], "valid", [], "NV8" ], [ [ 69956, 69967 ], "disallowed" ], [ [ 69968, 70003 ], "valid" ], [ [ 70004, 70005 ], "valid", [], "NV8" ], [ [ 70006, 70006 ], "valid" ], [ [ 70007, 70015 ], "disallowed" ], [ [ 70016, 70084 ], "valid" ], [ [ 70085, 70088 ], "valid", [], "NV8" ], [ [ 70089, 70089 ], "valid", [], "NV8" ], [ [ 70090, 70092 ], "valid" ], [ [ 70093, 70093 ], "valid", [], "NV8" ], [ [ 70094, 70095 ], "disallowed" ], [ [ 70096, 70105 ], "valid" ], [ [ 70106, 70106 ], "valid" ], [ [ 70107, 70107 ], "valid", [], "NV8" ], [ [ 70108, 70108 ], "valid" ], [ [ 70109, 70111 ], "valid", [], "NV8" ], [ [ 70112, 70112 ], "disallowed" ], [ [ 70113, 70132 ], "valid", [], "NV8" ], [ [ 70133, 70143 ], "disallowed" ], [ [ 70144, 70161 ], "valid" ], [ [ 70162, 70162 ], "disallowed" ], [ [ 70163, 70199 ], "valid" ], [ [ 70200, 70205 ], "valid", [], "NV8" ], [ [ 70206, 70271 ], "disallowed" ], [ [ 70272, 70278 ], "valid" ], [ [ 70279, 70279 ], "disallowed" ], [ [ 70280, 70280 ], "valid" ], [ [ 70281, 70281 ], "disallowed" ], [ [ 70282, 70285 ], "valid" ], [ [ 70286, 70286 ], "disallowed" ], [ [ 70287, 70301 ], "valid" ], [ [ 70302, 70302 ], "disallowed" ], [ [ 70303, 70312 ], "valid" ], [ [ 70313, 70313 ], "valid", [], "NV8" ], [ [ 70314, 70319 ], "disallowed" ], [ [ 70320, 70378 ], "valid" ], [ [ 70379, 70383 ], "disallowed" ], [ [ 70384, 70393 ], "valid" ], [ [ 70394, 70399 ], "disallowed" ], [ [ 70400, 70400 ], "valid" ], [ [ 70401, 70403 ], "valid" ], [ [ 70404, 70404 ], "disallowed" ], [ [ 70405, 70412 ], "valid" ], [ [ 70413, 70414 ], "disallowed" ], [ [ 70415, 70416 ], "valid" ], [ [ 70417, 70418 ], "disallowed" ], [ [ 70419, 70440 ], "valid" ], [ [ 70441, 70441 ], "disallowed" ], [ [ 70442, 70448 ], "valid" ], [ [ 70449, 70449 ], "disallowed" ], [ [ 70450, 70451 ], "valid" ], [ [ 70452, 70452 ], "disallowed" ], [ [ 70453, 70457 ], "valid" ], [ [ 70458, 70459 ], "disallowed" ], [ [ 70460, 70468 ], "valid" ], [ [ 70469, 70470 ], "disallowed" ], [ [ 70471, 70472 ], "valid" ], [ [ 70473, 70474 ], "disallowed" ], [ [ 70475, 70477 ], "valid" ], [ [ 70478, 70479 ], "disallowed" ], [ [ 70480, 70480 ], "valid" ], [ [ 70481, 70486 ], "disallowed" ], [ [ 70487, 70487 ], "valid" ], [ [ 70488, 70492 ], "disallowed" ], [ [ 70493, 70499 ], "valid" ], [ [ 70500, 70501 ], "disallowed" ], [ [ 70502, 70508 ], "valid" ], [ [ 70509, 70511 ], "disallowed" ], [ [ 70512, 70516 ], "valid" ], [ [ 70517, 70783 ], "disallowed" ], [ [ 70784, 70853 ], "valid" ], [ [ 70854, 70854 ], "valid", [], "NV8" ], [ [ 70855, 70855 ], "valid" ], [ [ 70856, 70863 ], "disallowed" ], [ [ 70864, 70873 ], "valid" ], [ [ 70874, 71039 ], "disallowed" ], [ [ 71040, 71093 ], "valid" ], [ [ 71094, 71095 ], "disallowed" ], [ [ 71096, 71104 ], "valid" ], [ [ 71105, 71113 ], "valid", [], "NV8" ], [ [ 71114, 71127 ], "valid", [], "NV8" ], [ [ 71128, 71133 ], "valid" ], [ [ 71134, 71167 ], "disallowed" ], [ [ 71168, 71232 ], "valid" ], [ [ 71233, 71235 ], "valid", [], "NV8" ], [ [ 71236, 71236 ], "valid" ], [ [ 71237, 71247 ], "disallowed" ], [ [ 71248, 71257 ], "valid" ], [ [ 71258, 71295 ], "disallowed" ], [ [ 71296, 71351 ], "valid" ], [ [ 71352, 71359 ], "disallowed" ], [ [ 71360, 71369 ], "valid" ], [ [ 71370, 71423 ], "disallowed" ], [ [ 71424, 71449 ], "valid" ], [ [ 71450, 71452 ], "disallowed" ], [ [ 71453, 71467 ], "valid" ], [ [ 71468, 71471 ], "disallowed" ], [ [ 71472, 71481 ], "valid" ], [ [ 71482, 71487 ], "valid", [], "NV8" ], [ [ 71488, 71839 ], "disallowed" ], [ [ 71840, 71840 ], "mapped", [ 71872 ] ], [ [ 71841, 71841 ], "mapped", [ 71873 ] ], [ [ 71842, 71842 ], "mapped", [ 71874 ] ], [ [ 71843, 71843 ], "mapped", [ 71875 ] ], [ [ 71844, 71844 ], "mapped", [ 71876 ] ], [ [ 71845, 71845 ], "mapped", [ 71877 ] ], [ [ 71846, 71846 ], "mapped", [ 71878 ] ], [ [ 71847, 71847 ], "mapped", [ 71879 ] ], [ [ 71848, 71848 ], "mapped", [ 71880 ] ], [ [ 71849, 71849 ], "mapped", [ 71881 ] ], [ [ 71850, 71850 ], "mapped", [ 71882 ] ], [ [ 71851, 71851 ], "mapped", [ 71883 ] ], [ [ 71852, 71852 ], "mapped", [ 71884 ] ], [ [ 71853, 71853 ], "mapped", [ 71885 ] ], [ [ 71854, 71854 ], "mapped", [ 71886 ] ], [ [ 71855, 71855 ], "mapped", [ 71887 ] ], [ [ 71856, 71856 ], "mapped", [ 71888 ] ], [ [ 71857, 71857 ], "mapped", [ 71889 ] ], [ [ 71858, 71858 ], "mapped", [ 71890 ] ], [ [ 71859, 71859 ], "mapped", [ 71891 ] ], [ [ 71860, 71860 ], "mapped", [ 71892 ] ], [ [ 71861, 71861 ], "mapped", [ 71893 ] ], [ [ 71862, 71862 ], "mapped", [ 71894 ] ], [ [ 71863, 71863 ], "mapped", [ 71895 ] ], [ [ 71864, 71864 ], "mapped", [ 71896 ] ], [ [ 71865, 71865 ], "mapped", [ 71897 ] ], [ [ 71866, 71866 ], "mapped", [ 71898 ] ], [ [ 71867, 71867 ], "mapped", [ 71899 ] ], [ [ 71868, 71868 ], "mapped", [ 71900 ] ], [ [ 71869, 71869 ], "mapped", [ 71901 ] ], [ [ 71870, 71870 ], "mapped", [ 71902 ] ], [ [ 71871, 71871 ], "mapped", [ 71903 ] ], [ [ 71872, 71913 ], "valid" ], [ [ 71914, 71922 ], "valid", [], "NV8" ], [ [ 71923, 71934 ], "disallowed" ], [ [ 71935, 71935 ], "valid" ], [ [ 71936, 72383 ], "disallowed" ], [ [ 72384, 72440 ], "valid" ], [ [ 72441, 73727 ], "disallowed" ], [ [ 73728, 74606 ], "valid" ], [ [ 74607, 74648 ], "valid" ], [ [ 74649, 74649 ], "valid" ], [ [ 74650, 74751 ], "disallowed" ], [ [ 74752, 74850 ], "valid", [], "NV8" ], [ [ 74851, 74862 ], "valid", [], "NV8" ], [ [ 74863, 74863 ], "disallowed" ], [ [ 74864, 74867 ], "valid", [], "NV8" ], [ [ 74868, 74868 ], "valid", [], "NV8" ], [ [ 74869, 74879 ], "disallowed" ], [ [ 74880, 75075 ], "valid" ], [ [ 75076, 77823 ], "disallowed" ], [ [ 77824, 78894 ], "valid" ], [ [ 78895, 82943 ], "disallowed" ], [ [ 82944, 83526 ], "valid" ], [ [ 83527, 92159 ], "disallowed" ], [ [ 92160, 92728 ], "valid" ], [ [ 92729, 92735 ], "disallowed" ], [ [ 92736, 92766 ], "valid" ], [ [ 92767, 92767 ], "disallowed" ], [ [ 92768, 92777 ], "valid" ], [ [ 92778, 92781 ], "disallowed" ], [ [ 92782, 92783 ], "valid", [], "NV8" ], [ [ 92784, 92879 ], "disallowed" ], [ [ 92880, 92909 ], "valid" ], [ [ 92910, 92911 ], "disallowed" ], [ [ 92912, 92916 ], "valid" ], [ [ 92917, 92917 ], "valid", [], "NV8" ], [ [ 92918, 92927 ], "disallowed" ], [ [ 92928, 92982 ], "valid" ], [ [ 92983, 92991 ], "valid", [], "NV8" ], [ [ 92992, 92995 ], "valid" ], [ [ 92996, 92997 ], "valid", [], "NV8" ], [ [ 92998, 93007 ], "disallowed" ], [ [ 93008, 93017 ], "valid" ], [ [ 93018, 93018 ], "disallowed" ], [ [ 93019, 93025 ], "valid", [], "NV8" ], [ [ 93026, 93026 ], "disallowed" ], [ [ 93027, 93047 ], "valid" ], [ [ 93048, 93052 ], "disallowed" ], [ [ 93053, 93071 ], "valid" ], [ [ 93072, 93951 ], "disallowed" ], [ [ 93952, 94020 ], "valid" ], [ [ 94021, 94031 ], "disallowed" ], [ [ 94032, 94078 ], "valid" ], [ [ 94079, 94094 ], "disallowed" ], [ [ 94095, 94111 ], "valid" ], [ [ 94112, 110591 ], "disallowed" ], [ [ 110592, 110593 ], "valid" ], [ [ 110594, 113663 ], "disallowed" ], [ [ 113664, 113770 ], "valid" ], [ [ 113771, 113775 ], "disallowed" ], [ [ 113776, 113788 ], "valid" ], [ [ 113789, 113791 ], "disallowed" ], [ [ 113792, 113800 ], "valid" ], [ [ 113801, 113807 ], "disallowed" ], [ [ 113808, 113817 ], "valid" ], [ [ 113818, 113819 ], "disallowed" ], [ [ 113820, 113820 ], "valid", [], "NV8" ], [ [ 113821, 113822 ], "valid" ], [ [ 113823, 113823 ], "valid", [], "NV8" ], [ [ 113824, 113827 ], "ignored" ], [ [ 113828, 118783 ], "disallowed" ], [ [ 118784, 119029 ], "valid", [], "NV8" ], [ [ 119030, 119039 ], "disallowed" ], [ [ 119040, 119078 ], "valid", [], "NV8" ], [ [ 119079, 119080 ], "disallowed" ], [ [ 119081, 119081 ], "valid", [], "NV8" ], [ [ 119082, 119133 ], "valid", [], "NV8" ], [ [ 119134, 119134 ], "mapped", [ 119127, 119141 ] ], [ [ 119135, 119135 ], "mapped", [ 119128, 119141 ] ], [ [ 119136, 119136 ], "mapped", [ 119128, 119141, 119150 ] ], [ [ 119137, 119137 ], "mapped", [ 119128, 119141, 119151 ] ], [ [ 119138, 119138 ], "mapped", [ 119128, 119141, 119152 ] ], [ [ 119139, 119139 ], "mapped", [ 119128, 119141, 119153 ] ], [ [ 119140, 119140 ], "mapped", [ 119128, 119141, 119154 ] ], [ [ 119141, 119154 ], "valid", [], "NV8" ], [ [ 119155, 119162 ], "disallowed" ], [ [ 119163, 119226 ], "valid", [], "NV8" ], [ [ 119227, 119227 ], "mapped", [ 119225, 119141 ] ], [ [ 119228, 119228 ], "mapped", [ 119226, 119141 ] ], [ [ 119229, 119229 ], "mapped", [ 119225, 119141, 119150 ] ], [ [ 119230, 119230 ], "mapped", [ 119226, 119141, 119150 ] ], [ [ 119231, 119231 ], "mapped", [ 119225, 119141, 119151 ] ], [ [ 119232, 119232 ], "mapped", [ 119226, 119141, 119151 ] ], [ [ 119233, 119261 ], "valid", [], "NV8" ], [ [ 119262, 119272 ], "valid", [], "NV8" ], [ [ 119273, 119295 ], "disallowed" ], [ [ 119296, 119365 ], "valid", [], "NV8" ], [ [ 119366, 119551 ], "disallowed" ], [ [ 119552, 119638 ], "valid", [], "NV8" ], [ [ 119639, 119647 ], "disallowed" ], [ [ 119648, 119665 ], "valid", [], "NV8" ], [ [ 119666, 119807 ], "disallowed" ], [ [ 119808, 119808 ], "mapped", [ 97 ] ], [ [ 119809, 119809 ], "mapped", [ 98 ] ], [ [ 119810, 119810 ], "mapped", [ 99 ] ], [ [ 119811, 119811 ], "mapped", [ 100 ] ], [ [ 119812, 119812 ], "mapped", [ 101 ] ], [ [ 119813, 119813 ], "mapped", [ 102 ] ], [ [ 119814, 119814 ], "mapped", [ 103 ] ], [ [ 119815, 119815 ], "mapped", [ 104 ] ], [ [ 119816, 119816 ], "mapped", [ 105 ] ], [ [ 119817, 119817 ], "mapped", [ 106 ] ], [ [ 119818, 119818 ], "mapped", [ 107 ] ], [ [ 119819, 119819 ], "mapped", [ 108 ] ], [ [ 119820, 119820 ], "mapped", [ 109 ] ], [ [ 119821, 119821 ], "mapped", [ 110 ] ], [ [ 119822, 119822 ], "mapped", [ 111 ] ], [ [ 119823, 119823 ], "mapped", [ 112 ] ], [ [ 119824, 119824 ], "mapped", [ 113 ] ], [ [ 119825, 119825 ], "mapped", [ 114 ] ], [ [ 119826, 119826 ], "mapped", [ 115 ] ], [ [ 119827, 119827 ], "mapped", [ 116 ] ], [ [ 119828, 119828 ], "mapped", [ 117 ] ], [ [ 119829, 119829 ], "mapped", [ 118 ] ], [ [ 119830, 119830 ], "mapped", [ 119 ] ], [ [ 119831, 119831 ], "mapped", [ 120 ] ], [ [ 119832, 119832 ], "mapped", [ 121 ] ], [ [ 119833, 119833 ], "mapped", [ 122 ] ], [ [ 119834, 119834 ], "mapped", [ 97 ] ], [ [ 119835, 119835 ], "mapped", [ 98 ] ], [ [ 119836, 119836 ], "mapped", [ 99 ] ], [ [ 119837, 119837 ], "mapped", [ 100 ] ], [ [ 119838, 119838 ], "mapped", [ 101 ] ], [ [ 119839, 119839 ], "mapped", [ 102 ] ], [ [ 119840, 119840 ], "mapped", [ 103 ] ], [ [ 119841, 119841 ], "mapped", [ 104 ] ], [ [ 119842, 119842 ], "mapped", [ 105 ] ], [ [ 119843, 119843 ], "mapped", [ 106 ] ], [ [ 119844, 119844 ], "mapped", [ 107 ] ], [ [ 119845, 119845 ], "mapped", [ 108 ] ], [ [ 119846, 119846 ], "mapped", [ 109 ] ], [ [ 119847, 119847 ], "mapped", [ 110 ] ], [ [ 119848, 119848 ], "mapped", [ 111 ] ], [ [ 119849, 119849 ], "mapped", [ 112 ] ], [ [ 119850, 119850 ], "mapped", [ 113 ] ], [ [ 119851, 119851 ], "mapped", [ 114 ] ], [ [ 119852, 119852 ], "mapped", [ 115 ] ], [ [ 119853, 119853 ], "mapped", [ 116 ] ], [ [ 119854, 119854 ], "mapped", [ 117 ] ], [ [ 119855, 119855 ], "mapped", [ 118 ] ], [ [ 119856, 119856 ], "mapped", [ 119 ] ], [ [ 119857, 119857 ], "mapped", [ 120 ] ], [ [ 119858, 119858 ], "mapped", [ 121 ] ], [ [ 119859, 119859 ], "mapped", [ 122 ] ], [ [ 119860, 119860 ], "mapped", [ 97 ] ], [ [ 119861, 119861 ], "mapped", [ 98 ] ], [ [ 119862, 119862 ], "mapped", [ 99 ] ], [ [ 119863, 119863 ], "mapped", [ 100 ] ], [ [ 119864, 119864 ], "mapped", [ 101 ] ], [ [ 119865, 119865 ], "mapped", [ 102 ] ], [ [ 119866, 119866 ], "mapped", [ 103 ] ], [ [ 119867, 119867 ], "mapped", [ 104 ] ], [ [ 119868, 119868 ], "mapped", [ 105 ] ], [ [ 119869, 119869 ], "mapped", [ 106 ] ], [ [ 119870, 119870 ], "mapped", [ 107 ] ], [ [ 119871, 119871 ], "mapped", [ 108 ] ], [ [ 119872, 119872 ], "mapped", [ 109 ] ], [ [ 119873, 119873 ], "mapped", [ 110 ] ], [ [ 119874, 119874 ], "mapped", [ 111 ] ], [ [ 119875, 119875 ], "mapped", [ 112 ] ], [ [ 119876, 119876 ], "mapped", [ 113 ] ], [ [ 119877, 119877 ], "mapped", [ 114 ] ], [ [ 119878, 119878 ], "mapped", [ 115 ] ], [ [ 119879, 119879 ], "mapped", [ 116 ] ], [ [ 119880, 119880 ], "mapped", [ 117 ] ], [ [ 119881, 119881 ], "mapped", [ 118 ] ], [ [ 119882, 119882 ], "mapped", [ 119 ] ], [ [ 119883, 119883 ], "mapped", [ 120 ] ], [ [ 119884, 119884 ], "mapped", [ 121 ] ], [ [ 119885, 119885 ], "mapped", [ 122 ] ], [ [ 119886, 119886 ], "mapped", [ 97 ] ], [ [ 119887, 119887 ], "mapped", [ 98 ] ], [ [ 119888, 119888 ], "mapped", [ 99 ] ], [ [ 119889, 119889 ], "mapped", [ 100 ] ], [ [ 119890, 119890 ], "mapped", [ 101 ] ], [ [ 119891, 119891 ], "mapped", [ 102 ] ], [ [ 119892, 119892 ], "mapped", [ 103 ] ], [ [ 119893, 119893 ], "disallowed" ], [ [ 119894, 119894 ], "mapped", [ 105 ] ], [ [ 119895, 119895 ], "mapped", [ 106 ] ], [ [ 119896, 119896 ], "mapped", [ 107 ] ], [ [ 119897, 119897 ], "mapped", [ 108 ] ], [ [ 119898, 119898 ], "mapped", [ 109 ] ], [ [ 119899, 119899 ], "mapped", [ 110 ] ], [ [ 119900, 119900 ], "mapped", [ 111 ] ], [ [ 119901, 119901 ], "mapped", [ 112 ] ], [ [ 119902, 119902 ], "mapped", [ 113 ] ], [ [ 119903, 119903 ], "mapped", [ 114 ] ], [ [ 119904, 119904 ], "mapped", [ 115 ] ], [ [ 119905, 119905 ], "mapped", [ 116 ] ], [ [ 119906, 119906 ], "mapped", [ 117 ] ], [ [ 119907, 119907 ], "mapped", [ 118 ] ], [ [ 119908, 119908 ], "mapped", [ 119 ] ], [ [ 119909, 119909 ], "mapped", [ 120 ] ], [ [ 119910, 119910 ], "mapped", [ 121 ] ], [ [ 119911, 119911 ], "mapped", [ 122 ] ], [ [ 119912, 119912 ], "mapped", [ 97 ] ], [ [ 119913, 119913 ], "mapped", [ 98 ] ], [ [ 119914, 119914 ], "mapped", [ 99 ] ], [ [ 119915, 119915 ], "mapped", [ 100 ] ], [ [ 119916, 119916 ], "mapped", [ 101 ] ], [ [ 119917, 119917 ], "mapped", [ 102 ] ], [ [ 119918, 119918 ], "mapped", [ 103 ] ], [ [ 119919, 119919 ], "mapped", [ 104 ] ], [ [ 119920, 119920 ], "mapped", [ 105 ] ], [ [ 119921, 119921 ], "mapped", [ 106 ] ], [ [ 119922, 119922 ], "mapped", [ 107 ] ], [ [ 119923, 119923 ], "mapped", [ 108 ] ], [ [ 119924, 119924 ], "mapped", [ 109 ] ], [ [ 119925, 119925 ], "mapped", [ 110 ] ], [ [ 119926, 119926 ], "mapped", [ 111 ] ], [ [ 119927, 119927 ], "mapped", [ 112 ] ], [ [ 119928, 119928 ], "mapped", [ 113 ] ], [ [ 119929, 119929 ], "mapped", [ 114 ] ], [ [ 119930, 119930 ], "mapped", [ 115 ] ], [ [ 119931, 119931 ], "mapped", [ 116 ] ], [ [ 119932, 119932 ], "mapped", [ 117 ] ], [ [ 119933, 119933 ], "mapped", [ 118 ] ], [ [ 119934, 119934 ], "mapped", [ 119 ] ], [ [ 119935, 119935 ], "mapped", [ 120 ] ], [ [ 119936, 119936 ], "mapped", [ 121 ] ], [ [ 119937, 119937 ], "mapped", [ 122 ] ], [ [ 119938, 119938 ], "mapped", [ 97 ] ], [ [ 119939, 119939 ], "mapped", [ 98 ] ], [ [ 119940, 119940 ], "mapped", [ 99 ] ], [ [ 119941, 119941 ], "mapped", [ 100 ] ], [ [ 119942, 119942 ], "mapped", [ 101 ] ], [ [ 119943, 119943 ], "mapped", [ 102 ] ], [ [ 119944, 119944 ], "mapped", [ 103 ] ], [ [ 119945, 119945 ], "mapped", [ 104 ] ], [ [ 119946, 119946 ], "mapped", [ 105 ] ], [ [ 119947, 119947 ], "mapped", [ 106 ] ], [ [ 119948, 119948 ], "mapped", [ 107 ] ], [ [ 119949, 119949 ], "mapped", [ 108 ] ], [ [ 119950, 119950 ], "mapped", [ 109 ] ], [ [ 119951, 119951 ], "mapped", [ 110 ] ], [ [ 119952, 119952 ], "mapped", [ 111 ] ], [ [ 119953, 119953 ], "mapped", [ 112 ] ], [ [ 119954, 119954 ], "mapped", [ 113 ] ], [ [ 119955, 119955 ], "mapped", [ 114 ] ], [ [ 119956, 119956 ], "mapped", [ 115 ] ], [ [ 119957, 119957 ], "mapped", [ 116 ] ], [ [ 119958, 119958 ], "mapped", [ 117 ] ], [ [ 119959, 119959 ], "mapped", [ 118 ] ], [ [ 119960, 119960 ], "mapped", [ 119 ] ], [ [ 119961, 119961 ], "mapped", [ 120 ] ], [ [ 119962, 119962 ], "mapped", [ 121 ] ], [ [ 119963, 119963 ], "mapped", [ 122 ] ], [ [ 119964, 119964 ], "mapped", [ 97 ] ], [ [ 119965, 119965 ], "disallowed" ], [ [ 119966, 119966 ], "mapped", [ 99 ] ], [ [ 119967, 119967 ], "mapped", [ 100 ] ], [ [ 119968, 119969 ], "disallowed" ], [ [ 119970, 119970 ], "mapped", [ 103 ] ], [ [ 119971, 119972 ], "disallowed" ], [ [ 119973, 119973 ], "mapped", [ 106 ] ], [ [ 119974, 119974 ], "mapped", [ 107 ] ], [ [ 119975, 119976 ], "disallowed" ], [ [ 119977, 119977 ], "mapped", [ 110 ] ], [ [ 119978, 119978 ], "mapped", [ 111 ] ], [ [ 119979, 119979 ], "mapped", [ 112 ] ], [ [ 119980, 119980 ], "mapped", [ 113 ] ], [ [ 119981, 119981 ], "disallowed" ], [ [ 119982, 119982 ], "mapped", [ 115 ] ], [ [ 119983, 119983 ], "mapped", [ 116 ] ], [ [ 119984, 119984 ], "mapped", [ 117 ] ], [ [ 119985, 119985 ], "mapped", [ 118 ] ], [ [ 119986, 119986 ], "mapped", [ 119 ] ], [ [ 119987, 119987 ], "mapped", [ 120 ] ], [ [ 119988, 119988 ], "mapped", [ 121 ] ], [ [ 119989, 119989 ], "mapped", [ 122 ] ], [ [ 119990, 119990 ], "mapped", [ 97 ] ], [ [ 119991, 119991 ], "mapped", [ 98 ] ], [ [ 119992, 119992 ], "mapped", [ 99 ] ], [ [ 119993, 119993 ], "mapped", [ 100 ] ], [ [ 119994, 119994 ], "disallowed" ], [ [ 119995, 119995 ], "mapped", [ 102 ] ], [ [ 119996, 119996 ], "disallowed" ], [ [ 119997, 119997 ], "mapped", [ 104 ] ], [ [ 119998, 119998 ], "mapped", [ 105 ] ], [ [ 119999, 119999 ], "mapped", [ 106 ] ], [ [ 12e4, 12e4 ], "mapped", [ 107 ] ], [ [ 120001, 120001 ], "mapped", [ 108 ] ], [ [ 120002, 120002 ], "mapped", [ 109 ] ], [ [ 120003, 120003 ], "mapped", [ 110 ] ], [ [ 120004, 120004 ], "disallowed" ], [ [ 120005, 120005 ], "mapped", [ 112 ] ], [ [ 120006, 120006 ], "mapped", [ 113 ] ], [ [ 120007, 120007 ], "mapped", [ 114 ] ], [ [ 120008, 120008 ], "mapped", [ 115 ] ], [ [ 120009, 120009 ], "mapped", [ 116 ] ], [ [ 120010, 120010 ], "mapped", [ 117 ] ], [ [ 120011, 120011 ], "mapped", [ 118 ] ], [ [ 120012, 120012 ], "mapped", [ 119 ] ], [ [ 120013, 120013 ], "mapped", [ 120 ] ], [ [ 120014, 120014 ], "mapped", [ 121 ] ], [ [ 120015, 120015 ], "mapped", [ 122 ] ], [ [ 120016, 120016 ], "mapped", [ 97 ] ], [ [ 120017, 120017 ], "mapped", [ 98 ] ], [ [ 120018, 120018 ], "mapped", [ 99 ] ], [ [ 120019, 120019 ], "mapped", [ 100 ] ], [ [ 120020, 120020 ], "mapped", [ 101 ] ], [ [ 120021, 120021 ], "mapped", [ 102 ] ], [ [ 120022, 120022 ], "mapped", [ 103 ] ], [ [ 120023, 120023 ], "mapped", [ 104 ] ], [ [ 120024, 120024 ], "mapped", [ 105 ] ], [ [ 120025, 120025 ], "mapped", [ 106 ] ], [ [ 120026, 120026 ], "mapped", [ 107 ] ], [ [ 120027, 120027 ], "mapped", [ 108 ] ], [ [ 120028, 120028 ], "mapped", [ 109 ] ], [ [ 120029, 120029 ], "mapped", [ 110 ] ], [ [ 120030, 120030 ], "mapped", [ 111 ] ], [ [ 120031, 120031 ], "mapped", [ 112 ] ], [ [ 120032, 120032 ], "mapped", [ 113 ] ], [ [ 120033, 120033 ], "mapped", [ 114 ] ], [ [ 120034, 120034 ], "mapped", [ 115 ] ], [ [ 120035, 120035 ], "mapped", [ 116 ] ], [ [ 120036, 120036 ], "mapped", [ 117 ] ], [ [ 120037, 120037 ], "mapped", [ 118 ] ], [ [ 120038, 120038 ], "mapped", [ 119 ] ], [ [ 120039, 120039 ], "mapped", [ 120 ] ], [ [ 120040, 120040 ], "mapped", [ 121 ] ], [ [ 120041, 120041 ], "mapped", [ 122 ] ], [ [ 120042, 120042 ], "mapped", [ 97 ] ], [ [ 120043, 120043 ], "mapped", [ 98 ] ], [ [ 120044, 120044 ], "mapped", [ 99 ] ], [ [ 120045, 120045 ], "mapped", [ 100 ] ], [ [ 120046, 120046 ], "mapped", [ 101 ] ], [ [ 120047, 120047 ], "mapped", [ 102 ] ], [ [ 120048, 120048 ], "mapped", [ 103 ] ], [ [ 120049, 120049 ], "mapped", [ 104 ] ], [ [ 120050, 120050 ], "mapped", [ 105 ] ], [ [ 120051, 120051 ], "mapped", [ 106 ] ], [ [ 120052, 120052 ], "mapped", [ 107 ] ], [ [ 120053, 120053 ], "mapped", [ 108 ] ], [ [ 120054, 120054 ], "mapped", [ 109 ] ], [ [ 120055, 120055 ], "mapped", [ 110 ] ], [ [ 120056, 120056 ], "mapped", [ 111 ] ], [ [ 120057, 120057 ], "mapped", [ 112 ] ], [ [ 120058, 120058 ], "mapped", [ 113 ] ], [ [ 120059, 120059 ], "mapped", [ 114 ] ], [ [ 120060, 120060 ], "mapped", [ 115 ] ], [ [ 120061, 120061 ], "mapped", [ 116 ] ], [ [ 120062, 120062 ], "mapped", [ 117 ] ], [ [ 120063, 120063 ], "mapped", [ 118 ] ], [ [ 120064, 120064 ], "mapped", [ 119 ] ], [ [ 120065, 120065 ], "mapped", [ 120 ] ], [ [ 120066, 120066 ], "mapped", [ 121 ] ], [ [ 120067, 120067 ], "mapped", [ 122 ] ], [ [ 120068, 120068 ], "mapped", [ 97 ] ], [ [ 120069, 120069 ], "mapped", [ 98 ] ], [ [ 120070, 120070 ], "disallowed" ], [ [ 120071, 120071 ], "mapped", [ 100 ] ], [ [ 120072, 120072 ], "mapped", [ 101 ] ], [ [ 120073, 120073 ], "mapped", [ 102 ] ], [ [ 120074, 120074 ], "mapped", [ 103 ] ], [ [ 120075, 120076 ], "disallowed" ], [ [ 120077, 120077 ], "mapped", [ 106 ] ], [ [ 120078, 120078 ], "mapped", [ 107 ] ], [ [ 120079, 120079 ], "mapped", [ 108 ] ], [ [ 120080, 120080 ], "mapped", [ 109 ] ], [ [ 120081, 120081 ], "mapped", [ 110 ] ], [ [ 120082, 120082 ], "mapped", [ 111 ] ], [ [ 120083, 120083 ], "mapped", [ 112 ] ], [ [ 120084, 120084 ], "mapped", [ 113 ] ], [ [ 120085, 120085 ], "disallowed" ], [ [ 120086, 120086 ], "mapped", [ 115 ] ], [ [ 120087, 120087 ], "mapped", [ 116 ] ], [ [ 120088, 120088 ], "mapped", [ 117 ] ], [ [ 120089, 120089 ], "mapped", [ 118 ] ], [ [ 120090, 120090 ], "mapped", [ 119 ] ], [ [ 120091, 120091 ], "mapped", [ 120 ] ], [ [ 120092, 120092 ], "mapped", [ 121 ] ], [ [ 120093, 120093 ], "disallowed" ], [ [ 120094, 120094 ], "mapped", [ 97 ] ], [ [ 120095, 120095 ], "mapped", [ 98 ] ], [ [ 120096, 120096 ], "mapped", [ 99 ] ], [ [ 120097, 120097 ], "mapped", [ 100 ] ], [ [ 120098, 120098 ], "mapped", [ 101 ] ], [ [ 120099, 120099 ], "mapped", [ 102 ] ], [ [ 120100, 120100 ], "mapped", [ 103 ] ], [ [ 120101, 120101 ], "mapped", [ 104 ] ], [ [ 120102, 120102 ], "mapped", [ 105 ] ], [ [ 120103, 120103 ], "mapped", [ 106 ] ], [ [ 120104, 120104 ], "mapped", [ 107 ] ], [ [ 120105, 120105 ], "mapped", [ 108 ] ], [ [ 120106, 120106 ], "mapped", [ 109 ] ], [ [ 120107, 120107 ], "mapped", [ 110 ] ], [ [ 120108, 120108 ], "mapped", [ 111 ] ], [ [ 120109, 120109 ], "mapped", [ 112 ] ], [ [ 120110, 120110 ], "mapped", [ 113 ] ], [ [ 120111, 120111 ], "mapped", [ 114 ] ], [ [ 120112, 120112 ], "mapped", [ 115 ] ], [ [ 120113, 120113 ], "mapped", [ 116 ] ], [ [ 120114, 120114 ], "mapped", [ 117 ] ], [ [ 120115, 120115 ], "mapped", [ 118 ] ], [ [ 120116, 120116 ], "mapped", [ 119 ] ], [ [ 120117, 120117 ], "mapped", [ 120 ] ], [ [ 120118, 120118 ], "mapped", [ 121 ] ], [ [ 120119, 120119 ], "mapped", [ 122 ] ], [ [ 120120, 120120 ], "mapped", [ 97 ] ], [ [ 120121, 120121 ], "mapped", [ 98 ] ], [ [ 120122, 120122 ], "disallowed" ], [ [ 120123, 120123 ], "mapped", [ 100 ] ], [ [ 120124, 120124 ], "mapped", [ 101 ] ], [ [ 120125, 120125 ], "mapped", [ 102 ] ], [ [ 120126, 120126 ], "mapped", [ 103 ] ], [ [ 120127, 120127 ], "disallowed" ], [ [ 120128, 120128 ], "mapped", [ 105 ] ], [ [ 120129, 120129 ], "mapped", [ 106 ] ], [ [ 120130, 120130 ], "mapped", [ 107 ] ], [ [ 120131, 120131 ], "mapped", [ 108 ] ], [ [ 120132, 120132 ], "mapped", [ 109 ] ], [ [ 120133, 120133 ], "disallowed" ], [ [ 120134, 120134 ], "mapped", [ 111 ] ], [ [ 120135, 120137 ], "disallowed" ], [ [ 120138, 120138 ], "mapped", [ 115 ] ], [ [ 120139, 120139 ], "mapped", [ 116 ] ], [ [ 120140, 120140 ], "mapped", [ 117 ] ], [ [ 120141, 120141 ], "mapped", [ 118 ] ], [ [ 120142, 120142 ], "mapped", [ 119 ] ], [ [ 120143, 120143 ], "mapped", [ 120 ] ], [ [ 120144, 120144 ], "mapped", [ 121 ] ], [ [ 120145, 120145 ], "disallowed" ], [ [ 120146, 120146 ], "mapped", [ 97 ] ], [ [ 120147, 120147 ], "mapped", [ 98 ] ], [ [ 120148, 120148 ], "mapped", [ 99 ] ], [ [ 120149, 120149 ], "mapped", [ 100 ] ], [ [ 120150, 120150 ], "mapped", [ 101 ] ], [ [ 120151, 120151 ], "mapped", [ 102 ] ], [ [ 120152, 120152 ], "mapped", [ 103 ] ], [ [ 120153, 120153 ], "mapped", [ 104 ] ], [ [ 120154, 120154 ], "mapped", [ 105 ] ], [ [ 120155, 120155 ], "mapped", [ 106 ] ], [ [ 120156, 120156 ], "mapped", [ 107 ] ], [ [ 120157, 120157 ], "mapped", [ 108 ] ], [ [ 120158, 120158 ], "mapped", [ 109 ] ], [ [ 120159, 120159 ], "mapped", [ 110 ] ], [ [ 120160, 120160 ], "mapped", [ 111 ] ], [ [ 120161, 120161 ], "mapped", [ 112 ] ], [ [ 120162, 120162 ], "mapped", [ 113 ] ], [ [ 120163, 120163 ], "mapped", [ 114 ] ], [ [ 120164, 120164 ], "mapped", [ 115 ] ], [ [ 120165, 120165 ], "mapped", [ 116 ] ], [ [ 120166, 120166 ], "mapped", [ 117 ] ], [ [ 120167, 120167 ], "mapped", [ 118 ] ], [ [ 120168, 120168 ], "mapped", [ 119 ] ], [ [ 120169, 120169 ], "mapped", [ 120 ] ], [ [ 120170, 120170 ], "mapped", [ 121 ] ], [ [ 120171, 120171 ], "mapped", [ 122 ] ], [ [ 120172, 120172 ], "mapped", [ 97 ] ], [ [ 120173, 120173 ], "mapped", [ 98 ] ], [ [ 120174, 120174 ], "mapped", [ 99 ] ], [ [ 120175, 120175 ], "mapped", [ 100 ] ], [ [ 120176, 120176 ], "mapped", [ 101 ] ], [ [ 120177, 120177 ], "mapped", [ 102 ] ], [ [ 120178, 120178 ], "mapped", [ 103 ] ], [ [ 120179, 120179 ], "mapped", [ 104 ] ], [ [ 120180, 120180 ], "mapped", [ 105 ] ], [ [ 120181, 120181 ], "mapped", [ 106 ] ], [ [ 120182, 120182 ], "mapped", [ 107 ] ], [ [ 120183, 120183 ], "mapped", [ 108 ] ], [ [ 120184, 120184 ], "mapped", [ 109 ] ], [ [ 120185, 120185 ], "mapped", [ 110 ] ], [ [ 120186, 120186 ], "mapped", [ 111 ] ], [ [ 120187, 120187 ], "mapped", [ 112 ] ], [ [ 120188, 120188 ], "mapped", [ 113 ] ], [ [ 120189, 120189 ], "mapped", [ 114 ] ], [ [ 120190, 120190 ], "mapped", [ 115 ] ], [ [ 120191, 120191 ], "mapped", [ 116 ] ], [ [ 120192, 120192 ], "mapped", [ 117 ] ], [ [ 120193, 120193 ], "mapped", [ 118 ] ], [ [ 120194, 120194 ], "mapped", [ 119 ] ], [ [ 120195, 120195 ], "mapped", [ 120 ] ], [ [ 120196, 120196 ], "mapped", [ 121 ] ], [ [ 120197, 120197 ], "mapped", [ 122 ] ], [ [ 120198, 120198 ], "mapped", [ 97 ] ], [ [ 120199, 120199 ], "mapped", [ 98 ] ], [ [ 120200, 120200 ], "mapped", [ 99 ] ], [ [ 120201, 120201 ], "mapped", [ 100 ] ], [ [ 120202, 120202 ], "mapped", [ 101 ] ], [ [ 120203, 120203 ], "mapped", [ 102 ] ], [ [ 120204, 120204 ], "mapped", [ 103 ] ], [ [ 120205, 120205 ], "mapped", [ 104 ] ], [ [ 120206, 120206 ], "mapped", [ 105 ] ], [ [ 120207, 120207 ], "mapped", [ 106 ] ], [ [ 120208, 120208 ], "mapped", [ 107 ] ], [ [ 120209, 120209 ], "mapped", [ 108 ] ], [ [ 120210, 120210 ], "mapped", [ 109 ] ], [ [ 120211, 120211 ], "mapped", [ 110 ] ], [ [ 120212, 120212 ], "mapped", [ 111 ] ], [ [ 120213, 120213 ], "mapped", [ 112 ] ], [ [ 120214, 120214 ], "mapped", [ 113 ] ], [ [ 120215, 120215 ], "mapped", [ 114 ] ], [ [ 120216, 120216 ], "mapped", [ 115 ] ], [ [ 120217, 120217 ], "mapped", [ 116 ] ], [ [ 120218, 120218 ], "mapped", [ 117 ] ], [ [ 120219, 120219 ], "mapped", [ 118 ] ], [ [ 120220, 120220 ], "mapped", [ 119 ] ], [ [ 120221, 120221 ], "mapped", [ 120 ] ], [ [ 120222, 120222 ], "mapped", [ 121 ] ], [ [ 120223, 120223 ], "mapped", [ 122 ] ], [ [ 120224, 120224 ], "mapped", [ 97 ] ], [ [ 120225, 120225 ], "mapped", [ 98 ] ], [ [ 120226, 120226 ], "mapped", [ 99 ] ], [ [ 120227, 120227 ], "mapped", [ 100 ] ], [ [ 120228, 120228 ], "mapped", [ 101 ] ], [ [ 120229, 120229 ], "mapped", [ 102 ] ], [ [ 120230, 120230 ], "mapped", [ 103 ] ], [ [ 120231, 120231 ], "mapped", [ 104 ] ], [ [ 120232, 120232 ], "mapped", [ 105 ] ], [ [ 120233, 120233 ], "mapped", [ 106 ] ], [ [ 120234, 120234 ], "mapped", [ 107 ] ], [ [ 120235, 120235 ], "mapped", [ 108 ] ], [ [ 120236, 120236 ], "mapped", [ 109 ] ], [ [ 120237, 120237 ], "mapped", [ 110 ] ], [ [ 120238, 120238 ], "mapped", [ 111 ] ], [ [ 120239, 120239 ], "mapped", [ 112 ] ], [ [ 120240, 120240 ], "mapped", [ 113 ] ], [ [ 120241, 120241 ], "mapped", [ 114 ] ], [ [ 120242, 120242 ], "mapped", [ 115 ] ], [ [ 120243, 120243 ], "mapped", [ 116 ] ], [ [ 120244, 120244 ], "mapped", [ 117 ] ], [ [ 120245, 120245 ], "mapped", [ 118 ] ], [ [ 120246, 120246 ], "mapped", [ 119 ] ], [ [ 120247, 120247 ], "mapped", [ 120 ] ], [ [ 120248, 120248 ], "mapped", [ 121 ] ], [ [ 120249, 120249 ], "mapped", [ 122 ] ], [ [ 120250, 120250 ], "mapped", [ 97 ] ], [ [ 120251, 120251 ], "mapped", [ 98 ] ], [ [ 120252, 120252 ], "mapped", [ 99 ] ], [ [ 120253, 120253 ], "mapped", [ 100 ] ], [ [ 120254, 120254 ], "mapped", [ 101 ] ], [ [ 120255, 120255 ], "mapped", [ 102 ] ], [ [ 120256, 120256 ], "mapped", [ 103 ] ], [ [ 120257, 120257 ], "mapped", [ 104 ] ], [ [ 120258, 120258 ], "mapped", [ 105 ] ], [ [ 120259, 120259 ], "mapped", [ 106 ] ], [ [ 120260, 120260 ], "mapped", [ 107 ] ], [ [ 120261, 120261 ], "mapped", [ 108 ] ], [ [ 120262, 120262 ], "mapped", [ 109 ] ], [ [ 120263, 120263 ], "mapped", [ 110 ] ], [ [ 120264, 120264 ], "mapped", [ 111 ] ], [ [ 120265, 120265 ], "mapped", [ 112 ] ], [ [ 120266, 120266 ], "mapped", [ 113 ] ], [ [ 120267, 120267 ], "mapped", [ 114 ] ], [ [ 120268, 120268 ], "mapped", [ 115 ] ], [ [ 120269, 120269 ], "mapped", [ 116 ] ], [ [ 120270, 120270 ], "mapped", [ 117 ] ], [ [ 120271, 120271 ], "mapped", [ 118 ] ], [ [ 120272, 120272 ], "mapped", [ 119 ] ], [ [ 120273, 120273 ], "mapped", [ 120 ] ], [ [ 120274, 120274 ], "mapped", [ 121 ] ], [ [ 120275, 120275 ], "mapped", [ 122 ] ], [ [ 120276, 120276 ], "mapped", [ 97 ] ], [ [ 120277, 120277 ], "mapped", [ 98 ] ], [ [ 120278, 120278 ], "mapped", [ 99 ] ], [ [ 120279, 120279 ], "mapped", [ 100 ] ], [ [ 120280, 120280 ], "mapped", [ 101 ] ], [ [ 120281, 120281 ], "mapped", [ 102 ] ], [ [ 120282, 120282 ], "mapped", [ 103 ] ], [ [ 120283, 120283 ], "mapped", [ 104 ] ], [ [ 120284, 120284 ], "mapped", [ 105 ] ], [ [ 120285, 120285 ], "mapped", [ 106 ] ], [ [ 120286, 120286 ], "mapped", [ 107 ] ], [ [ 120287, 120287 ], "mapped", [ 108 ] ], [ [ 120288, 120288 ], "mapped", [ 109 ] ], [ [ 120289, 120289 ], "mapped", [ 110 ] ], [ [ 120290, 120290 ], "mapped", [ 111 ] ], [ [ 120291, 120291 ], "mapped", [ 112 ] ], [ [ 120292, 120292 ], "mapped", [ 113 ] ], [ [ 120293, 120293 ], "mapped", [ 114 ] ], [ [ 120294, 120294 ], "mapped", [ 115 ] ], [ [ 120295, 120295 ], "mapped", [ 116 ] ], [ [ 120296, 120296 ], "mapped", [ 117 ] ], [ [ 120297, 120297 ], "mapped", [ 118 ] ], [ [ 120298, 120298 ], "mapped", [ 119 ] ], [ [ 120299, 120299 ], "mapped", [ 120 ] ], [ [ 120300, 120300 ], "mapped", [ 121 ] ], [ [ 120301, 120301 ], "mapped", [ 122 ] ], [ [ 120302, 120302 ], "mapped", [ 97 ] ], [ [ 120303, 120303 ], "mapped", [ 98 ] ], [ [ 120304, 120304 ], "mapped", [ 99 ] ], [ [ 120305, 120305 ], "mapped", [ 100 ] ], [ [ 120306, 120306 ], "mapped", [ 101 ] ], [ [ 120307, 120307 ], "mapped", [ 102 ] ], [ [ 120308, 120308 ], "mapped", [ 103 ] ], [ [ 120309, 120309 ], "mapped", [ 104 ] ], [ [ 120310, 120310 ], "mapped", [ 105 ] ], [ [ 120311, 120311 ], "mapped", [ 106 ] ], [ [ 120312, 120312 ], "mapped", [ 107 ] ], [ [ 120313, 120313 ], "mapped", [ 108 ] ], [ [ 120314, 120314 ], "mapped", [ 109 ] ], [ [ 120315, 120315 ], "mapped", [ 110 ] ], [ [ 120316, 120316 ], "mapped", [ 111 ] ], [ [ 120317, 120317 ], "mapped", [ 112 ] ], [ [ 120318, 120318 ], "mapped", [ 113 ] ], [ [ 120319, 120319 ], "mapped", [ 114 ] ], [ [ 120320, 120320 ], "mapped", [ 115 ] ], [ [ 120321, 120321 ], "mapped", [ 116 ] ], [ [ 120322, 120322 ], "mapped", [ 117 ] ], [ [ 120323, 120323 ], "mapped", [ 118 ] ], [ [ 120324, 120324 ], "mapped", [ 119 ] ], [ [ 120325, 120325 ], "mapped", [ 120 ] ], [ [ 120326, 120326 ], "mapped", [ 121 ] ], [ [ 120327, 120327 ], "mapped", [ 122 ] ], [ [ 120328, 120328 ], "mapped", [ 97 ] ], [ [ 120329, 120329 ], "mapped", [ 98 ] ], [ [ 120330, 120330 ], "mapped", [ 99 ] ], [ [ 120331, 120331 ], "mapped", [ 100 ] ], [ [ 120332, 120332 ], "mapped", [ 101 ] ], [ [ 120333, 120333 ], "mapped", [ 102 ] ], [ [ 120334, 120334 ], "mapped", [ 103 ] ], [ [ 120335, 120335 ], "mapped", [ 104 ] ], [ [ 120336, 120336 ], "mapped", [ 105 ] ], [ [ 120337, 120337 ], "mapped", [ 106 ] ], [ [ 120338, 120338 ], "mapped", [ 107 ] ], [ [ 120339, 120339 ], "mapped", [ 108 ] ], [ [ 120340, 120340 ], "mapped", [ 109 ] ], [ [ 120341, 120341 ], "mapped", [ 110 ] ], [ [ 120342, 120342 ], "mapped", [ 111 ] ], [ [ 120343, 120343 ], "mapped", [ 112 ] ], [ [ 120344, 120344 ], "mapped", [ 113 ] ], [ [ 120345, 120345 ], "mapped", [ 114 ] ], [ [ 120346, 120346 ], "mapped", [ 115 ] ], [ [ 120347, 120347 ], "mapped", [ 116 ] ], [ [ 120348, 120348 ], "mapped", [ 117 ] ], [ [ 120349, 120349 ], "mapped", [ 118 ] ], [ [ 120350, 120350 ], "mapped", [ 119 ] ], [ [ 120351, 120351 ], "mapped", [ 120 ] ], [ [ 120352, 120352 ], "mapped", [ 121 ] ], [ [ 120353, 120353 ], "mapped", [ 122 ] ], [ [ 120354, 120354 ], "mapped", [ 97 ] ], [ [ 120355, 120355 ], "mapped", [ 98 ] ], [ [ 120356, 120356 ], "mapped", [ 99 ] ], [ [ 120357, 120357 ], "mapped", [ 100 ] ], [ [ 120358, 120358 ], "mapped", [ 101 ] ], [ [ 120359, 120359 ], "mapped", [ 102 ] ], [ [ 120360, 120360 ], "mapped", [ 103 ] ], [ [ 120361, 120361 ], "mapped", [ 104 ] ], [ [ 120362, 120362 ], "mapped", [ 105 ] ], [ [ 120363, 120363 ], "mapped", [ 106 ] ], [ [ 120364, 120364 ], "mapped", [ 107 ] ], [ [ 120365, 120365 ], "mapped", [ 108 ] ], [ [ 120366, 120366 ], "mapped", [ 109 ] ], [ [ 120367, 120367 ], "mapped", [ 110 ] ], [ [ 120368, 120368 ], "mapped", [ 111 ] ], [ [ 120369, 120369 ], "mapped", [ 112 ] ], [ [ 120370, 120370 ], "mapped", [ 113 ] ], [ [ 120371, 120371 ], "mapped", [ 114 ] ], [ [ 120372, 120372 ], "mapped", [ 115 ] ], [ [ 120373, 120373 ], "mapped", [ 116 ] ], [ [ 120374, 120374 ], "mapped", [ 117 ] ], [ [ 120375, 120375 ], "mapped", [ 118 ] ], [ [ 120376, 120376 ], "mapped", [ 119 ] ], [ [ 120377, 120377 ], "mapped", [ 120 ] ], [ [ 120378, 120378 ], "mapped", [ 121 ] ], [ [ 120379, 120379 ], "mapped", [ 122 ] ], [ [ 120380, 120380 ], "mapped", [ 97 ] ], [ [ 120381, 120381 ], "mapped", [ 98 ] ], [ [ 120382, 120382 ], "mapped", [ 99 ] ], [ [ 120383, 120383 ], "mapped", [ 100 ] ], [ [ 120384, 120384 ], "mapped", [ 101 ] ], [ [ 120385, 120385 ], "mapped", [ 102 ] ], [ [ 120386, 120386 ], "mapped", [ 103 ] ], [ [ 120387, 120387 ], "mapped", [ 104 ] ], [ [ 120388, 120388 ], "mapped", [ 105 ] ], [ [ 120389, 120389 ], "mapped", [ 106 ] ], [ [ 120390, 120390 ], "mapped", [ 107 ] ], [ [ 120391, 120391 ], "mapped", [ 108 ] ], [ [ 120392, 120392 ], "mapped", [ 109 ] ], [ [ 120393, 120393 ], "mapped", [ 110 ] ], [ [ 120394, 120394 ], "mapped", [ 111 ] ], [ [ 120395, 120395 ], "mapped", [ 112 ] ], [ [ 120396, 120396 ], "mapped", [ 113 ] ], [ [ 120397, 120397 ], "mapped", [ 114 ] ], [ [ 120398, 120398 ], "mapped", [ 115 ] ], [ [ 120399, 120399 ], "mapped", [ 116 ] ], [ [ 120400, 120400 ], "mapped", [ 117 ] ], [ [ 120401, 120401 ], "mapped", [ 118 ] ], [ [ 120402, 120402 ], "mapped", [ 119 ] ], [ [ 120403, 120403 ], "mapped", [ 120 ] ], [ [ 120404, 120404 ], "mapped", [ 121 ] ], [ [ 120405, 120405 ], "mapped", [ 122 ] ], [ [ 120406, 120406 ], "mapped", [ 97 ] ], [ [ 120407, 120407 ], "mapped", [ 98 ] ], [ [ 120408, 120408 ], "mapped", [ 99 ] ], [ [ 120409, 120409 ], "mapped", [ 100 ] ], [ [ 120410, 120410 ], "mapped", [ 101 ] ], [ [ 120411, 120411 ], "mapped", [ 102 ] ], [ [ 120412, 120412 ], "mapped", [ 103 ] ], [ [ 120413, 120413 ], "mapped", [ 104 ] ], [ [ 120414, 120414 ], "mapped", [ 105 ] ], [ [ 120415, 120415 ], "mapped", [ 106 ] ], [ [ 120416, 120416 ], "mapped", [ 107 ] ], [ [ 120417, 120417 ], "mapped", [ 108 ] ], [ [ 120418, 120418 ], "mapped", [ 109 ] ], [ [ 120419, 120419 ], "mapped", [ 110 ] ], [ [ 120420, 120420 ], "mapped", [ 111 ] ], [ [ 120421, 120421 ], "mapped", [ 112 ] ], [ [ 120422, 120422 ], "mapped", [ 113 ] ], [ [ 120423, 120423 ], "mapped", [ 114 ] ], [ [ 120424, 120424 ], "mapped", [ 115 ] ], [ [ 120425, 120425 ], "mapped", [ 116 ] ], [ [ 120426, 120426 ], "mapped", [ 117 ] ], [ [ 120427, 120427 ], "mapped", [ 118 ] ], [ [ 120428, 120428 ], "mapped", [ 119 ] ], [ [ 120429, 120429 ], "mapped", [ 120 ] ], [ [ 120430, 120430 ], "mapped", [ 121 ] ], [ [ 120431, 120431 ], "mapped", [ 122 ] ], [ [ 120432, 120432 ], "mapped", [ 97 ] ], [ [ 120433, 120433 ], "mapped", [ 98 ] ], [ [ 120434, 120434 ], "mapped", [ 99 ] ], [ [ 120435, 120435 ], "mapped", [ 100 ] ], [ [ 120436, 120436 ], "mapped", [ 101 ] ], [ [ 120437, 120437 ], "mapped", [ 102 ] ], [ [ 120438, 120438 ], "mapped", [ 103 ] ], [ [ 120439, 120439 ], "mapped", [ 104 ] ], [ [ 120440, 120440 ], "mapped", [ 105 ] ], [ [ 120441, 120441 ], "mapped", [ 106 ] ], [ [ 120442, 120442 ], "mapped", [ 107 ] ], [ [ 120443, 120443 ], "mapped", [ 108 ] ], [ [ 120444, 120444 ], "mapped", [ 109 ] ], [ [ 120445, 120445 ], "mapped", [ 110 ] ], [ [ 120446, 120446 ], "mapped", [ 111 ] ], [ [ 120447, 120447 ], "mapped", [ 112 ] ], [ [ 120448, 120448 ], "mapped", [ 113 ] ], [ [ 120449, 120449 ], "mapped", [ 114 ] ], [ [ 120450, 120450 ], "mapped", [ 115 ] ], [ [ 120451, 120451 ], "mapped", [ 116 ] ], [ [ 120452, 120452 ], "mapped", [ 117 ] ], [ [ 120453, 120453 ], "mapped", [ 118 ] ], [ [ 120454, 120454 ], "mapped", [ 119 ] ], [ [ 120455, 120455 ], "mapped", [ 120 ] ], [ [ 120456, 120456 ], "mapped", [ 121 ] ], [ [ 120457, 120457 ], "mapped", [ 122 ] ], [ [ 120458, 120458 ], "mapped", [ 97 ] ], [ [ 120459, 120459 ], "mapped", [ 98 ] ], [ [ 120460, 120460 ], "mapped", [ 99 ] ], [ [ 120461, 120461 ], "mapped", [ 100 ] ], [ [ 120462, 120462 ], "mapped", [ 101 ] ], [ [ 120463, 120463 ], "mapped", [ 102 ] ], [ [ 120464, 120464 ], "mapped", [ 103 ] ], [ [ 120465, 120465 ], "mapped", [ 104 ] ], [ [ 120466, 120466 ], "mapped", [ 105 ] ], [ [ 120467, 120467 ], "mapped", [ 106 ] ], [ [ 120468, 120468 ], "mapped", [ 107 ] ], [ [ 120469, 120469 ], "mapped", [ 108 ] ], [ [ 120470, 120470 ], "mapped", [ 109 ] ], [ [ 120471, 120471 ], "mapped", [ 110 ] ], [ [ 120472, 120472 ], "mapped", [ 111 ] ], [ [ 120473, 120473 ], "mapped", [ 112 ] ], [ [ 120474, 120474 ], "mapped", [ 113 ] ], [ [ 120475, 120475 ], "mapped", [ 114 ] ], [ [ 120476, 120476 ], "mapped", [ 115 ] ], [ [ 120477, 120477 ], "mapped", [ 116 ] ], [ [ 120478, 120478 ], "mapped", [ 117 ] ], [ [ 120479, 120479 ], "mapped", [ 118 ] ], [ [ 120480, 120480 ], "mapped", [ 119 ] ], [ [ 120481, 120481 ], "mapped", [ 120 ] ], [ [ 120482, 120482 ], "mapped", [ 121 ] ], [ [ 120483, 120483 ], "mapped", [ 122 ] ], [ [ 120484, 120484 ], "mapped", [ 305 ] ], [ [ 120485, 120485 ], "mapped", [ 567 ] ], [ [ 120486, 120487 ], "disallowed" ], [ [ 120488, 120488 ], "mapped", [ 945 ] ], [ [ 120489, 120489 ], "mapped", [ 946 ] ], [ [ 120490, 120490 ], "mapped", [ 947 ] ], [ [ 120491, 120491 ], "mapped", [ 948 ] ], [ [ 120492, 120492 ], "mapped", [ 949 ] ], [ [ 120493, 120493 ], "mapped", [ 950 ] ], [ [ 120494, 120494 ], "mapped", [ 951 ] ], [ [ 120495, 120495 ], "mapped", [ 952 ] ], [ [ 120496, 120496 ], "mapped", [ 953 ] ], [ [ 120497, 120497 ], "mapped", [ 954 ] ], [ [ 120498, 120498 ], "mapped", [ 955 ] ], [ [ 120499, 120499 ], "mapped", [ 956 ] ], [ [ 120500, 120500 ], "mapped", [ 957 ] ], [ [ 120501, 120501 ], "mapped", [ 958 ] ], [ [ 120502, 120502 ], "mapped", [ 959 ] ], [ [ 120503, 120503 ], "mapped", [ 960 ] ], [ [ 120504, 120504 ], "mapped", [ 961 ] ], [ [ 120505, 120505 ], "mapped", [ 952 ] ], [ [ 120506, 120506 ], "mapped", [ 963 ] ], [ [ 120507, 120507 ], "mapped", [ 964 ] ], [ [ 120508, 120508 ], "mapped", [ 965 ] ], [ [ 120509, 120509 ], "mapped", [ 966 ] ], [ [ 120510, 120510 ], "mapped", [ 967 ] ], [ [ 120511, 120511 ], "mapped", [ 968 ] ], [ [ 120512, 120512 ], "mapped", [ 969 ] ], [ [ 120513, 120513 ], "mapped", [ 8711 ] ], [ [ 120514, 120514 ], "mapped", [ 945 ] ], [ [ 120515, 120515 ], "mapped", [ 946 ] ], [ [ 120516, 120516 ], "mapped", [ 947 ] ], [ [ 120517, 120517 ], "mapped", [ 948 ] ], [ [ 120518, 120518 ], "mapped", [ 949 ] ], [ [ 120519, 120519 ], "mapped", [ 950 ] ], [ [ 120520, 120520 ], "mapped", [ 951 ] ], [ [ 120521, 120521 ], "mapped", [ 952 ] ], [ [ 120522, 120522 ], "mapped", [ 953 ] ], [ [ 120523, 120523 ], "mapped", [ 954 ] ], [ [ 120524, 120524 ], "mapped", [ 955 ] ], [ [ 120525, 120525 ], "mapped", [ 956 ] ], [ [ 120526, 120526 ], "mapped", [ 957 ] ], [ [ 120527, 120527 ], "mapped", [ 958 ] ], [ [ 120528, 120528 ], "mapped", [ 959 ] ], [ [ 120529, 120529 ], "mapped", [ 960 ] ], [ [ 120530, 120530 ], "mapped", [ 961 ] ], [ [ 120531, 120532 ], "mapped", [ 963 ] ], [ [ 120533, 120533 ], "mapped", [ 964 ] ], [ [ 120534, 120534 ], "mapped", [ 965 ] ], [ [ 120535, 120535 ], "mapped", [ 966 ] ], [ [ 120536, 120536 ], "mapped", [ 967 ] ], [ [ 120537, 120537 ], "mapped", [ 968 ] ], [ [ 120538, 120538 ], "mapped", [ 969 ] ], [ [ 120539, 120539 ], "mapped", [ 8706 ] ], [ [ 120540, 120540 ], "mapped", [ 949 ] ], [ [ 120541, 120541 ], "mapped", [ 952 ] ], [ [ 120542, 120542 ], "mapped", [ 954 ] ], [ [ 120543, 120543 ], "mapped", [ 966 ] ], [ [ 120544, 120544 ], "mapped", [ 961 ] ], [ [ 120545, 120545 ], "mapped", [ 960 ] ], [ [ 120546, 120546 ], "mapped", [ 945 ] ], [ [ 120547, 120547 ], "mapped", [ 946 ] ], [ [ 120548, 120548 ], "mapped", [ 947 ] ], [ [ 120549, 120549 ], "mapped", [ 948 ] ], [ [ 120550, 120550 ], "mapped", [ 949 ] ], [ [ 120551, 120551 ], "mapped", [ 950 ] ], [ [ 120552, 120552 ], "mapped", [ 951 ] ], [ [ 120553, 120553 ], "mapped", [ 952 ] ], [ [ 120554, 120554 ], "mapped", [ 953 ] ], [ [ 120555, 120555 ], "mapped", [ 954 ] ], [ [ 120556, 120556 ], "mapped", [ 955 ] ], [ [ 120557, 120557 ], "mapped", [ 956 ] ], [ [ 120558, 120558 ], "mapped", [ 957 ] ], [ [ 120559, 120559 ], "mapped", [ 958 ] ], [ [ 120560, 120560 ], "mapped", [ 959 ] ], [ [ 120561, 120561 ], "mapped", [ 960 ] ], [ [ 120562, 120562 ], "mapped", [ 961 ] ], [ [ 120563, 120563 ], "mapped", [ 952 ] ], [ [ 120564, 120564 ], "mapped", [ 963 ] ], [ [ 120565, 120565 ], "mapped", [ 964 ] ], [ [ 120566, 120566 ], "mapped", [ 965 ] ], [ [ 120567, 120567 ], "mapped", [ 966 ] ], [ [ 120568, 120568 ], "mapped", [ 967 ] ], [ [ 120569, 120569 ], "mapped", [ 968 ] ], [ [ 120570, 120570 ], "mapped", [ 969 ] ], [ [ 120571, 120571 ], "mapped", [ 8711 ] ], [ [ 120572, 120572 ], "mapped", [ 945 ] ], [ [ 120573, 120573 ], "mapped", [ 946 ] ], [ [ 120574, 120574 ], "mapped", [ 947 ] ], [ [ 120575, 120575 ], "mapped", [ 948 ] ], [ [ 120576, 120576 ], "mapped", [ 949 ] ], [ [ 120577, 120577 ], "mapped", [ 950 ] ], [ [ 120578, 120578 ], "mapped", [ 951 ] ], [ [ 120579, 120579 ], "mapped", [ 952 ] ], [ [ 120580, 120580 ], "mapped", [ 953 ] ], [ [ 120581, 120581 ], "mapped", [ 954 ] ], [ [ 120582, 120582 ], "mapped", [ 955 ] ], [ [ 120583, 120583 ], "mapped", [ 956 ] ], [ [ 120584, 120584 ], "mapped", [ 957 ] ], [ [ 120585, 120585 ], "mapped", [ 958 ] ], [ [ 120586, 120586 ], "mapped", [ 959 ] ], [ [ 120587, 120587 ], "mapped", [ 960 ] ], [ [ 120588, 120588 ], "mapped", [ 961 ] ], [ [ 120589, 120590 ], "mapped", [ 963 ] ], [ [ 120591, 120591 ], "mapped", [ 964 ] ], [ [ 120592, 120592 ], "mapped", [ 965 ] ], [ [ 120593, 120593 ], "mapped", [ 966 ] ], [ [ 120594, 120594 ], "mapped", [ 967 ] ], [ [ 120595, 120595 ], "mapped", [ 968 ] ], [ [ 120596, 120596 ], "mapped", [ 969 ] ], [ [ 120597, 120597 ], "mapped", [ 8706 ] ], [ [ 120598, 120598 ], "mapped", [ 949 ] ], [ [ 120599, 120599 ], "mapped", [ 952 ] ], [ [ 120600, 120600 ], "mapped", [ 954 ] ], [ [ 120601, 120601 ], "mapped", [ 966 ] ], [ [ 120602, 120602 ], "mapped", [ 961 ] ], [ [ 120603, 120603 ], "mapped", [ 960 ] ], [ [ 120604, 120604 ], "mapped", [ 945 ] ], [ [ 120605, 120605 ], "mapped", [ 946 ] ], [ [ 120606, 120606 ], "mapped", [ 947 ] ], [ [ 120607, 120607 ], "mapped", [ 948 ] ], [ [ 120608, 120608 ], "mapped", [ 949 ] ], [ [ 120609, 120609 ], "mapped", [ 950 ] ], [ [ 120610, 120610 ], "mapped", [ 951 ] ], [ [ 120611, 120611 ], "mapped", [ 952 ] ], [ [ 120612, 120612 ], "mapped", [ 953 ] ], [ [ 120613, 120613 ], "mapped", [ 954 ] ], [ [ 120614, 120614 ], "mapped", [ 955 ] ], [ [ 120615, 120615 ], "mapped", [ 956 ] ], [ [ 120616, 120616 ], "mapped", [ 957 ] ], [ [ 120617, 120617 ], "mapped", [ 958 ] ], [ [ 120618, 120618 ], "mapped", [ 959 ] ], [ [ 120619, 120619 ], "mapped", [ 960 ] ], [ [ 120620, 120620 ], "mapped", [ 961 ] ], [ [ 120621, 120621 ], "mapped", [ 952 ] ], [ [ 120622, 120622 ], "mapped", [ 963 ] ], [ [ 120623, 120623 ], "mapped", [ 964 ] ], [ [ 120624, 120624 ], "mapped", [ 965 ] ], [ [ 120625, 120625 ], "mapped", [ 966 ] ], [ [ 120626, 120626 ], "mapped", [ 967 ] ], [ [ 120627, 120627 ], "mapped", [ 968 ] ], [ [ 120628, 120628 ], "mapped", [ 969 ] ], [ [ 120629, 120629 ], "mapped", [ 8711 ] ], [ [ 120630, 120630 ], "mapped", [ 945 ] ], [ [ 120631, 120631 ], "mapped", [ 946 ] ], [ [ 120632, 120632 ], "mapped", [ 947 ] ], [ [ 120633, 120633 ], "mapped", [ 948 ] ], [ [ 120634, 120634 ], "mapped", [ 949 ] ], [ [ 120635, 120635 ], "mapped", [ 950 ] ], [ [ 120636, 120636 ], "mapped", [ 951 ] ], [ [ 120637, 120637 ], "mapped", [ 952 ] ], [ [ 120638, 120638 ], "mapped", [ 953 ] ], [ [ 120639, 120639 ], "mapped", [ 954 ] ], [ [ 120640, 120640 ], "mapped", [ 955 ] ], [ [ 120641, 120641 ], "mapped", [ 956 ] ], [ [ 120642, 120642 ], "mapped", [ 957 ] ], [ [ 120643, 120643 ], "mapped", [ 958 ] ], [ [ 120644, 120644 ], "mapped", [ 959 ] ], [ [ 120645, 120645 ], "mapped", [ 960 ] ], [ [ 120646, 120646 ], "mapped", [ 961 ] ], [ [ 120647, 120648 ], "mapped", [ 963 ] ], [ [ 120649, 120649 ], "mapped", [ 964 ] ], [ [ 120650, 120650 ], "mapped", [ 965 ] ], [ [ 120651, 120651 ], "mapped", [ 966 ] ], [ [ 120652, 120652 ], "mapped", [ 967 ] ], [ [ 120653, 120653 ], "mapped", [ 968 ] ], [ [ 120654, 120654 ], "mapped", [ 969 ] ], [ [ 120655, 120655 ], "mapped", [ 8706 ] ], [ [ 120656, 120656 ], "mapped", [ 949 ] ], [ [ 120657, 120657 ], "mapped", [ 952 ] ], [ [ 120658, 120658 ], "mapped", [ 954 ] ], [ [ 120659, 120659 ], "mapped", [ 966 ] ], [ [ 120660, 120660 ], "mapped", [ 961 ] ], [ [ 120661, 120661 ], "mapped", [ 960 ] ], [ [ 120662, 120662 ], "mapped", [ 945 ] ], [ [ 120663, 120663 ], "mapped", [ 946 ] ], [ [ 120664, 120664 ], "mapped", [ 947 ] ], [ [ 120665, 120665 ], "mapped", [ 948 ] ], [ [ 120666, 120666 ], "mapped", [ 949 ] ], [ [ 120667, 120667 ], "mapped", [ 950 ] ], [ [ 120668, 120668 ], "mapped", [ 951 ] ], [ [ 120669, 120669 ], "mapped", [ 952 ] ], [ [ 120670, 120670 ], "mapped", [ 953 ] ], [ [ 120671, 120671 ], "mapped", [ 954 ] ], [ [ 120672, 120672 ], "mapped", [ 955 ] ], [ [ 120673, 120673 ], "mapped", [ 956 ] ], [ [ 120674, 120674 ], "mapped", [ 957 ] ], [ [ 120675, 120675 ], "mapped", [ 958 ] ], [ [ 120676, 120676 ], "mapped", [ 959 ] ], [ [ 120677, 120677 ], "mapped", [ 960 ] ], [ [ 120678, 120678 ], "mapped", [ 961 ] ], [ [ 120679, 120679 ], "mapped", [ 952 ] ], [ [ 120680, 120680 ], "mapped", [ 963 ] ], [ [ 120681, 120681 ], "mapped", [ 964 ] ], [ [ 120682, 120682 ], "mapped", [ 965 ] ], [ [ 120683, 120683 ], "mapped", [ 966 ] ], [ [ 120684, 120684 ], "mapped", [ 967 ] ], [ [ 120685, 120685 ], "mapped", [ 968 ] ], [ [ 120686, 120686 ], "mapped", [ 969 ] ], [ [ 120687, 120687 ], "mapped", [ 8711 ] ], [ [ 120688, 120688 ], "mapped", [ 945 ] ], [ [ 120689, 120689 ], "mapped", [ 946 ] ], [ [ 120690, 120690 ], "mapped", [ 947 ] ], [ [ 120691, 120691 ], "mapped", [ 948 ] ], [ [ 120692, 120692 ], "mapped", [ 949 ] ], [ [ 120693, 120693 ], "mapped", [ 950 ] ], [ [ 120694, 120694 ], "mapped", [ 951 ] ], [ [ 120695, 120695 ], "mapped", [ 952 ] ], [ [ 120696, 120696 ], "mapped", [ 953 ] ], [ [ 120697, 120697 ], "mapped", [ 954 ] ], [ [ 120698, 120698 ], "mapped", [ 955 ] ], [ [ 120699, 120699 ], "mapped", [ 956 ] ], [ [ 120700, 120700 ], "mapped", [ 957 ] ], [ [ 120701, 120701 ], "mapped", [ 958 ] ], [ [ 120702, 120702 ], "mapped", [ 959 ] ], [ [ 120703, 120703 ], "mapped", [ 960 ] ], [ [ 120704, 120704 ], "mapped", [ 961 ] ], [ [ 120705, 120706 ], "mapped", [ 963 ] ], [ [ 120707, 120707 ], "mapped", [ 964 ] ], [ [ 120708, 120708 ], "mapped", [ 965 ] ], [ [ 120709, 120709 ], "mapped", [ 966 ] ], [ [ 120710, 120710 ], "mapped", [ 967 ] ], [ [ 120711, 120711 ], "mapped", [ 968 ] ], [ [ 120712, 120712 ], "mapped", [ 969 ] ], [ [ 120713, 120713 ], "mapped", [ 8706 ] ], [ [ 120714, 120714 ], "mapped", [ 949 ] ], [ [ 120715, 120715 ], "mapped", [ 952 ] ], [ [ 120716, 120716 ], "mapped", [ 954 ] ], [ [ 120717, 120717 ], "mapped", [ 966 ] ], [ [ 120718, 120718 ], "mapped", [ 961 ] ], [ [ 120719, 120719 ], "mapped", [ 960 ] ], [ [ 120720, 120720 ], "mapped", [ 945 ] ], [ [ 120721, 120721 ], "mapped", [ 946 ] ], [ [ 120722, 120722 ], "mapped", [ 947 ] ], [ [ 120723, 120723 ], "mapped", [ 948 ] ], [ [ 120724, 120724 ], "mapped", [ 949 ] ], [ [ 120725, 120725 ], "mapped", [ 950 ] ], [ [ 120726, 120726 ], "mapped", [ 951 ] ], [ [ 120727, 120727 ], "mapped", [ 952 ] ], [ [ 120728, 120728 ], "mapped", [ 953 ] ], [ [ 120729, 120729 ], "mapped", [ 954 ] ], [ [ 120730, 120730 ], "mapped", [ 955 ] ], [ [ 120731, 120731 ], "mapped", [ 956 ] ], [ [ 120732, 120732 ], "mapped", [ 957 ] ], [ [ 120733, 120733 ], "mapped", [ 958 ] ], [ [ 120734, 120734 ], "mapped", [ 959 ] ], [ [ 120735, 120735 ], "mapped", [ 960 ] ], [ [ 120736, 120736 ], "mapped", [ 961 ] ], [ [ 120737, 120737 ], "mapped", [ 952 ] ], [ [ 120738, 120738 ], "mapped", [ 963 ] ], [ [ 120739, 120739 ], "mapped", [ 964 ] ], [ [ 120740, 120740 ], "mapped", [ 965 ] ], [ [ 120741, 120741 ], "mapped", [ 966 ] ], [ [ 120742, 120742 ], "mapped", [ 967 ] ], [ [ 120743, 120743 ], "mapped", [ 968 ] ], [ [ 120744, 120744 ], "mapped", [ 969 ] ], [ [ 120745, 120745 ], "mapped", [ 8711 ] ], [ [ 120746, 120746 ], "mapped", [ 945 ] ], [ [ 120747, 120747 ], "mapped", [ 946 ] ], [ [ 120748, 120748 ], "mapped", [ 947 ] ], [ [ 120749, 120749 ], "mapped", [ 948 ] ], [ [ 120750, 120750 ], "mapped", [ 949 ] ], [ [ 120751, 120751 ], "mapped", [ 950 ] ], [ [ 120752, 120752 ], "mapped", [ 951 ] ], [ [ 120753, 120753 ], "mapped", [ 952 ] ], [ [ 120754, 120754 ], "mapped", [ 953 ] ], [ [ 120755, 120755 ], "mapped", [ 954 ] ], [ [ 120756, 120756 ], "mapped", [ 955 ] ], [ [ 120757, 120757 ], "mapped", [ 956 ] ], [ [ 120758, 120758 ], "mapped", [ 957 ] ], [ [ 120759, 120759 ], "mapped", [ 958 ] ], [ [ 120760, 120760 ], "mapped", [ 959 ] ], [ [ 120761, 120761 ], "mapped", [ 960 ] ], [ [ 120762, 120762 ], "mapped", [ 961 ] ], [ [ 120763, 120764 ], "mapped", [ 963 ] ], [ [ 120765, 120765 ], "mapped", [ 964 ] ], [ [ 120766, 120766 ], "mapped", [ 965 ] ], [ [ 120767, 120767 ], "mapped", [ 966 ] ], [ [ 120768, 120768 ], "mapped", [ 967 ] ], [ [ 120769, 120769 ], "mapped", [ 968 ] ], [ [ 120770, 120770 ], "mapped", [ 969 ] ], [ [ 120771, 120771 ], "mapped", [ 8706 ] ], [ [ 120772, 120772 ], "mapped", [ 949 ] ], [ [ 120773, 120773 ], "mapped", [ 952 ] ], [ [ 120774, 120774 ], "mapped", [ 954 ] ], [ [ 120775, 120775 ], "mapped", [ 966 ] ], [ [ 120776, 120776 ], "mapped", [ 961 ] ], [ [ 120777, 120777 ], "mapped", [ 960 ] ], [ [ 120778, 120779 ], "mapped", [ 989 ] ], [ [ 120780, 120781 ], "disallowed" ], [ [ 120782, 120782 ], "mapped", [ 48 ] ], [ [ 120783, 120783 ], "mapped", [ 49 ] ], [ [ 120784, 120784 ], "mapped", [ 50 ] ], [ [ 120785, 120785 ], "mapped", [ 51 ] ], [ [ 120786, 120786 ], "mapped", [ 52 ] ], [ [ 120787, 120787 ], "mapped", [ 53 ] ], [ [ 120788, 120788 ], "mapped", [ 54 ] ], [ [ 120789, 120789 ], "mapped", [ 55 ] ], [ [ 120790, 120790 ], "mapped", [ 56 ] ], [ [ 120791, 120791 ], "mapped", [ 57 ] ], [ [ 120792, 120792 ], "mapped", [ 48 ] ], [ [ 120793, 120793 ], "mapped", [ 49 ] ], [ [ 120794, 120794 ], "mapped", [ 50 ] ], [ [ 120795, 120795 ], "mapped", [ 51 ] ], [ [ 120796, 120796 ], "mapped", [ 52 ] ], [ [ 120797, 120797 ], "mapped", [ 53 ] ], [ [ 120798, 120798 ], "mapped", [ 54 ] ], [ [ 120799, 120799 ], "mapped", [ 55 ] ], [ [ 120800, 120800 ], "mapped", [ 56 ] ], [ [ 120801, 120801 ], "mapped", [ 57 ] ], [ [ 120802, 120802 ], "mapped", [ 48 ] ], [ [ 120803, 120803 ], "mapped", [ 49 ] ], [ [ 120804, 120804 ], "mapped", [ 50 ] ], [ [ 120805, 120805 ], "mapped", [ 51 ] ], [ [ 120806, 120806 ], "mapped", [ 52 ] ], [ [ 120807, 120807 ], "mapped", [ 53 ] ], [ [ 120808, 120808 ], "mapped", [ 54 ] ], [ [ 120809, 120809 ], "mapped", [ 55 ] ], [ [ 120810, 120810 ], "mapped", [ 56 ] ], [ [ 120811, 120811 ], "mapped", [ 57 ] ], [ [ 120812, 120812 ], "mapped", [ 48 ] ], [ [ 120813, 120813 ], "mapped", [ 49 ] ], [ [ 120814, 120814 ], "mapped", [ 50 ] ], [ [ 120815, 120815 ], "mapped", [ 51 ] ], [ [ 120816, 120816 ], "mapped", [ 52 ] ], [ [ 120817, 120817 ], "mapped", [ 53 ] ], [ [ 120818, 120818 ], "mapped", [ 54 ] ], [ [ 120819, 120819 ], "mapped", [ 55 ] ], [ [ 120820, 120820 ], "mapped", [ 56 ] ], [ [ 120821, 120821 ], "mapped", [ 57 ] ], [ [ 120822, 120822 ], "mapped", [ 48 ] ], [ [ 120823, 120823 ], "mapped", [ 49 ] ], [ [ 120824, 120824 ], "mapped", [ 50 ] ], [ [ 120825, 120825 ], "mapped", [ 51 ] ], [ [ 120826, 120826 ], "mapped", [ 52 ] ], [ [ 120827, 120827 ], "mapped", [ 53 ] ], [ [ 120828, 120828 ], "mapped", [ 54 ] ], [ [ 120829, 120829 ], "mapped", [ 55 ] ], [ [ 120830, 120830 ], "mapped", [ 56 ] ], [ [ 120831, 120831 ], "mapped", [ 57 ] ], [ [ 120832, 121343 ], "valid", [], "NV8" ], [ [ 121344, 121398 ], "valid" ], [ [ 121399, 121402 ], "valid", [], "NV8" ], [ [ 121403, 121452 ], "valid" ], [ [ 121453, 121460 ], "valid", [], "NV8" ], [ [ 121461, 121461 ], "valid" ], [ [ 121462, 121475 ], "valid", [], "NV8" ], [ [ 121476, 121476 ], "valid" ], [ [ 121477, 121483 ], "valid", [], "NV8" ], [ [ 121484, 121498 ], "disallowed" ], [ [ 121499, 121503 ], "valid" ], [ [ 121504, 121504 ], "disallowed" ], [ [ 121505, 121519 ], "valid" ], [ [ 121520, 124927 ], "disallowed" ], [ [ 124928, 125124 ], "valid" ], [ [ 125125, 125126 ], "disallowed" ], [ [ 125127, 125135 ], "valid", [], "NV8" ], [ [ 125136, 125142 ], "valid" ], [ [ 125143, 126463 ], "disallowed" ], [ [ 126464, 126464 ], "mapped", [ 1575 ] ], [ [ 126465, 126465 ], "mapped", [ 1576 ] ], [ [ 126466, 126466 ], "mapped", [ 1580 ] ], [ [ 126467, 126467 ], "mapped", [ 1583 ] ], [ [ 126468, 126468 ], "disallowed" ], [ [ 126469, 126469 ], "mapped", [ 1608 ] ], [ [ 126470, 126470 ], "mapped", [ 1586 ] ], [ [ 126471, 126471 ], "mapped", [ 1581 ] ], [ [ 126472, 126472 ], "mapped", [ 1591 ] ], [ [ 126473, 126473 ], "mapped", [ 1610 ] ], [ [ 126474, 126474 ], "mapped", [ 1603 ] ], [ [ 126475, 126475 ], "mapped", [ 1604 ] ], [ [ 126476, 126476 ], "mapped", [ 1605 ] ], [ [ 126477, 126477 ], "mapped", [ 1606 ] ], [ [ 126478, 126478 ], "mapped", [ 1587 ] ], [ [ 126479, 126479 ], "mapped", [ 1593 ] ], [ [ 126480, 126480 ], "mapped", [ 1601 ] ], [ [ 126481, 126481 ], "mapped", [ 1589 ] ], [ [ 126482, 126482 ], "mapped", [ 1602 ] ], [ [ 126483, 126483 ], "mapped", [ 1585 ] ], [ [ 126484, 126484 ], "mapped", [ 1588 ] ], [ [ 126485, 126485 ], "mapped", [ 1578 ] ], [ [ 126486, 126486 ], "mapped", [ 1579 ] ], [ [ 126487, 126487 ], "mapped", [ 1582 ] ], [ [ 126488, 126488 ], "mapped", [ 1584 ] ], [ [ 126489, 126489 ], "mapped", [ 1590 ] ], [ [ 126490, 126490 ], "mapped", [ 1592 ] ], [ [ 126491, 126491 ], "mapped", [ 1594 ] ], [ [ 126492, 126492 ], "mapped", [ 1646 ] ], [ [ 126493, 126493 ], "mapped", [ 1722 ] ], [ [ 126494, 126494 ], "mapped", [ 1697 ] ], [ [ 126495, 126495 ], "mapped", [ 1647 ] ], [ [ 126496, 126496 ], "disallowed" ], [ [ 126497, 126497 ], "mapped", [ 1576 ] ], [ [ 126498, 126498 ], "mapped", [ 1580 ] ], [ [ 126499, 126499 ], "disallowed" ], [ [ 126500, 126500 ], "mapped", [ 1607 ] ], [ [ 126501, 126502 ], "disallowed" ], [ [ 126503, 126503 ], "mapped", [ 1581 ] ], [ [ 126504, 126504 ], "disallowed" ], [ [ 126505, 126505 ], "mapped", [ 1610 ] ], [ [ 126506, 126506 ], "mapped", [ 1603 ] ], [ [ 126507, 126507 ], "mapped", [ 1604 ] ], [ [ 126508, 126508 ], "mapped", [ 1605 ] ], [ [ 126509, 126509 ], "mapped", [ 1606 ] ], [ [ 126510, 126510 ], "mapped", [ 1587 ] ], [ [ 126511, 126511 ], "mapped", [ 1593 ] ], [ [ 126512, 126512 ], "mapped", [ 1601 ] ], [ [ 126513, 126513 ], "mapped", [ 1589 ] ], [ [ 126514, 126514 ], "mapped", [ 1602 ] ], [ [ 126515, 126515 ], "disallowed" ], [ [ 126516, 126516 ], "mapped", [ 1588 ] ], [ [ 126517, 126517 ], "mapped", [ 1578 ] ], [ [ 126518, 126518 ], "mapped", [ 1579 ] ], [ [ 126519, 126519 ], "mapped", [ 1582 ] ], [ [ 126520, 126520 ], "disallowed" ], [ [ 126521, 126521 ], "mapped", [ 1590 ] ], [ [ 126522, 126522 ], "disallowed" ], [ [ 126523, 126523 ], "mapped", [ 1594 ] ], [ [ 126524, 126529 ], "disallowed" ], [ [ 126530, 126530 ], "mapped", [ 1580 ] ], [ [ 126531, 126534 ], "disallowed" ], [ [ 126535, 126535 ], "mapped", [ 1581 ] ], [ [ 126536, 126536 ], "disallowed" ], [ [ 126537, 126537 ], "mapped", [ 1610 ] ], [ [ 126538, 126538 ], "disallowed" ], [ [ 126539, 126539 ], "mapped", [ 1604 ] ], [ [ 126540, 126540 ], "disallowed" ], [ [ 126541, 126541 ], "mapped", [ 1606 ] ], [ [ 126542, 126542 ], "mapped", [ 1587 ] ], [ [ 126543, 126543 ], "mapped", [ 1593 ] ], [ [ 126544, 126544 ], "disallowed" ], [ [ 126545, 126545 ], "mapped", [ 1589 ] ], [ [ 126546, 126546 ], "mapped", [ 1602 ] ], [ [ 126547, 126547 ], "disallowed" ], [ [ 126548, 126548 ], "mapped", [ 1588 ] ], [ [ 126549, 126550 ], "disallowed" ], [ [ 126551, 126551 ], "mapped", [ 1582 ] ], [ [ 126552, 126552 ], "disallowed" ], [ [ 126553, 126553 ], "mapped", [ 1590 ] ], [ [ 126554, 126554 ], "disallowed" ], [ [ 126555, 126555 ], "mapped", [ 1594 ] ], [ [ 126556, 126556 ], "disallowed" ], [ [ 126557, 126557 ], "mapped", [ 1722 ] ], [ [ 126558, 126558 ], "disallowed" ], [ [ 126559, 126559 ], "mapped", [ 1647 ] ], [ [ 126560, 126560 ], "disallowed" ], [ [ 126561, 126561 ], "mapped", [ 1576 ] ], [ [ 126562, 126562 ], "mapped", [ 1580 ] ], [ [ 126563, 126563 ], "disallowed" ], [ [ 126564, 126564 ], "mapped", [ 1607 ] ], [ [ 126565, 126566 ], "disallowed" ], [ [ 126567, 126567 ], "mapped", [ 1581 ] ], [ [ 126568, 126568 ], "mapped", [ 1591 ] ], [ [ 126569, 126569 ], "mapped", [ 1610 ] ], [ [ 126570, 126570 ], "mapped", [ 1603 ] ], [ [ 126571, 126571 ], "disallowed" ], [ [ 126572, 126572 ], "mapped", [ 1605 ] ], [ [ 126573, 126573 ], "mapped", [ 1606 ] ], [ [ 126574, 126574 ], "mapped", [ 1587 ] ], [ [ 126575, 126575 ], "mapped", [ 1593 ] ], [ [ 126576, 126576 ], "mapped", [ 1601 ] ], [ [ 126577, 126577 ], "mapped", [ 1589 ] ], [ [ 126578, 126578 ], "mapped", [ 1602 ] ], [ [ 126579, 126579 ], "disallowed" ], [ [ 126580, 126580 ], "mapped", [ 1588 ] ], [ [ 126581, 126581 ], "mapped", [ 1578 ] ], [ [ 126582, 126582 ], "mapped", [ 1579 ] ], [ [ 126583, 126583 ], "mapped", [ 1582 ] ], [ [ 126584, 126584 ], "disallowed" ], [ [ 126585, 126585 ], "mapped", [ 1590 ] ], [ [ 126586, 126586 ], "mapped", [ 1592 ] ], [ [ 126587, 126587 ], "mapped", [ 1594 ] ], [ [ 126588, 126588 ], "mapped", [ 1646 ] ], [ [ 126589, 126589 ], "disallowed" ], [ [ 126590, 126590 ], "mapped", [ 1697 ] ], [ [ 126591, 126591 ], "disallowed" ], [ [ 126592, 126592 ], "mapped", [ 1575 ] ], [ [ 126593, 126593 ], "mapped", [ 1576 ] ], [ [ 126594, 126594 ], "mapped", [ 1580 ] ], [ [ 126595, 126595 ], "mapped", [ 1583 ] ], [ [ 126596, 126596 ], "mapped", [ 1607 ] ], [ [ 126597, 126597 ], "mapped", [ 1608 ] ], [ [ 126598, 126598 ], "mapped", [ 1586 ] ], [ [ 126599, 126599 ], "mapped", [ 1581 ] ], [ [ 126600, 126600 ], "mapped", [ 1591 ] ], [ [ 126601, 126601 ], "mapped", [ 1610 ] ], [ [ 126602, 126602 ], "disallowed" ], [ [ 126603, 126603 ], "mapped", [ 1604 ] ], [ [ 126604, 126604 ], "mapped", [ 1605 ] ], [ [ 126605, 126605 ], "mapped", [ 1606 ] ], [ [ 126606, 126606 ], "mapped", [ 1587 ] ], [ [ 126607, 126607 ], "mapped", [ 1593 ] ], [ [ 126608, 126608 ], "mapped", [ 1601 ] ], [ [ 126609, 126609 ], "mapped", [ 1589 ] ], [ [ 126610, 126610 ], "mapped", [ 1602 ] ], [ [ 126611, 126611 ], "mapped", [ 1585 ] ], [ [ 126612, 126612 ], "mapped", [ 1588 ] ], [ [ 126613, 126613 ], "mapped", [ 1578 ] ], [ [ 126614, 126614 ], "mapped", [ 1579 ] ], [ [ 126615, 126615 ], "mapped", [ 1582 ] ], [ [ 126616, 126616 ], "mapped", [ 1584 ] ], [ [ 126617, 126617 ], "mapped", [ 1590 ] ], [ [ 126618, 126618 ], "mapped", [ 1592 ] ], [ [ 126619, 126619 ], "mapped", [ 1594 ] ], [ [ 126620, 126624 ], "disallowed" ], [ [ 126625, 126625 ], "mapped", [ 1576 ] ], [ [ 126626, 126626 ], "mapped", [ 1580 ] ], [ [ 126627, 126627 ], "mapped", [ 1583 ] ], [ [ 126628, 126628 ], "disallowed" ], [ [ 126629, 126629 ], "mapped", [ 1608 ] ], [ [ 126630, 126630 ], "mapped", [ 1586 ] ], [ [ 126631, 126631 ], "mapped", [ 1581 ] ], [ [ 126632, 126632 ], "mapped", [ 1591 ] ], [ [ 126633, 126633 ], "mapped", [ 1610 ] ], [ [ 126634, 126634 ], "disallowed" ], [ [ 126635, 126635 ], "mapped", [ 1604 ] ], [ [ 126636, 126636 ], "mapped", [ 1605 ] ], [ [ 126637, 126637 ], "mapped", [ 1606 ] ], [ [ 126638, 126638 ], "mapped", [ 1587 ] ], [ [ 126639, 126639 ], "mapped", [ 1593 ] ], [ [ 126640, 126640 ], "mapped", [ 1601 ] ], [ [ 126641, 126641 ], "mapped", [ 1589 ] ], [ [ 126642, 126642 ], "mapped", [ 1602 ] ], [ [ 126643, 126643 ], "mapped", [ 1585 ] ], [ [ 126644, 126644 ], "mapped", [ 1588 ] ], [ [ 126645, 126645 ], "mapped", [ 1578 ] ], [ [ 126646, 126646 ], "mapped", [ 1579 ] ], [ [ 126647, 126647 ], "mapped", [ 1582 ] ], [ [ 126648, 126648 ], "mapped", [ 1584 ] ], [ [ 126649, 126649 ], "mapped", [ 1590 ] ], [ [ 126650, 126650 ], "mapped", [ 1592 ] ], [ [ 126651, 126651 ], "mapped", [ 1594 ] ], [ [ 126652, 126703 ], "disallowed" ], [ [ 126704, 126705 ], "valid", [], "NV8" ], [ [ 126706, 126975 ], "disallowed" ], [ [ 126976, 127019 ], "valid", [], "NV8" ], [ [ 127020, 127023 ], "disallowed" ], [ [ 127024, 127123 ], "valid", [], "NV8" ], [ [ 127124, 127135 ], "disallowed" ], [ [ 127136, 127150 ], "valid", [], "NV8" ], [ [ 127151, 127152 ], "disallowed" ], [ [ 127153, 127166 ], "valid", [], "NV8" ], [ [ 127167, 127167 ], "valid", [], "NV8" ], [ [ 127168, 127168 ], "disallowed" ], [ [ 127169, 127183 ], "valid", [], "NV8" ], [ [ 127184, 127184 ], "disallowed" ], [ [ 127185, 127199 ], "valid", [], "NV8" ], [ [ 127200, 127221 ], "valid", [], "NV8" ], [ [ 127222, 127231 ], "disallowed" ], [ [ 127232, 127232 ], "disallowed" ], [ [ 127233, 127233 ], "disallowed_STD3_mapped", [ 48, 44 ] ], [ [ 127234, 127234 ], "disallowed_STD3_mapped", [ 49, 44 ] ], [ [ 127235, 127235 ], "disallowed_STD3_mapped", [ 50, 44 ] ], [ [ 127236, 127236 ], "disallowed_STD3_mapped", [ 51, 44 ] ], [ [ 127237, 127237 ], "disallowed_STD3_mapped", [ 52, 44 ] ], [ [ 127238, 127238 ], "disallowed_STD3_mapped", [ 53, 44 ] ], [ [ 127239, 127239 ], "disallowed_STD3_mapped", [ 54, 44 ] ], [ [ 127240, 127240 ], "disallowed_STD3_mapped", [ 55, 44 ] ], [ [ 127241, 127241 ], "disallowed_STD3_mapped", [ 56, 44 ] ], [ [ 127242, 127242 ], "disallowed_STD3_mapped", [ 57, 44 ] ], [ [ 127243, 127244 ], "valid", [], "NV8" ], [ [ 127245, 127247 ], "disallowed" ], [ [ 127248, 127248 ], "disallowed_STD3_mapped", [ 40, 97, 41 ] ], [ [ 127249, 127249 ], "disallowed_STD3_mapped", [ 40, 98, 41 ] ], [ [ 127250, 127250 ], "disallowed_STD3_mapped", [ 40, 99, 41 ] ], [ [ 127251, 127251 ], "disallowed_STD3_mapped", [ 40, 100, 41 ] ], [ [ 127252, 127252 ], "disallowed_STD3_mapped", [ 40, 101, 41 ] ], [ [ 127253, 127253 ], "disallowed_STD3_mapped", [ 40, 102, 41 ] ], [ [ 127254, 127254 ], "disallowed_STD3_mapped", [ 40, 103, 41 ] ], [ [ 127255, 127255 ], "disallowed_STD3_mapped", [ 40, 104, 41 ] ], [ [ 127256, 127256 ], "disallowed_STD3_mapped", [ 40, 105, 41 ] ], [ [ 127257, 127257 ], "disallowed_STD3_mapped", [ 40, 106, 41 ] ], [ [ 127258, 127258 ], "disallowed_STD3_mapped", [ 40, 107, 41 ] ], [ [ 127259, 127259 ], "disallowed_STD3_mapped", [ 40, 108, 41 ] ], [ [ 127260, 127260 ], "disallowed_STD3_mapped", [ 40, 109, 41 ] ], [ [ 127261, 127261 ], "disallowed_STD3_mapped", [ 40, 110, 41 ] ], [ [ 127262, 127262 ], "disallowed_STD3_mapped", [ 40, 111, 41 ] ], [ [ 127263, 127263 ], "disallowed_STD3_mapped", [ 40, 112, 41 ] ], [ [ 127264, 127264 ], "disallowed_STD3_mapped", [ 40, 113, 41 ] ], [ [ 127265, 127265 ], "disallowed_STD3_mapped", [ 40, 114, 41 ] ], [ [ 127266, 127266 ], "disallowed_STD3_mapped", [ 40, 115, 41 ] ], [ [ 127267, 127267 ], "disallowed_STD3_mapped", [ 40, 116, 41 ] ], [ [ 127268, 127268 ], "disallowed_STD3_mapped", [ 40, 117, 41 ] ], [ [ 127269, 127269 ], "disallowed_STD3_mapped", [ 40, 118, 41 ] ], [ [ 127270, 127270 ], "disallowed_STD3_mapped", [ 40, 119, 41 ] ], [ [ 127271, 127271 ], "disallowed_STD3_mapped", [ 40, 120, 41 ] ], [ [ 127272, 127272 ], "disallowed_STD3_mapped", [ 40, 121, 41 ] ], [ [ 127273, 127273 ], "disallowed_STD3_mapped", [ 40, 122, 41 ] ], [ [ 127274, 127274 ], "mapped", [ 12308, 115, 12309 ] ], [ [ 127275, 127275 ], "mapped", [ 99 ] ], [ [ 127276, 127276 ], "mapped", [ 114 ] ], [ [ 127277, 127277 ], "mapped", [ 99, 100 ] ], [ [ 127278, 127278 ], "mapped", [ 119, 122 ] ], [ [ 127279, 127279 ], "disallowed" ], [ [ 127280, 127280 ], "mapped", [ 97 ] ], [ [ 127281, 127281 ], "mapped", [ 98 ] ], [ [ 127282, 127282 ], "mapped", [ 99 ] ], [ [ 127283, 127283 ], "mapped", [ 100 ] ], [ [ 127284, 127284 ], "mapped", [ 101 ] ], [ [ 127285, 127285 ], "mapped", [ 102 ] ], [ [ 127286, 127286 ], "mapped", [ 103 ] ], [ [ 127287, 127287 ], "mapped", [ 104 ] ], [ [ 127288, 127288 ], "mapped", [ 105 ] ], [ [ 127289, 127289 ], "mapped", [ 106 ] ], [ [ 127290, 127290 ], "mapped", [ 107 ] ], [ [ 127291, 127291 ], "mapped", [ 108 ] ], [ [ 127292, 127292 ], "mapped", [ 109 ] ], [ [ 127293, 127293 ], "mapped", [ 110 ] ], [ [ 127294, 127294 ], "mapped", [ 111 ] ], [ [ 127295, 127295 ], "mapped", [ 112 ] ], [ [ 127296, 127296 ], "mapped", [ 113 ] ], [ [ 127297, 127297 ], "mapped", [ 114 ] ], [ [ 127298, 127298 ], "mapped", [ 115 ] ], [ [ 127299, 127299 ], "mapped", [ 116 ] ], [ [ 127300, 127300 ], "mapped", [ 117 ] ], [ [ 127301, 127301 ], "mapped", [ 118 ] ], [ [ 127302, 127302 ], "mapped", [ 119 ] ], [ [ 127303, 127303 ], "mapped", [ 120 ] ], [ [ 127304, 127304 ], "mapped", [ 121 ] ], [ [ 127305, 127305 ], "mapped", [ 122 ] ], [ [ 127306, 127306 ], "mapped", [ 104, 118 ] ], [ [ 127307, 127307 ], "mapped", [ 109, 118 ] ], [ [ 127308, 127308 ], "mapped", [ 115, 100 ] ], [ [ 127309, 127309 ], "mapped", [ 115, 115 ] ], [ [ 127310, 127310 ], "mapped", [ 112, 112, 118 ] ], [ [ 127311, 127311 ], "mapped", [ 119, 99 ] ], [ [ 127312, 127318 ], "valid", [], "NV8" ], [ [ 127319, 127319 ], "valid", [], "NV8" ], [ [ 127320, 127326 ], "valid", [], "NV8" ], [ [ 127327, 127327 ], "valid", [], "NV8" ], [ [ 127328, 127337 ], "valid", [], "NV8" ], [ [ 127338, 127338 ], "mapped", [ 109, 99 ] ], [ [ 127339, 127339 ], "mapped", [ 109, 100 ] ], [ [ 127340, 127343 ], "disallowed" ], [ [ 127344, 127352 ], "valid", [], "NV8" ], [ [ 127353, 127353 ], "valid", [], "NV8" ], [ [ 127354, 127354 ], "valid", [], "NV8" ], [ [ 127355, 127356 ], "valid", [], "NV8" ], [ [ 127357, 127358 ], "valid", [], "NV8" ], [ [ 127359, 127359 ], "valid", [], "NV8" ], [ [ 127360, 127369 ], "valid", [], "NV8" ], [ [ 127370, 127373 ], "valid", [], "NV8" ], [ [ 127374, 127375 ], "valid", [], "NV8" ], [ [ 127376, 127376 ], "mapped", [ 100, 106 ] ], [ [ 127377, 127386 ], "valid", [], "NV8" ], [ [ 127387, 127461 ], "disallowed" ], [ [ 127462, 127487 ], "valid", [], "NV8" ], [ [ 127488, 127488 ], "mapped", [ 12411, 12363 ] ], [ [ 127489, 127489 ], "mapped", [ 12467, 12467 ] ], [ [ 127490, 127490 ], "mapped", [ 12469 ] ], [ [ 127491, 127503 ], "disallowed" ], [ [ 127504, 127504 ], "mapped", [ 25163 ] ], [ [ 127505, 127505 ], "mapped", [ 23383 ] ], [ [ 127506, 127506 ], "mapped", [ 21452 ] ], [ [ 127507, 127507 ], "mapped", [ 12487 ] ], [ [ 127508, 127508 ], "mapped", [ 20108 ] ], [ [ 127509, 127509 ], "mapped", [ 22810 ] ], [ [ 127510, 127510 ], "mapped", [ 35299 ] ], [ [ 127511, 127511 ], "mapped", [ 22825 ] ], [ [ 127512, 127512 ], "mapped", [ 20132 ] ], [ [ 127513, 127513 ], "mapped", [ 26144 ] ], [ [ 127514, 127514 ], "mapped", [ 28961 ] ], [ [ 127515, 127515 ], "mapped", [ 26009 ] ], [ [ 127516, 127516 ], "mapped", [ 21069 ] ], [ [ 127517, 127517 ], "mapped", [ 24460 ] ], [ [ 127518, 127518 ], "mapped", [ 20877 ] ], [ [ 127519, 127519 ], "mapped", [ 26032 ] ], [ [ 127520, 127520 ], "mapped", [ 21021 ] ], [ [ 127521, 127521 ], "mapped", [ 32066 ] ], [ [ 127522, 127522 ], "mapped", [ 29983 ] ], [ [ 127523, 127523 ], "mapped", [ 36009 ] ], [ [ 127524, 127524 ], "mapped", [ 22768 ] ], [ [ 127525, 127525 ], "mapped", [ 21561 ] ], [ [ 127526, 127526 ], "mapped", [ 28436 ] ], [ [ 127527, 127527 ], "mapped", [ 25237 ] ], [ [ 127528, 127528 ], "mapped", [ 25429 ] ], [ [ 127529, 127529 ], "mapped", [ 19968 ] ], [ [ 127530, 127530 ], "mapped", [ 19977 ] ], [ [ 127531, 127531 ], "mapped", [ 36938 ] ], [ [ 127532, 127532 ], "mapped", [ 24038 ] ], [ [ 127533, 127533 ], "mapped", [ 20013 ] ], [ [ 127534, 127534 ], "mapped", [ 21491 ] ], [ [ 127535, 127535 ], "mapped", [ 25351 ] ], [ [ 127536, 127536 ], "mapped", [ 36208 ] ], [ [ 127537, 127537 ], "mapped", [ 25171 ] ], [ [ 127538, 127538 ], "mapped", [ 31105 ] ], [ [ 127539, 127539 ], "mapped", [ 31354 ] ], [ [ 127540, 127540 ], "mapped", [ 21512 ] ], [ [ 127541, 127541 ], "mapped", [ 28288 ] ], [ [ 127542, 127542 ], "mapped", [ 26377 ] ], [ [ 127543, 127543 ], "mapped", [ 26376 ] ], [ [ 127544, 127544 ], "mapped", [ 30003 ] ], [ [ 127545, 127545 ], "mapped", [ 21106 ] ], [ [ 127546, 127546 ], "mapped", [ 21942 ] ], [ [ 127547, 127551 ], "disallowed" ], [ [ 127552, 127552 ], "mapped", [ 12308, 26412, 12309 ] ], [ [ 127553, 127553 ], "mapped", [ 12308, 19977, 12309 ] ], [ [ 127554, 127554 ], "mapped", [ 12308, 20108, 12309 ] ], [ [ 127555, 127555 ], "mapped", [ 12308, 23433, 12309 ] ], [ [ 127556, 127556 ], "mapped", [ 12308, 28857, 12309 ] ], [ [ 127557, 127557 ], "mapped", [ 12308, 25171, 12309 ] ], [ [ 127558, 127558 ], "mapped", [ 12308, 30423, 12309 ] ], [ [ 127559, 127559 ], "mapped", [ 12308, 21213, 12309 ] ], [ [ 127560, 127560 ], "mapped", [ 12308, 25943, 12309 ] ], [ [ 127561, 127567 ], "disallowed" ], [ [ 127568, 127568 ], "mapped", [ 24471 ] ], [ [ 127569, 127569 ], "mapped", [ 21487 ] ], [ [ 127570, 127743 ], "disallowed" ], [ [ 127744, 127776 ], "valid", [], "NV8" ], [ [ 127777, 127788 ], "valid", [], "NV8" ], [ [ 127789, 127791 ], "valid", [], "NV8" ], [ [ 127792, 127797 ], "valid", [], "NV8" ], [ [ 127798, 127798 ], "valid", [], "NV8" ], [ [ 127799, 127868 ], "valid", [], "NV8" ], [ [ 127869, 127869 ], "valid", [], "NV8" ], [ [ 127870, 127871 ], "valid", [], "NV8" ], [ [ 127872, 127891 ], "valid", [], "NV8" ], [ [ 127892, 127903 ], "valid", [], "NV8" ], [ [ 127904, 127940 ], "valid", [], "NV8" ], [ [ 127941, 127941 ], "valid", [], "NV8" ], [ [ 127942, 127946 ], "valid", [], "NV8" ], [ [ 127947, 127950 ], "valid", [], "NV8" ], [ [ 127951, 127955 ], "valid", [], "NV8" ], [ [ 127956, 127967 ], "valid", [], "NV8" ], [ [ 127968, 127984 ], "valid", [], "NV8" ], [ [ 127985, 127991 ], "valid", [], "NV8" ], [ [ 127992, 127999 ], "valid", [], "NV8" ], [ [ 128e3, 128062 ], "valid", [], "NV8" ], [ [ 128063, 128063 ], "valid", [], "NV8" ], [ [ 128064, 128064 ], "valid", [], "NV8" ], [ [ 128065, 128065 ], "valid", [], "NV8" ], [ [ 128066, 128247 ], "valid", [], "NV8" ], [ [ 128248, 128248 ], "valid", [], "NV8" ], [ [ 128249, 128252 ], "valid", [], "NV8" ], [ [ 128253, 128254 ], "valid", [], "NV8" ], [ [ 128255, 128255 ], "valid", [], "NV8" ], [ [ 128256, 128317 ], "valid", [], "NV8" ], [ [ 128318, 128319 ], "valid", [], "NV8" ], [ [ 128320, 128323 ], "valid", [], "NV8" ], [ [ 128324, 128330 ], "valid", [], "NV8" ], [ [ 128331, 128335 ], "valid", [], "NV8" ], [ [ 128336, 128359 ], "valid", [], "NV8" ], [ [ 128360, 128377 ], "valid", [], "NV8" ], [ [ 128378, 128378 ], "disallowed" ], [ [ 128379, 128419 ], "valid", [], "NV8" ], [ [ 128420, 128420 ], "disallowed" ], [ [ 128421, 128506 ], "valid", [], "NV8" ], [ [ 128507, 128511 ], "valid", [], "NV8" ], [ [ 128512, 128512 ], "valid", [], "NV8" ], [ [ 128513, 128528 ], "valid", [], "NV8" ], [ [ 128529, 128529 ], "valid", [], "NV8" ], [ [ 128530, 128532 ], "valid", [], "NV8" ], [ [ 128533, 128533 ], "valid", [], "NV8" ], [ [ 128534, 128534 ], "valid", [], "NV8" ], [ [ 128535, 128535 ], "valid", [], "NV8" ], [ [ 128536, 128536 ], "valid", [], "NV8" ], [ [ 128537, 128537 ], "valid", [], "NV8" ], [ [ 128538, 128538 ], "valid", [], "NV8" ], [ [ 128539, 128539 ], "valid", [], "NV8" ], [ [ 128540, 128542 ], "valid", [], "NV8" ], [ [ 128543, 128543 ], "valid", [], "NV8" ], [ [ 128544, 128549 ], "valid", [], "NV8" ], [ [ 128550, 128551 ], "valid", [], "NV8" ], [ [ 128552, 128555 ], "valid", [], "NV8" ], [ [ 128556, 128556 ], "valid", [], "NV8" ], [ [ 128557, 128557 ], "valid", [], "NV8" ], [ [ 128558, 128559 ], "valid", [], "NV8" ], [ [ 128560, 128563 ], "valid", [], "NV8" ], [ [ 128564, 128564 ], "valid", [], "NV8" ], [ [ 128565, 128576 ], "valid", [], "NV8" ], [ [ 128577, 128578 ], "valid", [], "NV8" ], [ [ 128579, 128580 ], "valid", [], "NV8" ], [ [ 128581, 128591 ], "valid", [], "NV8" ], [ [ 128592, 128639 ], "valid", [], "NV8" ], [ [ 128640, 128709 ], "valid", [], "NV8" ], [ [ 128710, 128719 ], "valid", [], "NV8" ], [ [ 128720, 128720 ], "valid", [], "NV8" ], [ [ 128721, 128735 ], "disallowed" ], [ [ 128736, 128748 ], "valid", [], "NV8" ], [ [ 128749, 128751 ], "disallowed" ], [ [ 128752, 128755 ], "valid", [], "NV8" ], [ [ 128756, 128767 ], "disallowed" ], [ [ 128768, 128883 ], "valid", [], "NV8" ], [ [ 128884, 128895 ], "disallowed" ], [ [ 128896, 128980 ], "valid", [], "NV8" ], [ [ 128981, 129023 ], "disallowed" ], [ [ 129024, 129035 ], "valid", [], "NV8" ], [ [ 129036, 129039 ], "disallowed" ], [ [ 129040, 129095 ], "valid", [], "NV8" ], [ [ 129096, 129103 ], "disallowed" ], [ [ 129104, 129113 ], "valid", [], "NV8" ], [ [ 129114, 129119 ], "disallowed" ], [ [ 129120, 129159 ], "valid", [], "NV8" ], [ [ 129160, 129167 ], "disallowed" ], [ [ 129168, 129197 ], "valid", [], "NV8" ], [ [ 129198, 129295 ], "disallowed" ], [ [ 129296, 129304 ], "valid", [], "NV8" ], [ [ 129305, 129407 ], "disallowed" ], [ [ 129408, 129412 ], "valid", [], "NV8" ], [ [ 129413, 129471 ], "disallowed" ], [ [ 129472, 129472 ], "valid", [], "NV8" ], [ [ 129473, 131069 ], "disallowed" ], [ [ 131070, 131071 ], "disallowed" ], [ [ 131072, 173782 ], "valid" ], [ [ 173783, 173823 ], "disallowed" ], [ [ 173824, 177972 ], "valid" ], [ [ 177973, 177983 ], "disallowed" ], [ [ 177984, 178205 ], "valid" ], [ [ 178206, 178207 ], "disallowed" ], [ [ 178208, 183969 ], "valid" ], [ [ 183970, 194559 ], "disallowed" ], [ [ 194560, 194560 ], "mapped", [ 20029 ] ], [ [ 194561, 194561 ], "mapped", [ 20024 ] ], [ [ 194562, 194562 ], "mapped", [ 20033 ] ], [ [ 194563, 194563 ], "mapped", [ 131362 ] ], [ [ 194564, 194564 ], "mapped", [ 20320 ] ], [ [ 194565, 194565 ], "mapped", [ 20398 ] ], [ [ 194566, 194566 ], "mapped", [ 20411 ] ], [ [ 194567, 194567 ], "mapped", [ 20482 ] ], [ [ 194568, 194568 ], "mapped", [ 20602 ] ], [ [ 194569, 194569 ], "mapped", [ 20633 ] ], [ [ 194570, 194570 ], "mapped", [ 20711 ] ], [ [ 194571, 194571 ], "mapped", [ 20687 ] ], [ [ 194572, 194572 ], "mapped", [ 13470 ] ], [ [ 194573, 194573 ], "mapped", [ 132666 ] ], [ [ 194574, 194574 ], "mapped", [ 20813 ] ], [ [ 194575, 194575 ], "mapped", [ 20820 ] ], [ [ 194576, 194576 ], "mapped", [ 20836 ] ], [ [ 194577, 194577 ], "mapped", [ 20855 ] ], [ [ 194578, 194578 ], "mapped", [ 132380 ] ], [ [ 194579, 194579 ], "mapped", [ 13497 ] ], [ [ 194580, 194580 ], "mapped", [ 20839 ] ], [ [ 194581, 194581 ], "mapped", [ 20877 ] ], [ [ 194582, 194582 ], "mapped", [ 132427 ] ], [ [ 194583, 194583 ], "mapped", [ 20887 ] ], [ [ 194584, 194584 ], "mapped", [ 20900 ] ], [ [ 194585, 194585 ], "mapped", [ 20172 ] ], [ [ 194586, 194586 ], "mapped", [ 20908 ] ], [ [ 194587, 194587 ], "mapped", [ 20917 ] ], [ [ 194588, 194588 ], "mapped", [ 168415 ] ], [ [ 194589, 194589 ], "mapped", [ 20981 ] ], [ [ 194590, 194590 ], "mapped", [ 20995 ] ], [ [ 194591, 194591 ], "mapped", [ 13535 ] ], [ [ 194592, 194592 ], "mapped", [ 21051 ] ], [ [ 194593, 194593 ], "mapped", [ 21062 ] ], [ [ 194594, 194594 ], "mapped", [ 21106 ] ], [ [ 194595, 194595 ], "mapped", [ 21111 ] ], [ [ 194596, 194596 ], "mapped", [ 13589 ] ], [ [ 194597, 194597 ], "mapped", [ 21191 ] ], [ [ 194598, 194598 ], "mapped", [ 21193 ] ], [ [ 194599, 194599 ], "mapped", [ 21220 ] ], [ [ 194600, 194600 ], "mapped", [ 21242 ] ], [ [ 194601, 194601 ], "mapped", [ 21253 ] ], [ [ 194602, 194602 ], "mapped", [ 21254 ] ], [ [ 194603, 194603 ], "mapped", [ 21271 ] ], [ [ 194604, 194604 ], "mapped", [ 21321 ] ], [ [ 194605, 194605 ], "mapped", [ 21329 ] ], [ [ 194606, 194606 ], "mapped", [ 21338 ] ], [ [ 194607, 194607 ], "mapped", [ 21363 ] ], [ [ 194608, 194608 ], "mapped", [ 21373 ] ], [ [ 194609, 194611 ], "mapped", [ 21375 ] ], [ [ 194612, 194612 ], "mapped", [ 133676 ] ], [ [ 194613, 194613 ], "mapped", [ 28784 ] ], [ [ 194614, 194614 ], "mapped", [ 21450 ] ], [ [ 194615, 194615 ], "mapped", [ 21471 ] ], [ [ 194616, 194616 ], "mapped", [ 133987 ] ], [ [ 194617, 194617 ], "mapped", [ 21483 ] ], [ [ 194618, 194618 ], "mapped", [ 21489 ] ], [ [ 194619, 194619 ], "mapped", [ 21510 ] ], [ [ 194620, 194620 ], "mapped", [ 21662 ] ], [ [ 194621, 194621 ], "mapped", [ 21560 ] ], [ [ 194622, 194622 ], "mapped", [ 21576 ] ], [ [ 194623, 194623 ], "mapped", [ 21608 ] ], [ [ 194624, 194624 ], "mapped", [ 21666 ] ], [ [ 194625, 194625 ], "mapped", [ 21750 ] ], [ [ 194626, 194626 ], "mapped", [ 21776 ] ], [ [ 194627, 194627 ], "mapped", [ 21843 ] ], [ [ 194628, 194628 ], "mapped", [ 21859 ] ], [ [ 194629, 194630 ], "mapped", [ 21892 ] ], [ [ 194631, 194631 ], "mapped", [ 21913 ] ], [ [ 194632, 194632 ], "mapped", [ 21931 ] ], [ [ 194633, 194633 ], "mapped", [ 21939 ] ], [ [ 194634, 194634 ], "mapped", [ 21954 ] ], [ [ 194635, 194635 ], "mapped", [ 22294 ] ], [ [ 194636, 194636 ], "mapped", [ 22022 ] ], [ [ 194637, 194637 ], "mapped", [ 22295 ] ], [ [ 194638, 194638 ], "mapped", [ 22097 ] ], [ [ 194639, 194639 ], "mapped", [ 22132 ] ], [ [ 194640, 194640 ], "mapped", [ 20999 ] ], [ [ 194641, 194641 ], "mapped", [ 22766 ] ], [ [ 194642, 194642 ], "mapped", [ 22478 ] ], [ [ 194643, 194643 ], "mapped", [ 22516 ] ], [ [ 194644, 194644 ], "mapped", [ 22541 ] ], [ [ 194645, 194645 ], "mapped", [ 22411 ] ], [ [ 194646, 194646 ], "mapped", [ 22578 ] ], [ [ 194647, 194647 ], "mapped", [ 22577 ] ], [ [ 194648, 194648 ], "mapped", [ 22700 ] ], [ [ 194649, 194649 ], "mapped", [ 136420 ] ], [ [ 194650, 194650 ], "mapped", [ 22770 ] ], [ [ 194651, 194651 ], "mapped", [ 22775 ] ], [ [ 194652, 194652 ], "mapped", [ 22790 ] ], [ [ 194653, 194653 ], "mapped", [ 22810 ] ], [ [ 194654, 194654 ], "mapped", [ 22818 ] ], [ [ 194655, 194655 ], "mapped", [ 22882 ] ], [ [ 194656, 194656 ], "mapped", [ 136872 ] ], [ [ 194657, 194657 ], "mapped", [ 136938 ] ], [ [ 194658, 194658 ], "mapped", [ 23020 ] ], [ [ 194659, 194659 ], "mapped", [ 23067 ] ], [ [ 194660, 194660 ], "mapped", [ 23079 ] ], [ [ 194661, 194661 ], "mapped", [ 23e3 ] ], [ [ 194662, 194662 ], "mapped", [ 23142 ] ], [ [ 194663, 194663 ], "mapped", [ 14062 ] ], [ [ 194664, 194664 ], "disallowed" ], [ [ 194665, 194665 ], "mapped", [ 23304 ] ], [ [ 194666, 194667 ], "mapped", [ 23358 ] ], [ [ 194668, 194668 ], "mapped", [ 137672 ] ], [ [ 194669, 194669 ], "mapped", [ 23491 ] ], [ [ 194670, 194670 ], "mapped", [ 23512 ] ], [ [ 194671, 194671 ], "mapped", [ 23527 ] ], [ [ 194672, 194672 ], "mapped", [ 23539 ] ], [ [ 194673, 194673 ], "mapped", [ 138008 ] ], [ [ 194674, 194674 ], "mapped", [ 23551 ] ], [ [ 194675, 194675 ], "mapped", [ 23558 ] ], [ [ 194676, 194676 ], "disallowed" ], [ [ 194677, 194677 ], "mapped", [ 23586 ] ], [ [ 194678, 194678 ], "mapped", [ 14209 ] ], [ [ 194679, 194679 ], "mapped", [ 23648 ] ], [ [ 194680, 194680 ], "mapped", [ 23662 ] ], [ [ 194681, 194681 ], "mapped", [ 23744 ] ], [ [ 194682, 194682 ], "mapped", [ 23693 ] ], [ [ 194683, 194683 ], "mapped", [ 138724 ] ], [ [ 194684, 194684 ], "mapped", [ 23875 ] ], [ [ 194685, 194685 ], "mapped", [ 138726 ] ], [ [ 194686, 194686 ], "mapped", [ 23918 ] ], [ [ 194687, 194687 ], "mapped", [ 23915 ] ], [ [ 194688, 194688 ], "mapped", [ 23932 ] ], [ [ 194689, 194689 ], "mapped", [ 24033 ] ], [ [ 194690, 194690 ], "mapped", [ 24034 ] ], [ [ 194691, 194691 ], "mapped", [ 14383 ] ], [ [ 194692, 194692 ], "mapped", [ 24061 ] ], [ [ 194693, 194693 ], "mapped", [ 24104 ] ], [ [ 194694, 194694 ], "mapped", [ 24125 ] ], [ [ 194695, 194695 ], "mapped", [ 24169 ] ], [ [ 194696, 194696 ], "mapped", [ 14434 ] ], [ [ 194697, 194697 ], "mapped", [ 139651 ] ], [ [ 194698, 194698 ], "mapped", [ 14460 ] ], [ [ 194699, 194699 ], "mapped", [ 24240 ] ], [ [ 194700, 194700 ], "mapped", [ 24243 ] ], [ [ 194701, 194701 ], "mapped", [ 24246 ] ], [ [ 194702, 194702 ], "mapped", [ 24266 ] ], [ [ 194703, 194703 ], "mapped", [ 172946 ] ], [ [ 194704, 194704 ], "mapped", [ 24318 ] ], [ [ 194705, 194706 ], "mapped", [ 140081 ] ], [ [ 194707, 194707 ], "mapped", [ 33281 ] ], [ [ 194708, 194709 ], "mapped", [ 24354 ] ], [ [ 194710, 194710 ], "mapped", [ 14535 ] ], [ [ 194711, 194711 ], "mapped", [ 144056 ] ], [ [ 194712, 194712 ], "mapped", [ 156122 ] ], [ [ 194713, 194713 ], "mapped", [ 24418 ] ], [ [ 194714, 194714 ], "mapped", [ 24427 ] ], [ [ 194715, 194715 ], "mapped", [ 14563 ] ], [ [ 194716, 194716 ], "mapped", [ 24474 ] ], [ [ 194717, 194717 ], "mapped", [ 24525 ] ], [ [ 194718, 194718 ], "mapped", [ 24535 ] ], [ [ 194719, 194719 ], "mapped", [ 24569 ] ], [ [ 194720, 194720 ], "mapped", [ 24705 ] ], [ [ 194721, 194721 ], "mapped", [ 14650 ] ], [ [ 194722, 194722 ], "mapped", [ 14620 ] ], [ [ 194723, 194723 ], "mapped", [ 24724 ] ], [ [ 194724, 194724 ], "mapped", [ 141012 ] ], [ [ 194725, 194725 ], "mapped", [ 24775 ] ], [ [ 194726, 194726 ], "mapped", [ 24904 ] ], [ [ 194727, 194727 ], "mapped", [ 24908 ] ], [ [ 194728, 194728 ], "mapped", [ 24910 ] ], [ [ 194729, 194729 ], "mapped", [ 24908 ] ], [ [ 194730, 194730 ], "mapped", [ 24954 ] ], [ [ 194731, 194731 ], "mapped", [ 24974 ] ], [ [ 194732, 194732 ], "mapped", [ 25010 ] ], [ [ 194733, 194733 ], "mapped", [ 24996 ] ], [ [ 194734, 194734 ], "mapped", [ 25007 ] ], [ [ 194735, 194735 ], "mapped", [ 25054 ] ], [ [ 194736, 194736 ], "mapped", [ 25074 ] ], [ [ 194737, 194737 ], "mapped", [ 25078 ] ], [ [ 194738, 194738 ], "mapped", [ 25104 ] ], [ [ 194739, 194739 ], "mapped", [ 25115 ] ], [ [ 194740, 194740 ], "mapped", [ 25181 ] ], [ [ 194741, 194741 ], "mapped", [ 25265 ] ], [ [ 194742, 194742 ], "mapped", [ 25300 ] ], [ [ 194743, 194743 ], "mapped", [ 25424 ] ], [ [ 194744, 194744 ], "mapped", [ 142092 ] ], [ [ 194745, 194745 ], "mapped", [ 25405 ] ], [ [ 194746, 194746 ], "mapped", [ 25340 ] ], [ [ 194747, 194747 ], "mapped", [ 25448 ] ], [ [ 194748, 194748 ], "mapped", [ 25475 ] ], [ [ 194749, 194749 ], "mapped", [ 25572 ] ], [ [ 194750, 194750 ], "mapped", [ 142321 ] ], [ [ 194751, 194751 ], "mapped", [ 25634 ] ], [ [ 194752, 194752 ], "mapped", [ 25541 ] ], [ [ 194753, 194753 ], "mapped", [ 25513 ] ], [ [ 194754, 194754 ], "mapped", [ 14894 ] ], [ [ 194755, 194755 ], "mapped", [ 25705 ] ], [ [ 194756, 194756 ], "mapped", [ 25726 ] ], [ [ 194757, 194757 ], "mapped", [ 25757 ] ], [ [ 194758, 194758 ], "mapped", [ 25719 ] ], [ [ 194759, 194759 ], "mapped", [ 14956 ] ], [ [ 194760, 194760 ], "mapped", [ 25935 ] ], [ [ 194761, 194761 ], "mapped", [ 25964 ] ], [ [ 194762, 194762 ], "mapped", [ 143370 ] ], [ [ 194763, 194763 ], "mapped", [ 26083 ] ], [ [ 194764, 194764 ], "mapped", [ 26360 ] ], [ [ 194765, 194765 ], "mapped", [ 26185 ] ], [ [ 194766, 194766 ], "mapped", [ 15129 ] ], [ [ 194767, 194767 ], "mapped", [ 26257 ] ], [ [ 194768, 194768 ], "mapped", [ 15112 ] ], [ [ 194769, 194769 ], "mapped", [ 15076 ] ], [ [ 194770, 194770 ], "mapped", [ 20882 ] ], [ [ 194771, 194771 ], "mapped", [ 20885 ] ], [ [ 194772, 194772 ], "mapped", [ 26368 ] ], [ [ 194773, 194773 ], "mapped", [ 26268 ] ], [ [ 194774, 194774 ], "mapped", [ 32941 ] ], [ [ 194775, 194775 ], "mapped", [ 17369 ] ], [ [ 194776, 194776 ], "mapped", [ 26391 ] ], [ [ 194777, 194777 ], "mapped", [ 26395 ] ], [ [ 194778, 194778 ], "mapped", [ 26401 ] ], [ [ 194779, 194779 ], "mapped", [ 26462 ] ], [ [ 194780, 194780 ], "mapped", [ 26451 ] ], [ [ 194781, 194781 ], "mapped", [ 144323 ] ], [ [ 194782, 194782 ], "mapped", [ 15177 ] ], [ [ 194783, 194783 ], "mapped", [ 26618 ] ], [ [ 194784, 194784 ], "mapped", [ 26501 ] ], [ [ 194785, 194785 ], "mapped", [ 26706 ] ], [ [ 194786, 194786 ], "mapped", [ 26757 ] ], [ [ 194787, 194787 ], "mapped", [ 144493 ] ], [ [ 194788, 194788 ], "mapped", [ 26766 ] ], [ [ 194789, 194789 ], "mapped", [ 26655 ] ], [ [ 194790, 194790 ], "mapped", [ 26900 ] ], [ [ 194791, 194791 ], "mapped", [ 15261 ] ], [ [ 194792, 194792 ], "mapped", [ 26946 ] ], [ [ 194793, 194793 ], "mapped", [ 27043 ] ], [ [ 194794, 194794 ], "mapped", [ 27114 ] ], [ [ 194795, 194795 ], "mapped", [ 27304 ] ], [ [ 194796, 194796 ], "mapped", [ 145059 ] ], [ [ 194797, 194797 ], "mapped", [ 27355 ] ], [ [ 194798, 194798 ], "mapped", [ 15384 ] ], [ [ 194799, 194799 ], "mapped", [ 27425 ] ], [ [ 194800, 194800 ], "mapped", [ 145575 ] ], [ [ 194801, 194801 ], "mapped", [ 27476 ] ], [ [ 194802, 194802 ], "mapped", [ 15438 ] ], [ [ 194803, 194803 ], "mapped", [ 27506 ] ], [ [ 194804, 194804 ], "mapped", [ 27551 ] ], [ [ 194805, 194805 ], "mapped", [ 27578 ] ], [ [ 194806, 194806 ], "mapped", [ 27579 ] ], [ [ 194807, 194807 ], "mapped", [ 146061 ] ], [ [ 194808, 194808 ], "mapped", [ 138507 ] ], [ [ 194809, 194809 ], "mapped", [ 146170 ] ], [ [ 194810, 194810 ], "mapped", [ 27726 ] ], [ [ 194811, 194811 ], "mapped", [ 146620 ] ], [ [ 194812, 194812 ], "mapped", [ 27839 ] ], [ [ 194813, 194813 ], "mapped", [ 27853 ] ], [ [ 194814, 194814 ], "mapped", [ 27751 ] ], [ [ 194815, 194815 ], "mapped", [ 27926 ] ], [ [ 194816, 194816 ], "mapped", [ 27966 ] ], [ [ 194817, 194817 ], "mapped", [ 28023 ] ], [ [ 194818, 194818 ], "mapped", [ 27969 ] ], [ [ 194819, 194819 ], "mapped", [ 28009 ] ], [ [ 194820, 194820 ], "mapped", [ 28024 ] ], [ [ 194821, 194821 ], "mapped", [ 28037 ] ], [ [ 194822, 194822 ], "mapped", [ 146718 ] ], [ [ 194823, 194823 ], "mapped", [ 27956 ] ], [ [ 194824, 194824 ], "mapped", [ 28207 ] ], [ [ 194825, 194825 ], "mapped", [ 28270 ] ], [ [ 194826, 194826 ], "mapped", [ 15667 ] ], [ [ 194827, 194827 ], "mapped", [ 28363 ] ], [ [ 194828, 194828 ], "mapped", [ 28359 ] ], [ [ 194829, 194829 ], "mapped", [ 147153 ] ], [ [ 194830, 194830 ], "mapped", [ 28153 ] ], [ [ 194831, 194831 ], "mapped", [ 28526 ] ], [ [ 194832, 194832 ], "mapped", [ 147294 ] ], [ [ 194833, 194833 ], "mapped", [ 147342 ] ], [ [ 194834, 194834 ], "mapped", [ 28614 ] ], [ [ 194835, 194835 ], "mapped", [ 28729 ] ], [ [ 194836, 194836 ], "mapped", [ 28702 ] ], [ [ 194837, 194837 ], "mapped", [ 28699 ] ], [ [ 194838, 194838 ], "mapped", [ 15766 ] ], [ [ 194839, 194839 ], "mapped", [ 28746 ] ], [ [ 194840, 194840 ], "mapped", [ 28797 ] ], [ [ 194841, 194841 ], "mapped", [ 28791 ] ], [ [ 194842, 194842 ], "mapped", [ 28845 ] ], [ [ 194843, 194843 ], "mapped", [ 132389 ] ], [ [ 194844, 194844 ], "mapped", [ 28997 ] ], [ [ 194845, 194845 ], "mapped", [ 148067 ] ], [ [ 194846, 194846 ], "mapped", [ 29084 ] ], [ [ 194847, 194847 ], "disallowed" ], [ [ 194848, 194848 ], "mapped", [ 29224 ] ], [ [ 194849, 194849 ], "mapped", [ 29237 ] ], [ [ 194850, 194850 ], "mapped", [ 29264 ] ], [ [ 194851, 194851 ], "mapped", [ 149e3 ] ], [ [ 194852, 194852 ], "mapped", [ 29312 ] ], [ [ 194853, 194853 ], "mapped", [ 29333 ] ], [ [ 194854, 194854 ], "mapped", [ 149301 ] ], [ [ 194855, 194855 ], "mapped", [ 149524 ] ], [ [ 194856, 194856 ], "mapped", [ 29562 ] ], [ [ 194857, 194857 ], "mapped", [ 29579 ] ], [ [ 194858, 194858 ], "mapped", [ 16044 ] ], [ [ 194859, 194859 ], "mapped", [ 29605 ] ], [ [ 194860, 194861 ], "mapped", [ 16056 ] ], [ [ 194862, 194862 ], "mapped", [ 29767 ] ], [ [ 194863, 194863 ], "mapped", [ 29788 ] ], [ [ 194864, 194864 ], "mapped", [ 29809 ] ], [ [ 194865, 194865 ], "mapped", [ 29829 ] ], [ [ 194866, 194866 ], "mapped", [ 29898 ] ], [ [ 194867, 194867 ], "mapped", [ 16155 ] ], [ [ 194868, 194868 ], "mapped", [ 29988 ] ], [ [ 194869, 194869 ], "mapped", [ 150582 ] ], [ [ 194870, 194870 ], "mapped", [ 30014 ] ], [ [ 194871, 194871 ], "mapped", [ 150674 ] ], [ [ 194872, 194872 ], "mapped", [ 30064 ] ], [ [ 194873, 194873 ], "mapped", [ 139679 ] ], [ [ 194874, 194874 ], "mapped", [ 30224 ] ], [ [ 194875, 194875 ], "mapped", [ 151457 ] ], [ [ 194876, 194876 ], "mapped", [ 151480 ] ], [ [ 194877, 194877 ], "mapped", [ 151620 ] ], [ [ 194878, 194878 ], "mapped", [ 16380 ] ], [ [ 194879, 194879 ], "mapped", [ 16392 ] ], [ [ 194880, 194880 ], "mapped", [ 30452 ] ], [ [ 194881, 194881 ], "mapped", [ 151795 ] ], [ [ 194882, 194882 ], "mapped", [ 151794 ] ], [ [ 194883, 194883 ], "mapped", [ 151833 ] ], [ [ 194884, 194884 ], "mapped", [ 151859 ] ], [ [ 194885, 194885 ], "mapped", [ 30494 ] ], [ [ 194886, 194887 ], "mapped", [ 30495 ] ], [ [ 194888, 194888 ], "mapped", [ 30538 ] ], [ [ 194889, 194889 ], "mapped", [ 16441 ] ], [ [ 194890, 194890 ], "mapped", [ 30603 ] ], [ [ 194891, 194891 ], "mapped", [ 16454 ] ], [ [ 194892, 194892 ], "mapped", [ 16534 ] ], [ [ 194893, 194893 ], "mapped", [ 152605 ] ], [ [ 194894, 194894 ], "mapped", [ 30798 ] ], [ [ 194895, 194895 ], "mapped", [ 30860 ] ], [ [ 194896, 194896 ], "mapped", [ 30924 ] ], [ [ 194897, 194897 ], "mapped", [ 16611 ] ], [ [ 194898, 194898 ], "mapped", [ 153126 ] ], [ [ 194899, 194899 ], "mapped", [ 31062 ] ], [ [ 194900, 194900 ], "mapped", [ 153242 ] ], [ [ 194901, 194901 ], "mapped", [ 153285 ] ], [ [ 194902, 194902 ], "mapped", [ 31119 ] ], [ [ 194903, 194903 ], "mapped", [ 31211 ] ], [ [ 194904, 194904 ], "mapped", [ 16687 ] ], [ [ 194905, 194905 ], "mapped", [ 31296 ] ], [ [ 194906, 194906 ], "mapped", [ 31306 ] ], [ [ 194907, 194907 ], "mapped", [ 31311 ] ], [ [ 194908, 194908 ], "mapped", [ 153980 ] ], [ [ 194909, 194910 ], "mapped", [ 154279 ] ], [ [ 194911, 194911 ], "disallowed" ], [ [ 194912, 194912 ], "mapped", [ 16898 ] ], [ [ 194913, 194913 ], "mapped", [ 154539 ] ], [ [ 194914, 194914 ], "mapped", [ 31686 ] ], [ [ 194915, 194915 ], "mapped", [ 31689 ] ], [ [ 194916, 194916 ], "mapped", [ 16935 ] ], [ [ 194917, 194917 ], "mapped", [ 154752 ] ], [ [ 194918, 194918 ], "mapped", [ 31954 ] ], [ [ 194919, 194919 ], "mapped", [ 17056 ] ], [ [ 194920, 194920 ], "mapped", [ 31976 ] ], [ [ 194921, 194921 ], "mapped", [ 31971 ] ], [ [ 194922, 194922 ], "mapped", [ 32e3 ] ], [ [ 194923, 194923 ], "mapped", [ 155526 ] ], [ [ 194924, 194924 ], "mapped", [ 32099 ] ], [ [ 194925, 194925 ], "mapped", [ 17153 ] ], [ [ 194926, 194926 ], "mapped", [ 32199 ] ], [ [ 194927, 194927 ], "mapped", [ 32258 ] ], [ [ 194928, 194928 ], "mapped", [ 32325 ] ], [ [ 194929, 194929 ], "mapped", [ 17204 ] ], [ [ 194930, 194930 ], "mapped", [ 156200 ] ], [ [ 194931, 194931 ], "mapped", [ 156231 ] ], [ [ 194932, 194932 ], "mapped", [ 17241 ] ], [ [ 194933, 194933 ], "mapped", [ 156377 ] ], [ [ 194934, 194934 ], "mapped", [ 32634 ] ], [ [ 194935, 194935 ], "mapped", [ 156478 ] ], [ [ 194936, 194936 ], "mapped", [ 32661 ] ], [ [ 194937, 194937 ], "mapped", [ 32762 ] ], [ [ 194938, 194938 ], "mapped", [ 32773 ] ], [ [ 194939, 194939 ], "mapped", [ 156890 ] ], [ [ 194940, 194940 ], "mapped", [ 156963 ] ], [ [ 194941, 194941 ], "mapped", [ 32864 ] ], [ [ 194942, 194942 ], "mapped", [ 157096 ] ], [ [ 194943, 194943 ], "mapped", [ 32880 ] ], [ [ 194944, 194944 ], "mapped", [ 144223 ] ], [ [ 194945, 194945 ], "mapped", [ 17365 ] ], [ [ 194946, 194946 ], "mapped", [ 32946 ] ], [ [ 194947, 194947 ], "mapped", [ 33027 ] ], [ [ 194948, 194948 ], "mapped", [ 17419 ] ], [ [ 194949, 194949 ], "mapped", [ 33086 ] ], [ [ 194950, 194950 ], "mapped", [ 23221 ] ], [ [ 194951, 194951 ], "mapped", [ 157607 ] ], [ [ 194952, 194952 ], "mapped", [ 157621 ] ], [ [ 194953, 194953 ], "mapped", [ 144275 ] ], [ [ 194954, 194954 ], "mapped", [ 144284 ] ], [ [ 194955, 194955 ], "mapped", [ 33281 ] ], [ [ 194956, 194956 ], "mapped", [ 33284 ] ], [ [ 194957, 194957 ], "mapped", [ 36766 ] ], [ [ 194958, 194958 ], "mapped", [ 17515 ] ], [ [ 194959, 194959 ], "mapped", [ 33425 ] ], [ [ 194960, 194960 ], "mapped", [ 33419 ] ], [ [ 194961, 194961 ], "mapped", [ 33437 ] ], [ [ 194962, 194962 ], "mapped", [ 21171 ] ], [ [ 194963, 194963 ], "mapped", [ 33457 ] ], [ [ 194964, 194964 ], "mapped", [ 33459 ] ], [ [ 194965, 194965 ], "mapped", [ 33469 ] ], [ [ 194966, 194966 ], "mapped", [ 33510 ] ], [ [ 194967, 194967 ], "mapped", [ 158524 ] ], [ [ 194968, 194968 ], "mapped", [ 33509 ] ], [ [ 194969, 194969 ], "mapped", [ 33565 ] ], [ [ 194970, 194970 ], "mapped", [ 33635 ] ], [ [ 194971, 194971 ], "mapped", [ 33709 ] ], [ [ 194972, 194972 ], "mapped", [ 33571 ] ], [ [ 194973, 194973 ], "mapped", [ 33725 ] ], [ [ 194974, 194974 ], "mapped", [ 33767 ] ], [ [ 194975, 194975 ], "mapped", [ 33879 ] ], [ [ 194976, 194976 ], "mapped", [ 33619 ] ], [ [ 194977, 194977 ], "mapped", [ 33738 ] ], [ [ 194978, 194978 ], "mapped", [ 33740 ] ], [ [ 194979, 194979 ], "mapped", [ 33756 ] ], [ [ 194980, 194980 ], "mapped", [ 158774 ] ], [ [ 194981, 194981 ], "mapped", [ 159083 ] ], [ [ 194982, 194982 ], "mapped", [ 158933 ] ], [ [ 194983, 194983 ], "mapped", [ 17707 ] ], [ [ 194984, 194984 ], "mapped", [ 34033 ] ], [ [ 194985, 194985 ], "mapped", [ 34035 ] ], [ [ 194986, 194986 ], "mapped", [ 34070 ] ], [ [ 194987, 194987 ], "mapped", [ 160714 ] ], [ [ 194988, 194988 ], "mapped", [ 34148 ] ], [ [ 194989, 194989 ], "mapped", [ 159532 ] ], [ [ 194990, 194990 ], "mapped", [ 17757 ] ], [ [ 194991, 194991 ], "mapped", [ 17761 ] ], [ [ 194992, 194992 ], "mapped", [ 159665 ] ], [ [ 194993, 194993 ], "mapped", [ 159954 ] ], [ [ 194994, 194994 ], "mapped", [ 17771 ] ], [ [ 194995, 194995 ], "mapped", [ 34384 ] ], [ [ 194996, 194996 ], "mapped", [ 34396 ] ], [ [ 194997, 194997 ], "mapped", [ 34407 ] ], [ [ 194998, 194998 ], "mapped", [ 34409 ] ], [ [ 194999, 194999 ], "mapped", [ 34473 ] ], [ [ 195e3, 195e3 ], "mapped", [ 34440 ] ], [ [ 195001, 195001 ], "mapped", [ 34574 ] ], [ [ 195002, 195002 ], "mapped", [ 34530 ] ], [ [ 195003, 195003 ], "mapped", [ 34681 ] ], [ [ 195004, 195004 ], "mapped", [ 34600 ] ], [ [ 195005, 195005 ], "mapped", [ 34667 ] ], [ [ 195006, 195006 ], "mapped", [ 34694 ] ], [ [ 195007, 195007 ], "disallowed" ], [ [ 195008, 195008 ], "mapped", [ 34785 ] ], [ [ 195009, 195009 ], "mapped", [ 34817 ] ], [ [ 195010, 195010 ], "mapped", [ 17913 ] ], [ [ 195011, 195011 ], "mapped", [ 34912 ] ], [ [ 195012, 195012 ], "mapped", [ 34915 ] ], [ [ 195013, 195013 ], "mapped", [ 161383 ] ], [ [ 195014, 195014 ], "mapped", [ 35031 ] ], [ [ 195015, 195015 ], "mapped", [ 35038 ] ], [ [ 195016, 195016 ], "mapped", [ 17973 ] ], [ [ 195017, 195017 ], "mapped", [ 35066 ] ], [ [ 195018, 195018 ], "mapped", [ 13499 ] ], [ [ 195019, 195019 ], "mapped", [ 161966 ] ], [ [ 195020, 195020 ], "mapped", [ 162150 ] ], [ [ 195021, 195021 ], "mapped", [ 18110 ] ], [ [ 195022, 195022 ], "mapped", [ 18119 ] ], [ [ 195023, 195023 ], "mapped", [ 35488 ] ], [ [ 195024, 195024 ], "mapped", [ 35565 ] ], [ [ 195025, 195025 ], "mapped", [ 35722 ] ], [ [ 195026, 195026 ], "mapped", [ 35925 ] ], [ [ 195027, 195027 ], "mapped", [ 162984 ] ], [ [ 195028, 195028 ], "mapped", [ 36011 ] ], [ [ 195029, 195029 ], "mapped", [ 36033 ] ], [ [ 195030, 195030 ], "mapped", [ 36123 ] ], [ [ 195031, 195031 ], "mapped", [ 36215 ] ], [ [ 195032, 195032 ], "mapped", [ 163631 ] ], [ [ 195033, 195033 ], "mapped", [ 133124 ] ], [ [ 195034, 195034 ], "mapped", [ 36299 ] ], [ [ 195035, 195035 ], "mapped", [ 36284 ] ], [ [ 195036, 195036 ], "mapped", [ 36336 ] ], [ [ 195037, 195037 ], "mapped", [ 133342 ] ], [ [ 195038, 195038 ], "mapped", [ 36564 ] ], [ [ 195039, 195039 ], "mapped", [ 36664 ] ], [ [ 195040, 195040 ], "mapped", [ 165330 ] ], [ [ 195041, 195041 ], "mapped", [ 165357 ] ], [ [ 195042, 195042 ], "mapped", [ 37012 ] ], [ [ 195043, 195043 ], "mapped", [ 37105 ] ], [ [ 195044, 195044 ], "mapped", [ 37137 ] ], [ [ 195045, 195045 ], "mapped", [ 165678 ] ], [ [ 195046, 195046 ], "mapped", [ 37147 ] ], [ [ 195047, 195047 ], "mapped", [ 37432 ] ], [ [ 195048, 195048 ], "mapped", [ 37591 ] ], [ [ 195049, 195049 ], "mapped", [ 37592 ] ], [ [ 195050, 195050 ], "mapped", [ 37500 ] ], [ [ 195051, 195051 ], "mapped", [ 37881 ] ], [ [ 195052, 195052 ], "mapped", [ 37909 ] ], [ [ 195053, 195053 ], "mapped", [ 166906 ] ], [ [ 195054, 195054 ], "mapped", [ 38283 ] ], [ [ 195055, 195055 ], "mapped", [ 18837 ] ], [ [ 195056, 195056 ], "mapped", [ 38327 ] ], [ [ 195057, 195057 ], "mapped", [ 167287 ] ], [ [ 195058, 195058 ], "mapped", [ 18918 ] ], [ [ 195059, 195059 ], "mapped", [ 38595 ] ], [ [ 195060, 195060 ], "mapped", [ 23986 ] ], [ [ 195061, 195061 ], "mapped", [ 38691 ] ], [ [ 195062, 195062 ], "mapped", [ 168261 ] ], [ [ 195063, 195063 ], "mapped", [ 168474 ] ], [ [ 195064, 195064 ], "mapped", [ 19054 ] ], [ [ 195065, 195065 ], "mapped", [ 19062 ] ], [ [ 195066, 195066 ], "mapped", [ 38880 ] ], [ [ 195067, 195067 ], "mapped", [ 168970 ] ], [ [ 195068, 195068 ], "mapped", [ 19122 ] ], [ [ 195069, 195069 ], "mapped", [ 169110 ] ], [ [ 195070, 195071 ], "mapped", [ 38923 ] ], [ [ 195072, 195072 ], "mapped", [ 38953 ] ], [ [ 195073, 195073 ], "mapped", [ 169398 ] ], [ [ 195074, 195074 ], "mapped", [ 39138 ] ], [ [ 195075, 195075 ], "mapped", [ 19251 ] ], [ [ 195076, 195076 ], "mapped", [ 39209 ] ], [ [ 195077, 195077 ], "mapped", [ 39335 ] ], [ [ 195078, 195078 ], "mapped", [ 39362 ] ], [ [ 195079, 195079 ], "mapped", [ 39422 ] ], [ [ 195080, 195080 ], "mapped", [ 19406 ] ], [ [ 195081, 195081 ], "mapped", [ 170800 ] ], [ [ 195082, 195082 ], "mapped", [ 39698 ] ], [ [ 195083, 195083 ], "mapped", [ 4e4 ] ], [ [ 195084, 195084 ], "mapped", [ 40189 ] ], [ [ 195085, 195085 ], "mapped", [ 19662 ] ], [ [ 195086, 195086 ], "mapped", [ 19693 ] ], [ [ 195087, 195087 ], "mapped", [ 40295 ] ], [ [ 195088, 195088 ], "mapped", [ 172238 ] ], [ [ 195089, 195089 ], "mapped", [ 19704 ] ], [ [ 195090, 195090 ], "mapped", [ 172293 ] ], [ [ 195091, 195091 ], "mapped", [ 172558 ] ], [ [ 195092, 195092 ], "mapped", [ 172689 ] ], [ [ 195093, 195093 ], "mapped", [ 40635 ] ], [ [ 195094, 195094 ], "mapped", [ 19798 ] ], [ [ 195095, 195095 ], "mapped", [ 40697 ] ], [ [ 195096, 195096 ], "mapped", [ 40702 ] ], [ [ 195097, 195097 ], "mapped", [ 40709 ] ], [ [ 195098, 195098 ], "mapped", [ 40719 ] ], [ [ 195099, 195099 ], "mapped", [ 40726 ] ], [ [ 195100, 195100 ], "mapped", [ 40763 ] ], [ [ 195101, 195101 ], "mapped", [ 173568 ] ], [ [ 195102, 196605 ], "disallowed" ], [ [ 196606, 196607 ], "disallowed" ], [ [ 196608, 262141 ], "disallowed" ], [ [ 262142, 262143 ], "disallowed" ], [ [ 262144, 327677 ], "disallowed" ], [ [ 327678, 327679 ], "disallowed" ], [ [ 327680, 393213 ], "disallowed" ], [ [ 393214, 393215 ], "disallowed" ], [ [ 393216, 458749 ], "disallowed" ], [ [ 458750, 458751 ], "disallowed" ], [ [ 458752, 524285 ], "disallowed" ], [ [ 524286, 524287 ], "disallowed" ], [ [ 524288, 589821 ], "disallowed" ], [ [ 589822, 589823 ], "disallowed" ], [ [ 589824, 655357 ], "disallowed" ], [ [ 655358, 655359 ], "disallowed" ], [ [ 655360, 720893 ], "disallowed" ], [ [ 720894, 720895 ], "disallowed" ], [ [ 720896, 786429 ], "disallowed" ], [ [ 786430, 786431 ], "disallowed" ], [ [ 786432, 851965 ], "disallowed" ], [ [ 851966, 851967 ], "disallowed" ], [ [ 851968, 917501 ], "disallowed" ], [ [ 917502, 917503 ], "disallowed" ], [ [ 917504, 917504 ], "disallowed" ], [ [ 917505, 917505 ], "disallowed" ], [ [ 917506, 917535 ], "disallowed" ], [ [ 917536, 917631 ], "disallowed" ], [ [ 917632, 917759 ], "disallowed" ], [ [ 917760, 917999 ], "ignored" ], [ [ 918e3, 983037 ], "disallowed" ], [ [ 983038, 983039 ], "disallowed" ], [ [ 983040, 1048573 ], "disallowed" ], [ [ 1048574, 1048575 ], "disallowed" ], [ [ 1048576, 1114109 ], "disallowed" ], [ [ 1114110, 1114111 ], "disallowed" ] ], hasRequiredTr46, hasRequiredUrlStateMachine, hasRequiredURLImpl, hasRequiredURL, hasRequiredPublicApi;

function requireTr46() {
    if (hasRequiredTr46) return tr46;
    hasRequiredTr46 = 1;
    var punycode = require$$0, mappingTable = require$$1, PROCESSING_OPTIONS = {
        TRANSITIONAL: 0,
        NONTRANSITIONAL: 1
    };
    function normalize(str) {
        return str.split("\0").map((function(s) {
            return s.normalize("NFC");
        })).join("\0");
    }
    function findStatus(val) {
        for (var start = 0, end = mappingTable.length - 1; start <= end; ) {
            var mid = Math.floor((start + end) / 2), target = mappingTable[mid];
            if (target[0][0] <= val && target[0][1] >= val) return target;
            target[0][0] > val ? end = mid - 1 : start = mid + 1;
        }
        return null;
    }
    var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
    function countSymbols(string) {
        return string.replace(regexAstralSymbols, "_").length;
    }
    var combiningMarksRegex = /[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08E4-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C03\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D01-\u0D03\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u192B\u1930-\u193B\u19B0-\u19C0\u19C8\u19C9\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ABE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFC-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C4\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2D]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD804[\uDC00-\uDC02\uDC38-\uDC46\uDC7F-\uDC82\uDCB0-\uDCBA\uDD00-\uDD02\uDD27-\uDD34\uDD73\uDD80-\uDD82\uDDB3-\uDDC0\uDE2C-\uDE37\uDEDF-\uDEEA\uDF01-\uDF03\uDF3C\uDF3E-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF62\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDCB0-\uDCC3\uDDAF-\uDDB5\uDDB8-\uDDC0\uDE30-\uDE40\uDEAB-\uDEB7]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF51-\uDF7E\uDF8F-\uDF92]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD83A[\uDCD0-\uDCD6]|\uDB40[\uDD00-\uDDEF]/;
    function validateLabel(label, processing_option) {
        "xn--" === label.substr(0, 4) && (label = punycode.toUnicode(label));
        var error = !1;
        (normalize(label) !== label || "-" === label[3] && "-" === label[4] || "-" === label[0] || "-" === label[label.length - 1] || -1 !== label.indexOf(".") || 0 === label.search(combiningMarksRegex)) && (error = !0);
        for (var len = countSymbols(label), i = 0; i < len; ++i) {
            var status = findStatus(label.codePointAt(i));
            if (processing === PROCESSING_OPTIONS.TRANSITIONAL && "valid" !== status[1] || processing === PROCESSING_OPTIONS.NONTRANSITIONAL && "valid" !== status[1] && "deviation" !== status[1]) {
                error = !0;
                break;
            }
        }
        return {
            label: label,
            error: error
        };
    }
    function processing(domain_name, useSTD3, processing_option) {
        var result = function(domain_name, useSTD3, processing_option) {
            for (var hasError = !1, processed = "", len = countSymbols(domain_name), i = 0; i < len; ++i) {
                var codePoint = domain_name.codePointAt(i), status = findStatus(codePoint);
                switch (status[1]) {
                  case "disallowed":
                    hasError = !0, processed += String.fromCodePoint(codePoint);
                    break;

                  case "ignored":
                    break;

                  case "mapped":
                    processed += String.fromCodePoint.apply(String, status[2]);
                    break;

                  case "deviation":
                    processed += processing_option === PROCESSING_OPTIONS.TRANSITIONAL ? String.fromCodePoint.apply(String, status[2]) : String.fromCodePoint(codePoint);
                    break;

                  case "valid":
                    processed += String.fromCodePoint(codePoint);
                    break;

                  case "disallowed_STD3_mapped":
                    useSTD3 ? (hasError = !0, processed += String.fromCodePoint(codePoint)) : processed += String.fromCodePoint.apply(String, status[2]);
                    break;

                  case "disallowed_STD3_valid":
                    useSTD3 && (hasError = !0), processed += String.fromCodePoint(codePoint);
                }
            }
            return {
                string: processed,
                error: hasError
            };
        }(domain_name, useSTD3, processing_option);
        result.string = normalize(result.string);
        for (var labels = result.string.split("."), i = 0; i < labels.length; ++i) try {
            var validation = validateLabel(labels[i]);
            labels[i] = validation.label, result.error = result.error || validation.error;
        } catch (e) {
            result.error = !0;
        }
        return {
            string: labels.join("."),
            error: result.error
        };
    }
    return tr46.toASCII = function(domain_name, useSTD3, processing_option, verifyDnsLength) {
        var result = processing(domain_name, useSTD3, processing_option), labels = result.string.split(".");
        if (labels = labels.map((function(l) {
            try {
                return punycode.toASCII(l);
            } catch (e) {
                return result.error = !0, l;
            }
        })), verifyDnsLength) {
            var total = labels.slice(0, labels.length - 1).join(".").length;
            (total.length > 253 || 0 === total.length) && (result.error = !0);
            for (var i = 0; i < labels.length; ++i) if (labels.length > 63 || 0 === labels.length) {
                result.error = !0;
                break;
            }
        }
        return result.error ? null : labels.join(".");
    }, tr46.toUnicode = function(domain_name, useSTD3) {
        var result = processing(domain_name, useSTD3, PROCESSING_OPTIONS.NONTRANSITIONAL);
        return {
            domain: result.string,
            error: result.error
        };
    }, tr46.PROCESSING_OPTIONS = PROCESSING_OPTIONS, tr46;
}

function requireUrlStateMachine() {
    return hasRequiredUrlStateMachine || (hasRequiredUrlStateMachine = 1, function(module) {
        const punycode = require$$0, tr46 = requireTr46(), specialSchemes = {
            ftp: 21,
            file: null,
            gopher: 70,
            http: 80,
            https: 443,
            ws: 80,
            wss: 443
        }, failure = Symbol("failure");
        function countSymbols(str) {
            return punycode.ucs2.decode(str).length;
        }
        function at(input, idx) {
            const c = input[idx];
            return isNaN(c) ? void 0 : String.fromCodePoint(c);
        }
        function isASCIIDigit(c) {
            return c >= 48 && c <= 57;
        }
        function isASCIIAlpha(c) {
            return c >= 65 && c <= 90 || c >= 97 && c <= 122;
        }
        function isASCIIHex(c) {
            return isASCIIDigit(c) || c >= 65 && c <= 70 || c >= 97 && c <= 102;
        }
        function isSingleDot(buffer) {
            return "." === buffer || "%2e" === buffer.toLowerCase();
        }
        function isWindowsDriveLetterString(string) {
            return 2 === string.length && isASCIIAlpha(string.codePointAt(0)) && (":" === string[1] || "|" === string[1]);
        }
        function isSpecialScheme(scheme) {
            return void 0 !== specialSchemes[scheme];
        }
        function isSpecial(url) {
            return isSpecialScheme(url.scheme);
        }
        function percentEncode(c) {
            let hex = c.toString(16).toUpperCase();
            return 1 === hex.length && (hex = "0" + hex), "%" + hex;
        }
        function isC0ControlPercentEncode(c) {
            return c <= 31 || c > 126;
        }
        const extraPathPercentEncodeSet = new Set([ 32, 34, 35, 60, 62, 63, 96, 123, 125 ]);
        function isPathPercentEncode(c) {
            return isC0ControlPercentEncode(c) || extraPathPercentEncodeSet.has(c);
        }
        const extraUserinfoPercentEncodeSet = new Set([ 47, 58, 59, 61, 64, 91, 92, 93, 94, 124 ]);
        function isUserinfoPercentEncode(c) {
            return isPathPercentEncode(c) || extraUserinfoPercentEncodeSet.has(c);
        }
        function percentEncodeChar(c, encodeSetPredicate) {
            const cStr = String.fromCodePoint(c);
            return encodeSetPredicate(c) ? function(c) {
                const buf = new Buffer(c);
                let str = "";
                for (let i = 0; i < buf.length; ++i) str += percentEncode(buf[i]);
                return str;
            }(cStr) : cStr;
        }
        function parseIPv4Number(input) {
            let R = 10;
            if (input.length >= 2 && "0" === input.charAt(0) && "x" === input.charAt(1).toLowerCase() ? (input = input.substring(2), 
            R = 16) : input.length >= 2 && "0" === input.charAt(0) && (input = input.substring(1), 
            R = 8), "" === input) return 0;
            return (10 === R ? /[^0-9]/ : 16 === R ? /[^0-9A-Fa-f]/ : /[^0-7]/).test(input) ? failure : parseInt(input, R);
        }
        function parseHost(input, isSpecialArg) {
            if ("[" === input[0]) return "]" !== input[input.length - 1] ? failure : function(input) {
                const address = [ 0, 0, 0, 0, 0, 0, 0, 0 ];
                let pieceIndex = 0, compress = null, pointer = 0;
                if (58 === (input = punycode.ucs2.decode(input))[pointer]) {
                    if (58 !== input[pointer + 1]) return failure;
                    pointer += 2, ++pieceIndex, compress = pieceIndex;
                }
                for (;pointer < input.length; ) {
                    if (8 === pieceIndex) return failure;
                    if (58 === input[pointer]) {
                        if (null !== compress) return failure;
                        ++pointer, ++pieceIndex, compress = pieceIndex;
                        continue;
                    }
                    let value = 0, length = 0;
                    for (;length < 4 && isASCIIHex(input[pointer]); ) value = 16 * value + parseInt(at(input, pointer), 16), 
                    ++pointer, ++length;
                    if (46 === input[pointer]) {
                        if (0 === length) return failure;
                        if (pointer -= length, pieceIndex > 6) return failure;
                        let numbersSeen = 0;
                        for (;void 0 !== input[pointer]; ) {
                            let ipv4Piece = null;
                            if (numbersSeen > 0) {
                                if (!(46 === input[pointer] && numbersSeen < 4)) return failure;
                                ++pointer;
                            }
                            if (!isASCIIDigit(input[pointer])) return failure;
                            for (;isASCIIDigit(input[pointer]); ) {
                                const number = parseInt(at(input, pointer));
                                if (null === ipv4Piece) ipv4Piece = number; else {
                                    if (0 === ipv4Piece) return failure;
                                    ipv4Piece = 10 * ipv4Piece + number;
                                }
                                if (ipv4Piece > 255) return failure;
                                ++pointer;
                            }
                            address[pieceIndex] = 256 * address[pieceIndex] + ipv4Piece, ++numbersSeen, 2 !== numbersSeen && 4 !== numbersSeen || ++pieceIndex;
                        }
                        if (4 !== numbersSeen) return failure;
                        break;
                    }
                    if (58 === input[pointer]) {
                        if (++pointer, void 0 === input[pointer]) return failure;
                    } else if (void 0 !== input[pointer]) return failure;
                    address[pieceIndex] = value, ++pieceIndex;
                }
                if (null !== compress) {
                    let swaps = pieceIndex - compress;
                    for (pieceIndex = 7; 0 !== pieceIndex && swaps > 0; ) {
                        const temp = address[compress + swaps - 1];
                        address[compress + swaps - 1] = address[pieceIndex], address[pieceIndex] = temp, 
                        --pieceIndex, --swaps;
                    }
                } else if (null === compress && 8 !== pieceIndex) return failure;
                return address;
            }(input.substring(1, input.length - 1));
            if (!isSpecialArg) return function(input) {
                if (function(string) {
                    return -1 !== string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|\/|:|\?|@|\[|\\|\]/);
                }(input)) return failure;
                let output = "";
                const decoded = punycode.ucs2.decode(input);
                for (let i = 0; i < decoded.length; ++i) output += percentEncodeChar(decoded[i], isC0ControlPercentEncode);
                return output;
            }(input);
            const domain = function(str) {
                const input = new Buffer(str), output = [];
                for (let i = 0; i < input.length; ++i) 37 !== input[i] ? output.push(input[i]) : 37 === input[i] && isASCIIHex(input[i + 1]) && isASCIIHex(input[i + 2]) ? (output.push(parseInt(input.slice(i + 1, i + 3).toString(), 16)), 
                i += 2) : output.push(input[i]);
                return new Buffer(output).toString();
            }(input), asciiDomain = tr46.toASCII(domain, !1, tr46.PROCESSING_OPTIONS.NONTRANSITIONAL, !1);
            if (null === asciiDomain) return failure;
            if (function(string) {
                return -1 !== string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|%|\/|:|\?|@|\[|\\|\]/);
            }(asciiDomain)) return failure;
            const ipv4Host = function(input) {
                const parts = input.split(".");
                if ("" === parts[parts.length - 1] && parts.length > 1 && parts.pop(), parts.length > 4) return input;
                const numbers = [];
                for (const part of parts) {
                    if ("" === part) return input;
                    const n = parseIPv4Number(part);
                    if (n === failure) return input;
                    numbers.push(n);
                }
                for (let i = 0; i < numbers.length - 1; ++i) if (numbers[i] > 255) return failure;
                if (numbers[numbers.length - 1] >= Math.pow(256, 5 - numbers.length)) return failure;
                let ipv4 = numbers.pop(), counter = 0;
                for (const n of numbers) ipv4 += n * Math.pow(256, 3 - counter), ++counter;
                return ipv4;
            }(asciiDomain);
            return "number" == typeof ipv4Host || ipv4Host === failure ? ipv4Host : asciiDomain;
        }
        function serializeHost(host) {
            return "number" == typeof host ? function(address) {
                let output = "", n = address;
                for (let i = 1; i <= 4; ++i) output = String(n % 256) + output, 4 !== i && (output = "." + output), 
                n = Math.floor(n / 256);
                return output;
            }(host) : host instanceof Array ? "[" + function(address) {
                let output = "";
                const compress = function(arr) {
                    let maxIdx = null, maxLen = 1, currStart = null, currLen = 0;
                    for (let i = 0; i < arr.length; ++i) 0 !== arr[i] ? (currLen > maxLen && (maxIdx = currStart, 
                    maxLen = currLen), currStart = null, currLen = 0) : (null === currStart && (currStart = i), 
                    ++currLen);
                    return currLen > maxLen && (maxIdx = currStart, maxLen = currLen), {
                        idx: maxIdx,
                        len: maxLen
                    };
                }(address).idx;
                let ignore0 = !1;
                for (let pieceIndex = 0; pieceIndex <= 7; ++pieceIndex) ignore0 && 0 === address[pieceIndex] || (ignore0 && (ignore0 = !1), 
                compress !== pieceIndex ? (output += address[pieceIndex].toString(16), 7 !== pieceIndex && (output += ":")) : (output += 0 === pieceIndex ? "::" : ":", 
                ignore0 = !0));
                return output;
            }(host) + "]" : host;
        }
        function shortenPath(url) {
            const path = url.path;
            0 !== path.length && ("file" === url.scheme && 1 === path.length && function(string) {
                return /^[A-Za-z]:$/.test(string);
            }(path[0]) || path.pop());
        }
        function includesCredentials(url) {
            return "" !== url.username || "" !== url.password;
        }
        function URLStateMachine(input, base, encodingOverride, url, stateOverride) {
            if (this.pointer = 0, this.input = input, this.base = base || null, this.encodingOverride = encodingOverride || "utf-8", 
            this.stateOverride = stateOverride, this.url = url, this.failure = !1, this.parseError = !1, 
            !this.url) {
                this.url = {
                    scheme: "",
                    username: "",
                    password: "",
                    host: null,
                    port: null,
                    path: [],
                    query: null,
                    fragment: null,
                    cannotBeABaseURL: !1
                };
                const res = function(url) {
                    return url.replace(/^[\u0000-\u001F\u0020]+|[\u0000-\u001F\u0020]+$/g, "");
                }(this.input);
                res !== this.input && (this.parseError = !0), this.input = res;
            }
            const res = function(url) {
                return url.replace(/\u0009|\u000A|\u000D/g, "");
            }(this.input);
            for (res !== this.input && (this.parseError = !0), this.input = res, this.state = stateOverride || "scheme start", 
            this.buffer = "", this.atFlag = !1, this.arrFlag = !1, this.passwordTokenSeenFlag = !1, 
            this.input = punycode.ucs2.decode(this.input); this.pointer <= this.input.length; ++this.pointer) {
                const c = this.input[this.pointer], cStr = isNaN(c) ? void 0 : String.fromCodePoint(c), ret = this["parse " + this.state](c, cStr);
                if (!ret) break;
                if (ret === failure) {
                    this.failure = !0;
                    break;
                }
            }
        }
        URLStateMachine.prototype["parse scheme start"] = function(c, cStr) {
            if (isASCIIAlpha(c)) this.buffer += cStr.toLowerCase(), this.state = "scheme"; else {
                if (this.stateOverride) return this.parseError = !0, failure;
                this.state = "no scheme", --this.pointer;
            }
            return !0;
        }, URLStateMachine.prototype["parse scheme"] = function(c, cStr) {
            if (function(c) {
                return isASCIIAlpha(c) || isASCIIDigit(c);
            }(c) || 43 === c || 45 === c || 46 === c) this.buffer += cStr.toLowerCase(); else if (58 === c) {
                if (this.stateOverride) {
                    if (isSpecial(this.url) && !isSpecialScheme(this.buffer)) return !1;
                    if (!isSpecial(this.url) && isSpecialScheme(this.buffer)) return !1;
                    if ((includesCredentials(this.url) || null !== this.url.port) && "file" === this.buffer) return !1;
                    if ("file" === this.url.scheme && ("" === this.url.host || null === this.url.host)) return !1;
                }
                if (this.url.scheme = this.buffer, this.buffer = "", this.stateOverride) return !1;
                "file" === this.url.scheme ? (47 === this.input[this.pointer + 1] && 47 === this.input[this.pointer + 2] || (this.parseError = !0), 
                this.state = "file") : isSpecial(this.url) && null !== this.base && this.base.scheme === this.url.scheme ? this.state = "special relative or authority" : isSpecial(this.url) ? this.state = "special authority slashes" : 47 === this.input[this.pointer + 1] ? (this.state = "path or authority", 
                ++this.pointer) : (this.url.cannotBeABaseURL = !0, this.url.path.push(""), this.state = "cannot-be-a-base-URL path");
            } else {
                if (this.stateOverride) return this.parseError = !0, failure;
                this.buffer = "", this.state = "no scheme", this.pointer = -1;
            }
            return !0;
        }, URLStateMachine.prototype["parse no scheme"] = function(c) {
            return null === this.base || this.base.cannotBeABaseURL && 35 !== c ? failure : (this.base.cannotBeABaseURL && 35 === c ? (this.url.scheme = this.base.scheme, 
            this.url.path = this.base.path.slice(), this.url.query = this.base.query, this.url.fragment = "", 
            this.url.cannotBeABaseURL = !0, this.state = "fragment") : "file" === this.base.scheme ? (this.state = "file", 
            --this.pointer) : (this.state = "relative", --this.pointer), !0);
        }, URLStateMachine.prototype["parse special relative or authority"] = function(c) {
            return 47 === c && 47 === this.input[this.pointer + 1] ? (this.state = "special authority ignore slashes", 
            ++this.pointer) : (this.parseError = !0, this.state = "relative", --this.pointer), 
            !0;
        }, URLStateMachine.prototype["parse path or authority"] = function(c) {
            return 47 === c ? this.state = "authority" : (this.state = "path", --this.pointer), 
            !0;
        }, URLStateMachine.prototype["parse relative"] = function(c) {
            return this.url.scheme = this.base.scheme, isNaN(c) ? (this.url.username = this.base.username, 
            this.url.password = this.base.password, this.url.host = this.base.host, this.url.port = this.base.port, 
            this.url.path = this.base.path.slice(), this.url.query = this.base.query) : 47 === c ? this.state = "relative slash" : 63 === c ? (this.url.username = this.base.username, 
            this.url.password = this.base.password, this.url.host = this.base.host, this.url.port = this.base.port, 
            this.url.path = this.base.path.slice(), this.url.query = "", this.state = "query") : 35 === c ? (this.url.username = this.base.username, 
            this.url.password = this.base.password, this.url.host = this.base.host, this.url.port = this.base.port, 
            this.url.path = this.base.path.slice(), this.url.query = this.base.query, this.url.fragment = "", 
            this.state = "fragment") : isSpecial(this.url) && 92 === c ? (this.parseError = !0, 
            this.state = "relative slash") : (this.url.username = this.base.username, this.url.password = this.base.password, 
            this.url.host = this.base.host, this.url.port = this.base.port, this.url.path = this.base.path.slice(0, this.base.path.length - 1), 
            this.state = "path", --this.pointer), !0;
        }, URLStateMachine.prototype["parse relative slash"] = function(c) {
            return !isSpecial(this.url) || 47 !== c && 92 !== c ? 47 === c ? this.state = "authority" : (this.url.username = this.base.username, 
            this.url.password = this.base.password, this.url.host = this.base.host, this.url.port = this.base.port, 
            this.state = "path", --this.pointer) : (92 === c && (this.parseError = !0), this.state = "special authority ignore slashes"), 
            !0;
        }, URLStateMachine.prototype["parse special authority slashes"] = function(c) {
            return 47 === c && 47 === this.input[this.pointer + 1] ? (this.state = "special authority ignore slashes", 
            ++this.pointer) : (this.parseError = !0, this.state = "special authority ignore slashes", 
            --this.pointer), !0;
        }, URLStateMachine.prototype["parse special authority ignore slashes"] = function(c) {
            return 47 !== c && 92 !== c ? (this.state = "authority", --this.pointer) : this.parseError = !0, 
            !0;
        }, URLStateMachine.prototype["parse authority"] = function(c, cStr) {
            if (64 === c) {
                this.parseError = !0, this.atFlag && (this.buffer = "%40" + this.buffer), this.atFlag = !0;
                const len = countSymbols(this.buffer);
                for (let pointer = 0; pointer < len; ++pointer) {
                    const codePoint = this.buffer.codePointAt(pointer);
                    if (58 === codePoint && !this.passwordTokenSeenFlag) {
                        this.passwordTokenSeenFlag = !0;
                        continue;
                    }
                    const encodedCodePoints = percentEncodeChar(codePoint, isUserinfoPercentEncode);
                    this.passwordTokenSeenFlag ? this.url.password += encodedCodePoints : this.url.username += encodedCodePoints;
                }
                this.buffer = "";
            } else if (isNaN(c) || 47 === c || 63 === c || 35 === c || isSpecial(this.url) && 92 === c) {
                if (this.atFlag && "" === this.buffer) return this.parseError = !0, failure;
                this.pointer -= countSymbols(this.buffer) + 1, this.buffer = "", this.state = "host";
            } else this.buffer += cStr;
            return !0;
        }, URLStateMachine.prototype["parse hostname"] = URLStateMachine.prototype["parse host"] = function(c, cStr) {
            if (this.stateOverride && "file" === this.url.scheme) --this.pointer, this.state = "file host"; else if (58 !== c || this.arrFlag) if (isNaN(c) || 47 === c || 63 === c || 35 === c || isSpecial(this.url) && 92 === c) {
                if (--this.pointer, isSpecial(this.url) && "" === this.buffer) return this.parseError = !0, 
                failure;
                if (this.stateOverride && "" === this.buffer && (includesCredentials(this.url) || null !== this.url.port)) return this.parseError = !0, 
                !1;
                const host = parseHost(this.buffer, isSpecial(this.url));
                if (host === failure) return failure;
                if (this.url.host = host, this.buffer = "", this.state = "path start", this.stateOverride) return !1;
            } else 91 === c ? this.arrFlag = !0 : 93 === c && (this.arrFlag = !1), this.buffer += cStr; else {
                if ("" === this.buffer) return this.parseError = !0, failure;
                const host = parseHost(this.buffer, isSpecial(this.url));
                if (host === failure) return failure;
                if (this.url.host = host, this.buffer = "", this.state = "port", "hostname" === this.stateOverride) return !1;
            }
            return !0;
        }, URLStateMachine.prototype["parse port"] = function(c, cStr) {
            if (isASCIIDigit(c)) this.buffer += cStr; else {
                if (!(isNaN(c) || 47 === c || 63 === c || 35 === c || isSpecial(this.url) && 92 === c || this.stateOverride)) return this.parseError = !0, 
                failure;
                if ("" !== this.buffer) {
                    const port = parseInt(this.buffer);
                    if (port > Math.pow(2, 16) - 1) return this.parseError = !0, failure;
                    this.url.port = port === (scheme = this.url.scheme, specialSchemes[scheme]) ? null : port, 
                    this.buffer = "";
                }
                if (this.stateOverride) return !1;
                this.state = "path start", --this.pointer;
            }
            var scheme;
            return !0;
        };
        const fileOtherwiseCodePoints = new Set([ 47, 92, 63, 35 ]);
        URLStateMachine.prototype["parse file"] = function(c) {
            var cp1, cp2;
            return this.url.scheme = "file", 47 === c || 92 === c ? (92 === c && (this.parseError = !0), 
            this.state = "file slash") : null !== this.base && "file" === this.base.scheme ? isNaN(c) ? (this.url.host = this.base.host, 
            this.url.path = this.base.path.slice(), this.url.query = this.base.query) : 63 === c ? (this.url.host = this.base.host, 
            this.url.path = this.base.path.slice(), this.url.query = "", this.state = "query") : 35 === c ? (this.url.host = this.base.host, 
            this.url.path = this.base.path.slice(), this.url.query = this.base.query, this.url.fragment = "", 
            this.state = "fragment") : (this.input.length - this.pointer - 1 == 0 || (cp1 = c, 
            cp2 = this.input[this.pointer + 1], !isASCIIAlpha(cp1) || 58 !== cp2 && 124 !== cp2) || this.input.length - this.pointer - 1 >= 2 && !fileOtherwiseCodePoints.has(this.input[this.pointer + 2]) ? (this.url.host = this.base.host, 
            this.url.path = this.base.path.slice(), shortenPath(this.url)) : this.parseError = !0, 
            this.state = "path", --this.pointer) : (this.state = "path", --this.pointer), !0;
        }, URLStateMachine.prototype["parse file slash"] = function(c) {
            return 47 === c || 92 === c ? (92 === c && (this.parseError = !0), this.state = "file host") : (null !== this.base && "file" === this.base.scheme && (!function(string) {
                return 2 === string.length && isASCIIAlpha(string.codePointAt(0)) && ":" === string[1];
            }(this.base.path[0]) ? this.url.host = this.base.host : this.url.path.push(this.base.path[0])), 
            this.state = "path", --this.pointer), !0;
        }, URLStateMachine.prototype["parse file host"] = function(c, cStr) {
            if (isNaN(c) || 47 === c || 92 === c || 63 === c || 35 === c) if (--this.pointer, 
            !this.stateOverride && isWindowsDriveLetterString(this.buffer)) this.parseError = !0, 
            this.state = "path"; else if ("" === this.buffer) {
                if (this.url.host = "", this.stateOverride) return !1;
                this.state = "path start";
            } else {
                let host = parseHost(this.buffer, isSpecial(this.url));
                if (host === failure) return failure;
                if ("localhost" === host && (host = ""), this.url.host = host, this.stateOverride) return !1;
                this.buffer = "", this.state = "path start";
            } else this.buffer += cStr;
            return !0;
        }, URLStateMachine.prototype["parse path start"] = function(c) {
            return isSpecial(this.url) ? (92 === c && (this.parseError = !0), this.state = "path", 
            47 !== c && 92 !== c && --this.pointer) : this.stateOverride || 63 !== c ? this.stateOverride || 35 !== c ? void 0 !== c && (this.state = "path", 
            47 !== c && --this.pointer) : (this.url.fragment = "", this.state = "fragment") : (this.url.query = "", 
            this.state = "query"), !0;
        }, URLStateMachine.prototype["parse path"] = function(c) {
            if (isNaN(c) || 47 === c || isSpecial(this.url) && 92 === c || !this.stateOverride && (63 === c || 35 === c)) {
                if (isSpecial(this.url) && 92 === c && (this.parseError = !0), ".." === (buffer = (buffer = this.buffer).toLowerCase()) || "%2e." === buffer || ".%2e" === buffer || "%2e%2e" === buffer ? (shortenPath(this.url), 
                47 === c || isSpecial(this.url) && 92 === c || this.url.path.push("")) : !isSingleDot(this.buffer) || 47 === c || isSpecial(this.url) && 92 === c ? isSingleDot(this.buffer) || ("file" === this.url.scheme && 0 === this.url.path.length && isWindowsDriveLetterString(this.buffer) && ("" !== this.url.host && null !== this.url.host && (this.parseError = !0, 
                this.url.host = ""), this.buffer = this.buffer[0] + ":"), this.url.path.push(this.buffer)) : this.url.path.push(""), 
                this.buffer = "", "file" === this.url.scheme && (void 0 === c || 63 === c || 35 === c)) for (;this.url.path.length > 1 && "" === this.url.path[0]; ) this.parseError = !0, 
                this.url.path.shift();
                63 === c && (this.url.query = "", this.state = "query"), 35 === c && (this.url.fragment = "", 
                this.state = "fragment");
            } else 37 !== c || isASCIIHex(this.input[this.pointer + 1]) && isASCIIHex(this.input[this.pointer + 2]) || (this.parseError = !0), 
            this.buffer += percentEncodeChar(c, isPathPercentEncode);
            var buffer;
            return !0;
        }, URLStateMachine.prototype["parse cannot-be-a-base-URL path"] = function(c) {
            return 63 === c ? (this.url.query = "", this.state = "query") : 35 === c ? (this.url.fragment = "", 
            this.state = "fragment") : (isNaN(c) || 37 === c || (this.parseError = !0), 37 !== c || isASCIIHex(this.input[this.pointer + 1]) && isASCIIHex(this.input[this.pointer + 2]) || (this.parseError = !0), 
            isNaN(c) || (this.url.path[0] = this.url.path[0] + percentEncodeChar(c, isC0ControlPercentEncode))), 
            !0;
        }, URLStateMachine.prototype["parse query"] = function(c, cStr) {
            if (isNaN(c) || !this.stateOverride && 35 === c) {
                isSpecial(this.url) && "ws" !== this.url.scheme && "wss" !== this.url.scheme || (this.encodingOverride = "utf-8");
                const buffer = new Buffer(this.buffer);
                for (let i = 0; i < buffer.length; ++i) buffer[i] < 33 || buffer[i] > 126 || 34 === buffer[i] || 35 === buffer[i] || 60 === buffer[i] || 62 === buffer[i] ? this.url.query += percentEncode(buffer[i]) : this.url.query += String.fromCodePoint(buffer[i]);
                this.buffer = "", 35 === c && (this.url.fragment = "", this.state = "fragment");
            } else 37 !== c || isASCIIHex(this.input[this.pointer + 1]) && isASCIIHex(this.input[this.pointer + 2]) || (this.parseError = !0), 
            this.buffer += cStr;
            return !0;
        }, URLStateMachine.prototype["parse fragment"] = function(c) {
            return isNaN(c) || (0 === c ? this.parseError = !0 : (37 !== c || isASCIIHex(this.input[this.pointer + 1]) && isASCIIHex(this.input[this.pointer + 2]) || (this.parseError = !0), 
            this.url.fragment += percentEncodeChar(c, isC0ControlPercentEncode))), !0;
        }, module.exports.serializeURL = function(url, excludeFragment) {
            let output = url.scheme + ":";
            if (null !== url.host ? (output += "//", "" === url.username && "" === url.password || (output += url.username, 
            "" !== url.password && (output += ":" + url.password), output += "@"), output += serializeHost(url.host), 
            null !== url.port && (output += ":" + url.port)) : null === url.host && "file" === url.scheme && (output += "//"), 
            url.cannotBeABaseURL) output += url.path[0]; else for (const string of url.path) output += "/" + string;
            return null !== url.query && (output += "?" + url.query), excludeFragment || null === url.fragment || (output += "#" + url.fragment), 
            output;
        }, module.exports.serializeURLOrigin = function(url) {
            switch (url.scheme) {
              case "blob":
                try {
                    return module.exports.serializeURLOrigin(module.exports.parseURL(url.path[0]));
                } catch (e) {
                    return "null";
                }

              case "ftp":
              case "gopher":
              case "http":
              case "https":
              case "ws":
              case "wss":
                return function(tuple) {
                    let result = tuple.scheme + "://";
                    return result += serializeHost(tuple.host), null !== tuple.port && (result += ":" + tuple.port), 
                    result;
                }({
                    scheme: url.scheme,
                    host: url.host,
                    port: url.port
                });

              case "file":
                return "file://";

              default:
                return "null";
            }
        }, module.exports.basicURLParse = function(input, options) {
            void 0 === options && (options = {});
            const usm = new URLStateMachine(input, options.baseURL, options.encodingOverride, options.url, options.stateOverride);
            return usm.failure ? "failure" : usm.url;
        }, module.exports.setTheUsername = function(url, username) {
            url.username = "";
            const decoded = punycode.ucs2.decode(username);
            for (let i = 0; i < decoded.length; ++i) url.username += percentEncodeChar(decoded[i], isUserinfoPercentEncode);
        }, module.exports.setThePassword = function(url, password) {
            url.password = "";
            const decoded = punycode.ucs2.decode(password);
            for (let i = 0; i < decoded.length; ++i) url.password += percentEncodeChar(decoded[i], isUserinfoPercentEncode);
        }, module.exports.serializeHost = serializeHost, module.exports.cannotHaveAUsernamePasswordPort = function(url) {
            return null === url.host || "" === url.host || url.cannotBeABaseURL || "file" === url.scheme;
        }, module.exports.serializeInteger = function(integer) {
            return String(integer);
        }, module.exports.parseURL = function(input, options) {
            return void 0 === options && (options = {}), module.exports.basicURLParse(input, {
                baseURL: options.baseURL,
                encodingOverride: options.encodingOverride
            });
        };
    }(urlStateMachine)), urlStateMachine.exports;
}

function requireURLImpl() {
    if (hasRequiredURLImpl) return URLImpl;
    hasRequiredURLImpl = 1;
    const usm = requireUrlStateMachine();
    return URLImpl.implementation = class {
        constructor(constructorArgs) {
            const url = constructorArgs[0], base = constructorArgs[1];
            let parsedBase = null;
            if (void 0 !== base && (parsedBase = usm.basicURLParse(base), "failure" === parsedBase)) throw new TypeError("Invalid base URL");
            const parsedURL = usm.basicURLParse(url, {
                baseURL: parsedBase
            });
            if ("failure" === parsedURL) throw new TypeError("Invalid URL");
            this._url = parsedURL;
        }
        get href() {
            return usm.serializeURL(this._url);
        }
        set href(v) {
            const parsedURL = usm.basicURLParse(v);
            if ("failure" === parsedURL) throw new TypeError("Invalid URL");
            this._url = parsedURL;
        }
        get origin() {
            return usm.serializeURLOrigin(this._url);
        }
        get protocol() {
            return this._url.scheme + ":";
        }
        set protocol(v) {
            usm.basicURLParse(v + ":", {
                url: this._url,
                stateOverride: "scheme start"
            });
        }
        get username() {
            return this._url.username;
        }
        set username(v) {
            usm.cannotHaveAUsernamePasswordPort(this._url) || usm.setTheUsername(this._url, v);
        }
        get password() {
            return this._url.password;
        }
        set password(v) {
            usm.cannotHaveAUsernamePasswordPort(this._url) || usm.setThePassword(this._url, v);
        }
        get host() {
            const url = this._url;
            return null === url.host ? "" : null === url.port ? usm.serializeHost(url.host) : usm.serializeHost(url.host) + ":" + usm.serializeInteger(url.port);
        }
        set host(v) {
            this._url.cannotBeABaseURL || usm.basicURLParse(v, {
                url: this._url,
                stateOverride: "host"
            });
        }
        get hostname() {
            return null === this._url.host ? "" : usm.serializeHost(this._url.host);
        }
        set hostname(v) {
            this._url.cannotBeABaseURL || usm.basicURLParse(v, {
                url: this._url,
                stateOverride: "hostname"
            });
        }
        get port() {
            return null === this._url.port ? "" : usm.serializeInteger(this._url.port);
        }
        set port(v) {
            usm.cannotHaveAUsernamePasswordPort(this._url) || ("" === v ? this._url.port = null : usm.basicURLParse(v, {
                url: this._url,
                stateOverride: "port"
            }));
        }
        get pathname() {
            return this._url.cannotBeABaseURL ? this._url.path[0] : 0 === this._url.path.length ? "" : "/" + this._url.path.join("/");
        }
        set pathname(v) {
            this._url.cannotBeABaseURL || (this._url.path = [], usm.basicURLParse(v, {
                url: this._url,
                stateOverride: "path start"
            }));
        }
        get search() {
            return null === this._url.query || "" === this._url.query ? "" : "?" + this._url.query;
        }
        set search(v) {
            const url = this._url;
            if ("" === v) return void (url.query = null);
            const input = "?" === v[0] ? v.substring(1) : v;
            url.query = "", usm.basicURLParse(input, {
                url: url,
                stateOverride: "query"
            });
        }
        get hash() {
            return null === this._url.fragment || "" === this._url.fragment ? "" : "#" + this._url.fragment;
        }
        set hash(v) {
            if ("" === v) return void (this._url.fragment = null);
            const input = "#" === v[0] ? v.substring(1) : v;
            this._url.fragment = "", usm.basicURLParse(input, {
                url: this._url,
                stateOverride: "fragment"
            });
        }
        toJSON() {
            return this.href;
        }
    }, URLImpl;
}

function requireURL() {
    return hasRequiredURL || (hasRequiredURL = 1, function(module) {
        const conversions = requireLib$1(), utils = requireUtils(), Impl = requireURLImpl(), impl = utils.implSymbol;
        function URL(url) {
            if (!this || this[impl] || !(this instanceof URL)) throw new TypeError("Failed to construct 'URL': Please use the 'new' operator, this DOM object constructor cannot be called as a function.");
            if (arguments.length < 1) throw new TypeError("Failed to construct 'URL': 1 argument required, but only " + arguments.length + " present.");
            const args = [];
            for (let i = 0; i < arguments.length && i < 2; ++i) args[i] = arguments[i];
            args[0] = conversions.USVString(args[0]), void 0 !== args[1] && (args[1] = conversions.USVString(args[1])), 
            module.exports.setup(this, args);
        }
        URL.prototype.toJSON = function() {
            if (!this || !module.exports.is(this)) throw new TypeError("Illegal invocation");
            const args = [];
            for (let i = 0; i < arguments.length && i < 0; ++i) args[i] = arguments[i];
            return this[impl].toJSON.apply(this[impl], args);
        }, Object.defineProperty(URL.prototype, "href", {
            get() {
                return this[impl].href;
            },
            set(V) {
                V = conversions.USVString(V), this[impl].href = V;
            },
            enumerable: !0,
            configurable: !0
        }), URL.prototype.toString = function() {
            if (!this || !module.exports.is(this)) throw new TypeError("Illegal invocation");
            return this.href;
        }, Object.defineProperty(URL.prototype, "origin", {
            get() {
                return this[impl].origin;
            },
            enumerable: !0,
            configurable: !0
        }), Object.defineProperty(URL.prototype, "protocol", {
            get() {
                return this[impl].protocol;
            },
            set(V) {
                V = conversions.USVString(V), this[impl].protocol = V;
            },
            enumerable: !0,
            configurable: !0
        }), Object.defineProperty(URL.prototype, "username", {
            get() {
                return this[impl].username;
            },
            set(V) {
                V = conversions.USVString(V), this[impl].username = V;
            },
            enumerable: !0,
            configurable: !0
        }), Object.defineProperty(URL.prototype, "password", {
            get() {
                return this[impl].password;
            },
            set(V) {
                V = conversions.USVString(V), this[impl].password = V;
            },
            enumerable: !0,
            configurable: !0
        }), Object.defineProperty(URL.prototype, "host", {
            get() {
                return this[impl].host;
            },
            set(V) {
                V = conversions.USVString(V), this[impl].host = V;
            },
            enumerable: !0,
            configurable: !0
        }), Object.defineProperty(URL.prototype, "hostname", {
            get() {
                return this[impl].hostname;
            },
            set(V) {
                V = conversions.USVString(V), this[impl].hostname = V;
            },
            enumerable: !0,
            configurable: !0
        }), Object.defineProperty(URL.prototype, "port", {
            get() {
                return this[impl].port;
            },
            set(V) {
                V = conversions.USVString(V), this[impl].port = V;
            },
            enumerable: !0,
            configurable: !0
        }), Object.defineProperty(URL.prototype, "pathname", {
            get() {
                return this[impl].pathname;
            },
            set(V) {
                V = conversions.USVString(V), this[impl].pathname = V;
            },
            enumerable: !0,
            configurable: !0
        }), Object.defineProperty(URL.prototype, "search", {
            get() {
                return this[impl].search;
            },
            set(V) {
                V = conversions.USVString(V), this[impl].search = V;
            },
            enumerable: !0,
            configurable: !0
        }), Object.defineProperty(URL.prototype, "hash", {
            get() {
                return this[impl].hash;
            },
            set(V) {
                V = conversions.USVString(V), this[impl].hash = V;
            },
            enumerable: !0,
            configurable: !0
        }), module.exports = {
            is: obj => !!obj && obj[impl] instanceof Impl.implementation,
            create(constructorArgs, privateData) {
                let obj = Object.create(URL.prototype);
                return this.setup(obj, constructorArgs, privateData), obj;
            },
            setup(obj, constructorArgs, privateData) {
                privateData || (privateData = {}), privateData.wrapper = obj, obj[impl] = new Impl.implementation(constructorArgs, privateData), 
                obj[impl][utils.wrapperSymbol] = obj;
            },
            interface: URL,
            expose: {
                Window: {
                    URL: URL
                },
                Worker: {
                    URL: URL
                }
            }
        };
    }(URL$2)), URL$2.exports;
}

function requirePublicApi() {
    return hasRequiredPublicApi || (hasRequiredPublicApi = 1, publicApi.URL = requireURL().interface, 
    publicApi.serializeURL = requireUrlStateMachine().serializeURL, publicApi.serializeURLOrigin = requireUrlStateMachine().serializeURLOrigin, 
    publicApi.basicURLParse = requireUrlStateMachine().basicURLParse, publicApi.setTheUsername = requireUrlStateMachine().setTheUsername, 
    publicApi.setThePassword = requireUrlStateMachine().setThePassword, publicApi.serializeHost = requireUrlStateMachine().serializeHost, 
    publicApi.serializeInteger = requireUrlStateMachine().serializeInteger, publicApi.parseURL = requireUrlStateMachine().parseURL), 
    publicApi;
}

var publicApiExports = requirePublicApi(), whatwgUrl = getDefaultExportFromCjs(publicApiExports);

const Readable = Stream$1.Readable, BUFFER = Symbol("buffer"), TYPE = Symbol("type");

let Blob$1 = class Blob {
    constructor() {
        this[TYPE] = "";
        const blobParts = arguments[0], options = arguments[1], buffers = [];
        let size = 0;
        if (blobParts) {
            const a = blobParts, length = Number(a.length);
            for (let i = 0; i < length; i++) {
                const element = a[i];
                let buffer;
                buffer = element instanceof Buffer ? element : ArrayBuffer.isView(element) ? Buffer.from(element.buffer, element.byteOffset, element.byteLength) : element instanceof ArrayBuffer ? Buffer.from(element) : element instanceof Blob ? element[BUFFER] : Buffer.from("string" == typeof element ? element : String(element)), 
                size += buffer.length, buffers.push(buffer);
            }
        }
        this[BUFFER] = Buffer.concat(buffers);
        let type = options && void 0 !== options.type && String(options.type).toLowerCase();
        type && !/[^\u0020-\u007E]/.test(type) && (this[TYPE] = type);
    }
    get size() {
        return this[BUFFER].length;
    }
    get type() {
        return this[TYPE];
    }
    text() {
        return Promise.resolve(this[BUFFER].toString());
    }
    arrayBuffer() {
        const buf = this[BUFFER], ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
        return Promise.resolve(ab);
    }
    stream() {
        const readable = new Readable;
        return readable._read = function() {}, readable.push(this[BUFFER]), readable.push(null), 
        readable;
    }
    toString() {
        return "[object Blob]";
    }
    slice() {
        const size = this.size, start = arguments[0], end = arguments[1];
        let relativeStart, relativeEnd;
        relativeStart = void 0 === start ? 0 : start < 0 ? Math.max(size + start, 0) : Math.min(start, size), 
        relativeEnd = void 0 === end ? size : end < 0 ? Math.max(size + end, 0) : Math.min(end, size);
        const span = Math.max(relativeEnd - relativeStart, 0), slicedBuffer = this[BUFFER].slice(relativeStart, relativeStart + span), blob = new Blob([], {
            type: arguments[2]
        });
        return blob[BUFFER] = slicedBuffer, blob;
    }
}, convert;

function FetchError(message, type, systemError) {
    Error.call(this, message), this.message = message, this.type = type, systemError && (this.code = this.errno = systemError.code), 
    Error.captureStackTrace(this, this.constructor);
}

Object.defineProperties(Blob$1.prototype, {
    size: {
        enumerable: !0
    },
    type: {
        enumerable: !0
    },
    slice: {
        enumerable: !0
    }
}), Object.defineProperty(Blob$1.prototype, Symbol.toStringTag, {
    value: "Blob",
    writable: !1,
    enumerable: !1,
    configurable: !0
}), FetchError.prototype = Object.create(Error.prototype), FetchError.prototype.constructor = FetchError, 
FetchError.prototype.name = "FetchError";

try {
    convert = require("encoding").convert;
} catch (e) {}

const INTERNALS = Symbol("Body internals"), PassThrough = Stream$1.PassThrough;

function Body(body) {
    var _this = this, _ref = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, _ref$size = _ref.size;
    let size = void 0 === _ref$size ? 0 : _ref$size;
    var _ref$timeout = _ref.timeout;
    let timeout = void 0 === _ref$timeout ? 0 : _ref$timeout;
    null == body ? body = null : isURLSearchParams(body) ? body = Buffer.from(body.toString()) : isBlob(body) || Buffer.isBuffer(body) || ("[object ArrayBuffer]" === Object.prototype.toString.call(body) ? body = Buffer.from(body) : ArrayBuffer.isView(body) ? body = Buffer.from(body.buffer, body.byteOffset, body.byteLength) : body instanceof Stream$1 || (body = Buffer.from(String(body)))), 
    this[INTERNALS] = {
        body: body,
        disturbed: !1,
        error: null
    }, this.size = size, this.timeout = timeout, body instanceof Stream$1 && body.on("error", (function(err) {
        const error = "AbortError" === err.name ? err : new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, "system", err);
        _this[INTERNALS].error = error;
    }));
}

function consumeBody() {
    var _this4 = this;
    if (this[INTERNALS].disturbed) return Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));
    if (this[INTERNALS].disturbed = !0, this[INTERNALS].error) return Body.Promise.reject(this[INTERNALS].error);
    let body = this.body;
    if (null === body) return Body.Promise.resolve(Buffer.alloc(0));
    if (isBlob(body) && (body = body.stream()), Buffer.isBuffer(body)) return Body.Promise.resolve(body);
    if (!(body instanceof Stream$1)) return Body.Promise.resolve(Buffer.alloc(0));
    let accum = [], accumBytes = 0, abort = !1;
    return new Body.Promise((function(resolve, reject) {
        let resTimeout;
        _this4.timeout && (resTimeout = setTimeout((function() {
            abort = !0, reject(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, "body-timeout"));
        }), _this4.timeout)), body.on("error", (function(err) {
            "AbortError" === err.name ? (abort = !0, reject(err)) : reject(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, "system", err));
        })), body.on("data", (function(chunk) {
            if (!abort && null !== chunk) {
                if (_this4.size && accumBytes + chunk.length > _this4.size) return abort = !0, void reject(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, "max-size"));
                accumBytes += chunk.length, accum.push(chunk);
            }
        })), body.on("end", (function() {
            if (!abort) {
                clearTimeout(resTimeout);
                try {
                    resolve(Buffer.concat(accum, accumBytes));
                } catch (err) {
                    reject(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, "system", err));
                }
            }
        }));
    }));
}

function convertBody(buffer, headers) {
    if ("function" != typeof convert) throw new Error("The package `encoding` must be installed to use the textConverted() function");
    const ct = headers.get("content-type");
    let res, str, charset = "utf-8";
    return ct && (res = /charset=([^;]*)/i.exec(ct)), str = buffer.slice(0, 1024).toString(), 
    !res && str && (res = /<meta.+?charset=(['"])(.+?)\1/i.exec(str)), !res && str && (res = /<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(str), 
    res || (res = /<meta[\s]+?content=(['"])(.+?)\1[\s]+?http-equiv=(['"])content-type\3/i.exec(str), 
    res && res.pop()), res && (res = /charset=(.*)/i.exec(res.pop()))), !res && str && (res = /<\?xml.+?encoding=(['"])(.+?)\1/i.exec(str)), 
    res && (charset = res.pop(), "gb2312" !== charset && "gbk" !== charset || (charset = "gb18030")), 
    convert(buffer, "UTF-8", charset).toString();
}

function isURLSearchParams(obj) {
    return "object" == typeof obj && "function" == typeof obj.append && "function" == typeof obj.delete && "function" == typeof obj.get && "function" == typeof obj.getAll && "function" == typeof obj.has && "function" == typeof obj.set && ("URLSearchParams" === obj.constructor.name || "[object URLSearchParams]" === Object.prototype.toString.call(obj) || "function" == typeof obj.sort);
}

function isBlob(obj) {
    return "object" == typeof obj && "function" == typeof obj.arrayBuffer && "string" == typeof obj.type && "function" == typeof obj.stream && "function" == typeof obj.constructor && "string" == typeof obj.constructor.name && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);
}

function clone(instance) {
    let p1, p2, body = instance.body;
    if (instance.bodyUsed) throw new Error("cannot clone body after it is used");
    return body instanceof Stream$1 && "function" != typeof body.getBoundary && (p1 = new PassThrough, 
    p2 = new PassThrough, body.pipe(p1), body.pipe(p2), instance[INTERNALS].body = p1, 
    body = p2), body;
}

function extractContentType(body) {
    return null === body ? null : "string" == typeof body ? "text/plain;charset=UTF-8" : isURLSearchParams(body) ? "application/x-www-form-urlencoded;charset=UTF-8" : isBlob(body) ? body.type || null : Buffer.isBuffer(body) || "[object ArrayBuffer]" === Object.prototype.toString.call(body) || ArrayBuffer.isView(body) ? null : "function" == typeof body.getBoundary ? `multipart/form-data;boundary=${body.getBoundary()}` : body instanceof Stream$1 ? null : "text/plain;charset=UTF-8";
}

Body.prototype = {
    get body() {
        return this[INTERNALS].body;
    },
    get bodyUsed() {
        return this[INTERNALS].disturbed;
    },
    arrayBuffer() {
        return consumeBody.call(this).then((function(buf) {
            return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
        }));
    },
    blob() {
        let ct = this.headers && this.headers.get("content-type") || "";
        return consumeBody.call(this).then((function(buf) {
            return Object.assign(new Blob$1([], {
                type: ct.toLowerCase()
            }), {
                [BUFFER]: buf
            });
        }));
    },
    json() {
        var _this2 = this;
        return consumeBody.call(this).then((function(buffer) {
            try {
                return JSON.parse(buffer.toString());
            } catch (err) {
                return Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, "invalid-json"));
            }
        }));
    },
    text() {
        return consumeBody.call(this).then((function(buffer) {
            return buffer.toString();
        }));
    },
    buffer() {
        return consumeBody.call(this);
    },
    textConverted() {
        var _this3 = this;
        return consumeBody.call(this).then((function(buffer) {
            return convertBody(buffer, _this3.headers);
        }));
    }
}, Object.defineProperties(Body.prototype, {
    body: {
        enumerable: !0
    },
    bodyUsed: {
        enumerable: !0
    },
    arrayBuffer: {
        enumerable: !0
    },
    blob: {
        enumerable: !0
    },
    json: {
        enumerable: !0
    },
    text: {
        enumerable: !0
    }
}), Body.mixIn = function(proto) {
    for (const name of Object.getOwnPropertyNames(Body.prototype)) if (!(name in proto)) {
        const desc = Object.getOwnPropertyDescriptor(Body.prototype, name);
        Object.defineProperty(proto, name, desc);
    }
}, Body.Promise = global.Promise;

const invalidTokenRegex = /[^\^_`a-zA-Z\-0-9!#$%&'*+.|~]/, invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/;

function validateName(name) {
    if (name = `${name}`, invalidTokenRegex.test(name) || "" === name) throw new TypeError(`${name} is not a legal HTTP header name`);
}

function validateValue(value) {
    if (value = `${value}`, invalidHeaderCharRegex.test(value)) throw new TypeError(`${value} is not a legal HTTP header value`);
}

function find(map, name) {
    name = name.toLowerCase();
    for (const key in map) if (key.toLowerCase() === name) return key;
}

const MAP = Symbol("map");

class Headers {
    constructor() {
        let init = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : void 0;
        if (this[MAP] = Object.create(null), init instanceof Headers) {
            const rawHeaders = init.raw(), headerNames = Object.keys(rawHeaders);
            for (const headerName of headerNames) for (const value of rawHeaders[headerName]) this.append(headerName, value);
        } else if (null == init) ; else {
            if ("object" != typeof init) throw new TypeError("Provided initializer must be an object");
            {
                const method = init[Symbol.iterator];
                if (null != method) {
                    if ("function" != typeof method) throw new TypeError("Header pairs must be iterable");
                    const pairs = [];
                    for (const pair of init) {
                        if ("object" != typeof pair || "function" != typeof pair[Symbol.iterator]) throw new TypeError("Each header pair must be iterable");
                        pairs.push(Array.from(pair));
                    }
                    for (const pair of pairs) {
                        if (2 !== pair.length) throw new TypeError("Each header pair must be a name/value tuple");
                        this.append(pair[0], pair[1]);
                    }
                } else for (const key of Object.keys(init)) {
                    const value = init[key];
                    this.append(key, value);
                }
            }
        }
    }
    get(name) {
        validateName(name = `${name}`);
        const key = find(this[MAP], name);
        return void 0 === key ? null : this[MAP][key].join(", ");
    }
    forEach(callback) {
        let thisArg = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : void 0, pairs = getHeaders(this), i = 0;
        for (;i < pairs.length; ) {
            var _pairs$i = pairs[i];
            const name = _pairs$i[0], value = _pairs$i[1];
            callback.call(thisArg, value, name, this), pairs = getHeaders(this), i++;
        }
    }
    set(name, value) {
        value = `${value}`, validateName(name = `${name}`), validateValue(value);
        const key = find(this[MAP], name);
        this[MAP][void 0 !== key ? key : name] = [ value ];
    }
    append(name, value) {
        value = `${value}`, validateName(name = `${name}`), validateValue(value);
        const key = find(this[MAP], name);
        void 0 !== key ? this[MAP][key].push(value) : this[MAP][name] = [ value ];
    }
    has(name) {
        return validateName(name = `${name}`), void 0 !== find(this[MAP], name);
    }
    delete(name) {
        validateName(name = `${name}`);
        const key = find(this[MAP], name);
        void 0 !== key && delete this[MAP][key];
    }
    raw() {
        return this[MAP];
    }
    keys() {
        return createHeadersIterator(this, "key");
    }
    values() {
        return createHeadersIterator(this, "value");
    }
    [Symbol.iterator]() {
        return createHeadersIterator(this, "key+value");
    }
}

function getHeaders(headers) {
    let kind = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "key+value";
    return Object.keys(headers[MAP]).sort().map("key" === kind ? function(k) {
        return k.toLowerCase();
    } : "value" === kind ? function(k) {
        return headers[MAP][k].join(", ");
    } : function(k) {
        return [ k.toLowerCase(), headers[MAP][k].join(", ") ];
    });
}

Headers.prototype.entries = Headers.prototype[Symbol.iterator], Object.defineProperty(Headers.prototype, Symbol.toStringTag, {
    value: "Headers",
    writable: !1,
    enumerable: !1,
    configurable: !0
}), Object.defineProperties(Headers.prototype, {
    get: {
        enumerable: !0
    },
    forEach: {
        enumerable: !0
    },
    set: {
        enumerable: !0
    },
    append: {
        enumerable: !0
    },
    has: {
        enumerable: !0
    },
    delete: {
        enumerable: !0
    },
    keys: {
        enumerable: !0
    },
    values: {
        enumerable: !0
    },
    entries: {
        enumerable: !0
    }
});

const INTERNAL = Symbol("internal");

function createHeadersIterator(target, kind) {
    const iterator = Object.create(HeadersIteratorPrototype);
    return iterator[INTERNAL] = {
        target: target,
        kind: kind,
        index: 0
    }, iterator;
}

const HeadersIteratorPrototype = Object.setPrototypeOf({
    next() {
        if (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) throw new TypeError("Value of `this` is not a HeadersIterator");
        var _INTERNAL = this[INTERNAL];
        const target = _INTERNAL.target, kind = _INTERNAL.kind, index = _INTERNAL.index, values = getHeaders(target, kind);
        return index >= values.length ? {
            value: void 0,
            done: !0
        } : (this[INTERNAL].index = index + 1, {
            value: values[index],
            done: !1
        });
    }
}, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));

Object.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {
    value: "HeadersIterator",
    writable: !1,
    enumerable: !1,
    configurable: !0
});

const INTERNALS$1 = Symbol("Response internals"), STATUS_CODES = http.STATUS_CODES;

class Response {
    constructor() {
        let body = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, opts = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        Body.call(this, body, opts);
        const status = opts.status || 200, headers = new Headers(opts.headers);
        if (null != body && !headers.has("Content-Type")) {
            const contentType = extractContentType(body);
            contentType && headers.append("Content-Type", contentType);
        }
        this[INTERNALS$1] = {
            url: opts.url,
            status: status,
            statusText: opts.statusText || STATUS_CODES[status],
            headers: headers,
            counter: opts.counter
        };
    }
    get url() {
        return this[INTERNALS$1].url || "";
    }
    get status() {
        return this[INTERNALS$1].status;
    }
    get ok() {
        return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
    }
    get redirected() {
        return this[INTERNALS$1].counter > 0;
    }
    get statusText() {
        return this[INTERNALS$1].statusText;
    }
    get headers() {
        return this[INTERNALS$1].headers;
    }
    clone() {
        return new Response(clone(this), {
            url: this.url,
            status: this.status,
            statusText: this.statusText,
            headers: this.headers,
            ok: this.ok,
            redirected: this.redirected
        });
    }
}

Body.mixIn(Response.prototype), Object.defineProperties(Response.prototype, {
    url: {
        enumerable: !0
    },
    status: {
        enumerable: !0
    },
    ok: {
        enumerable: !0
    },
    redirected: {
        enumerable: !0
    },
    statusText: {
        enumerable: !0
    },
    headers: {
        enumerable: !0
    },
    clone: {
        enumerable: !0
    }
}), Object.defineProperty(Response.prototype, Symbol.toStringTag, {
    value: "Response",
    writable: !1,
    enumerable: !1,
    configurable: !0
});

const INTERNALS$2 = Symbol("Request internals"), URL$1 = Url.URL || whatwgUrl.URL, parse_url = Url.parse, format_url = Url.format;

function parseURL(urlStr) {
    return /^[a-zA-Z][a-zA-Z\d+\-.]*:/.exec(urlStr) && (urlStr = new URL$1(urlStr).toString()), 
    parse_url(urlStr);
}

function isRequest(input) {
    return "object" == typeof input && "object" == typeof input[INTERNALS$2];
}

function isAbortSignal(signal) {
    const proto = signal && "object" == typeof signal && Object.getPrototypeOf(signal);
    return !(!proto || "AbortSignal" !== proto.constructor.name);
}

Stream$1.Readable.prototype;

class Request {
    constructor(input) {
        let parsedURL, init = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        isRequest(input) ? parsedURL = parseURL(input.url) : (parsedURL = input && input.href ? parseURL(input.href) : parseURL(`${input}`), 
        input = {});
        let method = init.method || input.method || "GET";
        if (method = method.toUpperCase(), (null != init.body || isRequest(input) && null !== input.body) && ("GET" === method || "HEAD" === method)) throw new TypeError("Request with GET/HEAD method cannot have body");
        let inputBody = null != init.body ? init.body : isRequest(input) && null !== input.body ? clone(input) : null;
        Body.call(this, inputBody, {
            timeout: init.timeout || input.timeout || 0,
            size: init.size || input.size || 0
        });
        const headers = new Headers(init.headers || input.headers || {});
        if (null != inputBody && !headers.has("Content-Type")) {
            const contentType = extractContentType(inputBody);
            contentType && headers.append("Content-Type", contentType);
        }
        let signal = isRequest(input) ? input.signal : null;
        if ("signal" in init && (signal = init.signal), null != signal && !isAbortSignal(signal)) throw new TypeError("Expected signal to be an instanceof AbortSignal");
        this[INTERNALS$2] = {
            method: method,
            redirect: init.redirect || input.redirect || "follow",
            headers: headers,
            parsedURL: parsedURL,
            signal: signal
        }, this.follow = void 0 !== init.follow ? init.follow : void 0 !== input.follow ? input.follow : 20, 
        this.compress = void 0 !== init.compress ? init.compress : void 0 === input.compress || input.compress, 
        this.counter = init.counter || input.counter || 0, this.agent = init.agent || input.agent;
    }
    get method() {
        return this[INTERNALS$2].method;
    }
    get url() {
        return format_url(this[INTERNALS$2].parsedURL);
    }
    get headers() {
        return this[INTERNALS$2].headers;
    }
    get redirect() {
        return this[INTERNALS$2].redirect;
    }
    get signal() {
        return this[INTERNALS$2].signal;
    }
    clone() {
        return new Request(this);
    }
}

function AbortError(message) {
    Error.call(this, message), this.type = "aborted", this.message = message, Error.captureStackTrace(this, this.constructor);
}

Body.mixIn(Request.prototype), Object.defineProperty(Request.prototype, Symbol.toStringTag, {
    value: "Request",
    writable: !1,
    enumerable: !1,
    configurable: !0
}), Object.defineProperties(Request.prototype, {
    method: {
        enumerable: !0
    },
    url: {
        enumerable: !0
    },
    headers: {
        enumerable: !0
    },
    redirect: {
        enumerable: !0
    },
    clone: {
        enumerable: !0
    },
    signal: {
        enumerable: !0
    }
}), AbortError.prototype = Object.create(Error.prototype), AbortError.prototype.constructor = AbortError, 
AbortError.prototype.name = "AbortError", Url.URL || whatwgUrl.URL, Stream$1.PassThrough;

var bufferUtil = {
    exports: {}
}, constants$1, hasRequiredConstants;

function requireConstants() {
    if (hasRequiredConstants) return constants$1;
    hasRequiredConstants = 1;
    const BINARY_TYPES = [ "nodebuffer", "arraybuffer", "fragments" ], hasBlob = "undefined" != typeof Blob;
    return hasBlob && BINARY_TYPES.push("blob"), constants$1 = {
        BINARY_TYPES: BINARY_TYPES,
        EMPTY_BUFFER: Buffer.alloc(0),
        GUID: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
        hasBlob: hasBlob,
        kForOnEventAttribute: Symbol("kIsForOnEventAttribute"),
        kListener: Symbol("kListener"),
        kStatusCode: Symbol("status-code"),
        kWebSocket: Symbol("websocket"),
        NOOP: () => {}
    };
}

var bufferutil = {
    exports: {}
}, nodeGypBuild$1 = {
    exports: {}
}, nodeGypBuild, hasRequiredNodeGypBuild$1, hasRequiredNodeGypBuild, fallback$1, hasRequiredFallback$1, hasRequiredBufferutil, hasRequiredBufferUtil, limiter, hasRequiredLimiter, permessageDeflate, hasRequiredPermessageDeflate;

function requireNodeGypBuild$1() {
    if (hasRequiredNodeGypBuild$1) return nodeGypBuild;
    hasRequiredNodeGypBuild$1 = 1;
    var fs$1 = fs, path$1 = path, os = require$$2$2, runtimeRequire = "function" == typeof __webpack_require__ ? __non_webpack_require__ : commonjsRequire, vars = process.config && process.config.variables || {}, prebuildsOnly = !!process.env.PREBUILDS_ONLY, abi = process.versions.modules, runtime = !(!process.versions || !process.versions.electron) || !!process.env.ELECTRON_RUN_AS_NODE || "undefined" != typeof window && window.process && "renderer" === window.process.type ? "electron" : process.versions && process.versions.nw ? "node-webkit" : "node", arch = process.env.npm_config_arch || os.arch(), platform = process.env.npm_config_platform || os.platform(), libc = process.env.LIBC || (function(platform) {
        return "linux" === platform && fs$1.existsSync("/etc/alpine-release");
    }(platform) ? "musl" : "glibc"), armv = process.env.ARM_VERSION || ("arm64" === arch ? "8" : vars.arm_version) || "", uv = (process.versions.uv || "").split(".")[0];
    function load(dir) {
        return runtimeRequire(load.resolve(dir));
    }
    function readdirSync(dir) {
        try {
            return fs$1.readdirSync(dir);
        } catch (err) {
            return [];
        }
    }
    function getFirst(dir, filter) {
        var files = readdirSync(dir).filter(filter);
        return files[0] && path$1.join(dir, files[0]);
    }
    function matchBuild(name) {
        return /\.node$/.test(name);
    }
    function parseTuple(name) {
        var arr = name.split("-");
        if (2 === arr.length) {
            var platform = arr[0], architectures = arr[1].split("+");
            if (platform && architectures.length && architectures.every(Boolean)) return {
                name: name,
                platform: platform,
                architectures: architectures
            };
        }
    }
    function matchTuple(platform, arch) {
        return function(tuple) {
            return null != tuple && (tuple.platform === platform && tuple.architectures.includes(arch));
        };
    }
    function compareTuples(a, b) {
        return a.architectures.length - b.architectures.length;
    }
    function parseTags(file) {
        var arr = file.split("."), tags = {
            file: file,
            specificity: 0
        };
        if ("node" === arr.pop()) {
            for (var i = 0; i < arr.length; i++) {
                var tag = arr[i];
                if ("node" === tag || "electron" === tag || "node-webkit" === tag) tags.runtime = tag; else if ("napi" === tag) tags.napi = !0; else if ("abi" === tag.slice(0, 3)) tags.abi = tag.slice(3); else if ("uv" === tag.slice(0, 2)) tags.uv = tag.slice(2); else if ("armv" === tag.slice(0, 4)) tags.armv = tag.slice(4); else {
                    if ("glibc" !== tag && "musl" !== tag) continue;
                    tags.libc = tag;
                }
                tags.specificity++;
            }
            return tags;
        }
    }
    function matchTags(runtime, abi) {
        return function(tags) {
            return null != tags && (!(tags.runtime && tags.runtime !== runtime && !function(tags) {
                return "node" === tags.runtime && tags.napi;
            }(tags)) && (!(tags.abi && tags.abi !== abi && !tags.napi) && ((!tags.uv || tags.uv === uv) && ((!tags.armv || tags.armv === armv) && (!tags.libc || tags.libc === libc)))));
        };
    }
    function compareTags(runtime) {
        return function(a, b) {
            return a.runtime !== b.runtime ? a.runtime === runtime ? -1 : 1 : a.abi !== b.abi ? a.abi ? -1 : 1 : a.specificity !== b.specificity ? a.specificity > b.specificity ? -1 : 1 : 0;
        };
    }
    return nodeGypBuild = load, load.resolve = load.path = function(dir) {
        dir = path$1.resolve(dir || ".");
        try {
            var name = runtimeRequire(path$1.join(dir, "package.json")).name.toUpperCase().replace(/-/g, "_");
            process.env[name + "_PREBUILD"] && (dir = process.env[name + "_PREBUILD"]);
        } catch (err) {}
        if (!prebuildsOnly) {
            var release = getFirst(path$1.join(dir, "build/Release"), matchBuild);
            if (release) return release;
            var debug = getFirst(path$1.join(dir, "build/Debug"), matchBuild);
            if (debug) return debug;
        }
        var prebuild = resolve(dir);
        if (prebuild) return prebuild;
        var nearby = resolve(path$1.dirname(process.execPath));
        if (nearby) return nearby;
        var target = [ "platform=" + platform, "arch=" + arch, "runtime=" + runtime, "abi=" + abi, "uv=" + uv, armv ? "armv=" + armv : "", "libc=" + libc, "node=" + process.versions.node, process.versions.electron ? "electron=" + process.versions.electron : "", "function" == typeof __webpack_require__ ? "webpack=true" : "" ].filter(Boolean).join(" ");
        throw new Error("No native build was found for " + target + "\n    loaded from: " + dir + "\n");
        function resolve(dir) {
            var tuple = readdirSync(path$1.join(dir, "prebuilds")).map(parseTuple).filter(matchTuple(platform, arch)).sort(compareTuples)[0];
            if (tuple) {
                var prebuilds = path$1.join(dir, "prebuilds", tuple.name), winner = readdirSync(prebuilds).map(parseTags).filter(matchTags(runtime, abi)).sort(compareTags(runtime))[0];
                return winner ? path$1.join(prebuilds, winner.file) : void 0;
            }
        }
    }, load.parseTags = parseTags, load.matchTags = matchTags, load.compareTags = compareTags, 
    load.parseTuple = parseTuple, load.matchTuple = matchTuple, load.compareTuples = compareTuples, 
    nodeGypBuild;
}

function requireNodeGypBuild() {
    if (hasRequiredNodeGypBuild) return nodeGypBuild$1.exports;
    hasRequiredNodeGypBuild = 1;
    const runtimeRequire = "function" == typeof __webpack_require__ ? __non_webpack_require__ : commonjsRequire;
    return "function" == typeof runtimeRequire.addon ? nodeGypBuild$1.exports = runtimeRequire.addon.bind(runtimeRequire) : nodeGypBuild$1.exports = requireNodeGypBuild$1(), 
    nodeGypBuild$1.exports;
}

function requireFallback$1() {
    if (hasRequiredFallback$1) return fallback$1;
    hasRequiredFallback$1 = 1;
    return fallback$1 = {
        mask: (source, mask, output, offset, length) => {
            for (var i = 0; i < length; i++) output[offset + i] = source[i] ^ mask[3 & i];
        },
        unmask: (buffer, mask) => {
            const length = buffer.length;
            for (var i = 0; i < length; i++) buffer[i] ^= mask[3 & i];
        }
    }, fallback$1;
}

function requireBufferutil() {
    if (hasRequiredBufferutil) return bufferutil.exports;
    hasRequiredBufferutil = 1;
    try {
        bufferutil.exports = requireNodeGypBuild()(__dirname);
    } catch (e) {
        bufferutil.exports = requireFallback$1();
    }
    return bufferutil.exports;
}

function requireBufferUtil() {
    if (hasRequiredBufferUtil) return bufferUtil.exports;
    hasRequiredBufferUtil = 1;
    const {EMPTY_BUFFER: EMPTY_BUFFER} = requireConstants(), FastBuffer = Buffer[Symbol.species];
    function _mask(source, mask, output, offset, length) {
        for (let i = 0; i < length; i++) output[offset + i] = source[i] ^ mask[3 & i];
    }
    function _unmask(buffer, mask) {
        for (let i = 0; i < buffer.length; i++) buffer[i] ^= mask[3 & i];
    }
    if (bufferUtil.exports = {
        concat: function(list, totalLength) {
            if (0 === list.length) return EMPTY_BUFFER;
            if (1 === list.length) return list[0];
            const target = Buffer.allocUnsafe(totalLength);
            let offset = 0;
            for (let i = 0; i < list.length; i++) {
                const buf = list[i];
                target.set(buf, offset), offset += buf.length;
            }
            return offset < totalLength ? new FastBuffer(target.buffer, target.byteOffset, offset) : target;
        },
        mask: _mask,
        toArrayBuffer: function(buf) {
            return buf.length === buf.buffer.byteLength ? buf.buffer : buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);
        },
        toBuffer: function toBuffer(data) {
            if (toBuffer.readOnly = !0, Buffer.isBuffer(data)) return data;
            let buf;
            return data instanceof ArrayBuffer ? buf = new FastBuffer(data) : ArrayBuffer.isView(data) ? buf = new FastBuffer(data.buffer, data.byteOffset, data.byteLength) : (buf = Buffer.from(data), 
            toBuffer.readOnly = !1), buf;
        },
        unmask: _unmask
    }, !process.env.WS_NO_BUFFER_UTIL) try {
        const bufferUtil$1 = requireBufferutil();
        bufferUtil.exports.mask = function(source, mask, output, offset, length) {
            length < 48 ? _mask(source, mask, output, offset, length) : bufferUtil$1.mask(source, mask, output, offset, length);
        }, bufferUtil.exports.unmask = function(buffer, mask) {
            buffer.length < 32 ? _unmask(buffer, mask) : bufferUtil$1.unmask(buffer, mask);
        };
    } catch (e) {}
    return bufferUtil.exports;
}

function requireLimiter() {
    if (hasRequiredLimiter) return limiter;
    hasRequiredLimiter = 1;
    const kDone = Symbol("kDone"), kRun = Symbol("kRun");
    return limiter = class {
        constructor(concurrency) {
            this[kDone] = () => {
                this.pending--, this[kRun]();
            }, this.concurrency = concurrency || 1 / 0, this.jobs = [], this.pending = 0;
        }
        add(job) {
            this.jobs.push(job), this[kRun]();
        }
        [kRun]() {
            if (this.pending !== this.concurrency && this.jobs.length) {
                const job = this.jobs.shift();
                this.pending++, job(this[kDone]);
            }
        }
    };
}

function requirePermessageDeflate() {
    if (hasRequiredPermessageDeflate) return permessageDeflate;
    hasRequiredPermessageDeflate = 1;
    const zlib$1 = zlib, bufferUtil = requireBufferUtil(), Limiter = requireLimiter(), {kStatusCode: kStatusCode} = requireConstants(), FastBuffer = Buffer[Symbol.species], TRAILER = Buffer.from([ 0, 0, 255, 255 ]), kPerMessageDeflate = Symbol("permessage-deflate"), kTotalLength = Symbol("total-length"), kCallback = Symbol("callback"), kBuffers = Symbol("buffers"), kError = Symbol("error");
    let zlibLimiter;
    function deflateOnData(chunk) {
        this[kBuffers].push(chunk), this[kTotalLength] += chunk.length;
    }
    function inflateOnData(chunk) {
        this[kTotalLength] += chunk.length, this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload ? this[kBuffers].push(chunk) : (this[kError] = new RangeError("Max payload size exceeded"), 
        this[kError].code = "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH", this[kError][kStatusCode] = 1009, 
        this.removeListener("data", inflateOnData), this.reset());
    }
    function inflateOnError(err) {
        this[kPerMessageDeflate]._inflate = null, err[kStatusCode] = 1007, this[kCallback](err);
    }
    return permessageDeflate = class {
        constructor(options, isServer, maxPayload) {
            if (this._maxPayload = 0 | maxPayload, this._options = options || {}, this._threshold = void 0 !== this._options.threshold ? this._options.threshold : 1024, 
            this._isServer = !!isServer, this._deflate = null, this._inflate = null, this.params = null, 
            !zlibLimiter) {
                const concurrency = void 0 !== this._options.concurrencyLimit ? this._options.concurrencyLimit : 10;
                zlibLimiter = new Limiter(concurrency);
            }
        }
        static get extensionName() {
            return "permessage-deflate";
        }
        offer() {
            const params = {};
            return this._options.serverNoContextTakeover && (params.server_no_context_takeover = !0), 
            this._options.clientNoContextTakeover && (params.client_no_context_takeover = !0), 
            this._options.serverMaxWindowBits && (params.server_max_window_bits = this._options.serverMaxWindowBits), 
            this._options.clientMaxWindowBits ? params.client_max_window_bits = this._options.clientMaxWindowBits : null == this._options.clientMaxWindowBits && (params.client_max_window_bits = !0), 
            params;
        }
        accept(configurations) {
            return configurations = this.normalizeParams(configurations), this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations), 
            this.params;
        }
        cleanup() {
            if (this._inflate && (this._inflate.close(), this._inflate = null), this._deflate) {
                const callback = this._deflate[kCallback];
                this._deflate.close(), this._deflate = null, callback && callback(new Error("The deflate stream was closed while data was being processed"));
            }
        }
        acceptAsServer(offers) {
            const opts = this._options, accepted = offers.find((params => !(!1 === opts.serverNoContextTakeover && params.server_no_context_takeover || params.server_max_window_bits && (!1 === opts.serverMaxWindowBits || "number" == typeof opts.serverMaxWindowBits && opts.serverMaxWindowBits > params.server_max_window_bits) || "number" == typeof opts.clientMaxWindowBits && !params.client_max_window_bits)));
            if (!accepted) throw new Error("None of the extension offers can be accepted");
            return opts.serverNoContextTakeover && (accepted.server_no_context_takeover = !0), 
            opts.clientNoContextTakeover && (accepted.client_no_context_takeover = !0), "number" == typeof opts.serverMaxWindowBits && (accepted.server_max_window_bits = opts.serverMaxWindowBits), 
            "number" == typeof opts.clientMaxWindowBits ? accepted.client_max_window_bits = opts.clientMaxWindowBits : !0 !== accepted.client_max_window_bits && !1 !== opts.clientMaxWindowBits || delete accepted.client_max_window_bits, 
            accepted;
        }
        acceptAsClient(response) {
            const params = response[0];
            if (!1 === this._options.clientNoContextTakeover && params.client_no_context_takeover) throw new Error('Unexpected parameter "client_no_context_takeover"');
            if (params.client_max_window_bits) {
                if (!1 === this._options.clientMaxWindowBits || "number" == typeof this._options.clientMaxWindowBits && params.client_max_window_bits > this._options.clientMaxWindowBits) throw new Error('Unexpected or invalid parameter "client_max_window_bits"');
            } else "number" == typeof this._options.clientMaxWindowBits && (params.client_max_window_bits = this._options.clientMaxWindowBits);
            return params;
        }
        normalizeParams(configurations) {
            return configurations.forEach((params => {
                Object.keys(params).forEach((key => {
                    let value = params[key];
                    if (value.length > 1) throw new Error(`Parameter "${key}" must have only a single value`);
                    if (value = value[0], "client_max_window_bits" === key) {
                        if (!0 !== value) {
                            const num = +value;
                            if (!Number.isInteger(num) || num < 8 || num > 15) throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
                            value = num;
                        } else if (!this._isServer) throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
                    } else if ("server_max_window_bits" === key) {
                        const num = +value;
                        if (!Number.isInteger(num) || num < 8 || num > 15) throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
                        value = num;
                    } else {
                        if ("client_no_context_takeover" !== key && "server_no_context_takeover" !== key) throw new Error(`Unknown parameter "${key}"`);
                        if (!0 !== value) throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
                    }
                    params[key] = value;
                }));
            })), configurations;
        }
        decompress(data, fin, callback) {
            zlibLimiter.add((done => {
                this._decompress(data, fin, ((err, result) => {
                    done(), callback(err, result);
                }));
            }));
        }
        compress(data, fin, callback) {
            zlibLimiter.add((done => {
                this._compress(data, fin, ((err, result) => {
                    done(), callback(err, result);
                }));
            }));
        }
        _decompress(data, fin, callback) {
            const endpoint = this._isServer ? "client" : "server";
            if (!this._inflate) {
                const key = `${endpoint}_max_window_bits`, windowBits = "number" != typeof this.params[key] ? zlib$1.Z_DEFAULT_WINDOWBITS : this.params[key];
                this._inflate = zlib$1.createInflateRaw({
                    ...this._options.zlibInflateOptions,
                    windowBits: windowBits
                }), this._inflate[kPerMessageDeflate] = this, this._inflate[kTotalLength] = 0, this._inflate[kBuffers] = [], 
                this._inflate.on("error", inflateOnError), this._inflate.on("data", inflateOnData);
            }
            this._inflate[kCallback] = callback, this._inflate.write(data), fin && this._inflate.write(TRAILER), 
            this._inflate.flush((() => {
                const err = this._inflate[kError];
                if (err) return this._inflate.close(), this._inflate = null, void callback(err);
                const data = bufferUtil.concat(this._inflate[kBuffers], this._inflate[kTotalLength]);
                this._inflate._readableState.endEmitted ? (this._inflate.close(), this._inflate = null) : (this._inflate[kTotalLength] = 0, 
                this._inflate[kBuffers] = [], fin && this.params[`${endpoint}_no_context_takeover`] && this._inflate.reset()), 
                callback(null, data);
            }));
        }
        _compress(data, fin, callback) {
            const endpoint = this._isServer ? "server" : "client";
            if (!this._deflate) {
                const key = `${endpoint}_max_window_bits`, windowBits = "number" != typeof this.params[key] ? zlib$1.Z_DEFAULT_WINDOWBITS : this.params[key];
                this._deflate = zlib$1.createDeflateRaw({
                    ...this._options.zlibDeflateOptions,
                    windowBits: windowBits
                }), this._deflate[kTotalLength] = 0, this._deflate[kBuffers] = [], this._deflate.on("data", deflateOnData);
            }
            this._deflate[kCallback] = callback, this._deflate.write(data), this._deflate.flush(zlib$1.Z_SYNC_FLUSH, (() => {
                if (!this._deflate) return;
                let data = bufferUtil.concat(this._deflate[kBuffers], this._deflate[kTotalLength]);
                fin && (data = new FastBuffer(data.buffer, data.byteOffset, data.length - 4)), this._deflate[kCallback] = null, 
                this._deflate[kTotalLength] = 0, this._deflate[kBuffers] = [], fin && this.params[`${endpoint}_no_context_takeover`] && this._deflate.reset(), 
                callback(null, data);
            }));
        }
    };
}

var validation = {
    exports: {}
}, utf8Validate = {
    exports: {}
}, fallback, hasRequiredFallback, hasRequiredUtf8Validate, hasRequiredValidation, receiver, hasRequiredReceiver, sender, hasRequiredSender, eventTarget, hasRequiredEventTarget, extension, hasRequiredExtension, websocket, hasRequiredWebsocket, subprotocol, hasRequiredSubprotocol, websocketServer, hasRequiredWebsocketServer;

function requireFallback() {
    if (hasRequiredFallback) return fallback;
    return hasRequiredFallback = 1, fallback = function(buf) {
        const len = buf.length;
        let i = 0;
        for (;i < len; ) if (128 & buf[i]) if (192 == (224 & buf[i])) {
            if (i + 1 === len || 128 != (192 & buf[i + 1]) || 192 == (254 & buf[i])) return !1;
            i += 2;
        } else if (224 == (240 & buf[i])) {
            if (i + 2 >= len || 128 != (192 & buf[i + 1]) || 128 != (192 & buf[i + 2]) || 224 === buf[i] && 128 == (224 & buf[i + 1]) || 237 === buf[i] && 160 == (224 & buf[i + 1])) return !1;
            i += 3;
        } else {
            if (240 != (248 & buf[i])) return !1;
            if (i + 3 >= len || 128 != (192 & buf[i + 1]) || 128 != (192 & buf[i + 2]) || 128 != (192 & buf[i + 3]) || 240 === buf[i] && 128 == (240 & buf[i + 1]) || 244 === buf[i] && buf[i + 1] > 143 || buf[i] > 244) return !1;
            i += 4;
        } else i++;
        return !0;
    };
}

function requireUtf8Validate() {
    if (hasRequiredUtf8Validate) return utf8Validate.exports;
    hasRequiredUtf8Validate = 1;
    try {
        utf8Validate.exports = requireNodeGypBuild()(__dirname);
    } catch (e) {
        utf8Validate.exports = requireFallback();
    }
    return utf8Validate.exports;
}

function requireValidation() {
    if (hasRequiredValidation) return validation.exports;
    hasRequiredValidation = 1;
    const {isUtf8: isUtf8} = require$$0$4, {hasBlob: hasBlob} = requireConstants();
    function _isValidUTF8(buf) {
        const len = buf.length;
        let i = 0;
        for (;i < len; ) if (128 & buf[i]) if (192 == (224 & buf[i])) {
            if (i + 1 === len || 128 != (192 & buf[i + 1]) || 192 == (254 & buf[i])) return !1;
            i += 2;
        } else if (224 == (240 & buf[i])) {
            if (i + 2 >= len || 128 != (192 & buf[i + 1]) || 128 != (192 & buf[i + 2]) || 224 === buf[i] && 128 == (224 & buf[i + 1]) || 237 === buf[i] && 160 == (224 & buf[i + 1])) return !1;
            i += 3;
        } else {
            if (240 != (248 & buf[i])) return !1;
            if (i + 3 >= len || 128 != (192 & buf[i + 1]) || 128 != (192 & buf[i + 2]) || 128 != (192 & buf[i + 3]) || 240 === buf[i] && 128 == (240 & buf[i + 1]) || 244 === buf[i] && buf[i + 1] > 143 || buf[i] > 244) return !1;
            i += 4;
        } else i++;
        return !0;
    }
    if (validation.exports = {
        isBlob: function(value) {
            return hasBlob && "object" == typeof value && "function" == typeof value.arrayBuffer && "string" == typeof value.type && "function" == typeof value.stream && ("Blob" === value[Symbol.toStringTag] || "File" === value[Symbol.toStringTag]);
        },
        isValidStatusCode: function(code) {
            return code >= 1e3 && code <= 1014 && 1004 !== code && 1005 !== code && 1006 !== code || code >= 3e3 && code <= 4999;
        },
        isValidUTF8: _isValidUTF8,
        tokenChars: [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0 ]
    }, isUtf8) validation.exports.isValidUTF8 = function(buf) {
        return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);
    }; else if (!process.env.WS_NO_UTF_8_VALIDATE) try {
        const isValidUTF8 = requireUtf8Validate();
        validation.exports.isValidUTF8 = function(buf) {
            return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF8(buf);
        };
    } catch (e) {}
    return validation.exports;
}

function requireReceiver() {
    if (hasRequiredReceiver) return receiver;
    hasRequiredReceiver = 1;
    const {Writable: Writable} = Stream$1, PerMessageDeflate = requirePermessageDeflate(), {BINARY_TYPES: BINARY_TYPES, EMPTY_BUFFER: EMPTY_BUFFER, kStatusCode: kStatusCode, kWebSocket: kWebSocket} = requireConstants(), {concat: concat, toArrayBuffer: toArrayBuffer, unmask: unmask} = requireBufferUtil(), {isValidStatusCode: isValidStatusCode, isValidUTF8: isValidUTF8} = requireValidation(), FastBuffer = Buffer[Symbol.species];
    return receiver = class extends Writable {
        constructor(options = {}) {
            super(), this._allowSynchronousEvents = void 0 === options.allowSynchronousEvents || options.allowSynchronousEvents, 
            this._binaryType = options.binaryType || BINARY_TYPES[0], this._extensions = options.extensions || {}, 
            this._isServer = !!options.isServer, this._maxPayload = 0 | options.maxPayload, 
            this._skipUTF8Validation = !!options.skipUTF8Validation, this[kWebSocket] = void 0, 
            this._bufferedBytes = 0, this._buffers = [], this._compressed = !1, this._payloadLength = 0, 
            this._mask = void 0, this._fragmented = 0, this._masked = !1, this._fin = !1, this._opcode = 0, 
            this._totalPayloadLength = 0, this._messageLength = 0, this._fragments = [], this._errored = !1, 
            this._loop = !1, this._state = 0;
        }
        _write(chunk, encoding, cb) {
            if (8 === this._opcode && 0 == this._state) return cb();
            this._bufferedBytes += chunk.length, this._buffers.push(chunk), this.startLoop(cb);
        }
        consume(n) {
            if (this._bufferedBytes -= n, n === this._buffers[0].length) return this._buffers.shift();
            if (n < this._buffers[0].length) {
                const buf = this._buffers[0];
                return this._buffers[0] = new FastBuffer(buf.buffer, buf.byteOffset + n, buf.length - n), 
                new FastBuffer(buf.buffer, buf.byteOffset, n);
            }
            const dst = Buffer.allocUnsafe(n);
            do {
                const buf = this._buffers[0], offset = dst.length - n;
                n >= buf.length ? dst.set(this._buffers.shift(), offset) : (dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset), 
                this._buffers[0] = new FastBuffer(buf.buffer, buf.byteOffset + n, buf.length - n)), 
                n -= buf.length;
            } while (n > 0);
            return dst;
        }
        startLoop(cb) {
            this._loop = !0;
            do {
                switch (this._state) {
                  case 0:
                    this.getInfo(cb);
                    break;

                  case 1:
                    this.getPayloadLength16(cb);
                    break;

                  case 2:
                    this.getPayloadLength64(cb);
                    break;

                  case 3:
                    this.getMask();
                    break;

                  case 4:
                    this.getData(cb);
                    break;

                  case 5:
                  case 6:
                    return void (this._loop = !1);
                }
            } while (this._loop);
            this._errored || cb();
        }
        getInfo(cb) {
            if (this._bufferedBytes < 2) return void (this._loop = !1);
            const buf = this.consume(2);
            if (48 & buf[0]) {
                return void cb(this.createError(RangeError, "RSV2 and RSV3 must be clear", !0, 1002, "WS_ERR_UNEXPECTED_RSV_2_3"));
            }
            const compressed = !(64 & ~buf[0]);
            if (!compressed || this._extensions[PerMessageDeflate.extensionName]) {
                if (this._fin = !(128 & ~buf[0]), this._opcode = 15 & buf[0], this._payloadLength = 127 & buf[1], 
                0 === this._opcode) {
                    if (compressed) {
                        return void cb(this.createError(RangeError, "RSV1 must be clear", !0, 1002, "WS_ERR_UNEXPECTED_RSV_1"));
                    }
                    if (!this._fragmented) {
                        return void cb(this.createError(RangeError, "invalid opcode 0", !0, 1002, "WS_ERR_INVALID_OPCODE"));
                    }
                    this._opcode = this._fragmented;
                } else if (1 === this._opcode || 2 === this._opcode) {
                    if (this._fragmented) {
                        return void cb(this.createError(RangeError, `invalid opcode ${this._opcode}`, !0, 1002, "WS_ERR_INVALID_OPCODE"));
                    }
                    this._compressed = compressed;
                } else {
                    if (!(this._opcode > 7 && this._opcode < 11)) {
                        return void cb(this.createError(RangeError, `invalid opcode ${this._opcode}`, !0, 1002, "WS_ERR_INVALID_OPCODE"));
                    }
                    if (!this._fin) {
                        return void cb(this.createError(RangeError, "FIN must be set", !0, 1002, "WS_ERR_EXPECTED_FIN"));
                    }
                    if (compressed) {
                        return void cb(this.createError(RangeError, "RSV1 must be clear", !0, 1002, "WS_ERR_UNEXPECTED_RSV_1"));
                    }
                    if (this._payloadLength > 125 || 8 === this._opcode && 1 === this._payloadLength) {
                        return void cb(this.createError(RangeError, `invalid payload length ${this._payloadLength}`, !0, 1002, "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH"));
                    }
                }
                if (this._fin || this._fragmented || (this._fragmented = this._opcode), this._masked = !(128 & ~buf[1]), 
                this._isServer) {
                    if (!this._masked) {
                        return void cb(this.createError(RangeError, "MASK must be set", !0, 1002, "WS_ERR_EXPECTED_MASK"));
                    }
                } else if (this._masked) {
                    return void cb(this.createError(RangeError, "MASK must be clear", !0, 1002, "WS_ERR_UNEXPECTED_MASK"));
                }
                126 === this._payloadLength ? this._state = 1 : 127 === this._payloadLength ? this._state = 2 : this.haveLength(cb);
            } else {
                cb(this.createError(RangeError, "RSV1 must be clear", !0, 1002, "WS_ERR_UNEXPECTED_RSV_1"));
            }
        }
        getPayloadLength16(cb) {
            this._bufferedBytes < 2 ? this._loop = !1 : (this._payloadLength = this.consume(2).readUInt16BE(0), 
            this.haveLength(cb));
        }
        getPayloadLength64(cb) {
            if (this._bufferedBytes < 8) return void (this._loop = !1);
            const buf = this.consume(8), num = buf.readUInt32BE(0);
            if (num > Math.pow(2, 21) - 1) {
                cb(this.createError(RangeError, "Unsupported WebSocket frame: payload length > 2^53 - 1", !1, 1009, "WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH"));
            } else this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4), this.haveLength(cb);
        }
        haveLength(cb) {
            if (this._payloadLength && this._opcode < 8 && (this._totalPayloadLength += this._payloadLength, 
            this._totalPayloadLength > this._maxPayload && this._maxPayload > 0)) {
                cb(this.createError(RangeError, "Max payload size exceeded", !1, 1009, "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"));
            } else this._masked ? this._state = 3 : this._state = 4;
        }
        getMask() {
            this._bufferedBytes < 4 ? this._loop = !1 : (this._mask = this.consume(4), this._state = 4);
        }
        getData(cb) {
            let data = EMPTY_BUFFER;
            if (this._payloadLength) {
                if (this._bufferedBytes < this._payloadLength) return void (this._loop = !1);
                data = this.consume(this._payloadLength), this._masked && this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3] && unmask(data, this._mask);
            }
            if (this._opcode > 7) this.controlMessage(data, cb); else {
                if (this._compressed) return this._state = 5, void this.decompress(data, cb);
                data.length && (this._messageLength = this._totalPayloadLength, this._fragments.push(data)), 
                this.dataMessage(cb);
            }
        }
        decompress(data, cb) {
            this._extensions[PerMessageDeflate.extensionName].decompress(data, this._fin, ((err, buf) => {
                if (err) return cb(err);
                if (buf.length) {
                    if (this._messageLength += buf.length, this._messageLength > this._maxPayload && this._maxPayload > 0) {
                        const error = this.createError(RangeError, "Max payload size exceeded", !1, 1009, "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH");
                        return void cb(error);
                    }
                    this._fragments.push(buf);
                }
                this.dataMessage(cb), 0 === this._state && this.startLoop(cb);
            }));
        }
        dataMessage(cb) {
            if (!this._fin) return void (this._state = 0);
            const messageLength = this._messageLength, fragments = this._fragments;
            if (this._totalPayloadLength = 0, this._messageLength = 0, this._fragmented = 0, 
            this._fragments = [], 2 === this._opcode) {
                let data;
                data = "nodebuffer" === this._binaryType ? concat(fragments, messageLength) : "arraybuffer" === this._binaryType ? toArrayBuffer(concat(fragments, messageLength)) : "blob" === this._binaryType ? new Blob(fragments) : fragments, 
                this._allowSynchronousEvents ? (this.emit("message", data, !0), this._state = 0) : (this._state = 6, 
                setImmediate((() => {
                    this.emit("message", data, !0), this._state = 0, this.startLoop(cb);
                })));
            } else {
                const buf = concat(fragments, messageLength);
                if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
                    const error = this.createError(Error, "invalid UTF-8 sequence", !0, 1007, "WS_ERR_INVALID_UTF8");
                    return void cb(error);
                }
                5 === this._state || this._allowSynchronousEvents ? (this.emit("message", buf, !1), 
                this._state = 0) : (this._state = 6, setImmediate((() => {
                    this.emit("message", buf, !1), this._state = 0, this.startLoop(cb);
                })));
            }
        }
        controlMessage(data, cb) {
            if (8 !== this._opcode) this._allowSynchronousEvents ? (this.emit(9 === this._opcode ? "ping" : "pong", data), 
            this._state = 0) : (this._state = 6, setImmediate((() => {
                this.emit(9 === this._opcode ? "ping" : "pong", data), this._state = 0, this.startLoop(cb);
            }))); else {
                if (0 === data.length) this._loop = !1, this.emit("conclude", 1005, EMPTY_BUFFER), 
                this.end(); else {
                    const code = data.readUInt16BE(0);
                    if (!isValidStatusCode(code)) {
                        const error = this.createError(RangeError, `invalid status code ${code}`, !0, 1002, "WS_ERR_INVALID_CLOSE_CODE");
                        return void cb(error);
                    }
                    const buf = new FastBuffer(data.buffer, data.byteOffset + 2, data.length - 2);
                    if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
                        const error = this.createError(Error, "invalid UTF-8 sequence", !0, 1007, "WS_ERR_INVALID_UTF8");
                        return void cb(error);
                    }
                    this._loop = !1, this.emit("conclude", code, buf), this.end();
                }
                this._state = 0;
            }
        }
        createError(ErrorCtor, message, prefix, statusCode, errorCode) {
            this._loop = !1, this._errored = !0;
            const err = new ErrorCtor(prefix ? `Invalid WebSocket frame: ${message}` : message);
            return Error.captureStackTrace(err, this.createError), err.code = errorCode, err[kStatusCode] = statusCode, 
            err;
        }
    }, receiver;
}

function requireSender() {
    if (hasRequiredSender) return sender;
    hasRequiredSender = 1;
    const {randomFillSync: randomFillSync} = crypto$1, PerMessageDeflate = requirePermessageDeflate(), {EMPTY_BUFFER: EMPTY_BUFFER, kWebSocket: kWebSocket, NOOP: NOOP} = requireConstants(), {isBlob: isBlob, isValidStatusCode: isValidStatusCode} = requireValidation(), {mask: applyMask, toBuffer: toBuffer} = requireBufferUtil(), kByteLength = Symbol("kByteLength"), maskBuffer = Buffer.alloc(4);
    let randomPool, randomPoolPointer = 8192;
    class Sender {
        constructor(socket, extensions, generateMask) {
            this._extensions = extensions || {}, generateMask && (this._generateMask = generateMask, 
            this._maskBuffer = Buffer.alloc(4)), this._socket = socket, this._firstFragment = !0, 
            this._compress = !1, this._bufferedBytes = 0, this._queue = [], this._state = 0, 
            this.onerror = NOOP, this[kWebSocket] = void 0;
        }
        static frame(data, options) {
            let mask, dataLength, merge = !1, offset = 2, skipMasking = !1;
            options.mask && (mask = options.maskBuffer || maskBuffer, options.generateMask ? options.generateMask(mask) : (8192 === randomPoolPointer && (void 0 === randomPool && (randomPool = Buffer.alloc(8192)), 
            randomFillSync(randomPool, 0, 8192), randomPoolPointer = 0), mask[0] = randomPool[randomPoolPointer++], 
            mask[1] = randomPool[randomPoolPointer++], mask[2] = randomPool[randomPoolPointer++], 
            mask[3] = randomPool[randomPoolPointer++]), skipMasking = !(mask[0] | mask[1] | mask[2] | mask[3]), 
            offset = 6), "string" == typeof data ? dataLength = options.mask && !skipMasking || void 0 === options[kByteLength] ? (data = Buffer.from(data)).length : options[kByteLength] : (dataLength = data.length, 
            merge = options.mask && options.readOnly && !skipMasking);
            let payloadLength = dataLength;
            dataLength >= 65536 ? (offset += 8, payloadLength = 127) : dataLength > 125 && (offset += 2, 
            payloadLength = 126);
            const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);
            return target[0] = options.fin ? 128 | options.opcode : options.opcode, options.rsv1 && (target[0] |= 64), 
            target[1] = payloadLength, 126 === payloadLength ? target.writeUInt16BE(dataLength, 2) : 127 === payloadLength && (target[2] = target[3] = 0, 
            target.writeUIntBE(dataLength, 4, 6)), options.mask ? (target[1] |= 128, target[offset - 4] = mask[0], 
            target[offset - 3] = mask[1], target[offset - 2] = mask[2], target[offset - 1] = mask[3], 
            skipMasking ? [ target, data ] : merge ? (applyMask(data, mask, target, offset, dataLength), 
            [ target ]) : (applyMask(data, mask, data, 0, dataLength), [ target, data ])) : [ target, data ];
        }
        close(code, data, mask, cb) {
            let buf;
            if (void 0 === code) buf = EMPTY_BUFFER; else {
                if ("number" != typeof code || !isValidStatusCode(code)) throw new TypeError("First argument must be a valid error code number");
                if (void 0 !== data && data.length) {
                    const length = Buffer.byteLength(data);
                    if (length > 123) throw new RangeError("The message must not be greater than 123 bytes");
                    buf = Buffer.allocUnsafe(2 + length), buf.writeUInt16BE(code, 0), "string" == typeof data ? buf.write(data, 2) : buf.set(data, 2);
                } else buf = Buffer.allocUnsafe(2), buf.writeUInt16BE(code, 0);
            }
            const options = {
                [kByteLength]: buf.length,
                fin: !0,
                generateMask: this._generateMask,
                mask: mask,
                maskBuffer: this._maskBuffer,
                opcode: 8,
                readOnly: !1,
                rsv1: !1
            };
            0 !== this._state ? this.enqueue([ this.dispatch, buf, !1, options, cb ]) : this.sendFrame(Sender.frame(buf, options), cb);
        }
        ping(data, mask, cb) {
            let byteLength, readOnly;
            if ("string" == typeof data ? (byteLength = Buffer.byteLength(data), readOnly = !1) : isBlob(data) ? (byteLength = data.size, 
            readOnly = !1) : (byteLength = (data = toBuffer(data)).length, readOnly = toBuffer.readOnly), 
            byteLength > 125) throw new RangeError("The data size must not be greater than 125 bytes");
            const options = {
                [kByteLength]: byteLength,
                fin: !0,
                generateMask: this._generateMask,
                mask: mask,
                maskBuffer: this._maskBuffer,
                opcode: 9,
                readOnly: readOnly,
                rsv1: !1
            };
            isBlob(data) ? 0 !== this._state ? this.enqueue([ this.getBlobData, data, !1, options, cb ]) : this.getBlobData(data, !1, options, cb) : 0 !== this._state ? this.enqueue([ this.dispatch, data, !1, options, cb ]) : this.sendFrame(Sender.frame(data, options), cb);
        }
        pong(data, mask, cb) {
            let byteLength, readOnly;
            if ("string" == typeof data ? (byteLength = Buffer.byteLength(data), readOnly = !1) : isBlob(data) ? (byteLength = data.size, 
            readOnly = !1) : (byteLength = (data = toBuffer(data)).length, readOnly = toBuffer.readOnly), 
            byteLength > 125) throw new RangeError("The data size must not be greater than 125 bytes");
            const options = {
                [kByteLength]: byteLength,
                fin: !0,
                generateMask: this._generateMask,
                mask: mask,
                maskBuffer: this._maskBuffer,
                opcode: 10,
                readOnly: readOnly,
                rsv1: !1
            };
            isBlob(data) ? 0 !== this._state ? this.enqueue([ this.getBlobData, data, !1, options, cb ]) : this.getBlobData(data, !1, options, cb) : 0 !== this._state ? this.enqueue([ this.dispatch, data, !1, options, cb ]) : this.sendFrame(Sender.frame(data, options), cb);
        }
        send(data, options, cb) {
            const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
            let byteLength, readOnly, opcode = options.binary ? 2 : 1, rsv1 = options.compress;
            "string" == typeof data ? (byteLength = Buffer.byteLength(data), readOnly = !1) : isBlob(data) ? (byteLength = data.size, 
            readOnly = !1) : (byteLength = (data = toBuffer(data)).length, readOnly = toBuffer.readOnly), 
            this._firstFragment ? (this._firstFragment = !1, rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? "server_no_context_takeover" : "client_no_context_takeover"] && (rsv1 = byteLength >= perMessageDeflate._threshold), 
            this._compress = rsv1) : (rsv1 = !1, opcode = 0), options.fin && (this._firstFragment = !0);
            const opts = {
                [kByteLength]: byteLength,
                fin: options.fin,
                generateMask: this._generateMask,
                mask: options.mask,
                maskBuffer: this._maskBuffer,
                opcode: opcode,
                readOnly: readOnly,
                rsv1: rsv1
            };
            isBlob(data) ? 0 !== this._state ? this.enqueue([ this.getBlobData, data, this._compress, opts, cb ]) : this.getBlobData(data, this._compress, opts, cb) : 0 !== this._state ? this.enqueue([ this.dispatch, data, this._compress, opts, cb ]) : this.dispatch(data, this._compress, opts, cb);
        }
        getBlobData(blob, compress, options, cb) {
            this._bufferedBytes += options[kByteLength], this._state = 2, blob.arrayBuffer().then((arrayBuffer => {
                if (this._socket.destroyed) {
                    const err = new Error("The socket was closed while the blob was being read");
                    return void process.nextTick(callCallbacks, this, err, cb);
                }
                this._bufferedBytes -= options[kByteLength];
                const data = toBuffer(arrayBuffer);
                compress ? this.dispatch(data, compress, options, cb) : (this._state = 0, this.sendFrame(Sender.frame(data, options), cb), 
                this.dequeue());
            })).catch((err => {
                process.nextTick(onError, this, err, cb);
            }));
        }
        dispatch(data, compress, options, cb) {
            if (!compress) return void this.sendFrame(Sender.frame(data, options), cb);
            const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
            this._bufferedBytes += options[kByteLength], this._state = 1, perMessageDeflate.compress(data, options.fin, ((_, buf) => {
                if (this._socket.destroyed) {
                    callCallbacks(this, new Error("The socket was closed while data was being compressed"), cb);
                } else this._bufferedBytes -= options[kByteLength], this._state = 0, options.readOnly = !1, 
                this.sendFrame(Sender.frame(buf, options), cb), this.dequeue();
            }));
        }
        dequeue() {
            for (;0 === this._state && this._queue.length; ) {
                const params = this._queue.shift();
                this._bufferedBytes -= params[3][kByteLength], Reflect.apply(params[0], this, params.slice(1));
            }
        }
        enqueue(params) {
            this._bufferedBytes += params[3][kByteLength], this._queue.push(params);
        }
        sendFrame(list, cb) {
            2 === list.length ? (this._socket.cork(), this._socket.write(list[0]), this._socket.write(list[1], cb), 
            this._socket.uncork()) : this._socket.write(list[0], cb);
        }
    }
    function callCallbacks(sender, err, cb) {
        "function" == typeof cb && cb(err);
        for (let i = 0; i < sender._queue.length; i++) {
            const params = sender._queue[i], callback = params[params.length - 1];
            "function" == typeof callback && callback(err);
        }
    }
    function onError(sender, err, cb) {
        callCallbacks(sender, err, cb), sender.onerror(err);
    }
    return sender = Sender;
}

function requireEventTarget() {
    if (hasRequiredEventTarget) return eventTarget;
    hasRequiredEventTarget = 1;
    const {kForOnEventAttribute: kForOnEventAttribute, kListener: kListener} = requireConstants(), kCode = Symbol("kCode"), kData = Symbol("kData"), kError = Symbol("kError"), kMessage = Symbol("kMessage"), kReason = Symbol("kReason"), kTarget = Symbol("kTarget"), kType = Symbol("kType"), kWasClean = Symbol("kWasClean");
    class Event {
        constructor(type) {
            this[kTarget] = null, this[kType] = type;
        }
        get target() {
            return this[kTarget];
        }
        get type() {
            return this[kType];
        }
    }
    Object.defineProperty(Event.prototype, "target", {
        enumerable: !0
    }), Object.defineProperty(Event.prototype, "type", {
        enumerable: !0
    });
    class CloseEvent extends Event {
        constructor(type, options = {}) {
            super(type), this[kCode] = void 0 === options.code ? 0 : options.code, this[kReason] = void 0 === options.reason ? "" : options.reason, 
            this[kWasClean] = void 0 !== options.wasClean && options.wasClean;
        }
        get code() {
            return this[kCode];
        }
        get reason() {
            return this[kReason];
        }
        get wasClean() {
            return this[kWasClean];
        }
    }
    Object.defineProperty(CloseEvent.prototype, "code", {
        enumerable: !0
    }), Object.defineProperty(CloseEvent.prototype, "reason", {
        enumerable: !0
    }), Object.defineProperty(CloseEvent.prototype, "wasClean", {
        enumerable: !0
    });
    class ErrorEvent extends Event {
        constructor(type, options = {}) {
            super(type), this[kError] = void 0 === options.error ? null : options.error, this[kMessage] = void 0 === options.message ? "" : options.message;
        }
        get error() {
            return this[kError];
        }
        get message() {
            return this[kMessage];
        }
    }
    Object.defineProperty(ErrorEvent.prototype, "error", {
        enumerable: !0
    }), Object.defineProperty(ErrorEvent.prototype, "message", {
        enumerable: !0
    });
    class MessageEvent extends Event {
        constructor(type, options = {}) {
            super(type), this[kData] = void 0 === options.data ? null : options.data;
        }
        get data() {
            return this[kData];
        }
    }
    Object.defineProperty(MessageEvent.prototype, "data", {
        enumerable: !0
    });
    const EventTarget = {
        addEventListener(type, handler, options = {}) {
            for (const listener of this.listeners(type)) if (!options[kForOnEventAttribute] && listener[kListener] === handler && !listener[kForOnEventAttribute]) return;
            let wrapper;
            if ("message" === type) wrapper = function(data, isBinary) {
                const event = new MessageEvent("message", {
                    data: isBinary ? data : data.toString()
                });
                event[kTarget] = this, callListener(handler, this, event);
            }; else if ("close" === type) wrapper = function(code, message) {
                const event = new CloseEvent("close", {
                    code: code,
                    reason: message.toString(),
                    wasClean: this._closeFrameReceived && this._closeFrameSent
                });
                event[kTarget] = this, callListener(handler, this, event);
            }; else if ("error" === type) wrapper = function(error) {
                const event = new ErrorEvent("error", {
                    error: error,
                    message: error.message
                });
                event[kTarget] = this, callListener(handler, this, event);
            }; else {
                if ("open" !== type) return;
                wrapper = function() {
                    const event = new Event("open");
                    event[kTarget] = this, callListener(handler, this, event);
                };
            }
            wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute], wrapper[kListener] = handler, 
            options.once ? this.once(type, wrapper) : this.on(type, wrapper);
        },
        removeEventListener(type, handler) {
            for (const listener of this.listeners(type)) if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {
                this.removeListener(type, listener);
                break;
            }
        }
    };
    function callListener(listener, thisArg, event) {
        "object" == typeof listener && listener.handleEvent ? listener.handleEvent.call(listener, event) : listener.call(thisArg, event);
    }
    return eventTarget = {
        CloseEvent: CloseEvent,
        ErrorEvent: ErrorEvent,
        Event: Event,
        EventTarget: EventTarget,
        MessageEvent: MessageEvent
    };
}

function requireExtension() {
    if (hasRequiredExtension) return extension;
    hasRequiredExtension = 1;
    const {tokenChars: tokenChars} = requireValidation();
    function push(dest, name, elem) {
        void 0 === dest[name] ? dest[name] = [ elem ] : dest[name].push(elem);
    }
    return extension = {
        format: function(extensions) {
            return Object.keys(extensions).map((extension => {
                let configurations = extensions[extension];
                return Array.isArray(configurations) || (configurations = [ configurations ]), configurations.map((params => [ extension ].concat(Object.keys(params).map((k => {
                    let values = params[k];
                    return Array.isArray(values) || (values = [ values ]), values.map((v => !0 === v ? k : `${k}=${v}`)).join("; ");
                }))).join("; "))).join(", ");
            })).join(", ");
        },
        parse: function(header) {
            const offers = Object.create(null);
            let extensionName, paramName, params = Object.create(null), mustUnescape = !1, isEscaping = !1, inQuotes = !1, start = -1, code = -1, end = -1, i = 0;
            for (;i < header.length; i++) if (code = header.charCodeAt(i), void 0 === extensionName) if (-1 === end && 1 === tokenChars[code]) -1 === start && (start = i); else if (0 === i || 32 !== code && 9 !== code) {
                if (59 !== code && 44 !== code) throw new SyntaxError(`Unexpected character at index ${i}`);
                {
                    if (-1 === start) throw new SyntaxError(`Unexpected character at index ${i}`);
                    -1 === end && (end = i);
                    const name = header.slice(start, end);
                    44 === code ? (push(offers, name, params), params = Object.create(null)) : extensionName = name, 
                    start = end = -1;
                }
            } else -1 === end && -1 !== start && (end = i); else if (void 0 === paramName) if (-1 === end && 1 === tokenChars[code]) -1 === start && (start = i); else if (32 === code || 9 === code) -1 === end && -1 !== start && (end = i); else if (59 === code || 44 === code) {
                if (-1 === start) throw new SyntaxError(`Unexpected character at index ${i}`);
                -1 === end && (end = i), push(params, header.slice(start, end), !0), 44 === code && (push(offers, extensionName, params), 
                params = Object.create(null), extensionName = void 0), start = end = -1;
            } else {
                if (61 !== code || -1 === start || -1 !== end) throw new SyntaxError(`Unexpected character at index ${i}`);
                paramName = header.slice(start, i), start = end = -1;
            } else if (isEscaping) {
                if (1 !== tokenChars[code]) throw new SyntaxError(`Unexpected character at index ${i}`);
                -1 === start ? start = i : mustUnescape || (mustUnescape = !0), isEscaping = !1;
            } else if (inQuotes) if (1 === tokenChars[code]) -1 === start && (start = i); else if (34 === code && -1 !== start) inQuotes = !1, 
            end = i; else {
                if (92 !== code) throw new SyntaxError(`Unexpected character at index ${i}`);
                isEscaping = !0;
            } else if (34 === code && 61 === header.charCodeAt(i - 1)) inQuotes = !0; else if (-1 === end && 1 === tokenChars[code]) -1 === start && (start = i); else if (-1 === start || 32 !== code && 9 !== code) {
                if (59 !== code && 44 !== code) throw new SyntaxError(`Unexpected character at index ${i}`);
                {
                    if (-1 === start) throw new SyntaxError(`Unexpected character at index ${i}`);
                    -1 === end && (end = i);
                    let value = header.slice(start, end);
                    mustUnescape && (value = value.replace(/\\/g, ""), mustUnescape = !1), push(params, paramName, value), 
                    44 === code && (push(offers, extensionName, params), params = Object.create(null), 
                    extensionName = void 0), paramName = void 0, start = end = -1;
                }
            } else -1 === end && (end = i);
            if (-1 === start || inQuotes || 32 === code || 9 === code) throw new SyntaxError("Unexpected end of input");
            -1 === end && (end = i);
            const token = header.slice(start, end);
            return void 0 === extensionName ? push(offers, token, params) : (void 0 === paramName ? push(params, token, !0) : push(params, paramName, mustUnescape ? token.replace(/\\/g, "") : token), 
            push(offers, extensionName, params)), offers;
        }
    }, extension;
}

function requireWebsocket() {
    if (hasRequiredWebsocket) return websocket;
    hasRequiredWebsocket = 1;
    const EventEmitter = require$$0$5, https$1 = https, http$1 = http, net = require$$3$1, tls = require$$4, {randomBytes: randomBytes, createHash: createHash} = crypto$1, {URL: URL} = Url, PerMessageDeflate = requirePermessageDeflate(), Receiver = requireReceiver(), Sender = requireSender(), {isBlob: isBlob} = requireValidation(), {BINARY_TYPES: BINARY_TYPES, EMPTY_BUFFER: EMPTY_BUFFER, GUID: GUID, kForOnEventAttribute: kForOnEventAttribute, kListener: kListener, kStatusCode: kStatusCode, kWebSocket: kWebSocket, NOOP: NOOP} = requireConstants(), {EventTarget: {addEventListener: addEventListener, removeEventListener: removeEventListener}} = requireEventTarget(), {format: format, parse: parse} = requireExtension(), {toBuffer: toBuffer} = requireBufferUtil(), kAborted = Symbol("kAborted"), protocolVersions = [ 8, 13 ], readyStates = [ "CONNECTING", "OPEN", "CLOSING", "CLOSED" ], subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;
    class WebSocket extends EventEmitter {
        constructor(address, protocols, options) {
            super(), this._binaryType = BINARY_TYPES[0], this._closeCode = 1006, this._closeFrameReceived = !1, 
            this._closeFrameSent = !1, this._closeMessage = EMPTY_BUFFER, this._closeTimer = null, 
            this._errorEmitted = !1, this._extensions = {}, this._paused = !1, this._protocol = "", 
            this._readyState = WebSocket.CONNECTING, this._receiver = null, this._sender = null, 
            this._socket = null, null !== address ? (this._bufferedAmount = 0, this._isServer = !1, 
            this._redirects = 0, void 0 === protocols ? protocols = [] : Array.isArray(protocols) || ("object" == typeof protocols && null !== protocols ? (options = protocols, 
            protocols = []) : protocols = [ protocols ]), initAsClient(this, address, protocols, options)) : (this._autoPong = options.autoPong, 
            this._isServer = !0);
        }
        get binaryType() {
            return this._binaryType;
        }
        set binaryType(type) {
            BINARY_TYPES.includes(type) && (this._binaryType = type, this._receiver && (this._receiver._binaryType = type));
        }
        get bufferedAmount() {
            return this._socket ? this._socket._writableState.length + this._sender._bufferedBytes : this._bufferedAmount;
        }
        get extensions() {
            return Object.keys(this._extensions).join();
        }
        get isPaused() {
            return this._paused;
        }
        get onclose() {
            return null;
        }
        get onerror() {
            return null;
        }
        get onopen() {
            return null;
        }
        get onmessage() {
            return null;
        }
        get protocol() {
            return this._protocol;
        }
        get readyState() {
            return this._readyState;
        }
        get url() {
            return this._url;
        }
        setSocket(socket, head, options) {
            const receiver = new Receiver({
                allowSynchronousEvents: options.allowSynchronousEvents,
                binaryType: this.binaryType,
                extensions: this._extensions,
                isServer: this._isServer,
                maxPayload: options.maxPayload,
                skipUTF8Validation: options.skipUTF8Validation
            }), sender = new Sender(socket, this._extensions, options.generateMask);
            this._receiver = receiver, this._sender = sender, this._socket = socket, receiver[kWebSocket] = this, 
            sender[kWebSocket] = this, socket[kWebSocket] = this, receiver.on("conclude", receiverOnConclude), 
            receiver.on("drain", receiverOnDrain), receiver.on("error", receiverOnError), receiver.on("message", receiverOnMessage), 
            receiver.on("ping", receiverOnPing), receiver.on("pong", receiverOnPong), sender.onerror = senderOnError, 
            socket.setTimeout && socket.setTimeout(0), socket.setNoDelay && socket.setNoDelay(), 
            head.length > 0 && socket.unshift(head), socket.on("close", socketOnClose), socket.on("data", socketOnData), 
            socket.on("end", socketOnEnd), socket.on("error", socketOnError), this._readyState = WebSocket.OPEN, 
            this.emit("open");
        }
        emitClose() {
            if (!this._socket) return this._readyState = WebSocket.CLOSED, void this.emit("close", this._closeCode, this._closeMessage);
            this._extensions[PerMessageDeflate.extensionName] && this._extensions[PerMessageDeflate.extensionName].cleanup(), 
            this._receiver.removeAllListeners(), this._readyState = WebSocket.CLOSED, this.emit("close", this._closeCode, this._closeMessage);
        }
        close(code, data) {
            if (this.readyState !== WebSocket.CLOSED) if (this.readyState !== WebSocket.CONNECTING) this.readyState !== WebSocket.CLOSING ? (this._readyState = WebSocket.CLOSING, 
            this._sender.close(code, data, !this._isServer, (err => {
                err || (this._closeFrameSent = !0, (this._closeFrameReceived || this._receiver._writableState.errorEmitted) && this._socket.end());
            })), setCloseTimer(this)) : this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted) && this._socket.end(); else {
                const msg = "WebSocket was closed before the connection was established";
                abortHandshake(this, this._req, msg);
            }
        }
        pause() {
            this.readyState !== WebSocket.CONNECTING && this.readyState !== WebSocket.CLOSED && (this._paused = !0, 
            this._socket.pause());
        }
        ping(data, mask, cb) {
            if (this.readyState === WebSocket.CONNECTING) throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
            "function" == typeof data ? (cb = data, data = mask = void 0) : "function" == typeof mask && (cb = mask, 
            mask = void 0), "number" == typeof data && (data = data.toString()), this.readyState === WebSocket.OPEN ? (void 0 === mask && (mask = !this._isServer), 
            this._sender.ping(data || EMPTY_BUFFER, mask, cb)) : sendAfterClose(this, data, cb);
        }
        pong(data, mask, cb) {
            if (this.readyState === WebSocket.CONNECTING) throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
            "function" == typeof data ? (cb = data, data = mask = void 0) : "function" == typeof mask && (cb = mask, 
            mask = void 0), "number" == typeof data && (data = data.toString()), this.readyState === WebSocket.OPEN ? (void 0 === mask && (mask = !this._isServer), 
            this._sender.pong(data || EMPTY_BUFFER, mask, cb)) : sendAfterClose(this, data, cb);
        }
        resume() {
            this.readyState !== WebSocket.CONNECTING && this.readyState !== WebSocket.CLOSED && (this._paused = !1, 
            this._receiver._writableState.needDrain || this._socket.resume());
        }
        send(data, options, cb) {
            if (this.readyState === WebSocket.CONNECTING) throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
            if ("function" == typeof options && (cb = options, options = {}), "number" == typeof data && (data = data.toString()), 
            this.readyState !== WebSocket.OPEN) return void sendAfterClose(this, data, cb);
            const opts = {
                binary: "string" != typeof data,
                mask: !this._isServer,
                compress: !0,
                fin: !0,
                ...options
            };
            this._extensions[PerMessageDeflate.extensionName] || (opts.compress = !1), this._sender.send(data || EMPTY_BUFFER, opts, cb);
        }
        terminate() {
            if (this.readyState !== WebSocket.CLOSED) if (this.readyState !== WebSocket.CONNECTING) this._socket && (this._readyState = WebSocket.CLOSING, 
            this._socket.destroy()); else {
                const msg = "WebSocket was closed before the connection was established";
                abortHandshake(this, this._req, msg);
            }
        }
    }
    function initAsClient(websocket, address, protocols, options) {
        const opts = {
            allowSynchronousEvents: !0,
            autoPong: !0,
            protocolVersion: protocolVersions[1],
            maxPayload: 104857600,
            skipUTF8Validation: !1,
            perMessageDeflate: !0,
            followRedirects: !1,
            maxRedirects: 10,
            ...options,
            socketPath: void 0,
            hostname: void 0,
            protocol: void 0,
            timeout: void 0,
            method: "GET",
            host: void 0,
            path: void 0,
            port: void 0
        };
        if (websocket._autoPong = opts.autoPong, !protocolVersions.includes(opts.protocolVersion)) throw new RangeError(`Unsupported protocol version: ${opts.protocolVersion} (supported versions: ${protocolVersions.join(", ")})`);
        let parsedUrl;
        if (address instanceof URL) parsedUrl = address; else try {
            parsedUrl = new URL(address);
        } catch (e) {
            throw new SyntaxError(`Invalid URL: ${address}`);
        }
        "http:" === parsedUrl.protocol ? parsedUrl.protocol = "ws:" : "https:" === parsedUrl.protocol && (parsedUrl.protocol = "wss:"), 
        websocket._url = parsedUrl.href;
        const isSecure = "wss:" === parsedUrl.protocol, isIpcUrl = "ws+unix:" === parsedUrl.protocol;
        let invalidUrlMessage;
        if ("ws:" === parsedUrl.protocol || isSecure || isIpcUrl ? isIpcUrl && !parsedUrl.pathname ? invalidUrlMessage = "The URL's pathname is empty" : parsedUrl.hash && (invalidUrlMessage = "The URL contains a fragment identifier") : invalidUrlMessage = 'The URL\'s protocol must be one of "ws:", "wss:", "http:", "https", or "ws+unix:"', 
        invalidUrlMessage) {
            const err = new SyntaxError(invalidUrlMessage);
            if (0 === websocket._redirects) throw err;
            return void emitErrorAndClose(websocket, err);
        }
        const defaultPort = isSecure ? 443 : 80, key = randomBytes(16).toString("base64"), request = isSecure ? https$1.request : http$1.request, protocolSet = new Set;
        let perMessageDeflate, req;
        if (opts.createConnection = opts.createConnection || (isSecure ? tlsConnect : netConnect), 
        opts.defaultPort = opts.defaultPort || defaultPort, opts.port = parsedUrl.port || defaultPort, 
        opts.host = parsedUrl.hostname.startsWith("[") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname, 
        opts.headers = {
            ...opts.headers,
            "Sec-WebSocket-Version": opts.protocolVersion,
            "Sec-WebSocket-Key": key,
            Connection: "Upgrade",
            Upgrade: "websocket"
        }, opts.path = parsedUrl.pathname + parsedUrl.search, opts.timeout = opts.handshakeTimeout, 
        opts.perMessageDeflate && (perMessageDeflate = new PerMessageDeflate(!0 !== opts.perMessageDeflate ? opts.perMessageDeflate : {}, !1, opts.maxPayload), 
        opts.headers["Sec-WebSocket-Extensions"] = format({
            [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
        })), protocols.length) {
            for (const protocol of protocols) {
                if ("string" != typeof protocol || !subprotocolRegex.test(protocol) || protocolSet.has(protocol)) throw new SyntaxError("An invalid or duplicated subprotocol was specified");
                protocolSet.add(protocol);
            }
            opts.headers["Sec-WebSocket-Protocol"] = protocols.join(",");
        }
        if (opts.origin && (opts.protocolVersion < 13 ? opts.headers["Sec-WebSocket-Origin"] = opts.origin : opts.headers.Origin = opts.origin), 
        (parsedUrl.username || parsedUrl.password) && (opts.auth = `${parsedUrl.username}:${parsedUrl.password}`), 
        isIpcUrl) {
            const parts = opts.path.split(":");
            opts.socketPath = parts[0], opts.path = parts[1];
        }
        if (opts.followRedirects) {
            if (0 === websocket._redirects) {
                websocket._originalIpc = isIpcUrl, websocket._originalSecure = isSecure, websocket._originalHostOrSocketPath = isIpcUrl ? opts.socketPath : parsedUrl.host;
                const headers = options && options.headers;
                if (options = {
                    ...options,
                    headers: {}
                }, headers) for (const [key, value] of Object.entries(headers)) options.headers[key.toLowerCase()] = value;
            } else if (0 === websocket.listenerCount("redirect")) {
                const isSameHost = isIpcUrl ? !!websocket._originalIpc && opts.socketPath === websocket._originalHostOrSocketPath : !websocket._originalIpc && parsedUrl.host === websocket._originalHostOrSocketPath;
                (!isSameHost || websocket._originalSecure && !isSecure) && (delete opts.headers.authorization, 
                delete opts.headers.cookie, isSameHost || delete opts.headers.host, opts.auth = void 0);
            }
            opts.auth && !options.headers.authorization && (options.headers.authorization = "Basic " + Buffer.from(opts.auth).toString("base64")), 
            req = websocket._req = request(opts), websocket._redirects && websocket.emit("redirect", websocket.url, req);
        } else req = websocket._req = request(opts);
        opts.timeout && req.on("timeout", (() => {
            abortHandshake(websocket, req, "Opening handshake has timed out");
        })), req.on("error", (err => {
            null === req || req[kAborted] || (req = websocket._req = null, emitErrorAndClose(websocket, err));
        })), req.on("response", (res => {
            const location = res.headers.location, statusCode = res.statusCode;
            if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
                if (++websocket._redirects > opts.maxRedirects) return void abortHandshake(websocket, req, "Maximum redirects exceeded");
                let addr;
                req.abort();
                try {
                    addr = new URL(location, address);
                } catch (e) {
                    const err = new SyntaxError(`Invalid URL: ${location}`);
                    return void emitErrorAndClose(websocket, err);
                }
                initAsClient(websocket, addr, protocols, options);
            } else websocket.emit("unexpected-response", req, res) || abortHandshake(websocket, req, `Unexpected server response: ${res.statusCode}`);
        })), req.on("upgrade", ((res, socket, head) => {
            if (websocket.emit("upgrade", res), websocket.readyState !== WebSocket.CONNECTING) return;
            req = websocket._req = null;
            const upgrade = res.headers.upgrade;
            if (void 0 === upgrade || "websocket" !== upgrade.toLowerCase()) return void abortHandshake(websocket, socket, "Invalid Upgrade header");
            const digest = createHash("sha1").update(key + GUID).digest("base64");
            if (res.headers["sec-websocket-accept"] !== digest) return void abortHandshake(websocket, socket, "Invalid Sec-WebSocket-Accept header");
            const serverProt = res.headers["sec-websocket-protocol"];
            let protError;
            if (void 0 !== serverProt ? protocolSet.size ? protocolSet.has(serverProt) || (protError = "Server sent an invalid subprotocol") : protError = "Server sent a subprotocol but none was requested" : protocolSet.size && (protError = "Server sent no subprotocol"), 
            protError) return void abortHandshake(websocket, socket, protError);
            serverProt && (websocket._protocol = serverProt);
            const secWebSocketExtensions = res.headers["sec-websocket-extensions"];
            if (void 0 !== secWebSocketExtensions) {
                if (!perMessageDeflate) {
                    return void abortHandshake(websocket, socket, "Server sent a Sec-WebSocket-Extensions header but no extension was requested");
                }
                let extensions;
                try {
                    extensions = parse(secWebSocketExtensions);
                } catch (err) {
                    return void abortHandshake(websocket, socket, "Invalid Sec-WebSocket-Extensions header");
                }
                const extensionNames = Object.keys(extensions);
                if (1 !== extensionNames.length || extensionNames[0] !== PerMessageDeflate.extensionName) {
                    return void abortHandshake(websocket, socket, "Server indicated an extension that was not requested");
                }
                try {
                    perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
                } catch (err) {
                    return void abortHandshake(websocket, socket, "Invalid Sec-WebSocket-Extensions header");
                }
                websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
            }
            websocket.setSocket(socket, head, {
                allowSynchronousEvents: opts.allowSynchronousEvents,
                generateMask: opts.generateMask,
                maxPayload: opts.maxPayload,
                skipUTF8Validation: opts.skipUTF8Validation
            });
        })), opts.finishRequest ? opts.finishRequest(req, websocket) : req.end();
    }
    function emitErrorAndClose(websocket, err) {
        websocket._readyState = WebSocket.CLOSING, websocket._errorEmitted = !0, websocket.emit("error", err), 
        websocket.emitClose();
    }
    function netConnect(options) {
        return options.path = options.socketPath, net.connect(options);
    }
    function tlsConnect(options) {
        return options.path = void 0, options.servername || "" === options.servername || (options.servername = net.isIP(options.host) ? "" : options.host), 
        tls.connect(options);
    }
    function abortHandshake(websocket, stream, message) {
        websocket._readyState = WebSocket.CLOSING;
        const err = new Error(message);
        Error.captureStackTrace(err, abortHandshake), stream.setHeader ? (stream[kAborted] = !0, 
        stream.abort(), stream.socket && !stream.socket.destroyed && stream.socket.destroy(), 
        process.nextTick(emitErrorAndClose, websocket, err)) : (stream.destroy(err), stream.once("error", websocket.emit.bind(websocket, "error")), 
        stream.once("close", websocket.emitClose.bind(websocket)));
    }
    function sendAfterClose(websocket, data, cb) {
        if (data) {
            const length = isBlob(data) ? data.size : toBuffer(data).length;
            websocket._socket ? websocket._sender._bufferedBytes += length : websocket._bufferedAmount += length;
        }
        if (cb) {
            const err = new Error(`WebSocket is not open: readyState ${websocket.readyState} (${readyStates[websocket.readyState]})`);
            process.nextTick(cb, err);
        }
    }
    function receiverOnConclude(code, reason) {
        const websocket = this[kWebSocket];
        websocket._closeFrameReceived = !0, websocket._closeMessage = reason, websocket._closeCode = code, 
        void 0 !== websocket._socket[kWebSocket] && (websocket._socket.removeListener("data", socketOnData), 
        process.nextTick(resume, websocket._socket), 1005 === code ? websocket.close() : websocket.close(code, reason));
    }
    function receiverOnDrain() {
        const websocket = this[kWebSocket];
        websocket.isPaused || websocket._socket.resume();
    }
    function receiverOnError(err) {
        const websocket = this[kWebSocket];
        void 0 !== websocket._socket[kWebSocket] && (websocket._socket.removeListener("data", socketOnData), 
        process.nextTick(resume, websocket._socket), websocket.close(err[kStatusCode])), 
        websocket._errorEmitted || (websocket._errorEmitted = !0, websocket.emit("error", err));
    }
    function receiverOnFinish() {
        this[kWebSocket].emitClose();
    }
    function receiverOnMessage(data, isBinary) {
        this[kWebSocket].emit("message", data, isBinary);
    }
    function receiverOnPing(data) {
        const websocket = this[kWebSocket];
        websocket._autoPong && websocket.pong(data, !this._isServer, NOOP), websocket.emit("ping", data);
    }
    function receiverOnPong(data) {
        this[kWebSocket].emit("pong", data);
    }
    function resume(stream) {
        stream.resume();
    }
    function senderOnError(err) {
        const websocket = this[kWebSocket];
        websocket.readyState !== WebSocket.CLOSED && (websocket.readyState === WebSocket.OPEN && (websocket._readyState = WebSocket.CLOSING, 
        setCloseTimer(websocket)), this._socket.end(), websocket._errorEmitted || (websocket._errorEmitted = !0, 
        websocket.emit("error", err)));
    }
    function setCloseTimer(websocket) {
        websocket._closeTimer = setTimeout(websocket._socket.destroy.bind(websocket._socket), 3e4);
    }
    function socketOnClose() {
        const websocket = this[kWebSocket];
        let chunk;
        this.removeListener("close", socketOnClose), this.removeListener("data", socketOnData), 
        this.removeListener("end", socketOnEnd), websocket._readyState = WebSocket.CLOSING, 
        this._readableState.endEmitted || websocket._closeFrameReceived || websocket._receiver._writableState.errorEmitted || null === (chunk = websocket._socket.read()) || websocket._receiver.write(chunk), 
        websocket._receiver.end(), this[kWebSocket] = void 0, clearTimeout(websocket._closeTimer), 
        websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted ? websocket.emitClose() : (websocket._receiver.on("error", receiverOnFinish), 
        websocket._receiver.on("finish", receiverOnFinish));
    }
    function socketOnData(chunk) {
        this[kWebSocket]._receiver.write(chunk) || this.pause();
    }
    function socketOnEnd() {
        const websocket = this[kWebSocket];
        websocket._readyState = WebSocket.CLOSING, websocket._receiver.end(), this.end();
    }
    function socketOnError() {
        const websocket = this[kWebSocket];
        this.removeListener("error", socketOnError), this.on("error", NOOP), websocket && (websocket._readyState = WebSocket.CLOSING, 
        this.destroy());
    }
    return Object.defineProperty(WebSocket, "CONNECTING", {
        enumerable: !0,
        value: readyStates.indexOf("CONNECTING")
    }), Object.defineProperty(WebSocket.prototype, "CONNECTING", {
        enumerable: !0,
        value: readyStates.indexOf("CONNECTING")
    }), Object.defineProperty(WebSocket, "OPEN", {
        enumerable: !0,
        value: readyStates.indexOf("OPEN")
    }), Object.defineProperty(WebSocket.prototype, "OPEN", {
        enumerable: !0,
        value: readyStates.indexOf("OPEN")
    }), Object.defineProperty(WebSocket, "CLOSING", {
        enumerable: !0,
        value: readyStates.indexOf("CLOSING")
    }), Object.defineProperty(WebSocket.prototype, "CLOSING", {
        enumerable: !0,
        value: readyStates.indexOf("CLOSING")
    }), Object.defineProperty(WebSocket, "CLOSED", {
        enumerable: !0,
        value: readyStates.indexOf("CLOSED")
    }), Object.defineProperty(WebSocket.prototype, "CLOSED", {
        enumerable: !0,
        value: readyStates.indexOf("CLOSED")
    }), [ "binaryType", "bufferedAmount", "extensions", "isPaused", "protocol", "readyState", "url" ].forEach((property => {
        Object.defineProperty(WebSocket.prototype, property, {
            enumerable: !0
        });
    })), [ "open", "error", "close", "message" ].forEach((method => {
        Object.defineProperty(WebSocket.prototype, `on${method}`, {
            enumerable: !0,
            get() {
                for (const listener of this.listeners(method)) if (listener[kForOnEventAttribute]) return listener[kListener];
                return null;
            },
            set(handler) {
                for (const listener of this.listeners(method)) if (listener[kForOnEventAttribute]) {
                    this.removeListener(method, listener);
                    break;
                }
                "function" == typeof handler && this.addEventListener(method, handler, {
                    [kForOnEventAttribute]: !0
                });
            }
        });
    })), WebSocket.prototype.addEventListener = addEventListener, WebSocket.prototype.removeEventListener = removeEventListener, 
    websocket = WebSocket;
}

function requireSubprotocol() {
    if (hasRequiredSubprotocol) return subprotocol;
    hasRequiredSubprotocol = 1;
    const {tokenChars: tokenChars} = requireValidation();
    return subprotocol = {
        parse: function(header) {
            const protocols = new Set;
            let start = -1, end = -1, i = 0;
            for (;i < header.length; i++) {
                const code = header.charCodeAt(i);
                if (-1 === end && 1 === tokenChars[code]) -1 === start && (start = i); else if (0 === i || 32 !== code && 9 !== code) {
                    if (44 !== code) throw new SyntaxError(`Unexpected character at index ${i}`);
                    {
                        if (-1 === start) throw new SyntaxError(`Unexpected character at index ${i}`);
                        -1 === end && (end = i);
                        const protocol = header.slice(start, end);
                        if (protocols.has(protocol)) throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
                        protocols.add(protocol), start = end = -1;
                    }
                } else -1 === end && -1 !== start && (end = i);
            }
            if (-1 === start || -1 !== end) throw new SyntaxError("Unexpected end of input");
            const protocol = header.slice(start, i);
            if (protocols.has(protocol)) throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
            return protocols.add(protocol), protocols;
        }
    };
}

function requireWebsocketServer() {
    if (hasRequiredWebsocketServer) return websocketServer;
    hasRequiredWebsocketServer = 1;
    const EventEmitter = require$$0$5, http$1 = http, {createHash: createHash} = crypto$1, extension = requireExtension(), PerMessageDeflate = requirePermessageDeflate(), subprotocol = requireSubprotocol(), WebSocket = requireWebsocket(), {GUID: GUID, kWebSocket: kWebSocket} = requireConstants(), keyRegex = /^[+/0-9A-Za-z]{22}==$/;
    function emitClose(server) {
        server._state = 2, server.emit("close");
    }
    function socketOnError() {
        this.destroy();
    }
    function abortHandshake(socket, code, message, headers) {
        message = message || http$1.STATUS_CODES[code], headers = {
            Connection: "close",
            "Content-Type": "text/html",
            "Content-Length": Buffer.byteLength(message),
            ...headers
        }, socket.once("finish", socket.destroy), socket.end(`HTTP/1.1 ${code} ${http$1.STATUS_CODES[code]}\r\n` + Object.keys(headers).map((h => `${h}: ${headers[h]}`)).join("\r\n") + "\r\n\r\n" + message);
    }
    function abortHandshakeOrEmitwsClientError(server, req, socket, code, message) {
        if (server.listenerCount("wsClientError")) {
            const err = new Error(message);
            Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError), server.emit("wsClientError", err, socket, req);
        } else abortHandshake(socket, code, message);
    }
    return websocketServer = class extends EventEmitter {
        constructor(options, callback) {
            if (super(), null == (options = {
                allowSynchronousEvents: !0,
                autoPong: !0,
                maxPayload: 104857600,
                skipUTF8Validation: !1,
                perMessageDeflate: !1,
                handleProtocols: null,
                clientTracking: !0,
                verifyClient: null,
                noServer: !1,
                backlog: null,
                server: null,
                host: null,
                path: null,
                port: null,
                WebSocket: WebSocket,
                ...options
            }).port && !options.server && !options.noServer || null != options.port && (options.server || options.noServer) || options.server && options.noServer) throw new TypeError('One and only one of the "port", "server", or "noServer" options must be specified');
            if (null != options.port ? (this._server = http$1.createServer(((req, res) => {
                const body = http$1.STATUS_CODES[426];
                res.writeHead(426, {
                    "Content-Length": body.length,
                    "Content-Type": "text/plain"
                }), res.end(body);
            })), this._server.listen(options.port, options.host, options.backlog, callback)) : options.server && (this._server = options.server), 
            this._server) {
                const emitConnection = this.emit.bind(this, "connection");
                this._removeListeners = function(server, map) {
                    for (const event of Object.keys(map)) server.on(event, map[event]);
                    return function() {
                        for (const event of Object.keys(map)) server.removeListener(event, map[event]);
                    };
                }(this._server, {
                    listening: this.emit.bind(this, "listening"),
                    error: this.emit.bind(this, "error"),
                    upgrade: (req, socket, head) => {
                        this.handleUpgrade(req, socket, head, emitConnection);
                    }
                });
            }
            !0 === options.perMessageDeflate && (options.perMessageDeflate = {}), options.clientTracking && (this.clients = new Set, 
            this._shouldEmitClose = !1), this.options = options, this._state = 0;
        }
        address() {
            if (this.options.noServer) throw new Error('The server is operating in "noServer" mode');
            return this._server ? this._server.address() : null;
        }
        close(cb) {
            if (2 === this._state) return cb && this.once("close", (() => {
                cb(new Error("The server is not running"));
            })), void process.nextTick(emitClose, this);
            if (cb && this.once("close", cb), 1 !== this._state) if (this._state = 1, this.options.noServer || this.options.server) this._server && (this._removeListeners(), 
            this._removeListeners = this._server = null), this.clients && this.clients.size ? this._shouldEmitClose = !0 : process.nextTick(emitClose, this); else {
                const server = this._server;
                this._removeListeners(), this._removeListeners = this._server = null, server.close((() => {
                    emitClose(this);
                }));
            }
        }
        shouldHandle(req) {
            if (this.options.path) {
                const index = req.url.indexOf("?");
                if ((-1 !== index ? req.url.slice(0, index) : req.url) !== this.options.path) return !1;
            }
            return !0;
        }
        handleUpgrade(req, socket, head, cb) {
            socket.on("error", socketOnError);
            const key = req.headers["sec-websocket-key"], upgrade = req.headers.upgrade, version = +req.headers["sec-websocket-version"];
            if ("GET" !== req.method) {
                return void abortHandshakeOrEmitwsClientError(this, req, socket, 405, "Invalid HTTP method");
            }
            if (void 0 === upgrade || "websocket" !== upgrade.toLowerCase()) {
                return void abortHandshakeOrEmitwsClientError(this, req, socket, 400, "Invalid Upgrade header");
            }
            if (void 0 === key || !keyRegex.test(key)) {
                return void abortHandshakeOrEmitwsClientError(this, req, socket, 400, "Missing or invalid Sec-WebSocket-Key header");
            }
            if (8 !== version && 13 !== version) {
                return void abortHandshakeOrEmitwsClientError(this, req, socket, 400, "Missing or invalid Sec-WebSocket-Version header");
            }
            if (!this.shouldHandle(req)) return void abortHandshake(socket, 400);
            const secWebSocketProtocol = req.headers["sec-websocket-protocol"];
            let protocols = new Set;
            if (void 0 !== secWebSocketProtocol) try {
                protocols = subprotocol.parse(secWebSocketProtocol);
            } catch (err) {
                return void abortHandshakeOrEmitwsClientError(this, req, socket, 400, "Invalid Sec-WebSocket-Protocol header");
            }
            const secWebSocketExtensions = req.headers["sec-websocket-extensions"], extensions = {};
            if (this.options.perMessageDeflate && void 0 !== secWebSocketExtensions) {
                const perMessageDeflate = new PerMessageDeflate(this.options.perMessageDeflate, !0, this.options.maxPayload);
                try {
                    const offers = extension.parse(secWebSocketExtensions);
                    offers[PerMessageDeflate.extensionName] && (perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]), 
                    extensions[PerMessageDeflate.extensionName] = perMessageDeflate);
                } catch (err) {
                    return void abortHandshakeOrEmitwsClientError(this, req, socket, 400, "Invalid or unacceptable Sec-WebSocket-Extensions header");
                }
            }
            if (this.options.verifyClient) {
                const info = {
                    origin: req.headers["" + (8 === version ? "sec-websocket-origin" : "origin")],
                    secure: !(!req.socket.authorized && !req.socket.encrypted),
                    req: req
                };
                if (2 === this.options.verifyClient.length) return void this.options.verifyClient(info, ((verified, code, message, headers) => {
                    if (!verified) return abortHandshake(socket, code || 401, message, headers);
                    this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
                }));
                if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);
            }
            this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
        }
        completeUpgrade(extensions, key, protocols, req, socket, head, cb) {
            if (!socket.readable || !socket.writable) return socket.destroy();
            if (socket[kWebSocket]) throw new Error("server.handleUpgrade() was called more than once with the same socket, possibly due to a misconfiguration");
            if (this._state > 0) return abortHandshake(socket, 503);
            const headers = [ "HTTP/1.1 101 Switching Protocols", "Upgrade: websocket", "Connection: Upgrade", `Sec-WebSocket-Accept: ${createHash("sha1").update(key + GUID).digest("base64")}` ], ws = new this.options.WebSocket(null, void 0, this.options);
            if (protocols.size) {
                const protocol = this.options.handleProtocols ? this.options.handleProtocols(protocols, req) : protocols.values().next().value;
                protocol && (headers.push(`Sec-WebSocket-Protocol: ${protocol}`), ws._protocol = protocol);
            }
            if (extensions[PerMessageDeflate.extensionName]) {
                const params = extensions[PerMessageDeflate.extensionName].params, value = extension.format({
                    [PerMessageDeflate.extensionName]: [ params ]
                });
                headers.push(`Sec-WebSocket-Extensions: ${value}`), ws._extensions = extensions;
            }
            this.emit("headers", headers, req), socket.write(headers.concat("\r\n").join("\r\n")), 
            socket.removeListener("error", socketOnError), ws.setSocket(socket, head, {
                allowSynchronousEvents: this.options.allowSynchronousEvents,
                maxPayload: this.options.maxPayload,
                skipUTF8Validation: this.options.skipUTF8Validation
            }), this.clients && (this.clients.add(ws), ws.on("close", (() => {
                this.clients.delete(ws), this._shouldEmitClose && !this.clients.size && process.nextTick(emitClose, this);
            }))), cb(ws, req);
        }
    }, websocketServer;
}

requireReceiver(), requireSender(), requireWebsocket(), requireWebsocketServer();

var eventemitter3 = {
    exports: {}
}, hasRequiredEventemitter3;

function requireEventemitter3() {
    return hasRequiredEventemitter3 || (hasRequiredEventemitter3 = 1, function(module) {
        var has = Object.prototype.hasOwnProperty, prefix = "~";
        function Events() {}
        function EE(fn, context, once) {
            this.fn = fn, this.context = context, this.once = once || !1;
        }
        function addListener(emitter, event, fn, context, once) {
            if ("function" != typeof fn) throw new TypeError("The listener must be a function");
            var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
            return emitter._events[evt] ? emitter._events[evt].fn ? emitter._events[evt] = [ emitter._events[evt], listener ] : emitter._events[evt].push(listener) : (emitter._events[evt] = listener, 
            emitter._eventsCount++), emitter;
        }
        function clearEvent(emitter, evt) {
            0 == --emitter._eventsCount ? emitter._events = new Events : delete emitter._events[evt];
        }
        function EventEmitter() {
            this._events = new Events, this._eventsCount = 0;
        }
        Object.create && (Events.prototype = Object.create(null), (new Events).__proto__ || (prefix = !1)), 
        EventEmitter.prototype.eventNames = function() {
            var events, name, names = [];
            if (0 === this._eventsCount) return names;
            for (name in events = this._events) has.call(events, name) && names.push(prefix ? name.slice(1) : name);
            return Object.getOwnPropertySymbols ? names.concat(Object.getOwnPropertySymbols(events)) : names;
        }, EventEmitter.prototype.listeners = function(event) {
            var evt = prefix ? prefix + event : event, handlers = this._events[evt];
            if (!handlers) return [];
            if (handlers.fn) return [ handlers.fn ];
            for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) ee[i] = handlers[i].fn;
            return ee;
        }, EventEmitter.prototype.listenerCount = function(event) {
            var evt = prefix ? prefix + event : event, listeners = this._events[evt];
            return listeners ? listeners.fn ? 1 : listeners.length : 0;
        }, EventEmitter.prototype.emit = function(event, a1, a2, a3, a4, a5) {
            var evt = prefix ? prefix + event : event;
            if (!this._events[evt]) return !1;
            var args, i, listeners = this._events[evt], len = arguments.length;
            if (listeners.fn) {
                switch (listeners.once && this.removeListener(event, listeners.fn, void 0, !0), 
                len) {
                  case 1:
                    return listeners.fn.call(listeners.context), !0;

                  case 2:
                    return listeners.fn.call(listeners.context, a1), !0;

                  case 3:
                    return listeners.fn.call(listeners.context, a1, a2), !0;

                  case 4:
                    return listeners.fn.call(listeners.context, a1, a2, a3), !0;

                  case 5:
                    return listeners.fn.call(listeners.context, a1, a2, a3, a4), !0;

                  case 6:
                    return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), !0;
                }
                for (i = 1, args = new Array(len - 1); i < len; i++) args[i - 1] = arguments[i];
                listeners.fn.apply(listeners.context, args);
            } else {
                var j, length = listeners.length;
                for (i = 0; i < length; i++) switch (listeners[i].once && this.removeListener(event, listeners[i].fn, void 0, !0), 
                len) {
                  case 1:
                    listeners[i].fn.call(listeners[i].context);
                    break;

                  case 2:
                    listeners[i].fn.call(listeners[i].context, a1);
                    break;

                  case 3:
                    listeners[i].fn.call(listeners[i].context, a1, a2);
                    break;

                  case 4:
                    listeners[i].fn.call(listeners[i].context, a1, a2, a3);
                    break;

                  default:
                    if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) args[j - 1] = arguments[j];
                    listeners[i].fn.apply(listeners[i].context, args);
                }
            }
            return !0;
        }, EventEmitter.prototype.on = function(event, fn, context) {
            return addListener(this, event, fn, context, !1);
        }, EventEmitter.prototype.once = function(event, fn, context) {
            return addListener(this, event, fn, context, !0);
        }, EventEmitter.prototype.removeListener = function(event, fn, context, once) {
            var evt = prefix ? prefix + event : event;
            if (!this._events[evt]) return this;
            if (!fn) return clearEvent(this, evt), this;
            var listeners = this._events[evt];
            if (listeners.fn) listeners.fn !== fn || once && !listeners.once || context && listeners.context !== context || clearEvent(this, evt); else {
                for (var i = 0, events = [], length = listeners.length; i < length; i++) (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) && events.push(listeners[i]);
                events.length ? this._events[evt] = 1 === events.length ? events[0] : events : clearEvent(this, evt);
            }
            return this;
        }, EventEmitter.prototype.removeAllListeners = function(event) {
            var evt;
            return event ? (evt = prefix ? prefix + event : event, this._events[evt] && clearEvent(this, evt)) : (this._events = new Events, 
            this._eventsCount = 0), this;
        }, EventEmitter.prototype.off = EventEmitter.prototype.removeListener, EventEmitter.prototype.addListener = EventEmitter.prototype.on, 
        EventEmitter.prefixed = prefix, EventEmitter.EventEmitter = EventEmitter, module.exports = EventEmitter;
    }(eventemitter3)), eventemitter3.exports;
}

requireEventemitter3();

class HMAC extends Hash {
    constructor(hash$1, _key) {
        super(), this.finished = !1, this.destroyed = !1, hash(hash$1);
        const key = toBytes(_key);
        if (this.iHash = hash$1.create(), "function" != typeof this.iHash.update) throw new Error("Expected instance of class which extends utils.Hash");
        this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
        const blockLen = this.blockLen, pad = new Uint8Array(blockLen);
        pad.set(key.length > blockLen ? hash$1.create().update(key).digest() : key);
        for (let i = 0; i < pad.length; i++) pad[i] ^= 54;
        this.iHash.update(pad), this.oHash = hash$1.create();
        for (let i = 0; i < pad.length; i++) pad[i] ^= 106;
        this.oHash.update(pad), pad.fill(0);
    }
    update(buf) {
        return exists(this), this.iHash.update(buf), this;
    }
    digestInto(out) {
        exists(this), bytes(out, this.outputLen), this.finished = !0, this.iHash.digestInto(out), 
        this.oHash.update(out), this.oHash.digestInto(out), this.destroy();
    }
    digest() {
        const out = new Uint8Array(this.oHash.outputLen);
        return this.digestInto(out), out;
    }
    _cloneInto(to) {
        to || (to = Object.create(Object.getPrototypeOf(this), {}));
        const {oHash: oHash, iHash: iHash, finished: finished, destroyed: destroyed, blockLen: blockLen, outputLen: outputLen} = this;
        return to.finished = finished, to.destroyed = destroyed, to.blockLen = blockLen, 
        to.outputLen = outputLen, to.oHash = oHash._cloneInto(to.oHash), to.iHash = iHash._cloneInto(to.iHash), 
        to;
    }
    destroy() {
        this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
    }
}

const hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();

/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function validateSigVerOpts(opts) {
    void 0 !== opts.lowS && abool("lowS", opts.lowS), void 0 !== opts.prehash && abool("prehash", opts.prehash);
}

function validatePointOpts(curve) {
    const opts = validateBasic(curve);
    validateObject(opts, {
        a: "field",
        b: "field"
    }, {
        allowedPrivateKeyLengths: "array",
        wrapPrivateKey: "boolean",
        isTorsionFree: "function",
        clearCofactor: "function",
        allowInfinityPoint: "boolean",
        fromBytes: "function",
        toBytes: "function"
    });
    const {endo: endo, Fp: Fp, a: a} = opts;
    if (endo) {
        if (!Fp.eql(a, Fp.ZERO)) throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
        if ("object" != typeof endo || "bigint" != typeof endo.beta || "function" != typeof endo.splitScalar) throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
    }
    return Object.freeze({
        ...opts
    });
}

hmac.create = (hash, key) => new HMAC(hash, key);

const {bytesToNumberBE: b2n, hexToBytes: h2b} = ut, DER = {
    Err: class extends Error {
        constructor(m = "") {
            super(m);
        }
    },
    _tlv: {
        encode: (tag, data) => {
            const {Err: E} = DER;
            if (tag < 0 || tag > 256) throw new E("tlv.encode: wrong tag");
            if (1 & data.length) throw new E("tlv.encode: unpadded data");
            const dataLen = data.length / 2, len = numberToHexUnpadded(dataLen);
            if (len.length / 2 & 128) throw new E("tlv.encode: long form length too big");
            const lenLen = dataLen > 127 ? numberToHexUnpadded(len.length / 2 | 128) : "";
            return `${numberToHexUnpadded(tag)}${lenLen}${len}${data}`;
        },
        decode(tag, data) {
            const {Err: E} = DER;
            let pos = 0;
            if (tag < 0 || tag > 256) throw new E("tlv.encode: wrong tag");
            if (data.length < 2 || data[pos++] !== tag) throw new E("tlv.decode: wrong tlv");
            const first = data[pos++];
            let length = 0;
            if (!!(128 & first)) {
                const lenLen = 127 & first;
                if (!lenLen) throw new E("tlv.decode(long): indefinite length not supported");
                if (lenLen > 4) throw new E("tlv.decode(long): byte length is too big");
                const lengthBytes = data.subarray(pos, pos + lenLen);
                if (lengthBytes.length !== lenLen) throw new E("tlv.decode: length bytes not complete");
                if (0 === lengthBytes[0]) throw new E("tlv.decode(long): zero leftmost byte");
                for (const b of lengthBytes) length = length << 8 | b;
                if (pos += lenLen, length < 128) throw new E("tlv.decode(long): not minimal encoding");
            } else length = first;
            const v = data.subarray(pos, pos + length);
            if (v.length !== length) throw new E("tlv.decode: wrong value length");
            return {
                v: v,
                l: data.subarray(pos + length)
            };
        }
    },
    _int: {
        encode(num) {
            const {Err: E} = DER;
            if (num < _0n) throw new E("integer: negative integers are not allowed");
            let hex = numberToHexUnpadded(num);
            if (8 & Number.parseInt(hex[0], 16) && (hex = "00" + hex), 1 & hex.length) throw new E("unexpected assertion");
            return hex;
        },
        decode(data) {
            const {Err: E} = DER;
            if (128 & data[0]) throw new E("Invalid signature integer: negative");
            if (0 === data[0] && !(128 & data[1])) throw new E("Invalid signature integer: unnecessary leading zero");
            return b2n(data);
        }
    },
    toSig(hex) {
        const {Err: E, _int: int, _tlv: tlv} = DER, data = "string" == typeof hex ? h2b(hex) : hex;
        abytes(data);
        const {v: seqBytes, l: seqLeftBytes} = tlv.decode(48, data);
        if (seqLeftBytes.length) throw new E("Invalid signature: left bytes after parsing");
        const {v: rBytes, l: rLeftBytes} = tlv.decode(2, seqBytes), {v: sBytes, l: sLeftBytes} = tlv.decode(2, rLeftBytes);
        if (sLeftBytes.length) throw new E("Invalid signature: left bytes after parsing");
        return {
            r: int.decode(rBytes),
            s: int.decode(sBytes)
        };
    },
    hexFromSig(sig) {
        const {_tlv: tlv, _int: int} = DER, seq = `${tlv.encode(2, int.encode(sig.r))}${tlv.encode(2, int.encode(sig.s))}`;
        return tlv.encode(48, seq);
    }
}, _0n = BigInt(0), _1n$1 = BigInt(1);

BigInt(2);

const _3n = BigInt(3);

function weierstrassPoints(opts) {
    const CURVE = validatePointOpts(opts), {Fp: Fp} = CURVE, Fn = Field(CURVE.n, CURVE.nBitLength), toBytes = CURVE.toBytes || ((_c, point, _isCompressed) => {
        const a = point.toAffine();
        return concatBytes(Uint8Array.from([ 4 ]), Fp.toBytes(a.x), Fp.toBytes(a.y));
    }), fromBytes = CURVE.fromBytes || (bytes => {
        const tail = bytes.subarray(1);
        return {
            x: Fp.fromBytes(tail.subarray(0, Fp.BYTES)),
            y: Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES))
        };
    });
    function weierstrassEquation(x) {
        const {a: a, b: b} = CURVE, x2 = Fp.sqr(x), x3 = Fp.mul(x2, x);
        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b);
    }
    if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx))) throw new Error("bad generator point: equation left != right");
    function normPrivateKeyToScalar(key) {
        const {allowedPrivateKeyLengths: lengths, nByteLength: nByteLength, wrapPrivateKey: wrapPrivateKey, n: N} = CURVE;
        if (lengths && "bigint" != typeof key) {
            if (isBytes(key) && (key = bytesToHex(key)), "string" != typeof key || !lengths.includes(key.length)) throw new Error("Invalid key");
            key = key.padStart(2 * nByteLength, "0");
        }
        let num;
        try {
            num = "bigint" == typeof key ? key : bytesToNumberBE(ensureBytes("private key", key, nByteLength));
        } catch (error) {
            throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);
        }
        return wrapPrivateKey && (num = mod(num, N)), aInRange("private key", num, _1n$1, N), 
        num;
    }
    function assertPrjPoint(other) {
        if (!(other instanceof Point)) throw new Error("ProjectivePoint expected");
    }
    const toAffineMemo = memoized(((p, iz) => {
        const {px: x, py: y, pz: z} = p;
        if (Fp.eql(z, Fp.ONE)) return {
            x: x,
            y: y
        };
        const is0 = p.is0();
        null == iz && (iz = is0 ? Fp.ONE : Fp.inv(z));
        const ax = Fp.mul(x, iz), ay = Fp.mul(y, iz), zz = Fp.mul(z, iz);
        if (is0) return {
            x: Fp.ZERO,
            y: Fp.ZERO
        };
        if (!Fp.eql(zz, Fp.ONE)) throw new Error("invZ was invalid");
        return {
            x: ax,
            y: ay
        };
    })), assertValidMemo = memoized((p => {
        if (p.is0()) {
            if (CURVE.allowInfinityPoint && !Fp.is0(p.py)) return;
            throw new Error("bad point: ZERO");
        }
        const {x: x, y: y} = p.toAffine();
        if (!Fp.isValid(x) || !Fp.isValid(y)) throw new Error("bad point: x or y not FE");
        const left = Fp.sqr(y), right = weierstrassEquation(x);
        if (!Fp.eql(left, right)) throw new Error("bad point: equation left != right");
        if (!p.isTorsionFree()) throw new Error("bad point: not in prime-order subgroup");
        return !0;
    }));
    class Point {
        constructor(px, py, pz) {
            if (this.px = px, this.py = py, this.pz = pz, null == px || !Fp.isValid(px)) throw new Error("x required");
            if (null == py || !Fp.isValid(py)) throw new Error("y required");
            if (null == pz || !Fp.isValid(pz)) throw new Error("z required");
            Object.freeze(this);
        }
        static fromAffine(p) {
            const {x: x, y: y} = p || {};
            if (!p || !Fp.isValid(x) || !Fp.isValid(y)) throw new Error("invalid affine point");
            if (p instanceof Point) throw new Error("projective point not allowed");
            const is0 = i => Fp.eql(i, Fp.ZERO);
            return is0(x) && is0(y) ? Point.ZERO : new Point(x, y, Fp.ONE);
        }
        get x() {
            return this.toAffine().x;
        }
        get y() {
            return this.toAffine().y;
        }
        static normalizeZ(points) {
            const toInv = Fp.invertBatch(points.map((p => p.pz)));
            return points.map(((p, i) => p.toAffine(toInv[i]))).map(Point.fromAffine);
        }
        static fromHex(hex) {
            const P = Point.fromAffine(fromBytes(ensureBytes("pointHex", hex)));
            return P.assertValidity(), P;
        }
        static fromPrivateKey(privateKey) {
            return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));
        }
        static msm(points, scalars) {
            return pippenger(Point, Fn, points, scalars);
        }
        _setWindowSize(windowSize) {
            wnaf.setWindowSize(this, windowSize);
        }
        assertValidity() {
            assertValidMemo(this);
        }
        hasEvenY() {
            const {y: y} = this.toAffine();
            if (Fp.isOdd) return !Fp.isOdd(y);
            throw new Error("Field doesn't support isOdd");
        }
        equals(other) {
            assertPrjPoint(other);
            const {px: X1, py: Y1, pz: Z1} = this, {px: X2, py: Y2, pz: Z2} = other, U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1)), U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));
            return U1 && U2;
        }
        negate() {
            return new Point(this.px, Fp.neg(this.py), this.pz);
        }
        double() {
            const {a: a, b: b} = CURVE, b3 = Fp.mul(b, _3n), {px: X1, py: Y1, pz: Z1} = this;
            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO, t0 = Fp.mul(X1, X1), t1 = Fp.mul(Y1, Y1), t2 = Fp.mul(Z1, Z1), t3 = Fp.mul(X1, Y1);
            return t3 = Fp.add(t3, t3), Z3 = Fp.mul(X1, Z1), Z3 = Fp.add(Z3, Z3), X3 = Fp.mul(a, Z3), 
            Y3 = Fp.mul(b3, t2), Y3 = Fp.add(X3, Y3), X3 = Fp.sub(t1, Y3), Y3 = Fp.add(t1, Y3), 
            Y3 = Fp.mul(X3, Y3), X3 = Fp.mul(t3, X3), Z3 = Fp.mul(b3, Z3), t2 = Fp.mul(a, t2), 
            t3 = Fp.sub(t0, t2), t3 = Fp.mul(a, t3), t3 = Fp.add(t3, Z3), Z3 = Fp.add(t0, t0), 
            t0 = Fp.add(Z3, t0), t0 = Fp.add(t0, t2), t0 = Fp.mul(t0, t3), Y3 = Fp.add(Y3, t0), 
            t2 = Fp.mul(Y1, Z1), t2 = Fp.add(t2, t2), t0 = Fp.mul(t2, t3), X3 = Fp.sub(X3, t0), 
            Z3 = Fp.mul(t2, t1), Z3 = Fp.add(Z3, Z3), Z3 = Fp.add(Z3, Z3), new Point(X3, Y3, Z3);
        }
        add(other) {
            assertPrjPoint(other);
            const {px: X1, py: Y1, pz: Z1} = this, {px: X2, py: Y2, pz: Z2} = other;
            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO;
            const a = CURVE.a, b3 = Fp.mul(CURVE.b, _3n);
            let t0 = Fp.mul(X1, X2), t1 = Fp.mul(Y1, Y2), t2 = Fp.mul(Z1, Z2), t3 = Fp.add(X1, Y1), t4 = Fp.add(X2, Y2);
            t3 = Fp.mul(t3, t4), t4 = Fp.add(t0, t1), t3 = Fp.sub(t3, t4), t4 = Fp.add(X1, Z1);
            let t5 = Fp.add(X2, Z2);
            return t4 = Fp.mul(t4, t5), t5 = Fp.add(t0, t2), t4 = Fp.sub(t4, t5), t5 = Fp.add(Y1, Z1), 
            X3 = Fp.add(Y2, Z2), t5 = Fp.mul(t5, X3), X3 = Fp.add(t1, t2), t5 = Fp.sub(t5, X3), 
            Z3 = Fp.mul(a, t4), X3 = Fp.mul(b3, t2), Z3 = Fp.add(X3, Z3), X3 = Fp.sub(t1, Z3), 
            Z3 = Fp.add(t1, Z3), Y3 = Fp.mul(X3, Z3), t1 = Fp.add(t0, t0), t1 = Fp.add(t1, t0), 
            t2 = Fp.mul(a, t2), t4 = Fp.mul(b3, t4), t1 = Fp.add(t1, t2), t2 = Fp.sub(t0, t2), 
            t2 = Fp.mul(a, t2), t4 = Fp.add(t4, t2), t0 = Fp.mul(t1, t4), Y3 = Fp.add(Y3, t0), 
            t0 = Fp.mul(t5, t4), X3 = Fp.mul(t3, X3), X3 = Fp.sub(X3, t0), t0 = Fp.mul(t3, t1), 
            Z3 = Fp.mul(t5, Z3), Z3 = Fp.add(Z3, t0), new Point(X3, Y3, Z3);
        }
        subtract(other) {
            return this.add(other.negate());
        }
        is0() {
            return this.equals(Point.ZERO);
        }
        wNAF(n) {
            return wnaf.wNAFCached(this, n, Point.normalizeZ);
        }
        multiplyUnsafe(sc) {
            aInRange("scalar", sc, _0n, CURVE.n);
            const I = Point.ZERO;
            if (sc === _0n) return I;
            if (sc === _1n$1) return this;
            const {endo: endo} = CURVE;
            if (!endo) return wnaf.unsafeLadder(this, sc);
            let {k1neg: k1neg, k1: k1, k2neg: k2neg, k2: k2} = endo.splitScalar(sc), k1p = I, k2p = I, d = this;
            for (;k1 > _0n || k2 > _0n; ) k1 & _1n$1 && (k1p = k1p.add(d)), k2 & _1n$1 && (k2p = k2p.add(d)), 
            d = d.double(), k1 >>= _1n$1, k2 >>= _1n$1;
            return k1neg && (k1p = k1p.negate()), k2neg && (k2p = k2p.negate()), k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz), 
            k1p.add(k2p);
        }
        multiply(scalar) {
            const {endo: endo, n: N} = CURVE;
            let point, fake;
            if (aInRange("scalar", scalar, _1n$1, N), endo) {
                const {k1neg: k1neg, k1: k1, k2neg: k2neg, k2: k2} = endo.splitScalar(scalar);
                let {p: k1p, f: f1p} = this.wNAF(k1), {p: k2p, f: f2p} = this.wNAF(k2);
                k1p = wnaf.constTimeNegate(k1neg, k1p), k2p = wnaf.constTimeNegate(k2neg, k2p), 
                k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz), point = k1p.add(k2p), 
                fake = f1p.add(f2p);
            } else {
                const {p: p, f: f} = this.wNAF(scalar);
                point = p, fake = f;
            }
            return Point.normalizeZ([ point, fake ])[0];
        }
        multiplyAndAddUnsafe(Q, a, b) {
            const G = Point.BASE, mul = (P, a) => a !== _0n && a !== _1n$1 && P.equals(G) ? P.multiply(a) : P.multiplyUnsafe(a), sum = mul(this, a).add(mul(Q, b));
            return sum.is0() ? void 0 : sum;
        }
        toAffine(iz) {
            return toAffineMemo(this, iz);
        }
        isTorsionFree() {
            const {h: cofactor, isTorsionFree: isTorsionFree} = CURVE;
            if (cofactor === _1n$1) return !0;
            if (isTorsionFree) return isTorsionFree(Point, this);
            throw new Error("isTorsionFree() has not been declared for the elliptic curve");
        }
        clearCofactor() {
            const {h: cofactor, clearCofactor: clearCofactor} = CURVE;
            return cofactor === _1n$1 ? this : clearCofactor ? clearCofactor(Point, this) : this.multiplyUnsafe(CURVE.h);
        }
        toRawBytes(isCompressed = !0) {
            return abool("isCompressed", isCompressed), this.assertValidity(), toBytes(Point, this, isCompressed);
        }
        toHex(isCompressed = !0) {
            return abool("isCompressed", isCompressed), bytesToHex(this.toRawBytes(isCompressed));
        }
    }
    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE), Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);
    const _bits = CURVE.nBitLength, wnaf = wNAF(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
    return {
        CURVE: CURVE,
        ProjectivePoint: Point,
        normPrivateKeyToScalar: normPrivateKeyToScalar,
        weierstrassEquation: weierstrassEquation,
        isWithinCurveOrder: function(num) {
            return inRange$1(num, _1n$1, CURVE.n);
        }
    };
}

function validateOpts(curve) {
    const opts = validateBasic(curve);
    return validateObject(opts, {
        hash: "hash",
        hmac: "function",
        randomBytes: "function"
    }, {
        bits2int: "function",
        bits2int_modN: "function",
        lowS: "boolean"
    }), Object.freeze({
        lowS: !0,
        ...opts
    });
}

function weierstrass(curveDef) {
    const CURVE = validateOpts(curveDef), {Fp: Fp, n: CURVE_ORDER} = CURVE, compressedLen = Fp.BYTES + 1, uncompressedLen = 2 * Fp.BYTES + 1;
    function modN(a) {
        return mod(a, CURVE_ORDER);
    }
    function invN(a) {
        return invert(a, CURVE_ORDER);
    }
    const {ProjectivePoint: Point, normPrivateKeyToScalar: normPrivateKeyToScalar, weierstrassEquation: weierstrassEquation, isWithinCurveOrder: isWithinCurveOrder} = weierstrassPoints({
        ...CURVE,
        toBytes(_c, point, isCompressed) {
            const a = point.toAffine(), x = Fp.toBytes(a.x), cat = concatBytes;
            return abool("isCompressed", isCompressed), isCompressed ? cat(Uint8Array.from([ point.hasEvenY() ? 2 : 3 ]), x) : cat(Uint8Array.from([ 4 ]), x, Fp.toBytes(a.y));
        },
        fromBytes(bytes) {
            const len = bytes.length, head = bytes[0], tail = bytes.subarray(1);
            if (len !== compressedLen || 2 !== head && 3 !== head) {
                if (len === uncompressedLen && 4 === head) {
                    return {
                        x: Fp.fromBytes(tail.subarray(0, Fp.BYTES)),
                        y: Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES))
                    };
                }
                throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);
            }
            {
                const x = bytesToNumberBE(tail);
                if (!inRange$1(x, _1n$1, Fp.ORDER)) throw new Error("Point is not on curve");
                const y2 = weierstrassEquation(x);
                let y;
                try {
                    y = Fp.sqrt(y2);
                } catch (sqrtError) {
                    const suffix = sqrtError instanceof Error ? ": " + sqrtError.message : "";
                    throw new Error("Point is not on curve" + suffix);
                }
                return !(1 & ~head) !== ((y & _1n$1) === _1n$1) && (y = Fp.neg(y)), {
                    x: x,
                    y: y
                };
            }
        }
    }), numToNByteStr = num => bytesToHex(numberToBytesBE(num, CURVE.nByteLength));
    function isBiggerThanHalfOrder(number) {
        return number > CURVE_ORDER >> _1n$1;
    }
    const slcNum = (b, from, to) => bytesToNumberBE(b.slice(from, to));
    class Signature {
        constructor(r, s, recovery) {
            this.r = r, this.s = s, this.recovery = recovery, this.assertValidity();
        }
        static fromCompact(hex) {
            const l = CURVE.nByteLength;
            return hex = ensureBytes("compactSignature", hex, 2 * l), new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));
        }
        static fromDER(hex) {
            const {r: r, s: s} = DER.toSig(ensureBytes("DER", hex));
            return new Signature(r, s);
        }
        assertValidity() {
            aInRange("r", this.r, _1n$1, CURVE_ORDER), aInRange("s", this.s, _1n$1, CURVE_ORDER);
        }
        addRecoveryBit(recovery) {
            return new Signature(this.r, this.s, recovery);
        }
        recoverPublicKey(msgHash) {
            const {r: r, s: s, recovery: rec} = this, h = bits2int_modN(ensureBytes("msgHash", msgHash));
            if (null == rec || ![ 0, 1, 2, 3 ].includes(rec)) throw new Error("recovery id invalid");
            const radj = 2 === rec || 3 === rec ? r + CURVE.n : r;
            if (radj >= Fp.ORDER) throw new Error("recovery id 2 or 3 invalid");
            const prefix = 1 & rec ? "03" : "02", R = Point.fromHex(prefix + numToNByteStr(radj)), ir = invN(radj), u1 = modN(-h * ir), u2 = modN(s * ir), Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2);
            if (!Q) throw new Error("point at infinify");
            return Q.assertValidity(), Q;
        }
        hasHighS() {
            return isBiggerThanHalfOrder(this.s);
        }
        normalizeS() {
            return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;
        }
        toDERRawBytes() {
            return hexToBytes(this.toDERHex());
        }
        toDERHex() {
            return DER.hexFromSig({
                r: this.r,
                s: this.s
            });
        }
        toCompactRawBytes() {
            return hexToBytes(this.toCompactHex());
        }
        toCompactHex() {
            return numToNByteStr(this.r) + numToNByteStr(this.s);
        }
    }
    const utils = {
        isValidPrivateKey(privateKey) {
            try {
                return normPrivateKeyToScalar(privateKey), !0;
            } catch (error) {
                return !1;
            }
        },
        normPrivateKeyToScalar: normPrivateKeyToScalar,
        randomPrivateKey: () => {
            const length = getMinHashLength(CURVE.n);
            return mapHashToField(CURVE.randomBytes(length), CURVE.n);
        },
        precompute: (windowSize = 8, point = Point.BASE) => (point._setWindowSize(windowSize), 
        point.multiply(BigInt(3)), point)
    };
    function isProbPub(item) {
        const arr = isBytes(item), str = "string" == typeof item, len = (arr || str) && item.length;
        return arr ? len === compressedLen || len === uncompressedLen : str ? len === 2 * compressedLen || len === 2 * uncompressedLen : item instanceof Point;
    }
    const bits2int = CURVE.bits2int || function(bytes) {
        const num = bytesToNumberBE(bytes), delta = 8 * bytes.length - CURVE.nBitLength;
        return delta > 0 ? num >> BigInt(delta) : num;
    }, bits2int_modN = CURVE.bits2int_modN || function(bytes) {
        return modN(bits2int(bytes));
    }, ORDER_MASK = bitMask(CURVE.nBitLength);
    function int2octets(num) {
        return aInRange(`num < 2^${CURVE.nBitLength}`, num, _0n, ORDER_MASK), numberToBytesBE(num, CURVE.nByteLength);
    }
    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
        if ([ "recovered", "canonical" ].some((k => k in opts))) throw new Error("sign() legacy options not supported");
        const {hash: hash, randomBytes: randomBytes} = CURVE;
        let {lowS: lowS, prehash: prehash, extraEntropy: ent} = opts;
        null == lowS && (lowS = !0), msgHash = ensureBytes("msgHash", msgHash), validateSigVerOpts(opts), 
        prehash && (msgHash = ensureBytes("prehashed msgHash", hash(msgHash)));
        const h1int = bits2int_modN(msgHash), d = normPrivateKeyToScalar(privateKey), seedArgs = [ int2octets(d), int2octets(h1int) ];
        if (null != ent && !1 !== ent) {
            const e = !0 === ent ? randomBytes(Fp.BYTES) : ent;
            seedArgs.push(ensureBytes("extraEntropy", e));
        }
        const seed = concatBytes(...seedArgs), m = h1int;
        return {
            seed: seed,
            k2sig: function(kBytes) {
                const k = bits2int(kBytes);
                if (!isWithinCurveOrder(k)) return;
                const ik = invN(k), q = Point.BASE.multiply(k).toAffine(), r = modN(q.x);
                if (r === _0n) return;
                const s = modN(ik * modN(m + r * d));
                if (s === _0n) return;
                let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n$1), normS = s;
                return lowS && isBiggerThanHalfOrder(s) && (normS = function(s) {
                    return isBiggerThanHalfOrder(s) ? modN(-s) : s;
                }(s), recovery ^= 1), new Signature(r, normS, recovery);
            }
        };
    }
    const defaultSigOpts = {
        lowS: CURVE.lowS,
        prehash: !1
    }, defaultVerOpts = {
        lowS: CURVE.lowS,
        prehash: !1
    };
    return Point.BASE._setWindowSize(8), {
        CURVE: CURVE,
        getPublicKey: function(privateKey, isCompressed = !0) {
            return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);
        },
        getSharedSecret: function(privateA, publicB, isCompressed = !0) {
            if (isProbPub(privateA)) throw new Error("first arg must be private key");
            if (!isProbPub(publicB)) throw new Error("second arg must be public key");
            return Point.fromHex(publicB).multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
        },
        sign: function(msgHash, privKey, opts = defaultSigOpts) {
            const {seed: seed, k2sig: k2sig} = prepSig(msgHash, privKey, opts), C = CURVE;
            return createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac)(seed, k2sig);
        },
        verify: function(signature, msgHash, publicKey, opts = defaultVerOpts) {
            const sg = signature;
            if (msgHash = ensureBytes("msgHash", msgHash), publicKey = ensureBytes("publicKey", publicKey), 
            "strict" in opts) throw new Error("options.strict was renamed to lowS");
            validateSigVerOpts(opts);
            const {lowS: lowS, prehash: prehash} = opts;
            let _sig, P;
            try {
                if ("string" == typeof sg || isBytes(sg)) try {
                    _sig = Signature.fromDER(sg);
                } catch (derError) {
                    if (!(derError instanceof DER.Err)) throw derError;
                    _sig = Signature.fromCompact(sg);
                } else {
                    if ("object" != typeof sg || "bigint" != typeof sg.r || "bigint" != typeof sg.s) throw new Error("PARSE");
                    {
                        const {r: r, s: s} = sg;
                        _sig = new Signature(r, s);
                    }
                }
                P = Point.fromHex(publicKey);
            } catch (error) {
                if ("PARSE" === error.message) throw new Error("signature must be Signature instance, Uint8Array or hex string");
                return !1;
            }
            if (lowS && _sig.hasHighS()) return !1;
            prehash && (msgHash = CURVE.hash(msgHash));
            const {r: r, s: s} = _sig, h = bits2int_modN(msgHash), is = invN(s), u1 = modN(h * is), u2 = modN(r * is), R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine();
            return !!R && modN(R.x) === r;
        },
        ProjectivePoint: Point,
        Signature: Signature,
        utils: utils
    };
}

/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ function getHash(hash) {
    return {
        hash: hash,
        hmac: (key, ...msgs) => hmac(hash, key, concatBytes$1(...msgs)),
        randomBytes: randomBytes
    };
}

function createCurve(curveDef, defHash) {
    const create = hash => weierstrass({
        ...curveDef,
        ...getHash(hash)
    });
    return Object.freeze({
        ...create(defHash),
        create: create
    });
}

/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ BigInt(4);

const secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"), secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"), _1n = BigInt(1), _2n = BigInt(2), divNearest = (a, b) => (a + b / _2n) / b;

function sqrtMod(y) {
    const P = secp256k1P, _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22), _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88), b2 = y * y * y % P, b3 = b2 * b2 * y % P, b6 = pow2(b3, _3n, P) * b3 % P, b9 = pow2(b6, _3n, P) * b3 % P, b11 = pow2(b9, _2n, P) * b2 % P, b22 = pow2(b11, _11n, P) * b11 % P, b44 = pow2(b22, _22n, P) * b22 % P, b88 = pow2(b44, _44n, P) * b44 % P, b176 = pow2(b88, _88n, P) * b88 % P, b220 = pow2(b176, _44n, P) * b44 % P, b223 = pow2(b220, _3n, P) * b3 % P, t1 = pow2(b223, _23n, P) * b22 % P, t2 = pow2(t1, _6n, P) * b2 % P, root = pow2(t2, _2n, P);
    if (!Fp.eql(Fp.sqr(root), y)) throw new Error("Cannot find square root");
    return root;
}

const Fp = Field(secp256k1P, void 0, void 0, {
    sqrt: sqrtMod
}), secp256k1 = createCurve({
    a: BigInt(0),
    b: BigInt(7),
    Fp: Fp,
    n: secp256k1N,
    Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
    Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
    h: BigInt(1),
    lowS: !0,
    endo: {
        beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
        splitScalar: k => {
            const n = secp256k1N, a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), b1 = -_1n * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), b2 = a1, POW_2_128 = BigInt("0x100000000000000000000000000000000"), c1 = divNearest(b2 * k, n), c2 = divNearest(-b1 * k, n);
            let k1 = mod(k - c1 * a1 - c2 * a2, n), k2 = mod(-c1 * b1 - c2 * b2, n);
            const k1neg = k1 > POW_2_128, k2neg = k2 > POW_2_128;
            if (k1neg && (k1 = n - k1), k2neg && (k2 = n - k2), k1 > POW_2_128 || k2 > POW_2_128) throw new Error("splitScalar: Endomorphism failed, k=" + k);
            return {
                k1neg: k1neg,
                k1: k1,
                k2neg: k2neg,
                k2: k2
            };
        }
    }
}, sha256);

BigInt(0), secp256k1.ProjectivePoint;

const generateKeypair = () => {
    const privateScalar = ed25519.utils.randomPrivateKey(), publicKey = getPublicKey(privateScalar), secretKey = new Uint8Array(64);
    return secretKey.set(privateScalar), secretKey.set(publicKey, 32), {
        publicKey: publicKey,
        secretKey: secretKey
    };
}, getPublicKey = ed25519.getPublicKey;

function isOnCurve(publicKey) {
    try {
        return ed25519.ExtendedPoint.fromHex(publicKey), !0;
    } catch {
        return !1;
    }
}

const toBuffer = arr => Buffer$1.isBuffer(arr) ? arr : arr instanceof Uint8Array ? Buffer$1.from(arr.buffer, arr.byteOffset, arr.byteLength) : Buffer$1.from(arr);

class Struct {
    constructor(properties) {
        Object.assign(this, properties);
    }
    encode() {
        return Buffer$1.from(libExports$1.serialize(SOLANA_SCHEMA, this));
    }
    static decode(data) {
        return libExports$1.deserialize(SOLANA_SCHEMA, this, data);
    }
    static decodeUnchecked(data) {
        return libExports$1.deserializeUnchecked(SOLANA_SCHEMA, this, data);
    }
}

const SOLANA_SCHEMA = new Map;

var _PublicKey;

const MAX_SEED_LENGTH = 32, PUBLIC_KEY_LENGTH = 32;

function isPublicKeyData(value) {
    return void 0 !== value._bn;
}

let uniquePublicKeyCounter = 1;

class PublicKey extends Struct {
    constructor(value) {
        if (super({}), this._bn = void 0, isPublicKeyData(value)) this._bn = value._bn; else {
            if ("string" == typeof value) {
                const decoded = bs58.decode(value);
                if (decoded.length != PUBLIC_KEY_LENGTH) throw new Error("Invalid public key input");
                this._bn = new BN(decoded);
            } else this._bn = new BN(value);
            if (this._bn.byteLength() > PUBLIC_KEY_LENGTH) throw new Error("Invalid public key input");
        }
    }
    static unique() {
        const key = new PublicKey(uniquePublicKeyCounter);
        return uniquePublicKeyCounter += 1, new PublicKey(key.toBuffer());
    }
    equals(publicKey) {
        return this._bn.eq(publicKey._bn);
    }
    toBase58() {
        return bs58.encode(this.toBytes());
    }
    toJSON() {
        return this.toBase58();
    }
    toBytes() {
        const buf = this.toBuffer();
        return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
    }
    toBuffer() {
        const b = this._bn.toArrayLike(Buffer$1);
        if (b.length === PUBLIC_KEY_LENGTH) return b;
        const zeroPad = Buffer$1.alloc(32);
        return b.copy(zeroPad, 32 - b.length), zeroPad;
    }
    get [Symbol.toStringTag]() {
        return `PublicKey(${this.toString()})`;
    }
    toString() {
        return this.toBase58();
    }
    static async createWithSeed(fromPublicKey, seed, programId) {
        const buffer = Buffer$1.concat([ fromPublicKey.toBuffer(), Buffer$1.from(seed), programId.toBuffer() ]), publicKeyBytes = sha256(buffer);
        return new PublicKey(publicKeyBytes);
    }
    static createProgramAddressSync(seeds, programId) {
        let buffer = Buffer$1.alloc(0);
        seeds.forEach((function(seed) {
            if (seed.length > MAX_SEED_LENGTH) throw new TypeError("Max seed length exceeded");
            buffer = Buffer$1.concat([ buffer, toBuffer(seed) ]);
        })), buffer = Buffer$1.concat([ buffer, programId.toBuffer(), Buffer$1.from("ProgramDerivedAddress") ]);
        const publicKeyBytes = sha256(buffer);
        if (isOnCurve(publicKeyBytes)) throw new Error("Invalid seeds, address must fall off the curve");
        return new PublicKey(publicKeyBytes);
    }
    static async createProgramAddress(seeds, programId) {
        return this.createProgramAddressSync(seeds, programId);
    }
    static findProgramAddressSync(seeds, programId) {
        let address, nonce = 255;
        for (;0 != nonce; ) {
            try {
                const seedsWithNonce = seeds.concat(Buffer$1.from([ nonce ]));
                address = this.createProgramAddressSync(seedsWithNonce, programId);
            } catch (err) {
                if (err instanceof TypeError) throw err;
                nonce--;
                continue;
            }
            return [ address, nonce ];
        }
        throw new Error("Unable to find a viable program address nonce");
    }
    static async findProgramAddress(seeds, programId) {
        return this.findProgramAddressSync(seeds, programId);
    }
    static isOnCurve(pubkeyData) {
        return isOnCurve(new PublicKey(pubkeyData).toBytes());
    }
}

_PublicKey = PublicKey, PublicKey.default = new _PublicKey("11111111111111111111111111111111"), 
SOLANA_SCHEMA.set(PublicKey, {
    kind: "struct",
    fields: [ [ "_bn", "u256" ] ]
}), new PublicKey("BPFLoader1111111111111111111111111111111111");

const SIGNATURE_LENGTH_IN_BYTES = 64, publicKey = (property = "publicKey") => LayoutExports.blob(32, property), rustString = (property = "string") => {
    const rsl = LayoutExports.struct([ LayoutExports.u32("length"), LayoutExports.u32("lengthPadding"), LayoutExports.blob(LayoutExports.offset(LayoutExports.u32(), -8), "chars") ], property), _decode = rsl.decode.bind(rsl), _encode = rsl.encode.bind(rsl), rslShim = rsl;
    return rslShim.decode = (b, offset) => _decode(b, offset).chars.toString(), rslShim.encode = (str, b, offset) => {
        const data = {
            chars: Buffer$1.from(str, "utf8")
        };
        return _encode(data, b, offset);
    }, rslShim.alloc = str => LayoutExports.u32().span + LayoutExports.u32().span + Buffer$1.from(str, "utf8").length, 
    rslShim;
}, authorized = (property = "authorized") => LayoutExports.struct([ publicKey("staker"), publicKey("withdrawer") ], property), lockup = (property = "lockup") => LayoutExports.struct([ LayoutExports.ns64("unixTimestamp"), LayoutExports.ns64("epoch"), publicKey("custodian") ], property), voteInit = (property = "voteInit") => LayoutExports.struct([ publicKey("nodePubkey"), publicKey("authorizedVoter"), publicKey("authorizedWithdrawer"), LayoutExports.u8("commission") ], property), voteAuthorizeWithSeedArgs = (property = "voteAuthorizeWithSeedArgs") => LayoutExports.struct([ LayoutExports.u32("voteAuthorizationType"), publicKey("currentAuthorityDerivedKeyOwnerPubkey"), rustString("currentAuthorityDerivedKeySeed"), publicKey("newAuthorized") ], property);

Buffer$1.alloc(SIGNATURE_LENGTH_IN_BYTES).fill(0), new PublicKey("SysvarC1ock11111111111111111111111111111111"), 
new PublicKey("SysvarEpochSchedu1e111111111111111111111111"), new PublicKey("Sysvar1nstructions1111111111111111111111111"), 
new PublicKey("SysvarRecentB1ockHashes11111111111111111111"), new PublicKey("SysvarRent111111111111111111111111111111111"), 
new PublicKey("SysvarRewards111111111111111111111111111111"), new PublicKey("SysvarS1otHashes111111111111111111111111111"), 
new PublicKey("SysvarS1otHistory11111111111111111111111111"), new PublicKey("SysvarStakeHistory1111111111111111111111111");

const FeeCalculatorLayout = LayoutExports.nu64("lamportsPerSignature"), NonceAccountLayout = LayoutExports.struct([ LayoutExports.u32("version"), LayoutExports.u32("state"), publicKey("authorizedPubkey"), publicKey("nonce"), LayoutExports.struct([ FeeCalculatorLayout ], "feeCalculator") ]);

NonceAccountLayout.span;

const encodeDecode = layout => ({
    decode: layout.decode.bind(layout),
    encode: layout.encode.bind(layout)
}), bigInt = length => property => {
    const layout = LayoutExports.blob(length, property), {encode: encode, decode: decode} = encodeDecode(layout), bigIntLayout = layout;
    return bigIntLayout.decode = (buffer, offset) => {
        const src = decode(buffer, offset);
        return nodeExports.toBigIntLE(Buffer$1.from(src));
    }, bigIntLayout.encode = (bigInt, buffer, offset) => {
        const src = nodeExports.toBufferLE(bigInt, length);
        return encode(src, buffer, offset);
    }, bigIntLayout;
}, u64 = bigInt(8);

Object.freeze({
    Create: {
        index: 0,
        layout: LayoutExports.struct([ LayoutExports.u32("instruction"), LayoutExports.ns64("lamports"), LayoutExports.ns64("space"), publicKey("programId") ])
    },
    Assign: {
        index: 1,
        layout: LayoutExports.struct([ LayoutExports.u32("instruction"), publicKey("programId") ])
    },
    Transfer: {
        index: 2,
        layout: LayoutExports.struct([ LayoutExports.u32("instruction"), u64("lamports") ])
    },
    CreateWithSeed: {
        index: 3,
        layout: LayoutExports.struct([ LayoutExports.u32("instruction"), publicKey("base"), rustString("seed"), LayoutExports.ns64("lamports"), LayoutExports.ns64("space"), publicKey("programId") ])
    },
    AdvanceNonceAccount: {
        index: 4,
        layout: LayoutExports.struct([ LayoutExports.u32("instruction") ])
    },
    WithdrawNonceAccount: {
        index: 5,
        layout: LayoutExports.struct([ LayoutExports.u32("instruction"), LayoutExports.ns64("lamports") ])
    },
    InitializeNonceAccount: {
        index: 6,
        layout: LayoutExports.struct([ LayoutExports.u32("instruction"), publicKey("authorized") ])
    },
    AuthorizeNonceAccount: {
        index: 7,
        layout: LayoutExports.struct([ LayoutExports.u32("instruction"), publicKey("authorized") ])
    },
    Allocate: {
        index: 8,
        layout: LayoutExports.struct([ LayoutExports.u32("instruction"), LayoutExports.ns64("space") ])
    },
    AllocateWithSeed: {
        index: 9,
        layout: LayoutExports.struct([ LayoutExports.u32("instruction"), publicKey("base"), rustString("seed"), LayoutExports.ns64("space"), publicKey("programId") ])
    },
    AssignWithSeed: {
        index: 10,
        layout: LayoutExports.struct([ LayoutExports.u32("instruction"), publicKey("base"), rustString("seed"), publicKey("programId") ])
    },
    TransferWithSeed: {
        index: 11,
        layout: LayoutExports.struct([ LayoutExports.u32("instruction"), u64("lamports"), rustString("seed"), publicKey("programId") ])
    },
    UpgradeNonceAccount: {
        index: 12,
        layout: LayoutExports.struct([ LayoutExports.u32("instruction") ])
    }
}), new PublicKey("11111111111111111111111111111111"), new PublicKey("BPFLoader2111111111111111111111111111111111");

var agentkeepalive = {
    exports: {}
}, s = 1e3, m = 60 * s, h = 60 * m, d = 24 * h, w = 7 * d, y = 365.25 * d, ms$2 = function(val, options) {
    options = options || {};
    var type = typeof val;
    if ("string" === type && val.length > 0) return parse(val);
    if ("number" === type && isFinite(val)) return options.long ? fmtLong(val) : fmtShort(val);
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
};

function parse(str) {
    if (!((str = String(str)).length > 100)) {
        var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
        if (match) {
            var n = parseFloat(match[1]);
            switch ((match[2] || "ms").toLowerCase()) {
              case "years":
              case "year":
              case "yrs":
              case "yr":
              case "y":
                return n * y;

              case "weeks":
              case "week":
              case "w":
                return n * w;

              case "days":
              case "day":
              case "d":
                return n * d;

              case "hours":
              case "hour":
              case "hrs":
              case "hr":
              case "h":
                return n * h;

              case "minutes":
              case "minute":
              case "mins":
              case "min":
              case "m":
                return n * m;

              case "seconds":
              case "second":
              case "secs":
              case "sec":
              case "s":
                return n * s;

              case "milliseconds":
              case "millisecond":
              case "msecs":
              case "msec":
              case "ms":
                return n;

              default:
                return;
            }
        }
    }
}

function fmtShort(ms) {
    var msAbs = Math.abs(ms);
    return msAbs >= d ? Math.round(ms / d) + "d" : msAbs >= h ? Math.round(ms / h) + "h" : msAbs >= m ? Math.round(ms / m) + "m" : msAbs >= s ? Math.round(ms / s) + "s" : ms + "ms";
}

function fmtLong(ms) {
    var msAbs = Math.abs(ms);
    return msAbs >= d ? plural(ms, msAbs, d, "day") : msAbs >= h ? plural(ms, msAbs, h, "hour") : msAbs >= m ? plural(ms, msAbs, m, "minute") : msAbs >= s ? plural(ms, msAbs, s, "second") : ms + " ms";
}

function plural(ms, msAbs, n, name) {
    var isPlural = msAbs >= 1.5 * n;
    return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
}

/*!
 * humanize-ms - index.js
 * Copyright(c) 2014 dead_horse <dead_horse@qq.com>
 * MIT Licensed
 */ var util = require$$0$6, ms$1 = ms$2, humanizeMs = function(t) {
    if ("number" == typeof t) return t;
    var r = ms$1(t);
    if (void 0 === r) new Error(util.format("humanize-ms(%j) result undefined", t));
    return r;
}, constants = {
    CURRENT_ID: Symbol("agentkeepalive#currentId"),
    CREATE_ID: Symbol("agentkeepalive#createId"),
    INIT_SOCKET: Symbol("agentkeepalive#initSocket"),
    CREATE_HTTPS_CONNECTION: Symbol("agentkeepalive#createHttpsConnection"),
    SOCKET_CREATED_TIME: Symbol("agentkeepalive#socketCreatedTime"),
    SOCKET_NAME: Symbol("agentkeepalive#socketName"),
    SOCKET_REQUEST_COUNT: Symbol("agentkeepalive#socketRequestCount"),
    SOCKET_REQUEST_FINISHED_COUNT: Symbol("agentkeepalive#socketRequestFinishedCount")
};

const OriginalAgent = http.Agent, ms = humanizeMs, debug = require$$0$6.debuglog("agentkeepalive"), {INIT_SOCKET: INIT_SOCKET$1, CURRENT_ID: CURRENT_ID, CREATE_ID: CREATE_ID, SOCKET_CREATED_TIME: SOCKET_CREATED_TIME, SOCKET_NAME: SOCKET_NAME, SOCKET_REQUEST_COUNT: SOCKET_REQUEST_COUNT, SOCKET_REQUEST_FINISHED_COUNT: SOCKET_REQUEST_FINISHED_COUNT} = constants;

let defaultTimeoutListenerCount = 1;

const majorVersion = parseInt(process.version.split(".", 1)[0].substring(1));

function deprecate(message) {
    console.log("[agentkeepalive:deprecated] %s", message);
}

majorVersion >= 11 && majorVersion <= 12 ? defaultTimeoutListenerCount = 2 : majorVersion >= 13 && (defaultTimeoutListenerCount = 3);

class Agent extends OriginalAgent {
    constructor(options) {
        (options = options || {}).keepAlive = !1 !== options.keepAlive, void 0 === options.freeSocketTimeout && (options.freeSocketTimeout = 4e3), 
        options.keepAliveTimeout && (deprecate("options.keepAliveTimeout is deprecated, please use options.freeSocketTimeout instead"), 
        options.freeSocketTimeout = options.keepAliveTimeout, delete options.keepAliveTimeout), 
        options.freeSocketKeepAliveTimeout && (deprecate("options.freeSocketKeepAliveTimeout is deprecated, please use options.freeSocketTimeout instead"), 
        options.freeSocketTimeout = options.freeSocketKeepAliveTimeout, delete options.freeSocketKeepAliveTimeout), 
        void 0 === options.timeout && (options.timeout = Math.max(2 * options.freeSocketTimeout, 8e3)), 
        options.timeout = ms(options.timeout), options.freeSocketTimeout = ms(options.freeSocketTimeout), 
        options.socketActiveTTL = options.socketActiveTTL ? ms(options.socketActiveTTL) : 0, 
        super(options), this[CURRENT_ID] = 0, this.createSocketCount = 0, this.createSocketCountLastCheck = 0, 
        this.createSocketErrorCount = 0, this.createSocketErrorCountLastCheck = 0, this.closeSocketCount = 0, 
        this.closeSocketCountLastCheck = 0, this.errorSocketCount = 0, this.errorSocketCountLastCheck = 0, 
        this.requestCount = 0, this.requestCountLastCheck = 0, this.timeoutSocketCount = 0, 
        this.timeoutSocketCountLastCheck = 0, this.on("free", (socket => {
            const timeout = this.calcSocketTimeout(socket);
            timeout > 0 && socket.timeout !== timeout && socket.setTimeout(timeout);
        }));
    }
    get freeSocketKeepAliveTimeout() {
        return deprecate("agent.freeSocketKeepAliveTimeout is deprecated, please use agent.options.freeSocketTimeout instead"), 
        this.options.freeSocketTimeout;
    }
    get timeout() {
        return deprecate("agent.timeout is deprecated, please use agent.options.timeout instead"), 
        this.options.timeout;
    }
    get socketActiveTTL() {
        return deprecate("agent.socketActiveTTL is deprecated, please use agent.options.socketActiveTTL instead"), 
        this.options.socketActiveTTL;
    }
    calcSocketTimeout(socket) {
        let freeSocketTimeout = this.options.freeSocketTimeout;
        const socketActiveTTL = this.options.socketActiveTTL;
        if (socketActiveTTL) {
            const diff = socketActiveTTL - (Date.now() - socket[SOCKET_CREATED_TIME]);
            if (diff <= 0) return diff;
            freeSocketTimeout && diff < freeSocketTimeout && (freeSocketTimeout = diff);
        }
        if (freeSocketTimeout) {
            return socket.freeSocketTimeout || socket.freeSocketKeepAliveTimeout || freeSocketTimeout;
        }
    }
    keepSocketAlive(socket) {
        const result = super.keepSocketAlive(socket);
        if (!result) return result;
        const customTimeout = this.calcSocketTimeout(socket);
        return void 0 === customTimeout || (customTimeout <= 0 ? (debug("%s(requests: %s, finished: %s) free but need to destroy by TTL, request count %s, diff is %s", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT], customTimeout), 
        !1) : (socket.timeout !== customTimeout && socket.setTimeout(customTimeout), !0));
    }
    reuseSocket(...args) {
        super.reuseSocket(...args);
        const socket = args[0];
        args[1].reusedSocket = !0;
        const agentTimeout = this.options.timeout;
        getSocketTimeout(socket) !== agentTimeout && (socket.setTimeout(agentTimeout), debug("%s reset timeout to %sms", socket[SOCKET_NAME], agentTimeout)), 
        socket[SOCKET_REQUEST_COUNT]++, debug("%s(requests: %s, finished: %s) reuse on addRequest, timeout %sms", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT], getSocketTimeout(socket));
    }
    [CREATE_ID]() {
        const id = this[CURRENT_ID]++;
        return this[CURRENT_ID] === Number.MAX_SAFE_INTEGER && (this[CURRENT_ID] = 0), id;
    }
    [INIT_SOCKET$1](socket, options) {
        if (options.timeout) {
            getSocketTimeout(socket) || socket.setTimeout(options.timeout);
        }
        this.options.keepAlive && socket.setNoDelay(!0), this.createSocketCount++, this.options.socketActiveTTL && (socket[SOCKET_CREATED_TIME] = Date.now()), 
        socket[SOCKET_NAME] = `sock[${this[CREATE_ID]()}#${options._agentKey}]`.split("-----BEGIN", 1)[0], 
        socket[SOCKET_REQUEST_COUNT] = 1, socket[SOCKET_REQUEST_FINISHED_COUNT] = 0, installListeners(this, socket, options);
    }
    createConnection(options, oncreate) {
        let called = !1;
        const onNewCreate = (err, socket) => {
            if (!called) {
                if (called = !0, err) return this.createSocketErrorCount++, oncreate(err);
                this[INIT_SOCKET$1](socket, options), oncreate(err, socket);
            }
        }, newSocket = super.createConnection(options, onNewCreate);
        return newSocket && onNewCreate(null, newSocket), newSocket;
    }
    get statusChanged() {
        const changed = this.createSocketCount !== this.createSocketCountLastCheck || this.createSocketErrorCount !== this.createSocketErrorCountLastCheck || this.closeSocketCount !== this.closeSocketCountLastCheck || this.errorSocketCount !== this.errorSocketCountLastCheck || this.timeoutSocketCount !== this.timeoutSocketCountLastCheck || this.requestCount !== this.requestCountLastCheck;
        return changed && (this.createSocketCountLastCheck = this.createSocketCount, this.createSocketErrorCountLastCheck = this.createSocketErrorCount, 
        this.closeSocketCountLastCheck = this.closeSocketCount, this.errorSocketCountLastCheck = this.errorSocketCount, 
        this.timeoutSocketCountLastCheck = this.timeoutSocketCount, this.requestCountLastCheck = this.requestCount), 
        changed;
    }
    getCurrentStatus() {
        return {
            createSocketCount: this.createSocketCount,
            createSocketErrorCount: this.createSocketErrorCount,
            closeSocketCount: this.closeSocketCount,
            errorSocketCount: this.errorSocketCount,
            timeoutSocketCount: this.timeoutSocketCount,
            requestCount: this.requestCount,
            freeSockets: inspect(this.freeSockets),
            sockets: inspect(this.sockets),
            requests: inspect(this.requests)
        };
    }
}

function getSocketTimeout(socket) {
    return socket.timeout || socket._idleTimeout;
}

function installListeners(agent, socket, options) {
    function onFree() {
        if (!socket._httpMessage && 1 === socket[SOCKET_REQUEST_COUNT]) return;
        socket[SOCKET_REQUEST_FINISHED_COUNT]++, agent.requestCount++, debug("%s(requests: %s, finished: %s) free", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT]);
        const name = agent.getName(options);
        socket.writable && agent.requests[name] && agent.requests[name].length && (socket[SOCKET_REQUEST_COUNT]++, 
        debug("%s(requests: %s, finished: %s) will be reuse on agent free event", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT]));
    }
    function onClose(isError) {
        debug("%s(requests: %s, finished: %s) close, isError: %s", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT], isError), 
        agent.closeSocketCount++;
    }
    function onTimeout() {
        const listenerCount = socket.listeners("timeout").length, timeout = getSocketTimeout(socket), req = socket._httpMessage, reqTimeoutListenerCount = req && req.listeners("timeout").length || 0;
        debug("%s(requests: %s, finished: %s) timeout after %sms, listeners %s, defaultTimeoutListenerCount %s, hasHttpRequest %s, HttpRequest timeoutListenerCount %s", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT], timeout, listenerCount, defaultTimeoutListenerCount, !!req, reqTimeoutListenerCount), 
        debug.enabled && debug("timeout listeners: %s", socket.listeners("timeout").map((f => f.name)).join(", ")), 
        agent.timeoutSocketCount++;
        const name = agent.getName(options);
        if (agent.freeSockets[name] && -1 !== agent.freeSockets[name].indexOf(socket)) socket.destroy(), 
        agent.removeSocket(socket, options), debug("%s is free, destroy quietly", socket[SOCKET_NAME]); else if (0 === reqTimeoutListenerCount) {
            const error = new Error("Socket timeout");
            error.code = "ERR_SOCKET_TIMEOUT", error.timeout = timeout, socket.destroy(error), 
            agent.removeSocket(socket, options), debug("%s destroy with timeout error", socket[SOCKET_NAME]);
        }
    }
    function onError(err) {
        const listenerCount = socket.listeners("error").length;
        debug("%s(requests: %s, finished: %s) error: %s, listenerCount: %s", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT], err, listenerCount), 
        agent.errorSocketCount++, 1 === listenerCount && (debug("%s emit uncaught error event", socket[SOCKET_NAME]), 
        socket.removeListener("error", onError), socket.emit("error", err));
    }
    debug("%s create, timeout %sms", socket[SOCKET_NAME], getSocketTimeout(socket)), 
    socket.on("free", onFree), socket.on("close", onClose), socket.on("timeout", onTimeout), 
    socket.on("error", onError), socket.on("agentRemove", (function onRemove() {
        debug("%s(requests: %s, finished: %s) agentRemove", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT]), 
        socket.removeListener("close", onClose), socket.removeListener("error", onError), 
        socket.removeListener("free", onFree), socket.removeListener("timeout", onTimeout), 
        socket.removeListener("agentRemove", onRemove);
    }));
}

var agent = Agent;

function inspect(obj) {
    const res = {};
    for (const key in obj) res[key] = obj[key].length;
    return res;
}

const OriginalHttpsAgent = https.Agent, HttpAgent = agent, {INIT_SOCKET: INIT_SOCKET, CREATE_HTTPS_CONNECTION: CREATE_HTTPS_CONNECTION} = constants;

let HttpsAgent$1 = class extends HttpAgent {
    constructor(options) {
        super(options), this.defaultPort = 443, this.protocol = "https:", this.maxCachedSessions = this.options.maxCachedSessions, 
        void 0 === this.maxCachedSessions && (this.maxCachedSessions = 100), this._sessionCache = {
            map: {},
            list: []
        };
    }
    createConnection(options, oncreate) {
        const socket = this[CREATE_HTTPS_CONNECTION](options, oncreate);
        return this[INIT_SOCKET](socket, options), socket;
    }
};

HttpsAgent$1.prototype[CREATE_HTTPS_CONNECTION] = OriginalHttpsAgent.prototype.createConnection, 
[ "getName", "_getSession", "_cacheSession", "_evictSession" ].forEach((function(method) {
    "function" == typeof OriginalHttpsAgent.prototype[method] && (HttpsAgent$1.prototype[method] = OriginalHttpsAgent.prototype[method]);
}));

var https_agent = HttpsAgent$1;

agentkeepalive.exports = agent, agentkeepalive.exports.HttpsAgent = https_agent, 
agentkeepalive.exports.constants = constants, LayoutExports.struct([ LayoutExports.u32("typeIndex"), u64("deactivationSlot"), LayoutExports.nu64("lastExtendedSlot"), LayoutExports.u8("lastExtendedStartIndex"), LayoutExports.u8(), LayoutExports.seq(publicKey(), LayoutExports.offset(LayoutExports.u8(), -1), "authority") ]);

const PublicKeyFromString = coerce(instance(PublicKey), string(), (value => new PublicKey(value))), RawAccountDataResult = tuple([ string(), literal("base64") ]), BufferFromRawAccountData = coerce(instance(Buffer$1), RawAccountDataResult, (value => Buffer$1.from(value[0], "base64")));

function createRpcResult(result) {
    return union([ type({
        jsonrpc: literal("2.0"),
        id: string(),
        result: result
    }), type({
        jsonrpc: literal("2.0"),
        id: string(),
        error: type({
            code: unknown(),
            message: string(),
            data: optional(any())
        })
    }) ]);
}

const UnknownRpcResult = createRpcResult(unknown());

function jsonRpcResult(schema) {
    return coerce(createRpcResult(schema), UnknownRpcResult, (value => "error" in value ? value : {
        ...value,
        result: create(value.result, schema)
    }));
}

function jsonRpcResultAndContext(value) {
    return jsonRpcResult(type({
        context: type({
            slot: number()
        }),
        value: value
    }));
}

function notificationResultAndContext(value) {
    return type({
        context: type({
            slot: number()
        }),
        value: value
    });
}

const GetInflationGovernorResult = type({
    foundation: number(),
    foundationTerm: number(),
    initial: number(),
    taper: number(),
    terminal: number()
});

jsonRpcResult(array(nullable(type({
    epoch: number(),
    effectiveSlot: number(),
    amount: number(),
    postBalance: number(),
    commission: optional(nullable(number()))
}))));

const GetRecentPrioritizationFeesResult = array(type({
    slot: number(),
    prioritizationFee: number()
})), GetInflationRateResult = type({
    total: number(),
    validator: number(),
    foundation: number(),
    epoch: number()
}), GetEpochInfoResult = type({
    epoch: number(),
    slotIndex: number(),
    slotsInEpoch: number(),
    absoluteSlot: number(),
    blockHeight: optional(number()),
    transactionCount: optional(number())
}), GetEpochScheduleResult = type({
    slotsPerEpoch: number(),
    leaderScheduleSlotOffset: number(),
    warmup: boolean(),
    firstNormalEpoch: number(),
    firstNormalSlot: number()
}), GetLeaderScheduleResult = record(string(), array(number())), TransactionErrorResult = nullable(union([ type({}), string() ])), SignatureStatusResult = type({
    err: TransactionErrorResult
}), SignatureReceivedResult = literal("receivedSignature");

type({
    "solana-core": string(),
    "feature-set": optional(number())
});

const ParsedInstructionStruct = type({
    program: string(),
    programId: PublicKeyFromString,
    parsed: unknown()
}), PartiallyDecodedInstructionStruct = type({
    programId: PublicKeyFromString,
    accounts: array(PublicKeyFromString),
    data: string()
});

jsonRpcResultAndContext(type({
    err: nullable(union([ type({}), string() ])),
    logs: nullable(array(string())),
    accounts: optional(nullable(array(nullable(type({
        executable: boolean(),
        owner: string(),
        lamports: number(),
        data: array(string()),
        rentEpoch: optional(number())
    }))))),
    unitsConsumed: optional(number()),
    returnData: optional(nullable(type({
        programId: string(),
        data: tuple([ string(), literal("base64") ])
    }))),
    innerInstructions: optional(nullable(array(type({
        index: number(),
        instructions: array(union([ ParsedInstructionStruct, PartiallyDecodedInstructionStruct ]))
    }))))
})), jsonRpcResultAndContext(type({
    byIdentity: record(string(), array(number())),
    range: type({
        firstSlot: number(),
        lastSlot: number()
    })
})), jsonRpcResult(GetInflationGovernorResult), jsonRpcResult(GetInflationRateResult), 
jsonRpcResult(GetRecentPrioritizationFeesResult), jsonRpcResult(GetEpochInfoResult), 
jsonRpcResult(GetEpochScheduleResult), jsonRpcResult(GetLeaderScheduleResult), jsonRpcResult(number()), 
jsonRpcResultAndContext(type({
    total: number(),
    circulating: number(),
    nonCirculating: number(),
    nonCirculatingAccounts: array(PublicKeyFromString)
}));

const TokenAmountResult = type({
    amount: string(),
    uiAmount: nullable(number()),
    decimals: number(),
    uiAmountString: optional(string())
});

jsonRpcResultAndContext(array(type({
    address: PublicKeyFromString,
    amount: string(),
    uiAmount: nullable(number()),
    decimals: number(),
    uiAmountString: optional(string())
}))), jsonRpcResultAndContext(array(type({
    pubkey: PublicKeyFromString,
    account: type({
        executable: boolean(),
        owner: PublicKeyFromString,
        lamports: number(),
        data: BufferFromRawAccountData,
        rentEpoch: number()
    })
})));

const ParsedAccountDataResult = type({
    program: string(),
    parsed: unknown(),
    space: number()
});

jsonRpcResultAndContext(array(type({
    pubkey: PublicKeyFromString,
    account: type({
        executable: boolean(),
        owner: PublicKeyFromString,
        lamports: number(),
        data: ParsedAccountDataResult,
        rentEpoch: number()
    })
}))), jsonRpcResultAndContext(array(type({
    lamports: number(),
    address: PublicKeyFromString
})));

const AccountInfoResult = type({
    executable: boolean(),
    owner: PublicKeyFromString,
    lamports: number(),
    data: BufferFromRawAccountData,
    rentEpoch: number()
});

type({
    pubkey: PublicKeyFromString,
    account: AccountInfoResult
});

const ParsedOrRawAccountData = coerce(union([ instance(Buffer$1), ParsedAccountDataResult ]), union([ RawAccountDataResult, ParsedAccountDataResult ]), (value => Array.isArray(value) ? create(value, BufferFromRawAccountData) : value)), ParsedAccountInfoResult = type({
    executable: boolean(),
    owner: PublicKeyFromString,
    lamports: number(),
    data: ParsedOrRawAccountData,
    rentEpoch: number()
});

type({
    pubkey: PublicKeyFromString,
    account: ParsedAccountInfoResult
}), type({
    state: union([ literal("active"), literal("inactive"), literal("activating"), literal("deactivating") ]),
    active: number(),
    inactive: number()
}), jsonRpcResult(array(type({
    signature: string(),
    slot: number(),
    err: TransactionErrorResult,
    memo: nullable(string()),
    blockTime: optional(nullable(number()))
}))), jsonRpcResult(array(type({
    signature: string(),
    slot: number(),
    err: TransactionErrorResult,
    memo: nullable(string()),
    blockTime: optional(nullable(number()))
}))), type({
    subscription: number(),
    result: notificationResultAndContext(AccountInfoResult)
});

const ProgramAccountInfoResult = type({
    pubkey: PublicKeyFromString,
    account: AccountInfoResult
});

type({
    subscription: number(),
    result: notificationResultAndContext(ProgramAccountInfoResult)
});

const SlotInfoResult = type({
    parent: number(),
    slot: number(),
    root: number()
});

type({
    subscription: number(),
    result: SlotInfoResult
});

const SlotUpdateResult = union([ type({
    type: union([ literal("firstShredReceived"), literal("completed"), literal("optimisticConfirmation"), literal("root") ]),
    slot: number(),
    timestamp: number()
}), type({
    type: literal("createdBank"),
    parent: number(),
    slot: number(),
    timestamp: number()
}), type({
    type: literal("frozen"),
    slot: number(),
    timestamp: number(),
    stats: type({
        numTransactionEntries: number(),
        numSuccessfulTransactions: number(),
        numFailedTransactions: number(),
        maxTransactionsPerEntry: number()
    })
}), type({
    type: literal("dead"),
    slot: number(),
    timestamp: number(),
    err: string()
}) ]);

type({
    subscription: number(),
    result: SlotUpdateResult
}), type({
    subscription: number(),
    result: notificationResultAndContext(union([ SignatureStatusResult, SignatureReceivedResult ]))
}), type({
    subscription: number(),
    result: number()
}), type({
    pubkey: string(),
    gossip: nullable(string()),
    tpu: nullable(string()),
    rpc: nullable(string()),
    version: nullable(string())
});

const VoteAccountInfoResult = type({
    votePubkey: string(),
    nodePubkey: string(),
    activatedStake: number(),
    epochVoteAccount: boolean(),
    epochCredits: array(tuple([ number(), number(), number() ])),
    commission: number(),
    lastVote: number(),
    rootSlot: nullable(number())
});

jsonRpcResult(type({
    current: array(VoteAccountInfoResult),
    delinquent: array(VoteAccountInfoResult)
}));

const ConfirmationStatus = union([ literal("processed"), literal("confirmed"), literal("finalized") ]), SignatureStatusResponse = type({
    slot: number(),
    confirmations: nullable(number()),
    err: TransactionErrorResult,
    confirmationStatus: optional(ConfirmationStatus)
});

jsonRpcResultAndContext(array(nullable(SignatureStatusResponse))), jsonRpcResult(number());

const AddressTableLookupStruct = type({
    accountKey: PublicKeyFromString,
    writableIndexes: array(number()),
    readonlyIndexes: array(number())
}), ConfirmedTransactionResult = type({
    signatures: array(string()),
    message: type({
        accountKeys: array(string()),
        header: type({
            numRequiredSignatures: number(),
            numReadonlySignedAccounts: number(),
            numReadonlyUnsignedAccounts: number()
        }),
        instructions: array(type({
            accounts: array(number()),
            data: string(),
            programIdIndex: number()
        })),
        recentBlockhash: string(),
        addressTableLookups: optional(array(AddressTableLookupStruct))
    })
}), AnnotatedAccountKey = type({
    pubkey: PublicKeyFromString,
    signer: boolean(),
    writable: boolean(),
    source: optional(union([ literal("transaction"), literal("lookupTable") ]))
}), ConfirmedTransactionAccountsModeResult = type({
    accountKeys: array(AnnotatedAccountKey),
    signatures: array(string())
}), ParsedInstructionResult = type({
    parsed: unknown(),
    program: string(),
    programId: PublicKeyFromString
}), RawInstructionResult = type({
    accounts: array(PublicKeyFromString),
    data: string(),
    programId: PublicKeyFromString
}), InstructionResult = union([ RawInstructionResult, ParsedInstructionResult ]), UnknownInstructionResult = union([ type({
    parsed: unknown(),
    program: string(),
    programId: string()
}), type({
    accounts: array(string()),
    data: string(),
    programId: string()
}) ]), ParsedOrRawInstruction = coerce(InstructionResult, UnknownInstructionResult, (value => create(value, "accounts" in value ? RawInstructionResult : ParsedInstructionResult))), ParsedConfirmedTransactionResult = type({
    signatures: array(string()),
    message: type({
        accountKeys: array(AnnotatedAccountKey),
        instructions: array(ParsedOrRawInstruction),
        recentBlockhash: string(),
        addressTableLookups: optional(nullable(array(AddressTableLookupStruct)))
    })
}), TokenBalanceResult = type({
    accountIndex: number(),
    mint: string(),
    owner: optional(string()),
    uiTokenAmount: TokenAmountResult
}), LoadedAddressesResult = type({
    writable: array(PublicKeyFromString),
    readonly: array(PublicKeyFromString)
}), ConfirmedTransactionMetaResult = type({
    err: TransactionErrorResult,
    fee: number(),
    innerInstructions: optional(nullable(array(type({
        index: number(),
        instructions: array(type({
            accounts: array(number()),
            data: string(),
            programIdIndex: number()
        }))
    })))),
    preBalances: array(number()),
    postBalances: array(number()),
    logMessages: optional(nullable(array(string()))),
    preTokenBalances: optional(nullable(array(TokenBalanceResult))),
    postTokenBalances: optional(nullable(array(TokenBalanceResult))),
    loadedAddresses: optional(LoadedAddressesResult),
    computeUnitsConsumed: optional(number())
}), ParsedConfirmedTransactionMetaResult = type({
    err: TransactionErrorResult,
    fee: number(),
    innerInstructions: optional(nullable(array(type({
        index: number(),
        instructions: array(ParsedOrRawInstruction)
    })))),
    preBalances: array(number()),
    postBalances: array(number()),
    logMessages: optional(nullable(array(string()))),
    preTokenBalances: optional(nullable(array(TokenBalanceResult))),
    postTokenBalances: optional(nullable(array(TokenBalanceResult))),
    loadedAddresses: optional(LoadedAddressesResult),
    computeUnitsConsumed: optional(number())
}), TransactionVersionStruct = union([ literal(0), literal("legacy") ]), RewardsResult = type({
    pubkey: string(),
    lamports: number(),
    postBalance: nullable(number()),
    rewardType: nullable(string()),
    commission: optional(nullable(number()))
});

jsonRpcResult(nullable(type({
    blockhash: string(),
    previousBlockhash: string(),
    parentSlot: number(),
    transactions: array(type({
        transaction: ConfirmedTransactionResult,
        meta: nullable(ConfirmedTransactionMetaResult),
        version: optional(TransactionVersionStruct)
    })),
    rewards: optional(array(RewardsResult)),
    blockTime: nullable(number()),
    blockHeight: nullable(number())
}))), jsonRpcResult(nullable(type({
    blockhash: string(),
    previousBlockhash: string(),
    parentSlot: number(),
    rewards: optional(array(RewardsResult)),
    blockTime: nullable(number()),
    blockHeight: nullable(number())
}))), jsonRpcResult(nullable(type({
    blockhash: string(),
    previousBlockhash: string(),
    parentSlot: number(),
    transactions: array(type({
        transaction: ConfirmedTransactionAccountsModeResult,
        meta: nullable(ConfirmedTransactionMetaResult),
        version: optional(TransactionVersionStruct)
    })),
    rewards: optional(array(RewardsResult)),
    blockTime: nullable(number()),
    blockHeight: nullable(number())
}))), jsonRpcResult(nullable(type({
    blockhash: string(),
    previousBlockhash: string(),
    parentSlot: number(),
    transactions: array(type({
        transaction: ParsedConfirmedTransactionResult,
        meta: nullable(ParsedConfirmedTransactionMetaResult),
        version: optional(TransactionVersionStruct)
    })),
    rewards: optional(array(RewardsResult)),
    blockTime: nullable(number()),
    blockHeight: nullable(number())
}))), jsonRpcResult(nullable(type({
    blockhash: string(),
    previousBlockhash: string(),
    parentSlot: number(),
    transactions: array(type({
        transaction: ConfirmedTransactionAccountsModeResult,
        meta: nullable(ParsedConfirmedTransactionMetaResult),
        version: optional(TransactionVersionStruct)
    })),
    rewards: optional(array(RewardsResult)),
    blockTime: nullable(number()),
    blockHeight: nullable(number())
}))), jsonRpcResult(nullable(type({
    blockhash: string(),
    previousBlockhash: string(),
    parentSlot: number(),
    rewards: optional(array(RewardsResult)),
    blockTime: nullable(number()),
    blockHeight: nullable(number())
}))), jsonRpcResult(nullable(type({
    blockhash: string(),
    previousBlockhash: string(),
    parentSlot: number(),
    transactions: array(type({
        transaction: ConfirmedTransactionResult,
        meta: nullable(ConfirmedTransactionMetaResult)
    })),
    rewards: optional(array(RewardsResult)),
    blockTime: nullable(number())
}))), jsonRpcResult(nullable(type({
    blockhash: string(),
    previousBlockhash: string(),
    parentSlot: number(),
    signatures: array(string()),
    blockTime: nullable(number())
}))), jsonRpcResult(nullable(type({
    slot: number(),
    meta: nullable(ConfirmedTransactionMetaResult),
    blockTime: optional(nullable(number())),
    transaction: ConfirmedTransactionResult,
    version: optional(TransactionVersionStruct)
}))), jsonRpcResult(nullable(type({
    slot: number(),
    transaction: ParsedConfirmedTransactionResult,
    meta: nullable(ParsedConfirmedTransactionMetaResult),
    blockTime: optional(nullable(number())),
    version: optional(TransactionVersionStruct)
}))), jsonRpcResultAndContext(type({
    blockhash: string(),
    feeCalculator: type({
        lamportsPerSignature: number()
    })
})), jsonRpcResultAndContext(type({
    blockhash: string(),
    lastValidBlockHeight: number()
})), jsonRpcResultAndContext(boolean());

const PerfSampleResult = type({
    slot: number(),
    numTransactions: number(),
    numSlots: number(),
    samplePeriodSecs: number()
});

jsonRpcResult(array(PerfSampleResult)), jsonRpcResultAndContext(nullable(type({
    feeCalculator: type({
        lamportsPerSignature: number()
    })
}))), jsonRpcResult(string()), jsonRpcResult(string());

const LogsResult = type({
    err: TransactionErrorResult,
    logs: array(string()),
    signature: string()
});

type({
    result: notificationResultAndContext(LogsResult),
    subscription: number()
});

class Keypair {
    constructor(keypair) {
        this._keypair = void 0, this._keypair = keypair ?? generateKeypair();
    }
    static generate() {
        return new Keypair(generateKeypair());
    }
    static fromSecretKey(secretKey, options) {
        if (64 !== secretKey.byteLength) throw new Error("bad secret key size");
        const publicKey = secretKey.slice(32, 64);
        if (!options || !options.skipValidation) {
            const privateScalar = secretKey.slice(0, 32), computedPublicKey = getPublicKey(privateScalar);
            for (let ii = 0; ii < 32; ii++) if (publicKey[ii] !== computedPublicKey[ii]) throw new Error("provided secretKey is invalid");
        }
        return new Keypair({
            publicKey: publicKey,
            secretKey: secretKey
        });
    }
    static fromSeed(seed) {
        const publicKey = getPublicKey(seed), secretKey = new Uint8Array(64);
        return secretKey.set(seed), secretKey.set(publicKey, 32), new Keypair({
            publicKey: publicKey,
            secretKey: secretKey
        });
    }
    get publicKey() {
        return new PublicKey(this._keypair.publicKey);
    }
    get secretKey() {
        return new Uint8Array(this._keypair.secretKey);
    }
}

var _Lockup;

Object.freeze({
    CreateLookupTable: {
        index: 0,
        layout: LayoutExports.struct([ LayoutExports.u32("instruction"), u64("recentSlot"), LayoutExports.u8("bumpSeed") ])
    },
    FreezeLookupTable: {
        index: 1,
        layout: LayoutExports.struct([ LayoutExports.u32("instruction") ])
    },
    ExtendLookupTable: {
        index: 2,
        layout: LayoutExports.struct([ LayoutExports.u32("instruction"), u64(), LayoutExports.seq(publicKey(), LayoutExports.offset(LayoutExports.u32(), -8), "addresses") ])
    },
    DeactivateLookupTable: {
        index: 3,
        layout: LayoutExports.struct([ LayoutExports.u32("instruction") ])
    },
    CloseLookupTable: {
        index: 4,
        layout: LayoutExports.struct([ LayoutExports.u32("instruction") ])
    }
}), new PublicKey("AddressLookupTab1e1111111111111111111111111"), Object.freeze({
    RequestUnits: {
        index: 0,
        layout: LayoutExports.struct([ LayoutExports.u8("instruction"), LayoutExports.u32("units"), LayoutExports.u32("additionalFee") ])
    },
    RequestHeapFrame: {
        index: 1,
        layout: LayoutExports.struct([ LayoutExports.u8("instruction"), LayoutExports.u32("bytes") ])
    },
    SetComputeUnitLimit: {
        index: 2,
        layout: LayoutExports.struct([ LayoutExports.u8("instruction"), LayoutExports.u32("units") ])
    },
    SetComputeUnitPrice: {
        index: 3,
        layout: LayoutExports.struct([ LayoutExports.u8("instruction"), u64("microLamports") ])
    }
}), new PublicKey("ComputeBudget111111111111111111111111111111"), LayoutExports.struct([ LayoutExports.u8("numSignatures"), LayoutExports.u8("padding"), LayoutExports.u16("signatureOffset"), LayoutExports.u16("signatureInstructionIndex"), LayoutExports.u16("publicKeyOffset"), LayoutExports.u16("publicKeyInstructionIndex"), LayoutExports.u16("messageDataOffset"), LayoutExports.u16("messageDataSize"), LayoutExports.u16("messageInstructionIndex") ]), 
new PublicKey("Ed25519SigVerify111111111111111111111111111"), secp256k1.utils.isValidPrivateKey, 
secp256k1.getPublicKey, LayoutExports.struct([ LayoutExports.u8("numSignatures"), LayoutExports.u16("signatureOffset"), LayoutExports.u8("signatureInstructionIndex"), LayoutExports.u16("ethAddressOffset"), LayoutExports.u8("ethAddressInstructionIndex"), LayoutExports.u16("messageDataOffset"), LayoutExports.u16("messageDataSize"), LayoutExports.u8("messageInstructionIndex"), LayoutExports.blob(20, "ethAddress"), LayoutExports.blob(64, "signature"), LayoutExports.u8("recoveryId") ]), 
new PublicKey("KeccakSecp256k11111111111111111111111111111"), new PublicKey("StakeConfig11111111111111111111111111111111");

class Lockup {
    constructor(unixTimestamp, epoch, custodian) {
        this.unixTimestamp = void 0, this.epoch = void 0, this.custodian = void 0, this.unixTimestamp = unixTimestamp, 
        this.epoch = epoch, this.custodian = custodian;
    }
}

function loadKeypairFromFile(filePath = DEFAULT_KEYPAIR_PATH) {
    if (!doesFileExist(filePath)) return null;
    const jsonBytes = loadJsonFile(filePath);
    return Keypair.fromSecretKey(Buffer.from(jsonBytes));
}

function parseRpcUrlOrMoniker(input, includeBetaLabel = !0, allowUrl = !0) {
    if (allowUrl && input.match(/^http?s/i)) {
        try {
            return new URL(input).toString();
        } catch (err) {
            console.error("Unable to parse 'url':", input), process.exit(1);
        }
        return input;
    }
    return input.startsWith("local") || input.startsWith("l") ? "localhost" : input.startsWith("t") ? "testnet" : input.startsWith("d") ? "devnet" : (input.startsWith("m") || warnMessage("Unable to parse url or moniker. Falling back to mainnet"), 
    includeBetaLabel ? "mainnet-beta" : "mainnet");
}

function getSafeClusterMoniker(cluster, labels) {
    switch (labels || (labels = {
        devnet: {},
        localnet: {},
        mainnet: {},
        testnet: {}
    }), cluster = parseRpcUrlOrMoniker(cluster, !0, !1)) {
      case "localhost":
      case "localnet":
        cluster = "localnet";
        break;

      case "mainnet":
      case "mainnet-beta":
        cluster = "mainnet";
    }
    return !!Object.hasOwn(labels, cluster) && cluster;
}

async function getPlatformToolsVersions() {
    const res = await checkCommand("cargo build-sbf --version"), tools = {};
    return res ? (res.split("\n").map((line => {
        if (!(line = line.trim().toLowerCase())) return;
        const version = VERSION_REGEX.exec(line)?.[1];
        line.startsWith("rustc") && (tools.rust = version), line.startsWith("platform-tools") && (tools.platformTools = version), 
        line.startsWith("solana-cargo-build-") && (tools.buildSbf = version);
    })), tools) : tools;
}

async function cloneAccount({address: address, saveDir: saveDir = DEFAULT_ACCOUNTS_DIR, url: url}) {
    let command = [ `solana account ${address}`, "--output json" ];
    url && command.push(`--url ${parseRpcUrlOrMoniker(url, !0)}`);
    const saveFile = path.resolve(saveDir, `${address}.json`);
    return createFolders(saveFile), command.push(`--output-file ${saveFile}`), await src_default(command.join(" ")), 
    doesFileExist(saveFile) && loadJsonFile(saveFile) || !1;
}

async function cloneProgram({address: address, saveDir: saveDir = "programs", url: url}) {
    let command = [ "solana program dump" ];
    const saveFile = path.resolve(saveDir, `${address}.so`);
    return createFolders(saveDir), command.push(address, saveFile), url && command.push(`--url ${parseRpcUrlOrMoniker(url, !0)}`), 
    await src_default(command.join(" ")), !!doesFileExist(saveFile);
}

async function cloneProgramsFromConfig(config, settings, currentAccounts) {
    if (!config?.clone?.program) return null;
    for (const key in config.clone.program) {
        if (!config.clone.program.hasOwnProperty(key)) continue;
        const program = config.clone.program[key];
        if (program?.name || (program.name = key), settings.autoClone && warnMessage(`Auto clone program: ${program.address}`), 
        "always" === program.frequency) console.log("Always clone program:", program.address); else if (!0 === settings.force) console.log("Force clone program:", program.address); else {
            if (currentAccounts.has(program.address)) {
                console.log("Skipping clone program:", program.address);
                continue;
            }
            console.log("Clone program:", program.address);
        }
        await cloneProgram({
            address: program.address,
            saveDir: DEFAULT_ACCOUNTS_DIR_TEMP,
            url: program.cluster || config?.settings?.cluster
        }) || console.error("Failed to clone program:", program.address);
    }
}

async function cloneTokensFromConfig(config, settings, currentAccounts) {
    if (!config?.clone?.token) return null;
    for (const key in config.clone.token) {
        if (!config.clone.token.hasOwnProperty(key)) continue;
        const token = config.clone.token[key];
        if (token?.name || (token.name = key), "always" === token.frequency) console.log("Always clone token:", token.address); else if (!0 === settings.force) console.log("Force clone token:", token.address); else {
            if (currentAccounts.has(token.address)) {
                console.log("Skipping clone token:", token.address);
                continue;
            }
            console.log("Clone token:", token.address);
        }
        const newAccount = await cloneAccount({
            saveDir: DEFAULT_ACCOUNTS_DIR_TEMP,
            address: token.address,
            url: token.cluster || config.settings.cluster
        });
        if (newAccount) {
            if (1 == settings.force) ; else if (doesFileExist(path.join(config.settings.accountDir, `${token.address}.json`))) {
                const oldAccount = loadJsonFile(path.resolve(config.settings.accountDir, `${token.address}.json`));
                if (JSON.stringify(newAccount) !== JSON.stringify(oldAccount)) {
                    warnMessage(`${token.address} has changed`), settings.prompt;
                    continue;
                }
            }
        } else console.error("Failed to clone token:", token.address);
    }
}

async function cloneAccountsFromConfig(config, settings, currentAccounts) {
    if (!config?.clone?.account) return !1;
    const owners = new Map, changedAccounts = new Map;
    let newAccount = !1;
    for (const key in config.clone.account) {
        if (!config.clone.account.hasOwnProperty(key)) continue;
        const account = config.clone.account[key];
        if (account?.name || (account.name = key), "always" === account.frequency) console.log("Always clone account:", account.address); else if (!0 === settings.force) console.log("Force clone account:", account.address); else {
            if (currentAccounts.has(account.address)) {
                newAccount = loadJsonFile(path.join(config.settings.accountDir, currentAccounts.get(account.address))), 
                owners.set(newAccount.account.owner, account.cluster || config.settings.cluster), 
                console.log("Skipping clone account:", account.address);
                continue;
            }
            console.log("Clone account:", account.address);
        }
        if (newAccount = await cloneAccount({
            saveDir: DEFAULT_ACCOUNTS_DIR_TEMP,
            address: account.address,
            url: account.cluster || config.settings.cluster
        }), newAccount) {
            if (owners.set(newAccount.account.owner, account.cluster || config.settings.cluster), 
            1 == settings.force) ; else if (doesFileExist(path.join(config.settings.accountDir, `${account.address}.json`))) {
                const oldAccount = loadJsonFile(path.resolve(config.settings.accountDir, `${account.address}.json`));
                if (JSON.stringify(newAccount) !== JSON.stringify(oldAccount)) {
                    warnMessage(`${account.address} has changed`), settings.prompt && changedAccounts.set(newAccount.account.owner, newAccount);
                    continue;
                }
            }
        } else console.error("Failed to clone account:", account.address);
    }
    return {
        owners: owners,
        changedAccounts: changedAccounts
    };
}

function mergeOwnersMapWithConfig(owners, config = {}) {
    return owners ? (owners.delete("11111111111111111111111111111111"), owners.delete("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"), 
    owners.delete("TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb"), 0 == owners.size || owners.forEach(((cluster, address) => {
        config[address] = {
            address: address,
            cluster: cluster
        };
    })), config) : config;
}

function validateExpectedCloneCounts(accountDir, clone) {
    const clonedAccounts = loadFileNamesToMap(accountDir = path.resolve(accountDir), ".json"), clonedPrograms = loadFileNamesToMap(accountDir, ".so"), actual = clonedAccounts.size + clonedPrograms.size, autoCloned = new Map;
    clonedAccounts.forEach(((filename, key) => {
        autoCloned.set(loadJsonFile(path.join(accountDir, filename)).account.owner, "");
    }));
    let expected = 0;
    return clone && (clone.account && (expected += Object.keys(clone.account).length), 
    clone.token && (expected += Object.keys(clone.token).length), clone.program && (clone.program = mergeOwnersMapWithConfig(autoCloned, clone?.program || {}) || {}, 
    expected += Object.keys(clone.program).length)), {
        actual: actual,
        expected: expected
    };
}

_Lockup = Lockup, Lockup.default = new _Lockup(0, 0, PublicKey.default), Object.freeze({
    Initialize: {
        index: 0,
        layout: LayoutExports.struct([ LayoutExports.u32("instruction"), authorized(), lockup() ])
    },
    Authorize: {
        index: 1,
        layout: LayoutExports.struct([ LayoutExports.u32("instruction"), publicKey("newAuthorized"), LayoutExports.u32("stakeAuthorizationType") ])
    },
    Delegate: {
        index: 2,
        layout: LayoutExports.struct([ LayoutExports.u32("instruction") ])
    },
    Split: {
        index: 3,
        layout: LayoutExports.struct([ LayoutExports.u32("instruction"), LayoutExports.ns64("lamports") ])
    },
    Withdraw: {
        index: 4,
        layout: LayoutExports.struct([ LayoutExports.u32("instruction"), LayoutExports.ns64("lamports") ])
    },
    Deactivate: {
        index: 5,
        layout: LayoutExports.struct([ LayoutExports.u32("instruction") ])
    },
    Merge: {
        index: 7,
        layout: LayoutExports.struct([ LayoutExports.u32("instruction") ])
    },
    AuthorizeWithSeed: {
        index: 8,
        layout: LayoutExports.struct([ LayoutExports.u32("instruction"), publicKey("newAuthorized"), LayoutExports.u32("stakeAuthorizationType"), rustString("authoritySeed"), publicKey("authorityOwner") ])
    }
}), new PublicKey("Stake11111111111111111111111111111111111111"), Object.freeze({
    InitializeAccount: {
        index: 0,
        layout: LayoutExports.struct([ LayoutExports.u32("instruction"), voteInit() ])
    },
    Authorize: {
        index: 1,
        layout: LayoutExports.struct([ LayoutExports.u32("instruction"), publicKey("newAuthorized"), LayoutExports.u32("voteAuthorizationType") ])
    },
    Withdraw: {
        index: 3,
        layout: LayoutExports.struct([ LayoutExports.u32("instruction"), LayoutExports.ns64("lamports") ])
    },
    UpdateValidatorIdentity: {
        index: 4,
        layout: LayoutExports.struct([ LayoutExports.u32("instruction") ])
    },
    AuthorizeWithSeed: {
        index: 10,
        layout: LayoutExports.struct([ LayoutExports.u32("instruction"), voteAuthorizeWithSeedArgs() ])
    }
}), new PublicKey("Vote111111111111111111111111111111111111111"), new PublicKey("Va1idator1nfo111111111111111111111111111111"), 
type({
    name: string(),
    website: optional(string()),
    details: optional(string()),
    iconUrl: optional(string()),
    keybaseUsername: optional(string())
}), new PublicKey("Vote111111111111111111111111111111111111111"), LayoutExports.struct([ publicKey("nodePubkey"), publicKey("authorizedWithdrawer"), LayoutExports.u8("commission"), LayoutExports.nu64(), LayoutExports.seq(LayoutExports.struct([ LayoutExports.nu64("slot"), LayoutExports.u32("confirmationCount") ]), LayoutExports.offset(LayoutExports.u32(), -8), "votes"), LayoutExports.u8("rootSlotValid"), LayoutExports.nu64("rootSlot"), LayoutExports.nu64(), LayoutExports.seq(LayoutExports.struct([ LayoutExports.nu64("epoch"), publicKey("authorizedVoter") ]), LayoutExports.offset(LayoutExports.u32(), -8), "authorizedVoters"), LayoutExports.struct([ LayoutExports.seq(LayoutExports.struct([ publicKey("authorizedPubkey"), LayoutExports.nu64("epochOfLastAuthorizedSwitch"), LayoutExports.nu64("targetEpoch") ]), 32, "buf"), LayoutExports.nu64("idx"), LayoutExports.u8("isEmpty") ], "priorVoters"), LayoutExports.nu64(), LayoutExports.seq(LayoutExports.struct([ LayoutExports.nu64("epoch"), LayoutExports.nu64("credits"), LayoutExports.nu64("prevCredits") ]), LayoutExports.offset(LayoutExports.u32(), -8), "epochCredits"), LayoutExports.struct([ LayoutExports.nu64("slot"), LayoutExports.nu64("timestamp") ], "lastTimestamp") ]);

const ANCHOR_TOML = "Anchor.toml";

function loadAnchorToml(configPath, isConfigRequired = !1) {
    configPath.endsWith(ANCHOR_TOML) || (configPath = dirname(configPath)), directoryExists(configPath) && (configPath = join(configPath, ANCHOR_TOML));
    let anchor = {
        configPath: configPath
    };
    return doesFileExist(configPath, !0) ? (anchor = loadTomlFile(configPath) || anchor, 
    anchor.configPath = configPath, anchor) : (isConfigRequired && warningOutro("No Anchor.toml config file found. Operation canceled."), 
    !1);
}

function deconflictAnchorTomlWithConfig(anchorToml, config) {
    if (anchorToml.test?.validator?.clone) for (const cloner in anchorToml.test.validator.clone) Object.prototype.hasOwnProperty.call(anchorToml.test.validator.clone, cloner) && !config.clone.program[anchorToml.test.validator.clone[cloner].address] && (anchorToml.test.validator?.url && (anchorToml.test.validator.clone[cloner].cluster = anchorToml.test.validator.url), 
    config.clone.program[anchorToml.test.validator.clone[cloner].address] = anchorToml.test.validator.clone[cloner]);
    if (anchorToml.test?.validator?.account) for (const cloner in anchorToml.test.validator.account) Object.prototype.hasOwnProperty.call(anchorToml.test.validator.account, cloner) && !config.clone.account[anchorToml.test.validator.account[cloner].address] && (anchorToml.test.validator?.url && (anchorToml.test.validator.account[cloner].cluster = anchorToml.test.validator.url), 
    config.clone.account[anchorToml.test.validator.account[cloner].address] = anchorToml.test.validator.account[cloner]);
    return config;
}

function isGitRepo(targetFolder) {
    try {
        return "true" === execSync(`git -C ${targetFolder} rev-parse --is-inside-work-tree`, {
            stdio: "pipe"
        }).toString().trim();
    } catch (error) {
        return !1;
    }
}

function initGitRepo(targetFolder, commitMessage = "init") {
    try {
        createFolders(targetFolder, !0);
        const commands = [];
        return commands.push(`git init ${targetFolder}`, `git add ${join(targetFolder, ".")} --force`, `git -C ${targetFolder} commit -m "${commitMessage}"`), 
        execSync(commands.join(" && "), {
            stdio: "ignore"
        }), !0;
    } catch (error) {
        return console.error("[initGitRepo]", "Unable to execute 'git init'"), !1;
    }
}

const isUpKey = key => "up" === key.name || "k" === key.name || key.ctrl && "p" === key.name, isDownKey = key => "down" === key.name || "j" === key.name || key.ctrl && "n" === key.name, isBackspaceKey = key => "backspace" === key.name, isNumberKey = key => "123456789".includes(key.name), isEnterKey = key => "enter" === key.name || "return" === key.name;

class AbortPromptError extends Error {
    name="AbortPromptError";
    message="Prompt was aborted";
    constructor(options) {
        super(), this.cause = options?.cause;
    }
}

class CancelPromptError extends Error {
    name="CancelPromptError";
    message="Prompt was canceled";
}

class ExitPromptError extends Error {
    name="ExitPromptError";
}

class HookError extends Error {
    name="HookError";
}

class ValidationError extends Error {
    name="ValidationError";
}

const hookStorage = new AsyncLocalStorage;

function createStore(rl) {
    return {
        rl: rl,
        hooks: [],
        hooksCleanup: [],
        hooksEffect: [],
        index: 0,
        handleChange() {}
    };
}

function withHooks(rl, cb) {
    const store = createStore(rl);
    return hookStorage.run(store, (() => cb((function(render) {
        store.handleChange = () => {
            store.index = 0, render();
        }, store.handleChange();
    }))));
}

function getStore() {
    const store = hookStorage.getStore();
    if (!store) throw new HookError("[Inquirer] Hook functions can only be called from within a prompt");
    return store;
}

function readline() {
    return getStore().rl;
}

function withUpdates(fn) {
    return AsyncResource.bind(((...args) => {
        const store = getStore();
        let shouldUpdate = !1;
        const oldHandleChange = store.handleChange;
        store.handleChange = () => {
            shouldUpdate = !0;
        };
        const returnValue = fn(...args);
        return shouldUpdate && oldHandleChange(), store.handleChange = oldHandleChange, 
        returnValue;
    }));
}

function withPointer(cb) {
    const store = getStore(), {index: index} = store, returnValue = cb({
        get: () => store.hooks[index],
        set(value) {
            store.hooks[index] = value;
        },
        initialized: index in store.hooks
    });
    return store.index++, returnValue;
}

function handleChange() {
    getStore().handleChange();
}

const effectScheduler = {
    queue(cb) {
        const store = getStore(), {index: index} = store;
        store.hooksEffect.push((() => {
            store.hooksCleanup[index]?.();
            const cleanFn = cb(readline());
            if (null != cleanFn && "function" != typeof cleanFn) throw new ValidationError("useEffect return value must be a cleanup function or nothing.");
            store.hooksCleanup[index] = cleanFn;
        }));
    },
    run() {
        const store = getStore();
        withUpdates((() => {
            store.hooksEffect.forEach((effect => {
                effect();
            })), store.hooksEffect.length = 0;
        }))();
    },
    clearAll() {
        const store = getStore();
        store.hooksCleanup.forEach((cleanFn => {
            cleanFn?.();
        })), store.hooksEffect.length = 0, store.hooksCleanup.length = 0;
    }
};

function useState(defaultValue) {
    return withPointer((pointer => {
        const setFn = newValue => {
            pointer.get() !== newValue && (pointer.set(newValue), handleChange());
        };
        if (pointer.initialized) return [ pointer.get(), setFn ];
        const value = "function" == typeof defaultValue ? defaultValue() : defaultValue;
        return pointer.set(value), [ value, setFn ];
    }));
}

function useEffect(cb, depArray) {
    withPointer((pointer => {
        const oldDeps = pointer.get();
        (!Array.isArray(oldDeps) || depArray.some(((dep, i) => !Object.is(dep, oldDeps[i])))) && effectScheduler.queue(cb), 
        pointer.set(depArray);
    }));
}

var yoctocolorsCjs, hasRequiredYoctocolorsCjs;

function requireYoctocolorsCjs() {
    if (hasRequiredYoctocolorsCjs) return yoctocolorsCjs;
    hasRequiredYoctocolorsCjs = 1;
    const tty$1 = tty, hasColors = tty$1?.WriteStream?.prototype?.hasColors?.() ?? !1, format = (open, close) => {
        if (!hasColors) return input => input;
        const openCode = `[${open}m`, closeCode = `[${close}m`;
        return input => {
            const string = input + "";
            let index = string.indexOf(closeCode);
            if (-1 === index) return openCode + string + closeCode;
            let result = openCode, lastIndex = 0;
            for (;-1 !== index; ) result += string.slice(lastIndex, index) + openCode, lastIndex = index + closeCode.length, 
            index = string.indexOf(closeCode, lastIndex);
            return result += string.slice(lastIndex) + closeCode, result;
        };
    }, colors = {};
    return colors.reset = format(0, 0), colors.bold = format(1, 22), colors.dim = format(2, 22), 
    colors.italic = format(3, 23), colors.underline = format(4, 24), colors.overline = format(53, 55), 
    colors.inverse = format(7, 27), colors.hidden = format(8, 28), colors.strikethrough = format(9, 29), 
    colors.black = format(30, 39), colors.red = format(31, 39), colors.green = format(32, 39), 
    colors.yellow = format(33, 39), colors.blue = format(34, 39), colors.magenta = format(35, 39), 
    colors.cyan = format(36, 39), colors.white = format(37, 39), colors.gray = format(90, 39), 
    colors.bgBlack = format(40, 49), colors.bgRed = format(41, 49), colors.bgGreen = format(42, 49), 
    colors.bgYellow = format(43, 49), colors.bgBlue = format(44, 49), colors.bgMagenta = format(45, 49), 
    colors.bgCyan = format(46, 49), colors.bgWhite = format(47, 49), colors.bgGray = format(100, 49), 
    colors.redBright = format(91, 39), colors.greenBright = format(92, 39), colors.yellowBright = format(93, 39), 
    colors.blueBright = format(94, 39), colors.magentaBright = format(95, 39), colors.cyanBright = format(96, 39), 
    colors.whiteBright = format(97, 39), colors.bgRedBright = format(101, 49), colors.bgGreenBright = format(102, 49), 
    colors.bgYellowBright = format(103, 49), colors.bgBlueBright = format(104, 49), 
    colors.bgMagentaBright = format(105, 49), colors.bgCyanBright = format(106, 49), 
    colors.bgWhiteBright = format(107, 49), yoctocolorsCjs = colors;
}

var yoctocolorsCjsExports = requireYoctocolorsCjs(), colors = getDefaultExportFromCjs(yoctocolorsCjsExports);

function isUnicodeSupported() {
    return "win32" !== process$2.platform ? "linux" !== process$2.env.TERM : Boolean(process$2.env.WT_SESSION) || Boolean(process$2.env.TERMINUS_SUBLIME) || "{cmd::Cmder}" === process$2.env.ConEmuTask || "Terminus-Sublime" === process$2.env.TERM_PROGRAM || "vscode" === process$2.env.TERM_PROGRAM || "xterm-256color" === process$2.env.TERM || "alacritty" === process$2.env.TERM || "JetBrains-JediTerm" === process$2.env.TERMINAL_EMULATOR;
}

const common = {
    circleQuestionMark: "(?)",
    questionMarkPrefix: "(?)",
    square: "█",
    squareDarkShade: "▓",
    squareMediumShade: "▒",
    squareLightShade: "░",
    squareTop: "▀",
    squareBottom: "▄",
    squareLeft: "▌",
    squareRight: "▐",
    squareCenter: "■",
    bullet: "●",
    dot: "․",
    ellipsis: "…",
    pointerSmall: "›",
    triangleUp: "▲",
    triangleUpSmall: "▴",
    triangleDown: "▼",
    triangleDownSmall: "▾",
    triangleLeftSmall: "◂",
    triangleRightSmall: "▸",
    home: "⌂",
    heart: "♥",
    musicNote: "♪",
    musicNoteBeamed: "♫",
    arrowUp: "↑",
    arrowDown: "↓",
    arrowLeft: "←",
    arrowRight: "→",
    arrowLeftRight: "↔",
    arrowUpDown: "↕",
    almostEqual: "≈",
    notEqual: "≠",
    lessOrEqual: "≤",
    greaterOrEqual: "≥",
    identical: "≡",
    infinity: "∞",
    subscriptZero: "₀",
    subscriptOne: "₁",
    subscriptTwo: "₂",
    subscriptThree: "₃",
    subscriptFour: "₄",
    subscriptFive: "₅",
    subscriptSix: "₆",
    subscriptSeven: "₇",
    subscriptEight: "₈",
    subscriptNine: "₉",
    oneHalf: "½",
    oneThird: "⅓",
    oneQuarter: "¼",
    oneFifth: "⅕",
    oneSixth: "⅙",
    oneEighth: "⅛",
    twoThirds: "⅔",
    twoFifths: "⅖",
    threeQuarters: "¾",
    threeFifths: "⅗",
    threeEighths: "⅜",
    fourFifths: "⅘",
    fiveSixths: "⅚",
    fiveEighths: "⅝",
    sevenEighths: "⅞",
    line: "─",
    lineBold: "━",
    lineDouble: "═",
    lineDashed0: "┄",
    lineDashed1: "┅",
    lineDashed2: "┈",
    lineDashed3: "┉",
    lineDashed4: "╌",
    lineDashed5: "╍",
    lineDashed6: "╴",
    lineDashed7: "╶",
    lineDashed8: "╸",
    lineDashed9: "╺",
    lineDashed10: "╼",
    lineDashed11: "╾",
    lineDashed12: "−",
    lineDashed13: "–",
    lineDashed14: "‐",
    lineDashed15: "⁃",
    lineVertical: "│",
    lineVerticalBold: "┃",
    lineVerticalDouble: "║",
    lineVerticalDashed0: "┆",
    lineVerticalDashed1: "┇",
    lineVerticalDashed2: "┊",
    lineVerticalDashed3: "┋",
    lineVerticalDashed4: "╎",
    lineVerticalDashed5: "╏",
    lineVerticalDashed6: "╵",
    lineVerticalDashed7: "╷",
    lineVerticalDashed8: "╹",
    lineVerticalDashed9: "╻",
    lineVerticalDashed10: "╽",
    lineVerticalDashed11: "╿",
    lineDownLeft: "┐",
    lineDownLeftArc: "╮",
    lineDownBoldLeftBold: "┓",
    lineDownBoldLeft: "┒",
    lineDownLeftBold: "┑",
    lineDownDoubleLeftDouble: "╗",
    lineDownDoubleLeft: "╖",
    lineDownLeftDouble: "╕",
    lineDownRight: "┌",
    lineDownRightArc: "╭",
    lineDownBoldRightBold: "┏",
    lineDownBoldRight: "┎",
    lineDownRightBold: "┍",
    lineDownDoubleRightDouble: "╔",
    lineDownDoubleRight: "╓",
    lineDownRightDouble: "╒",
    lineUpLeft: "┘",
    lineUpLeftArc: "╯",
    lineUpBoldLeftBold: "┛",
    lineUpBoldLeft: "┚",
    lineUpLeftBold: "┙",
    lineUpDoubleLeftDouble: "╝",
    lineUpDoubleLeft: "╜",
    lineUpLeftDouble: "╛",
    lineUpRight: "└",
    lineUpRightArc: "╰",
    lineUpBoldRightBold: "┗",
    lineUpBoldRight: "┖",
    lineUpRightBold: "┕",
    lineUpDoubleRightDouble: "╚",
    lineUpDoubleRight: "╙",
    lineUpRightDouble: "╘",
    lineUpDownLeft: "┤",
    lineUpBoldDownBoldLeftBold: "┫",
    lineUpBoldDownBoldLeft: "┨",
    lineUpDownLeftBold: "┥",
    lineUpBoldDownLeftBold: "┩",
    lineUpDownBoldLeftBold: "┪",
    lineUpDownBoldLeft: "┧",
    lineUpBoldDownLeft: "┦",
    lineUpDoubleDownDoubleLeftDouble: "╣",
    lineUpDoubleDownDoubleLeft: "╢",
    lineUpDownLeftDouble: "╡",
    lineUpDownRight: "├",
    lineUpBoldDownBoldRightBold: "┣",
    lineUpBoldDownBoldRight: "┠",
    lineUpDownRightBold: "┝",
    lineUpBoldDownRightBold: "┡",
    lineUpDownBoldRightBold: "┢",
    lineUpDownBoldRight: "┟",
    lineUpBoldDownRight: "┞",
    lineUpDoubleDownDoubleRightDouble: "╠",
    lineUpDoubleDownDoubleRight: "╟",
    lineUpDownRightDouble: "╞",
    lineDownLeftRight: "┬",
    lineDownBoldLeftBoldRightBold: "┳",
    lineDownLeftBoldRightBold: "┯",
    lineDownBoldLeftRight: "┰",
    lineDownBoldLeftBoldRight: "┱",
    lineDownBoldLeftRightBold: "┲",
    lineDownLeftRightBold: "┮",
    lineDownLeftBoldRight: "┭",
    lineDownDoubleLeftDoubleRightDouble: "╦",
    lineDownDoubleLeftRight: "╥",
    lineDownLeftDoubleRightDouble: "╤",
    lineUpLeftRight: "┴",
    lineUpBoldLeftBoldRightBold: "┻",
    lineUpLeftBoldRightBold: "┷",
    lineUpBoldLeftRight: "┸",
    lineUpBoldLeftBoldRight: "┹",
    lineUpBoldLeftRightBold: "┺",
    lineUpLeftRightBold: "┶",
    lineUpLeftBoldRight: "┵",
    lineUpDoubleLeftDoubleRightDouble: "╩",
    lineUpDoubleLeftRight: "╨",
    lineUpLeftDoubleRightDouble: "╧",
    lineUpDownLeftRight: "┼",
    lineUpBoldDownBoldLeftBoldRightBold: "╋",
    lineUpDownBoldLeftBoldRightBold: "╈",
    lineUpBoldDownLeftBoldRightBold: "╇",
    lineUpBoldDownBoldLeftRightBold: "╊",
    lineUpBoldDownBoldLeftBoldRight: "╉",
    lineUpBoldDownLeftRight: "╀",
    lineUpDownBoldLeftRight: "╁",
    lineUpDownLeftBoldRight: "┽",
    lineUpDownLeftRightBold: "┾",
    lineUpBoldDownBoldLeftRight: "╂",
    lineUpDownLeftBoldRightBold: "┿",
    lineUpBoldDownLeftBoldRight: "╃",
    lineUpBoldDownLeftRightBold: "╄",
    lineUpDownBoldLeftBoldRight: "╅",
    lineUpDownBoldLeftRightBold: "╆",
    lineUpDoubleDownDoubleLeftDoubleRightDouble: "╬",
    lineUpDoubleDownDoubleLeftRight: "╫",
    lineUpDownLeftDoubleRightDouble: "╪",
    lineCross: "╳",
    lineBackslash: "╲",
    lineSlash: "╱"
}, specialMainSymbols = {
    tick: "✔",
    info: "ℹ",
    warning: "⚠",
    cross: "✘",
    squareSmall: "◻",
    squareSmallFilled: "◼",
    circle: "◯",
    circleFilled: "◉",
    circleDotted: "◌",
    circleDouble: "◎",
    circleCircle: "ⓞ",
    circleCross: "ⓧ",
    circlePipe: "Ⓘ",
    radioOn: "◉",
    radioOff: "◯",
    checkboxOn: "☒",
    checkboxOff: "☐",
    checkboxCircleOn: "ⓧ",
    checkboxCircleOff: "Ⓘ",
    pointer: "❯",
    triangleUpOutline: "△",
    triangleLeft: "◀",
    triangleRight: "▶",
    lozenge: "◆",
    lozengeOutline: "◇",
    hamburger: "☰",
    smiley: "㋡",
    mustache: "෴",
    star: "★",
    play: "▶",
    nodejs: "⬢",
    oneSeventh: "⅐",
    oneNinth: "⅑",
    oneTenth: "⅒"
}, specialFallbackSymbols = {
    tick: "√",
    info: "i",
    warning: "‼",
    cross: "×",
    squareSmall: "□",
    squareSmallFilled: "■",
    circle: "( )",
    circleFilled: "(*)",
    circleDotted: "( )",
    circleDouble: "( )",
    circleCircle: "(○)",
    circleCross: "(×)",
    circlePipe: "(│)",
    radioOn: "(*)",
    radioOff: "( )",
    checkboxOn: "[×]",
    checkboxOff: "[ ]",
    checkboxCircleOn: "(×)",
    checkboxCircleOff: "( )",
    pointer: ">",
    triangleUpOutline: "∆",
    triangleLeft: "◄",
    triangleRight: "►",
    lozenge: "♦",
    lozengeOutline: "◊",
    hamburger: "≡",
    smiley: "☺",
    mustache: "┌─┐",
    star: "✶",
    play: "►",
    nodejs: "♦",
    oneSeventh: "1/7",
    oneNinth: "1/9",
    oneTenth: "1/10"
}, mainSymbols = {
    ...common,
    ...specialMainSymbols
}, fallbackSymbols = {
    ...common,
    ...specialFallbackSymbols
}, shouldUseMain = isUnicodeSupported(), figures = shouldUseMain ? mainSymbols : fallbackSymbols, defaultTheme = {
    prefix: {
        idle: colors.blue("?"),
        done: colors.green(figures.tick)
    },
    spinner: {
        interval: 80,
        frames: [ "⠋", "⠙", "⠹", "⠸", "⠼", "⠴", "⠦", "⠧", "⠇", "⠏" ].map((frame => colors.yellow(frame)))
    },
    style: {
        answer: colors.cyan,
        message: colors.bold,
        error: text => colors.red(`> ${text}`),
        defaultAnswer: text => colors.dim(`(${text})`),
        help: colors.dim,
        highlight: colors.cyan,
        key: text => colors.cyan(colors.bold(`<${text}>`))
    }
};

function isPlainObject(value) {
    if ("object" != typeof value || null === value) return !1;
    let proto = value;
    for (;null !== Object.getPrototypeOf(proto); ) proto = Object.getPrototypeOf(proto);
    return Object.getPrototypeOf(value) === proto;
}

function deepMerge(...objects) {
    const output = {};
    for (const obj of objects) for (const [key, value] of Object.entries(obj)) {
        const prevValue = output[key];
        output[key] = isPlainObject(prevValue) && isPlainObject(value) ? deepMerge(prevValue, value) : value;
    }
    return output;
}

function makeTheme(...themes) {
    return deepMerge(...[ defaultTheme, ...themes.filter((theme => null != theme)) ]);
}

function usePrefix({status: status = "idle", theme: theme}) {
    const [showLoader, setShowLoader] = useState(!1), [tick, setTick] = useState(0), {prefix: prefix, spinner: spinner} = makeTheme(theme);
    if (useEffect((() => {
        if ("loading" === status) {
            let tickInterval, inc = -1;
            const delayTimeout = setTimeout(AsyncResource.bind((() => {
                setShowLoader(!0), tickInterval = setInterval(AsyncResource.bind((() => {
                    inc += 1, setTick(inc % spinner.frames.length);
                })), spinner.interval);
            })), 300);
            return () => {
                clearTimeout(delayTimeout), clearInterval(tickInterval);
            };
        }
        setShowLoader(!1);
    }), [ status ]), showLoader) return spinner.frames[tick];
    return "string" == typeof prefix ? prefix : prefix["loading" === status ? "idle" : status];
}

function useMemo(fn, dependencies) {
    return withPointer((pointer => {
        const prev = pointer.get();
        if (!prev || prev.dependencies.length !== dependencies.length || prev.dependencies.some(((dep, i) => dep !== dependencies[i]))) {
            const value = fn();
            return pointer.set({
                value: value,
                dependencies: dependencies
            }), value;
        }
        return prev.value;
    }));
}

function useRef(val) {
    return useState({
        current: val
    })[0];
}

function useKeypress(userHandler) {
    const signal = useRef(userHandler);
    signal.current = userHandler, useEffect((rl => {
        let ignore = !1;
        const handler = withUpdates(((_input, event) => {
            ignore || signal.current(event, rl);
        }));
        return rl.input.on("keypress", handler), () => {
            ignore = !0, rl.input.removeListener("keypress", handler);
        };
    }), []);
}

var cliWidth_1, hasRequiredCliWidth;

function requireCliWidth() {
    if (hasRequiredCliWidth) return cliWidth_1;
    return hasRequiredCliWidth = 1, cliWidth_1 = function(options) {
        const opts = function(options) {
            const defaultOpts = {
                defaultWidth: 0,
                output: process.stdout,
                tty: require$$0$7
            };
            if (!options) return defaultOpts;
            return Object.keys(defaultOpts).forEach((function(key) {
                options[key] || (options[key] = defaultOpts[key]);
            })), options;
        }(options);
        if (opts.output.getWindowSize) return opts.output.getWindowSize()[0] || opts.defaultWidth;
        if (opts.tty.getWindowSize) return opts.tty.getWindowSize()[1] || opts.defaultWidth;
        if (opts.output.columns) return opts.output.columns;
        if (process.env.CLI_WIDTH) {
            const width = parseInt(process.env.CLI_WIDTH, 10);
            if (!isNaN(width) && 0 !== width) return width;
        }
        return opts.defaultWidth;
    };
}

var cliWidthExports = requireCliWidth(), cliWidth = getDefaultExportFromCjs(cliWidthExports), stringWidth = {
    exports: {}
}, ansiRegex, hasRequiredAnsiRegex, stripAnsi$1, hasRequiredStripAnsi;

function requireAnsiRegex() {
    return hasRequiredAnsiRegex ? ansiRegex : (hasRequiredAnsiRegex = 1, ansiRegex = ({onlyFirst: onlyFirst = !1} = {}) => {
        const pattern = [ "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))" ].join("|");
        return new RegExp(pattern, onlyFirst ? void 0 : "g");
    });
}

function requireStripAnsi() {
    if (hasRequiredStripAnsi) return stripAnsi$1;
    hasRequiredStripAnsi = 1;
    const ansiRegex = requireAnsiRegex();
    return stripAnsi$1 = string => "string" == typeof string ? string.replace(ansiRegex(), "") : string, 
    stripAnsi$1;
}

var isFullwidthCodePoint = {
    exports: {}
}, hasRequiredIsFullwidthCodePoint, emojiRegex, hasRequiredEmojiRegex, hasRequiredStringWidth;

function requireIsFullwidthCodePoint() {
    if (hasRequiredIsFullwidthCodePoint) return isFullwidthCodePoint.exports;
    hasRequiredIsFullwidthCodePoint = 1;
    const isFullwidthCodePoint$1 = codePoint => !Number.isNaN(codePoint) && (codePoint >= 4352 && (codePoint <= 4447 || 9001 === codePoint || 9002 === codePoint || 11904 <= codePoint && codePoint <= 12871 && 12351 !== codePoint || 12880 <= codePoint && codePoint <= 19903 || 19968 <= codePoint && codePoint <= 42182 || 43360 <= codePoint && codePoint <= 43388 || 44032 <= codePoint && codePoint <= 55203 || 63744 <= codePoint && codePoint <= 64255 || 65040 <= codePoint && codePoint <= 65049 || 65072 <= codePoint && codePoint <= 65131 || 65281 <= codePoint && codePoint <= 65376 || 65504 <= codePoint && codePoint <= 65510 || 110592 <= codePoint && codePoint <= 110593 || 127488 <= codePoint && codePoint <= 127569 || 131072 <= codePoint && codePoint <= 262141));
    return isFullwidthCodePoint.exports = isFullwidthCodePoint$1, isFullwidthCodePoint.exports.default = isFullwidthCodePoint$1, 
    isFullwidthCodePoint.exports;
}

function requireEmojiRegex() {
    return hasRequiredEmojiRegex ? emojiRegex : (hasRequiredEmojiRegex = 1, emojiRegex = function() {
        return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F|\uD83D\uDC68(?:\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68\uD83C\uDFFB|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|[\u2695\u2696\u2708]\uFE0F|\uD83D[\uDC66\uDC67]|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708])\uFE0F|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C[\uDFFB-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)\uD83C\uDFFB|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB\uDFFC])|\uD83D\uDC69(?:\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB-\uDFFD])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|(?:(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)\uFE0F|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\u200D[\u2640\u2642])|\uD83C\uDFF4\u200D\u2620)\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDF6\uD83C\uDDE6|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDB5\uDDB6\uDDBB\uDDD2-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5\uDEEB\uDEEC\uDEF4-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
    });
}

function requireStringWidth() {
    if (hasRequiredStringWidth) return stringWidth.exports;
    hasRequiredStringWidth = 1;
    const stripAnsi = requireStripAnsi(), isFullwidthCodePoint = requireIsFullwidthCodePoint(), emojiRegex = requireEmojiRegex(), stringWidth$1 = string => {
        if ("string" != typeof string || 0 === string.length) return 0;
        if (0 === (string = stripAnsi(string)).length) return 0;
        string = string.replace(emojiRegex(), "  ");
        let width = 0;
        for (let i = 0; i < string.length; i++) {
            const code = string.codePointAt(i);
            code <= 31 || code >= 127 && code <= 159 || (code >= 768 && code <= 879 || (code > 65535 && i++, 
            width += isFullwidthCodePoint(code) ? 2 : 1));
        }
        return width;
    };
    return stringWidth.exports = stringWidth$1, stringWidth.exports.default = stringWidth$1, 
    stringWidth.exports;
}

var ansiStyles = {
    exports: {}
}, colorName, hasRequiredColorName, conversions, hasRequiredConversions, route, hasRequiredRoute, colorConvert, hasRequiredColorConvert, hasRequiredAnsiStyles, wrapAnsi_1, hasRequiredWrapAnsi;

function requireColorName() {
    return hasRequiredColorName ? colorName : (hasRequiredColorName = 1, colorName = {
        aliceblue: [ 240, 248, 255 ],
        antiquewhite: [ 250, 235, 215 ],
        aqua: [ 0, 255, 255 ],
        aquamarine: [ 127, 255, 212 ],
        azure: [ 240, 255, 255 ],
        beige: [ 245, 245, 220 ],
        bisque: [ 255, 228, 196 ],
        black: [ 0, 0, 0 ],
        blanchedalmond: [ 255, 235, 205 ],
        blue: [ 0, 0, 255 ],
        blueviolet: [ 138, 43, 226 ],
        brown: [ 165, 42, 42 ],
        burlywood: [ 222, 184, 135 ],
        cadetblue: [ 95, 158, 160 ],
        chartreuse: [ 127, 255, 0 ],
        chocolate: [ 210, 105, 30 ],
        coral: [ 255, 127, 80 ],
        cornflowerblue: [ 100, 149, 237 ],
        cornsilk: [ 255, 248, 220 ],
        crimson: [ 220, 20, 60 ],
        cyan: [ 0, 255, 255 ],
        darkblue: [ 0, 0, 139 ],
        darkcyan: [ 0, 139, 139 ],
        darkgoldenrod: [ 184, 134, 11 ],
        darkgray: [ 169, 169, 169 ],
        darkgreen: [ 0, 100, 0 ],
        darkgrey: [ 169, 169, 169 ],
        darkkhaki: [ 189, 183, 107 ],
        darkmagenta: [ 139, 0, 139 ],
        darkolivegreen: [ 85, 107, 47 ],
        darkorange: [ 255, 140, 0 ],
        darkorchid: [ 153, 50, 204 ],
        darkred: [ 139, 0, 0 ],
        darksalmon: [ 233, 150, 122 ],
        darkseagreen: [ 143, 188, 143 ],
        darkslateblue: [ 72, 61, 139 ],
        darkslategray: [ 47, 79, 79 ],
        darkslategrey: [ 47, 79, 79 ],
        darkturquoise: [ 0, 206, 209 ],
        darkviolet: [ 148, 0, 211 ],
        deeppink: [ 255, 20, 147 ],
        deepskyblue: [ 0, 191, 255 ],
        dimgray: [ 105, 105, 105 ],
        dimgrey: [ 105, 105, 105 ],
        dodgerblue: [ 30, 144, 255 ],
        firebrick: [ 178, 34, 34 ],
        floralwhite: [ 255, 250, 240 ],
        forestgreen: [ 34, 139, 34 ],
        fuchsia: [ 255, 0, 255 ],
        gainsboro: [ 220, 220, 220 ],
        ghostwhite: [ 248, 248, 255 ],
        gold: [ 255, 215, 0 ],
        goldenrod: [ 218, 165, 32 ],
        gray: [ 128, 128, 128 ],
        green: [ 0, 128, 0 ],
        greenyellow: [ 173, 255, 47 ],
        grey: [ 128, 128, 128 ],
        honeydew: [ 240, 255, 240 ],
        hotpink: [ 255, 105, 180 ],
        indianred: [ 205, 92, 92 ],
        indigo: [ 75, 0, 130 ],
        ivory: [ 255, 255, 240 ],
        khaki: [ 240, 230, 140 ],
        lavender: [ 230, 230, 250 ],
        lavenderblush: [ 255, 240, 245 ],
        lawngreen: [ 124, 252, 0 ],
        lemonchiffon: [ 255, 250, 205 ],
        lightblue: [ 173, 216, 230 ],
        lightcoral: [ 240, 128, 128 ],
        lightcyan: [ 224, 255, 255 ],
        lightgoldenrodyellow: [ 250, 250, 210 ],
        lightgray: [ 211, 211, 211 ],
        lightgreen: [ 144, 238, 144 ],
        lightgrey: [ 211, 211, 211 ],
        lightpink: [ 255, 182, 193 ],
        lightsalmon: [ 255, 160, 122 ],
        lightseagreen: [ 32, 178, 170 ],
        lightskyblue: [ 135, 206, 250 ],
        lightslategray: [ 119, 136, 153 ],
        lightslategrey: [ 119, 136, 153 ],
        lightsteelblue: [ 176, 196, 222 ],
        lightyellow: [ 255, 255, 224 ],
        lime: [ 0, 255, 0 ],
        limegreen: [ 50, 205, 50 ],
        linen: [ 250, 240, 230 ],
        magenta: [ 255, 0, 255 ],
        maroon: [ 128, 0, 0 ],
        mediumaquamarine: [ 102, 205, 170 ],
        mediumblue: [ 0, 0, 205 ],
        mediumorchid: [ 186, 85, 211 ],
        mediumpurple: [ 147, 112, 219 ],
        mediumseagreen: [ 60, 179, 113 ],
        mediumslateblue: [ 123, 104, 238 ],
        mediumspringgreen: [ 0, 250, 154 ],
        mediumturquoise: [ 72, 209, 204 ],
        mediumvioletred: [ 199, 21, 133 ],
        midnightblue: [ 25, 25, 112 ],
        mintcream: [ 245, 255, 250 ],
        mistyrose: [ 255, 228, 225 ],
        moccasin: [ 255, 228, 181 ],
        navajowhite: [ 255, 222, 173 ],
        navy: [ 0, 0, 128 ],
        oldlace: [ 253, 245, 230 ],
        olive: [ 128, 128, 0 ],
        olivedrab: [ 107, 142, 35 ],
        orange: [ 255, 165, 0 ],
        orangered: [ 255, 69, 0 ],
        orchid: [ 218, 112, 214 ],
        palegoldenrod: [ 238, 232, 170 ],
        palegreen: [ 152, 251, 152 ],
        paleturquoise: [ 175, 238, 238 ],
        palevioletred: [ 219, 112, 147 ],
        papayawhip: [ 255, 239, 213 ],
        peachpuff: [ 255, 218, 185 ],
        peru: [ 205, 133, 63 ],
        pink: [ 255, 192, 203 ],
        plum: [ 221, 160, 221 ],
        powderblue: [ 176, 224, 230 ],
        purple: [ 128, 0, 128 ],
        rebeccapurple: [ 102, 51, 153 ],
        red: [ 255, 0, 0 ],
        rosybrown: [ 188, 143, 143 ],
        royalblue: [ 65, 105, 225 ],
        saddlebrown: [ 139, 69, 19 ],
        salmon: [ 250, 128, 114 ],
        sandybrown: [ 244, 164, 96 ],
        seagreen: [ 46, 139, 87 ],
        seashell: [ 255, 245, 238 ],
        sienna: [ 160, 82, 45 ],
        silver: [ 192, 192, 192 ],
        skyblue: [ 135, 206, 235 ],
        slateblue: [ 106, 90, 205 ],
        slategray: [ 112, 128, 144 ],
        slategrey: [ 112, 128, 144 ],
        snow: [ 255, 250, 250 ],
        springgreen: [ 0, 255, 127 ],
        steelblue: [ 70, 130, 180 ],
        tan: [ 210, 180, 140 ],
        teal: [ 0, 128, 128 ],
        thistle: [ 216, 191, 216 ],
        tomato: [ 255, 99, 71 ],
        turquoise: [ 64, 224, 208 ],
        violet: [ 238, 130, 238 ],
        wheat: [ 245, 222, 179 ],
        white: [ 255, 255, 255 ],
        whitesmoke: [ 245, 245, 245 ],
        yellow: [ 255, 255, 0 ],
        yellowgreen: [ 154, 205, 50 ]
    });
}

function requireConversions() {
    if (hasRequiredConversions) return conversions;
    hasRequiredConversions = 1;
    const cssKeywords = requireColorName(), reverseKeywords = {};
    for (const key of Object.keys(cssKeywords)) reverseKeywords[cssKeywords[key]] = key;
    const convert = {
        rgb: {
            channels: 3,
            labels: "rgb"
        },
        hsl: {
            channels: 3,
            labels: "hsl"
        },
        hsv: {
            channels: 3,
            labels: "hsv"
        },
        hwb: {
            channels: 3,
            labels: "hwb"
        },
        cmyk: {
            channels: 4,
            labels: "cmyk"
        },
        xyz: {
            channels: 3,
            labels: "xyz"
        },
        lab: {
            channels: 3,
            labels: "lab"
        },
        lch: {
            channels: 3,
            labels: "lch"
        },
        hex: {
            channels: 1,
            labels: [ "hex" ]
        },
        keyword: {
            channels: 1,
            labels: [ "keyword" ]
        },
        ansi16: {
            channels: 1,
            labels: [ "ansi16" ]
        },
        ansi256: {
            channels: 1,
            labels: [ "ansi256" ]
        },
        hcg: {
            channels: 3,
            labels: [ "h", "c", "g" ]
        },
        apple: {
            channels: 3,
            labels: [ "r16", "g16", "b16" ]
        },
        gray: {
            channels: 1,
            labels: [ "gray" ]
        }
    };
    conversions = convert;
    for (const model of Object.keys(convert)) {
        if (!("channels" in convert[model])) throw new Error("missing channels property: " + model);
        if (!("labels" in convert[model])) throw new Error("missing channel labels property: " + model);
        if (convert[model].labels.length !== convert[model].channels) throw new Error("channel and label counts mismatch: " + model);
        const {channels: channels, labels: labels} = convert[model];
        delete convert[model].channels, delete convert[model].labels, Object.defineProperty(convert[model], "channels", {
            value: channels
        }), Object.defineProperty(convert[model], "labels", {
            value: labels
        });
    }
    function comparativeDistance(x, y) {
        return (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2 + (x[2] - y[2]) ** 2;
    }
    return convert.rgb.hsl = function(rgb) {
        const r = rgb[0] / 255, g = rgb[1] / 255, b = rgb[2] / 255, min = Math.min(r, g, b), max = Math.max(r, g, b), delta = max - min;
        let h, s;
        max === min ? h = 0 : r === max ? h = (g - b) / delta : g === max ? h = 2 + (b - r) / delta : b === max && (h = 4 + (r - g) / delta), 
        h = Math.min(60 * h, 360), h < 0 && (h += 360);
        const l = (min + max) / 2;
        return s = max === min ? 0 : l <= .5 ? delta / (max + min) : delta / (2 - max - min), 
        [ h, 100 * s, 100 * l ];
    }, convert.rgb.hsv = function(rgb) {
        let rdif, gdif, bdif, h, s;
        const r = rgb[0] / 255, g = rgb[1] / 255, b = rgb[2] / 255, v = Math.max(r, g, b), diff = v - Math.min(r, g, b), diffc = function(c) {
            return (v - c) / 6 / diff + .5;
        };
        return 0 === diff ? (h = 0, s = 0) : (s = diff / v, rdif = diffc(r), gdif = diffc(g), 
        bdif = diffc(b), r === v ? h = bdif - gdif : g === v ? h = 1 / 3 + rdif - bdif : b === v && (h = 2 / 3 + gdif - rdif), 
        h < 0 ? h += 1 : h > 1 && (h -= 1)), [ 360 * h, 100 * s, 100 * v ];
    }, convert.rgb.hwb = function(rgb) {
        const r = rgb[0], g = rgb[1];
        let b = rgb[2];
        const h = convert.rgb.hsl(rgb)[0], w = 1 / 255 * Math.min(r, Math.min(g, b));
        return b = 1 - 1 / 255 * Math.max(r, Math.max(g, b)), [ h, 100 * w, 100 * b ];
    }, convert.rgb.cmyk = function(rgb) {
        const r = rgb[0] / 255, g = rgb[1] / 255, b = rgb[2] / 255, k = Math.min(1 - r, 1 - g, 1 - b);
        return [ 100 * ((1 - r - k) / (1 - k) || 0), 100 * ((1 - g - k) / (1 - k) || 0), 100 * ((1 - b - k) / (1 - k) || 0), 100 * k ];
    }, convert.rgb.keyword = function(rgb) {
        const reversed = reverseKeywords[rgb];
        if (reversed) return reversed;
        let currentClosestKeyword, currentClosestDistance = 1 / 0;
        for (const keyword of Object.keys(cssKeywords)) {
            const distance = comparativeDistance(rgb, cssKeywords[keyword]);
            distance < currentClosestDistance && (currentClosestDistance = distance, currentClosestKeyword = keyword);
        }
        return currentClosestKeyword;
    }, convert.keyword.rgb = function(keyword) {
        return cssKeywords[keyword];
    }, convert.rgb.xyz = function(rgb) {
        let r = rgb[0] / 255, g = rgb[1] / 255, b = rgb[2] / 255;
        r = r > .04045 ? ((r + .055) / 1.055) ** 2.4 : r / 12.92, g = g > .04045 ? ((g + .055) / 1.055) ** 2.4 : g / 12.92, 
        b = b > .04045 ? ((b + .055) / 1.055) ** 2.4 : b / 12.92;
        return [ 100 * (.4124 * r + .3576 * g + .1805 * b), 100 * (.2126 * r + .7152 * g + .0722 * b), 100 * (.0193 * r + .1192 * g + .9505 * b) ];
    }, convert.rgb.lab = function(rgb) {
        const xyz = convert.rgb.xyz(rgb);
        let x = xyz[0], y = xyz[1], z = xyz[2];
        x /= 95.047, y /= 100, z /= 108.883, x = x > .008856 ? x ** (1 / 3) : 7.787 * x + 16 / 116, 
        y = y > .008856 ? y ** (1 / 3) : 7.787 * y + 16 / 116, z = z > .008856 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
        return [ 116 * y - 16, 500 * (x - y), 200 * (y - z) ];
    }, convert.hsl.rgb = function(hsl) {
        const h = hsl[0] / 360, s = hsl[1] / 100, l = hsl[2] / 100;
        let t2, t3, val;
        if (0 === s) return val = 255 * l, [ val, val, val ];
        t2 = l < .5 ? l * (1 + s) : l + s - l * s;
        const t1 = 2 * l - t2, rgb = [ 0, 0, 0 ];
        for (let i = 0; i < 3; i++) t3 = h + 1 / 3 * -(i - 1), t3 < 0 && t3++, t3 > 1 && t3--, 
        val = 6 * t3 < 1 ? t1 + 6 * (t2 - t1) * t3 : 2 * t3 < 1 ? t2 : 3 * t3 < 2 ? t1 + (t2 - t1) * (2 / 3 - t3) * 6 : t1, 
        rgb[i] = 255 * val;
        return rgb;
    }, convert.hsl.hsv = function(hsl) {
        const h = hsl[0];
        let s = hsl[1] / 100, l = hsl[2] / 100, smin = s;
        const lmin = Math.max(l, .01);
        l *= 2, s *= l <= 1 ? l : 2 - l, smin *= lmin <= 1 ? lmin : 2 - lmin;
        return [ h, 100 * (0 === l ? 2 * smin / (lmin + smin) : 2 * s / (l + s)), 100 * ((l + s) / 2) ];
    }, convert.hsv.rgb = function(hsv) {
        const h = hsv[0] / 60, s = hsv[1] / 100;
        let v = hsv[2] / 100;
        const hi = Math.floor(h) % 6, f = h - Math.floor(h), p = 255 * v * (1 - s), q = 255 * v * (1 - s * f), t = 255 * v * (1 - s * (1 - f));
        switch (v *= 255, hi) {
          case 0:
            return [ v, t, p ];

          case 1:
            return [ q, v, p ];

          case 2:
            return [ p, v, t ];

          case 3:
            return [ p, q, v ];

          case 4:
            return [ t, p, v ];

          case 5:
            return [ v, p, q ];
        }
    }, convert.hsv.hsl = function(hsv) {
        const h = hsv[0], s = hsv[1] / 100, v = hsv[2] / 100, vmin = Math.max(v, .01);
        let sl, l;
        l = (2 - s) * v;
        const lmin = (2 - s) * vmin;
        return sl = s * vmin, sl /= lmin <= 1 ? lmin : 2 - lmin, sl = sl || 0, l /= 2, [ h, 100 * sl, 100 * l ];
    }, convert.hwb.rgb = function(hwb) {
        const h = hwb[0] / 360;
        let wh = hwb[1] / 100, bl = hwb[2] / 100;
        const ratio = wh + bl;
        let f;
        ratio > 1 && (wh /= ratio, bl /= ratio);
        const i = Math.floor(6 * h), v = 1 - bl;
        f = 6 * h - i, 1 & i && (f = 1 - f);
        const n = wh + f * (v - wh);
        let r, g, b;
        switch (i) {
          default:
          case 6:
          case 0:
            r = v, g = n, b = wh;
            break;

          case 1:
            r = n, g = v, b = wh;
            break;

          case 2:
            r = wh, g = v, b = n;
            break;

          case 3:
            r = wh, g = n, b = v;
            break;

          case 4:
            r = n, g = wh, b = v;
            break;

          case 5:
            r = v, g = wh, b = n;
        }
        return [ 255 * r, 255 * g, 255 * b ];
    }, convert.cmyk.rgb = function(cmyk) {
        const c = cmyk[0] / 100, m = cmyk[1] / 100, y = cmyk[2] / 100, k = cmyk[3] / 100;
        return [ 255 * (1 - Math.min(1, c * (1 - k) + k)), 255 * (1 - Math.min(1, m * (1 - k) + k)), 255 * (1 - Math.min(1, y * (1 - k) + k)) ];
    }, convert.xyz.rgb = function(xyz) {
        const x = xyz[0] / 100, y = xyz[1] / 100, z = xyz[2] / 100;
        let r, g, b;
        return r = 3.2406 * x + -1.5372 * y + -.4986 * z, g = -.9689 * x + 1.8758 * y + .0415 * z, 
        b = .0557 * x + -.204 * y + 1.057 * z, r = r > .0031308 ? 1.055 * r ** (1 / 2.4) - .055 : 12.92 * r, 
        g = g > .0031308 ? 1.055 * g ** (1 / 2.4) - .055 : 12.92 * g, b = b > .0031308 ? 1.055 * b ** (1 / 2.4) - .055 : 12.92 * b, 
        r = Math.min(Math.max(0, r), 1), g = Math.min(Math.max(0, g), 1), b = Math.min(Math.max(0, b), 1), 
        [ 255 * r, 255 * g, 255 * b ];
    }, convert.xyz.lab = function(xyz) {
        let x = xyz[0], y = xyz[1], z = xyz[2];
        x /= 95.047, y /= 100, z /= 108.883, x = x > .008856 ? x ** (1 / 3) : 7.787 * x + 16 / 116, 
        y = y > .008856 ? y ** (1 / 3) : 7.787 * y + 16 / 116, z = z > .008856 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
        return [ 116 * y - 16, 500 * (x - y), 200 * (y - z) ];
    }, convert.lab.xyz = function(lab) {
        let x, y, z;
        y = (lab[0] + 16) / 116, x = lab[1] / 500 + y, z = y - lab[2] / 200;
        const y2 = y ** 3, x2 = x ** 3, z2 = z ** 3;
        return y = y2 > .008856 ? y2 : (y - 16 / 116) / 7.787, x = x2 > .008856 ? x2 : (x - 16 / 116) / 7.787, 
        z = z2 > .008856 ? z2 : (z - 16 / 116) / 7.787, x *= 95.047, y *= 100, z *= 108.883, 
        [ x, y, z ];
    }, convert.lab.lch = function(lab) {
        const l = lab[0], a = lab[1], b = lab[2];
        let h;
        h = 360 * Math.atan2(b, a) / 2 / Math.PI, h < 0 && (h += 360);
        return [ l, Math.sqrt(a * a + b * b), h ];
    }, convert.lch.lab = function(lch) {
        const l = lch[0], c = lch[1], hr = lch[2] / 360 * 2 * Math.PI;
        return [ l, c * Math.cos(hr), c * Math.sin(hr) ];
    }, convert.rgb.ansi16 = function(args, saturation = null) {
        const [r, g, b] = args;
        let value = null === saturation ? convert.rgb.hsv(args)[2] : saturation;
        if (value = Math.round(value / 50), 0 === value) return 30;
        let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
        return 2 === value && (ansi += 60), ansi;
    }, convert.hsv.ansi16 = function(args) {
        return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
    }, convert.rgb.ansi256 = function(args) {
        const r = args[0], g = args[1], b = args[2];
        if (r === g && g === b) return r < 8 ? 16 : r > 248 ? 231 : Math.round((r - 8) / 247 * 24) + 232;
        return 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
    }, convert.ansi16.rgb = function(args) {
        let color = args % 10;
        if (0 === color || 7 === color) return args > 50 && (color += 3.5), color = color / 10.5 * 255, 
        [ color, color, color ];
        const mult = .5 * (1 + ~~(args > 50));
        return [ (1 & color) * mult * 255, (color >> 1 & 1) * mult * 255, (color >> 2 & 1) * mult * 255 ];
    }, convert.ansi256.rgb = function(args) {
        if (args >= 232) {
            const c = 10 * (args - 232) + 8;
            return [ c, c, c ];
        }
        let rem;
        args -= 16;
        return [ Math.floor(args / 36) / 5 * 255, Math.floor((rem = args % 36) / 6) / 5 * 255, rem % 6 / 5 * 255 ];
    }, convert.rgb.hex = function(args) {
        const string = (((255 & Math.round(args[0])) << 16) + ((255 & Math.round(args[1])) << 8) + (255 & Math.round(args[2]))).toString(16).toUpperCase();
        return "000000".substring(string.length) + string;
    }, convert.hex.rgb = function(args) {
        const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
        if (!match) return [ 0, 0, 0 ];
        let colorString = match[0];
        3 === match[0].length && (colorString = colorString.split("").map((char => char + char)).join(""));
        const integer = parseInt(colorString, 16);
        return [ integer >> 16 & 255, integer >> 8 & 255, 255 & integer ];
    }, convert.rgb.hcg = function(rgb) {
        const r = rgb[0] / 255, g = rgb[1] / 255, b = rgb[2] / 255, max = Math.max(Math.max(r, g), b), min = Math.min(Math.min(r, g), b), chroma = max - min;
        let grayscale, hue;
        return grayscale = chroma < 1 ? min / (1 - chroma) : 0, hue = chroma <= 0 ? 0 : max === r ? (g - b) / chroma % 6 : max === g ? 2 + (b - r) / chroma : 4 + (r - g) / chroma, 
        hue /= 6, hue %= 1, [ 360 * hue, 100 * chroma, 100 * grayscale ];
    }, convert.hsl.hcg = function(hsl) {
        const s = hsl[1] / 100, l = hsl[2] / 100, c = l < .5 ? 2 * s * l : 2 * s * (1 - l);
        let f = 0;
        return c < 1 && (f = (l - .5 * c) / (1 - c)), [ hsl[0], 100 * c, 100 * f ];
    }, convert.hsv.hcg = function(hsv) {
        const s = hsv[1] / 100, v = hsv[2] / 100, c = s * v;
        let f = 0;
        return c < 1 && (f = (v - c) / (1 - c)), [ hsv[0], 100 * c, 100 * f ];
    }, convert.hcg.rgb = function(hcg) {
        const h = hcg[0] / 360, c = hcg[1] / 100, g = hcg[2] / 100;
        if (0 === c) return [ 255 * g, 255 * g, 255 * g ];
        const pure = [ 0, 0, 0 ], hi = h % 1 * 6, v = hi % 1, w = 1 - v;
        let mg = 0;
        switch (Math.floor(hi)) {
          case 0:
            pure[0] = 1, pure[1] = v, pure[2] = 0;
            break;

          case 1:
            pure[0] = w, pure[1] = 1, pure[2] = 0;
            break;

          case 2:
            pure[0] = 0, pure[1] = 1, pure[2] = v;
            break;

          case 3:
            pure[0] = 0, pure[1] = w, pure[2] = 1;
            break;

          case 4:
            pure[0] = v, pure[1] = 0, pure[2] = 1;
            break;

          default:
            pure[0] = 1, pure[1] = 0, pure[2] = w;
        }
        return mg = (1 - c) * g, [ 255 * (c * pure[0] + mg), 255 * (c * pure[1] + mg), 255 * (c * pure[2] + mg) ];
    }, convert.hcg.hsv = function(hcg) {
        const c = hcg[1] / 100, v = c + hcg[2] / 100 * (1 - c);
        let f = 0;
        return v > 0 && (f = c / v), [ hcg[0], 100 * f, 100 * v ];
    }, convert.hcg.hsl = function(hcg) {
        const c = hcg[1] / 100, l = hcg[2] / 100 * (1 - c) + .5 * c;
        let s = 0;
        return l > 0 && l < .5 ? s = c / (2 * l) : l >= .5 && l < 1 && (s = c / (2 * (1 - l))), 
        [ hcg[0], 100 * s, 100 * l ];
    }, convert.hcg.hwb = function(hcg) {
        const c = hcg[1] / 100, v = c + hcg[2] / 100 * (1 - c);
        return [ hcg[0], 100 * (v - c), 100 * (1 - v) ];
    }, convert.hwb.hcg = function(hwb) {
        const w = hwb[1] / 100, v = 1 - hwb[2] / 100, c = v - w;
        let g = 0;
        return c < 1 && (g = (v - c) / (1 - c)), [ hwb[0], 100 * c, 100 * g ];
    }, convert.apple.rgb = function(apple) {
        return [ apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255 ];
    }, convert.rgb.apple = function(rgb) {
        return [ rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535 ];
    }, convert.gray.rgb = function(args) {
        return [ args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255 ];
    }, convert.gray.hsl = function(args) {
        return [ 0, 0, args[0] ];
    }, convert.gray.hsv = convert.gray.hsl, convert.gray.hwb = function(gray) {
        return [ 0, 100, gray[0] ];
    }, convert.gray.cmyk = function(gray) {
        return [ 0, 0, 0, gray[0] ];
    }, convert.gray.lab = function(gray) {
        return [ gray[0], 0, 0 ];
    }, convert.gray.hex = function(gray) {
        const val = 255 & Math.round(gray[0] / 100 * 255), string = ((val << 16) + (val << 8) + val).toString(16).toUpperCase();
        return "000000".substring(string.length) + string;
    }, convert.rgb.gray = function(rgb) {
        return [ (rgb[0] + rgb[1] + rgb[2]) / 3 / 255 * 100 ];
    }, conversions;
}

function requireRoute() {
    if (hasRequiredRoute) return route;
    hasRequiredRoute = 1;
    const conversions = requireConversions();
    function deriveBFS(fromModel) {
        const graph = function() {
            const graph = {}, models = Object.keys(conversions);
            for (let len = models.length, i = 0; i < len; i++) graph[models[i]] = {
                distance: -1,
                parent: null
            };
            return graph;
        }(), queue = [ fromModel ];
        for (graph[fromModel].distance = 0; queue.length; ) {
            const current = queue.pop(), adjacents = Object.keys(conversions[current]);
            for (let len = adjacents.length, i = 0; i < len; i++) {
                const adjacent = adjacents[i], node = graph[adjacent];
                -1 === node.distance && (node.distance = graph[current].distance + 1, node.parent = current, 
                queue.unshift(adjacent));
            }
        }
        return graph;
    }
    function link(from, to) {
        return function(args) {
            return to(from(args));
        };
    }
    function wrapConversion(toModel, graph) {
        const path = [ graph[toModel].parent, toModel ];
        let fn = conversions[graph[toModel].parent][toModel], cur = graph[toModel].parent;
        for (;graph[cur].parent; ) path.unshift(graph[cur].parent), fn = link(conversions[graph[cur].parent][cur], fn), 
        cur = graph[cur].parent;
        return fn.conversion = path, fn;
    }
    return route = function(fromModel) {
        const graph = deriveBFS(fromModel), conversion = {}, models = Object.keys(graph);
        for (let len = models.length, i = 0; i < len; i++) {
            const toModel = models[i];
            null !== graph[toModel].parent && (conversion[toModel] = wrapConversion(toModel, graph));
        }
        return conversion;
    };
}

function requireColorConvert() {
    if (hasRequiredColorConvert) return colorConvert;
    hasRequiredColorConvert = 1;
    const conversions = requireConversions(), route = requireRoute(), convert = {};
    return Object.keys(conversions).forEach((fromModel => {
        convert[fromModel] = {}, Object.defineProperty(convert[fromModel], "channels", {
            value: conversions[fromModel].channels
        }), Object.defineProperty(convert[fromModel], "labels", {
            value: conversions[fromModel].labels
        });
        const routes = route(fromModel);
        Object.keys(routes).forEach((toModel => {
            const fn = routes[toModel];
            convert[fromModel][toModel] = function(fn) {
                const wrappedFn = function(...args) {
                    const arg0 = args[0];
                    if (null == arg0) return arg0;
                    arg0.length > 1 && (args = arg0);
                    const result = fn(args);
                    if ("object" == typeof result) for (let len = result.length, i = 0; i < len; i++) result[i] = Math.round(result[i]);
                    return result;
                };
                return "conversion" in fn && (wrappedFn.conversion = fn.conversion), wrappedFn;
            }(fn), convert[fromModel][toModel].raw = function(fn) {
                const wrappedFn = function(...args) {
                    const arg0 = args[0];
                    return null == arg0 ? arg0 : (arg0.length > 1 && (args = arg0), fn(args));
                };
                return "conversion" in fn && (wrappedFn.conversion = fn.conversion), wrappedFn;
            }(fn);
        }));
    })), colorConvert = convert;
}

function requireAnsiStyles() {
    return hasRequiredAnsiStyles || (hasRequiredAnsiStyles = 1, function(module) {
        const wrapAnsi16 = (fn, offset) => (...args) => `[${fn(...args) + offset}m`, wrapAnsi256 = (fn, offset) => (...args) => {
            const code = fn(...args);
            return `[${38 + offset};5;${code}m`;
        }, wrapAnsi16m = (fn, offset) => (...args) => {
            const rgb = fn(...args);
            return `[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
        }, ansi2ansi = n => n, rgb2rgb = (r, g, b) => [ r, g, b ], setLazyProperty = (object, property, get) => {
            Object.defineProperty(object, property, {
                get: () => {
                    const value = get();
                    return Object.defineProperty(object, property, {
                        value: value,
                        enumerable: !0,
                        configurable: !0
                    }), value;
                },
                enumerable: !0,
                configurable: !0
            });
        };
        let colorConvert;
        const makeDynamicStyles = (wrap, targetSpace, identity, isBackground) => {
            void 0 === colorConvert && (colorConvert = requireColorConvert());
            const offset = isBackground ? 10 : 0, styles = {};
            for (const [sourceSpace, suite] of Object.entries(colorConvert)) {
                const name = "ansi16" === sourceSpace ? "ansi" : sourceSpace;
                sourceSpace === targetSpace ? styles[name] = wrap(identity, offset) : "object" == typeof suite && (styles[name] = wrap(suite[targetSpace], offset));
            }
            return styles;
        };
        Object.defineProperty(module, "exports", {
            enumerable: !0,
            get: function() {
                const codes = new Map, styles = {
                    modifier: {
                        reset: [ 0, 0 ],
                        bold: [ 1, 22 ],
                        dim: [ 2, 22 ],
                        italic: [ 3, 23 ],
                        underline: [ 4, 24 ],
                        inverse: [ 7, 27 ],
                        hidden: [ 8, 28 ],
                        strikethrough: [ 9, 29 ]
                    },
                    color: {
                        black: [ 30, 39 ],
                        red: [ 31, 39 ],
                        green: [ 32, 39 ],
                        yellow: [ 33, 39 ],
                        blue: [ 34, 39 ],
                        magenta: [ 35, 39 ],
                        cyan: [ 36, 39 ],
                        white: [ 37, 39 ],
                        blackBright: [ 90, 39 ],
                        redBright: [ 91, 39 ],
                        greenBright: [ 92, 39 ],
                        yellowBright: [ 93, 39 ],
                        blueBright: [ 94, 39 ],
                        magentaBright: [ 95, 39 ],
                        cyanBright: [ 96, 39 ],
                        whiteBright: [ 97, 39 ]
                    },
                    bgColor: {
                        bgBlack: [ 40, 49 ],
                        bgRed: [ 41, 49 ],
                        bgGreen: [ 42, 49 ],
                        bgYellow: [ 43, 49 ],
                        bgBlue: [ 44, 49 ],
                        bgMagenta: [ 45, 49 ],
                        bgCyan: [ 46, 49 ],
                        bgWhite: [ 47, 49 ],
                        bgBlackBright: [ 100, 49 ],
                        bgRedBright: [ 101, 49 ],
                        bgGreenBright: [ 102, 49 ],
                        bgYellowBright: [ 103, 49 ],
                        bgBlueBright: [ 104, 49 ],
                        bgMagentaBright: [ 105, 49 ],
                        bgCyanBright: [ 106, 49 ],
                        bgWhiteBright: [ 107, 49 ]
                    }
                };
                styles.color.gray = styles.color.blackBright, styles.bgColor.bgGray = styles.bgColor.bgBlackBright, 
                styles.color.grey = styles.color.blackBright, styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;
                for (const [groupName, group] of Object.entries(styles)) {
                    for (const [styleName, style] of Object.entries(group)) styles[styleName] = {
                        open: `[${style[0]}m`,
                        close: `[${style[1]}m`
                    }, group[styleName] = styles[styleName], codes.set(style[0], style[1]);
                    Object.defineProperty(styles, groupName, {
                        value: group,
                        enumerable: !1
                    });
                }
                return Object.defineProperty(styles, "codes", {
                    value: codes,
                    enumerable: !1
                }), styles.color.close = "[39m", styles.bgColor.close = "[49m", setLazyProperty(styles.color, "ansi", (() => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, !1))), 
                setLazyProperty(styles.color, "ansi256", (() => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, !1))), 
                setLazyProperty(styles.color, "ansi16m", (() => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, !1))), 
                setLazyProperty(styles.bgColor, "ansi", (() => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, !0))), 
                setLazyProperty(styles.bgColor, "ansi256", (() => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, !0))), 
                setLazyProperty(styles.bgColor, "ansi16m", (() => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, !0))), 
                styles;
            }
        });
    }(ansiStyles)), ansiStyles.exports;
}

function requireWrapAnsi() {
    if (hasRequiredWrapAnsi) return wrapAnsi_1;
    hasRequiredWrapAnsi = 1;
    const stringWidth = requireStringWidth(), stripAnsi = requireStripAnsi(), ansiStyles = requireAnsiStyles(), ESCAPES = new Set([ "", "" ]), wrapAnsi = code => `${ESCAPES.values().next().value}[${code}m`, wrapWord = (rows, word, columns) => {
        const characters = [ ...word ];
        let isInsideEscape = !1, visible = stringWidth(stripAnsi(rows[rows.length - 1]));
        for (const [index, character] of characters.entries()) {
            const characterLength = stringWidth(character);
            if (visible + characterLength <= columns ? rows[rows.length - 1] += character : (rows.push(character), 
            visible = 0), ESCAPES.has(character)) isInsideEscape = !0; else if (isInsideEscape && "m" === character) {
                isInsideEscape = !1;
                continue;
            }
            isInsideEscape || (visible += characterLength, visible === columns && index < characters.length - 1 && (rows.push(""), 
            visible = 0));
        }
        !visible && rows[rows.length - 1].length > 0 && rows.length > 1 && (rows[rows.length - 2] += rows.pop());
    }, stringVisibleTrimSpacesRight = str => {
        const words = str.split(" ");
        let last = words.length;
        for (;last > 0 && !(stringWidth(words[last - 1]) > 0); ) last--;
        return last === words.length ? str : words.slice(0, last).join(" ") + words.slice(last).join("");
    }, exec = (string, columns, options = {}) => {
        if (!1 !== options.trim && "" === string.trim()) return "";
        let escapeCode, pre = "", ret = "";
        const lengths = (string => string.split(" ").map((character => stringWidth(character))))(string);
        let rows = [ "" ];
        for (const [index, word] of string.split(" ").entries()) {
            !1 !== options.trim && (rows[rows.length - 1] = rows[rows.length - 1].trimLeft());
            let rowLength = stringWidth(rows[rows.length - 1]);
            if (0 !== index && (rowLength >= columns && (!1 === options.wordWrap || !1 === options.trim) && (rows.push(""), 
            rowLength = 0), (rowLength > 0 || !1 === options.trim) && (rows[rows.length - 1] += " ", 
            rowLength++)), options.hard && lengths[index] > columns) {
                const remainingColumns = columns - rowLength, breaksStartingThisLine = 1 + Math.floor((lengths[index] - remainingColumns - 1) / columns);
                Math.floor((lengths[index] - 1) / columns) < breaksStartingThisLine && rows.push(""), 
                wrapWord(rows, word, columns);
            } else {
                if (rowLength + lengths[index] > columns && rowLength > 0 && lengths[index] > 0) {
                    if (!1 === options.wordWrap && rowLength < columns) {
                        wrapWord(rows, word, columns);
                        continue;
                    }
                    rows.push("");
                }
                rowLength + lengths[index] > columns && !1 === options.wordWrap ? wrapWord(rows, word, columns) : rows[rows.length - 1] += word;
            }
        }
        !1 !== options.trim && (rows = rows.map(stringVisibleTrimSpacesRight)), pre = rows.join("\n");
        for (const [index, character] of [ ...pre ].entries()) {
            if (ret += character, ESCAPES.has(character)) {
                const code = parseFloat(/\d[^m]*/.exec(pre.slice(index, index + 4)));
                escapeCode = 39 === code ? null : code;
            }
            const code = ansiStyles.codes.get(Number(escapeCode));
            escapeCode && code && ("\n" === pre[index + 1] ? ret += wrapAnsi(code) : "\n" === character && (ret += wrapAnsi(escapeCode)));
        }
        return ret;
    };
    return wrapAnsi_1 = (string, columns, options) => String(string).normalize().replace(/\r\n/g, "\n").split("\n").map((line => exec(line, columns, options))).join("\n"), 
    wrapAnsi_1;
}

ansiStyles.exports;

var wrapAnsiExports = requireWrapAnsi(), wrapAnsi = getDefaultExportFromCjs(wrapAnsiExports), lib, hasRequiredLib;

function breakLines(content, width) {
    return content.split("\n").flatMap((line => wrapAnsi(line, width, {
        trim: !1,
        hard: !0
    }).split("\n").map((str => str.trimEnd())))).join("\n");
}

function readlineWidth() {
    return cliWidth({
        defaultWidth: 80,
        output: readline().output
    });
}

function split(content, width) {
    return breakLines(content, width).split("\n");
}

function rotate(count, items) {
    const max = items.length, offset = (count % max + max) % max;
    return [ ...items.slice(offset), ...items.slice(0, offset) ];
}

function lines({items: items, width: width, renderItem: renderItem, active: active, position: requested, pageSize: pageSize}) {
    const layouts = items.map(((item, index) => ({
        item: item,
        index: index,
        isActive: index === active
    }))), layoutsInPage = rotate(active - requested, layouts).slice(0, pageSize), renderItemAt = index => null == layoutsInPage[index] ? [] : split(renderItem(layoutsInPage[index]), width), pageBuffer = Array.from({
        length: pageSize
    }), activeItem = renderItemAt(requested).slice(0, pageSize), position = requested + activeItem.length <= pageSize ? requested : pageSize - activeItem.length;
    pageBuffer.splice(position, activeItem.length, ...activeItem);
    let bufferPointer = position + activeItem.length, layoutPointer = requested + 1;
    for (;bufferPointer < pageSize && layoutPointer < layoutsInPage.length; ) {
        for (const line of renderItemAt(layoutPointer)) if (pageBuffer[bufferPointer++] = line, 
        bufferPointer >= pageSize) break;
        layoutPointer++;
    }
    for (bufferPointer = position - 1, layoutPointer = requested - 1; bufferPointer >= 0 && layoutPointer >= 0; ) {
        for (const line of renderItemAt(layoutPointer).reverse()) if (pageBuffer[bufferPointer--] = line, 
        bufferPointer < 0) break;
        layoutPointer--;
    }
    return pageBuffer.filter((line => "string" == typeof line));
}

function finite({active: active, pageSize: pageSize, total: total}) {
    const middle = Math.floor(pageSize / 2);
    return total <= pageSize || active < middle ? active : active >= total - middle ? active + pageSize - total : middle;
}

function infinite({active: active, lastActive: lastActive, total: total, pageSize: pageSize, pointer: pointer}) {
    return total <= pageSize ? active : lastActive < active && active - lastActive < pageSize ? Math.min(Math.floor(pageSize / 2), pointer + active - lastActive) : pointer;
}

function usePagination({items: items, active: active, renderItem: renderItem, pageSize: pageSize, loop: loop = !0}) {
    const state = useRef({
        position: 0,
        lastActive: 0
    }), position = loop ? infinite({
        active: active,
        lastActive: state.current.lastActive,
        total: items.length,
        pageSize: pageSize,
        pointer: state.current.position
    }) : finite({
        active: active,
        total: items.length,
        pageSize: pageSize
    });
    return state.current.position = position, state.current.lastActive = active, lines({
        items: items,
        width: readlineWidth(),
        renderItem: renderItem,
        active: active,
        position: position,
        pageSize: pageSize
    }).join("\n");
}

function requireLib() {
    if (hasRequiredLib) return lib;
    hasRequiredLib = 1;
    const Stream = Stream$1;
    return lib = class extends Stream {
        #isTTY=null;
        constructor(opts = {}) {
            super(opts), this.writable = this.readable = !0, this.muted = !1, this.on("pipe", this._onpipe), 
            this.replace = opts.replace, this._prompt = opts.prompt || null, this._hadControl = !1;
        }
        #destSrc(key, def) {
            return this._dest ? this._dest[key] : this._src ? this._src[key] : def;
        }
        #proxy(method, ...args) {
            "function" == typeof this._dest?.[method] && this._dest[method](...args), "function" == typeof this._src?.[method] && this._src[method](...args);
        }
        get isTTY() {
            return null !== this.#isTTY ? this.#isTTY : this.#destSrc("isTTY", !1);
        }
        set isTTY(val) {
            this.#isTTY = val;
        }
        get rows() {
            return this.#destSrc("rows");
        }
        get columns() {
            return this.#destSrc("columns");
        }
        mute() {
            this.muted = !0;
        }
        unmute() {
            this.muted = !1;
        }
        _onpipe(src) {
            this._src = src;
        }
        pipe(dest, options) {
            return this._dest = dest, super.pipe(dest, options);
        }
        pause() {
            if (this._src) return this._src.pause();
        }
        resume() {
            if (this._src) return this._src.resume();
        }
        write(c) {
            if (this.muted) {
                if (!this.replace) return !0;
                if (c.match(/^\u001b/)) return 0 === c.indexOf(this._prompt) && (c = (c = c.slice(this._prompt.length)).replace(/./g, this.replace), 
                c = this._prompt + c), this._hadControl = !0, this.emit("data", c);
                this._prompt && this._hadControl && 0 === c.indexOf(this._prompt) && (this._hadControl = !1, 
                this.emit("data", this._prompt), c = c.slice(this._prompt.length)), c = c.toString().replace(/./g, this.replace);
            }
            this.emit("data", c);
        }
        end(c) {
            this.muted && (c = c && this.replace ? c.toString().replace(/./g, this.replace) : null), 
            c && this.emit("data", c), this.emit("end");
        }
        destroy(...args) {
            return this.#proxy("destroy", ...args);
        }
        destroySoon(...args) {
            return this.#proxy("destroySoon", ...args);
        }
        close(...args) {
            return this.#proxy("close", ...args);
        }
    }, lib;
}

var libExports = requireLib(), MuteStream = getDefaultExportFromCjs(libExports), stripAnsiExports = requireStripAnsi(), stripAnsi = getDefaultExportFromCjs(stripAnsiExports), ansiEscapes$1 = {
    exports: {}
}, hasRequiredAnsiEscapes;

function requireAnsiEscapes() {
    return hasRequiredAnsiEscapes || (hasRequiredAnsiEscapes = 1, function(module) {
        const ansiEscapes = module.exports;
        module.exports.default = ansiEscapes;
        const ESC = "[", OSC = "]", BEL = "", SEP = ";", isTerminalApp = "Apple_Terminal" === process.env.TERM_PROGRAM;
        ansiEscapes.cursorTo = (x, y) => {
            if ("number" != typeof x) throw new TypeError("The `x` argument is required");
            return "number" != typeof y ? ESC + (x + 1) + "G" : ESC + (y + 1) + ";" + (x + 1) + "H";
        }, ansiEscapes.cursorMove = (x, y) => {
            if ("number" != typeof x) throw new TypeError("The `x` argument is required");
            let ret = "";
            return x < 0 ? ret += ESC + -x + "D" : x > 0 && (ret += ESC + x + "C"), y < 0 ? ret += ESC + -y + "A" : y > 0 && (ret += ESC + y + "B"), 
            ret;
        }, ansiEscapes.cursorUp = (count = 1) => ESC + count + "A", ansiEscapes.cursorDown = (count = 1) => ESC + count + "B", 
        ansiEscapes.cursorForward = (count = 1) => ESC + count + "C", ansiEscapes.cursorBackward = (count = 1) => ESC + count + "D", 
        ansiEscapes.cursorLeft = "[G", ansiEscapes.cursorSavePosition = isTerminalApp ? "7" : "[s", 
        ansiEscapes.cursorRestorePosition = isTerminalApp ? "8" : "[u", ansiEscapes.cursorGetPosition = "[6n", 
        ansiEscapes.cursorNextLine = "[E", ansiEscapes.cursorPrevLine = "[F", ansiEscapes.cursorHide = "[?25l", 
        ansiEscapes.cursorShow = "[?25h", ansiEscapes.eraseLines = count => {
            let clear = "";
            for (let i = 0; i < count; i++) clear += ansiEscapes.eraseLine + (i < count - 1 ? ansiEscapes.cursorUp() : "");
            return count && (clear += ansiEscapes.cursorLeft), clear;
        }, ansiEscapes.eraseEndLine = "[K", ansiEscapes.eraseStartLine = "[1K", ansiEscapes.eraseLine = "[2K", 
        ansiEscapes.eraseDown = "[J", ansiEscapes.eraseUp = "[1J", ansiEscapes.eraseScreen = "[2J", 
        ansiEscapes.scrollUp = "[S", ansiEscapes.scrollDown = "[T", ansiEscapes.clearScreen = "c", 
        ansiEscapes.clearTerminal = "win32" === process.platform ? `${ansiEscapes.eraseScreen}${ESC}0f` : `${ansiEscapes.eraseScreen}${ESC}3J${ESC}H`, 
        ansiEscapes.beep = BEL, ansiEscapes.link = (text, url) => [ OSC, "8", SEP, SEP, url, BEL, text, OSC, "8", SEP, SEP, BEL ].join(""), 
        ansiEscapes.image = (buffer, options = {}) => {
            let ret = `${OSC}1337;File=inline=1`;
            return options.width && (ret += `;width=${options.width}`), options.height && (ret += `;height=${options.height}`), 
            !1 === options.preserveAspectRatio && (ret += ";preserveAspectRatio=0"), ret + ":" + buffer.toString("base64") + BEL;
        }, ansiEscapes.iTerm = {
            setCwd: (cwd = process.cwd()) => `${OSC}50;CurrentDir=${cwd}${BEL}`,
            annotation: (message, options = {}) => {
                let ret = `${OSC}1337;`;
                const hasX = void 0 !== options.x, hasY = void 0 !== options.y;
                if ((hasX || hasY) && (!hasX || !hasY || void 0 === options.length)) throw new Error("`x`, `y` and `length` must be defined when `x` or `y` is defined");
                return message = message.replace(/\|/g, ""), ret += options.isHidden ? "AddHiddenAnnotation=" : "AddAnnotation=", 
                options.length > 0 ? ret += (hasX ? [ message, options.length, options.x, options.y ] : [ options.length, message ]).join("|") : ret += message, 
                ret + BEL;
            }
        };
    }(ansiEscapes$1)), ansiEscapes$1.exports;
}

var ansiEscapesExports = requireAnsiEscapes(), ansiEscapes = getDefaultExportFromCjs(ansiEscapesExports);

const height = content => content.split("\n").length, lastLine = content => content.split("\n").pop() ?? "";

function cursorDown(n) {
    return n > 0 ? ansiEscapes.cursorDown(n) : "";
}

class ScreenManager {
    rl;
    height=0;
    extraLinesUnderPrompt=0;
    cursorPos;
    constructor(rl) {
        this.rl = rl, this.rl = rl, this.cursorPos = rl.getCursorPos();
    }
    write(content) {
        this.rl.output.unmute(), this.rl.output.write(content), this.rl.output.mute();
    }
    render(content, bottomContent = "") {
        const promptLine = lastLine(content), rawPromptLine = stripAnsi(promptLine);
        let prompt = rawPromptLine;
        this.rl.line.length > 0 && (prompt = prompt.slice(0, -this.rl.line.length)), this.rl.setPrompt(prompt), 
        this.cursorPos = this.rl.getCursorPos();
        const width = readlineWidth();
        content = breakLines(content, width), bottomContent = breakLines(bottomContent, width), 
        rawPromptLine.length % width == 0 && (content += "\n");
        let output = content + (bottomContent ? "\n" + bottomContent : "");
        const bottomContentHeight = Math.floor(rawPromptLine.length / width) - this.cursorPos.rows + (bottomContent ? height(bottomContent) : 0);
        bottomContentHeight > 0 && (output += ansiEscapes.cursorUp(bottomContentHeight)), 
        output += ansiEscapes.cursorTo(this.cursorPos.cols), this.write(cursorDown(this.extraLinesUnderPrompt) + ansiEscapes.eraseLines(this.height) + output), 
        this.extraLinesUnderPrompt = bottomContentHeight, this.height = height(output);
    }
    checkCursorPos() {
        const cursorPos = this.rl.getCursorPos();
        cursorPos.cols !== this.cursorPos.cols && (this.write(ansiEscapes.cursorTo(cursorPos.cols)), 
        this.cursorPos = cursorPos);
    }
    done({clearContent: clearContent}) {
        this.rl.setPrompt("");
        let output = cursorDown(this.extraLinesUnderPrompt);
        output += clearContent ? ansiEscapes.eraseLines(this.height) : "\n", output += ansiEscapes.cursorShow, 
        this.write(output), this.rl.close();
    }
}

class PromisePolyfill extends Promise {
    static withResolver() {
        let resolve, reject;
        return {
            promise: new Promise(((res, rej) => {
                resolve = res, reject = rej;
            })),
            resolve: resolve,
            reject: reject
        };
    }
}

function createPrompt(view) {
    return (config, context = {}) => {
        const {input: input = process.stdin, signal: signal} = context, cleanups = new Set, output = new MuteStream;
        output.pipe(context.output ?? process.stdout);
        const rl = readline$1.createInterface({
            terminal: !0,
            input: input,
            output: output
        }), screen = new ScreenManager(rl), {promise: promise, resolve: resolve, reject: reject} = PromisePolyfill.withResolver(), cancel = () => reject(new CancelPromptError);
        if (signal) {
            const abort = () => reject(new AbortPromptError({
                cause: signal.reason
            }));
            if (signal.aborted) return abort(), Object.assign(promise, {
                cancel: cancel
            });
            signal.addEventListener("abort", abort), cleanups.add((() => signal.removeEventListener("abort", abort)));
        }
        cleanups.add(onExit(((code, signal) => {
            reject(new ExitPromptError(`User force closed the prompt with ${code} ${signal}`));
        })));
        const checkCursorPos = () => screen.checkCursorPos();
        return rl.input.on("keypress", checkCursorPos), cleanups.add((() => rl.input.removeListener("keypress", checkCursorPos))), 
        withHooks(rl, (cycle => {
            const hooksCleanup = AsyncResource.bind((() => effectScheduler.clearAll()));
            return rl.on("close", hooksCleanup), cleanups.add((() => rl.removeListener("close", hooksCleanup))), 
            cycle((() => {
                try {
                    const nextView = view(config, (value => {
                        setImmediate((() => resolve(value)));
                    })), [content, bottomContent] = "string" == typeof nextView ? [ nextView ] : nextView;
                    screen.render(content, bottomContent), effectScheduler.run();
                } catch (error) {
                    reject(error);
                }
            })), Object.assign(promise.then((answer => (effectScheduler.clearAll(), answer)), (error => {
                throw effectScheduler.clearAll(), error;
            })).finally((() => {
                cleanups.forEach((cleanup => cleanup())), screen.done({
                    clearContent: Boolean(context?.clearPromptOnDone)
                }), output.end();
            })).then((() => promise)), {
                cancel: cancel
            });
        }));
    };
}

class Separator {
    separator=colors.dim(Array.from({
        length: 15
    }).join(figures.line));
    type="separator";
    constructor(separator) {
        separator && (this.separator = separator);
    }
    static isSeparator(choice) {
        return Boolean(choice && "object" == typeof choice && "type" in choice && "separator" === choice.type);
    }
}

const selectTheme = {
    icon: {
        cursor: figures.pointer
    },
    style: {
        disabled: text => colors.dim(`- ${text}`),
        description: text => colors.cyan(text)
    },
    helpMode: "auto"
};

function isSelectable(item) {
    return !Separator.isSeparator(item) && !item.disabled;
}

function normalizeChoices(choices) {
    return choices.map((choice => {
        if (Separator.isSeparator(choice)) return choice;
        if ("string" == typeof choice) return {
            value: choice,
            name: choice,
            short: choice,
            disabled: !1
        };
        const name = choice.name ?? String(choice.value);
        return {
            value: choice.value,
            name: name,
            description: choice.description,
            short: choice.short ?? name,
            disabled: choice.disabled ?? !1
        };
    }));
}

var select = createPrompt(((config, done) => {
    const {loop: loop = !0, pageSize: pageSize = 7} = config, firstRender = useRef(!0), theme = makeTheme(selectTheme, config.theme), [status, setStatus] = useState("idle"), prefix = usePrefix({
        status: status,
        theme: theme
    }), searchTimeoutRef = useRef(), items = useMemo((() => normalizeChoices(config.choices)), [ config.choices ]), bounds = useMemo((() => {
        const first = items.findIndex(isSelectable), last = items.findLastIndex(isSelectable);
        if (-1 === first) throw new ValidationError("[select prompt] No selectable choices. All choices are disabled.");
        return {
            first: first,
            last: last
        };
    }), [ items ]), defaultItemIndex = useMemo((() => "default" in config ? items.findIndex((item => isSelectable(item) && item.value === config.default)) : -1), [ config.default, items ]), [active, setActive] = useState(-1 === defaultItemIndex ? bounds.first : defaultItemIndex), selectedChoice = items[active];
    useKeypress(((key, rl) => {
        if (clearTimeout(searchTimeoutRef.current), isEnterKey(key)) setStatus("done"), 
        done(selectedChoice.value); else if (isUpKey(key) || isDownKey(key)) {
            if (rl.clearLine(0), loop || isUpKey(key) && active !== bounds.first || isDownKey(key) && active !== bounds.last) {
                const offset = isUpKey(key) ? -1 : 1;
                let next = active;
                do {
                    next = (next + offset + items.length) % items.length;
                } while (!isSelectable(items[next]));
                setActive(next);
            }
        } else if (isNumberKey(key)) {
            rl.clearLine(0);
            const position = Number(key.name) - 1, item = items[position];
            null != item && isSelectable(item) && setActive(position);
        } else if (isBackspaceKey(key)) rl.clearLine(0); else {
            const searchTerm = rl.line.toLowerCase(), matchIndex = items.findIndex((item => !(Separator.isSeparator(item) || !isSelectable(item)) && item.name.toLowerCase().startsWith(searchTerm)));
            -1 !== matchIndex && setActive(matchIndex), searchTimeoutRef.current = setTimeout((() => {
                rl.clearLine(0);
            }), 700);
        }
    })), useEffect((() => () => {
        clearTimeout(searchTimeoutRef.current);
    }), []);
    const message = theme.style.message(config.message, status);
    let helpTipTop = "", helpTipBottom = "";
    ("always" === theme.helpMode || "auto" === theme.helpMode && firstRender.current) && (firstRender.current = !1, 
    items.length > pageSize ? helpTipBottom = `\n${theme.style.help("(Use arrow keys to reveal more choices)")}` : helpTipTop = theme.style.help("(Use arrow keys)"));
    const page = usePagination({
        items: items,
        active: active,
        renderItem({item: item, isActive: isActive}) {
            if (Separator.isSeparator(item)) return ` ${item.separator}`;
            if (item.disabled) {
                const disabledLabel = "string" == typeof item.disabled ? item.disabled : "(disabled)";
                return theme.style.disabled(`${item.name} ${disabledLabel}`);
            }
            return (isActive ? theme.style.highlight : x => x)(`${isActive ? theme.icon.cursor : " "} ${item.name}`);
        },
        pageSize: pageSize,
        loop: loop
    });
    if ("done" === status) return `${prefix} ${message} ${theme.style.answer(selectedChoice.short)}`;
    const choiceDescription = selectedChoice.description ? `\n${theme.style.description(selectedChoice.description)}` : "";
    return `${[ prefix, message, helpTipTop ].filter(Boolean).join(" ")}\n${page}${helpTipBottom}${choiceDescription}${ansiEscapes.cursorHide}`;
}));

async function promptToInitGitRepo(defaultGitDir, exitOnFailToCreate = !0) {
    return select({
        message: "Would you like to initialize a git repo?",
        default: "y",
        choices: [ {
            name: "(y) Yes",
            short: "y",
            value: !0,
            description: `Default repo directory: ${defaultGitDir}`
        }, {
            name: "(n) No",
            short: "n",
            value: !1,
            description: "Skip it"
        } ]
    }).then((answer => (1 == answer && (initGitRepo(defaultGitDir), !isGitRepo(defaultGitDir) && exitOnFailToCreate && warningOutro(`Unable to initialize a new git repo at: ${defaultGitDir}`)), 
    !0))).catch((err => !1));
}

function cloneCommand() {
    return new Command("clone").configureOutput(cliOutputConfig).description("clone all the accounts and programs listed in the Solana.toml file").addOption(new Option("--force", "force clone all fixtures, even if they exist")).addOption(new Option("--no-prompt", "skip the prompts to override any existing fixtures")).addOption(COMMON_OPTIONS.accountDir).addOption(COMMON_OPTIONS.config).addOption(new Option(COMMON_OPTIONS.url.flags, COMMON_OPTIONS.url.description).default("mainnet")).action((async options => {
        titleMessage("Clone fixtures (accounts and programs)"), await checkCommand("solana account --help", {
            exit: !0,
            message: "Unable to detect the 'solana account' command. Do you have it installed?"
        });
        let targetGitDir = process.cwd();
        isGitRepo(targetGitDir) || (warnMessage("Cloning fixtures without tracking changes via git is not recommended"), 
        await promptToInitGitRepo(targetGitDir));
        let config = loadConfigToml(options.config, options, !0);
        const anchorToml = loadAnchorToml(config.configPath);
        anchorToml && (config = deconflictAnchorTomlWithConfig(anchorToml, config)), updateGitignore([ DEFAULT_CACHE_DIR, DEFAULT_TEST_LEDGER_DIR ]), 
        rmSync(DEFAULT_ACCOUNTS_DIR_TEMP, {
            recursive: !0,
            force: !0
        });
        const currentAccounts = loadFileNamesToMap(config.settings.accountDir), accounts = await cloneAccountsFromConfig(config, options, currentAccounts);
        await cloneTokensFromConfig(config, options, currentAccounts);
        let detectedPrograms = {};
        accounts && (detectedPrograms = mergeOwnersMapWithConfig(accounts.owners), await cloneProgramsFromConfig({
            settings: config.settings,
            clone: {
                program: detectedPrograms
            }
        }, {
            ...options,
            autoClone: !0
        }, currentAccounts)), await cloneProgramsFromConfig(config, options, currentAccounts), 
        createFolders(DEFAULT_ACCOUNTS_DIR_TEMP), moveFiles(DEFAULT_ACCOUNTS_DIR_TEMP, config.settings.accountDir, !0), 
        rmSync(DEFAULT_ACCOUNTS_DIR_TEMP, {
            recursive: !0,
            force: !0
        });
        const cloneCounts = validateExpectedCloneCounts(config.settings.accountDir, config.clone);
        cloneCounts.actual === cloneCounts.expected ? console.log(`Completed cloning ${cloneCounts.actual} ${1 == cloneCounts.actual ? "account" : "accounts"}`) : warnMessage(`Completed cloning fixtures. Expected ${cloneCounts.expected} fixtures, but only ${cloneCounts.actual} found`);
    }));
}

function buildTestValidatorCommand({reset: reset = !1, verbose: verbose = !1, accountDir: accountDir = DEFAULT_ACCOUNTS_DIR, ledgerDir: ledgerDir = DEFAULT_TEST_LEDGER_DIR, authority: authority, localPrograms: localPrograms} = {}) {
    const command = [ "solana-test-validator" ], stagingDir = resolve(DEFAULT_ACCOUNTS_DIR_LOADED);
    if (reset && (rmSync(stagingDir, {
        recursive: !0,
        force: !0
    }), command.push("--reset")), ledgerDir && (createFolders(ledgerDir), command.push(`--ledger ${ledgerDir}`)), 
    accountDir) if (directoryExists(accountDir = resolve(accountDir))) {
        createFolders(stagingDir, !1), moveFiles(accountDir, stagingDir, !0), command.push(`--account-dir ${stagingDir}`);
        loadFileNamesToMap(accountDir, ".so").forEach(((_value, address) => {
            authority ? command.push(`--upgradeable-program ${address}`, resolve(accountDir, `${address}.so`), authority) : command.push(`--bpf-program ${address}`, resolve(accountDir, `${address}.so`));
        }));
    } else verbose && (warnMessage(`Accounts directory does not exist: ${accountDir}`), 
    warnMessage("Skipping cloning of fixtures"));
    if (localPrograms) for (const key in localPrograms) Object.prototype.hasOwnProperty.call(localPrograms, key) && command.push(`--upgradeable-program ${localPrograms[key].address}`, localPrograms[key].filePath, authority);
    return command.join(" ");
}

function runTestValidator({command: command, args: args}) {
    console.log("");
    const child = spawn$1(command, args, {
        detached: !1,
        stdio: "inherit",
        shell: !0
    });
    child.on("error", (err => {
        console.error(`Failed to start the command: ${err.message}`);
    })), child.on("exit", (code => {
        0 === code ? console.log("Command executed successfully.") : console.error(`Command exited with code ${code}`);
    }));
}

async function promptToAutoClone() {
    return console.log(), select({
        message: "Would you like to perform the 'clone' command now?",
        default: "y",
        choices: [ {
            name: "(y) Yes",
            short: "y",
            value: !0,
            description: "Yes, clone all the accounts and programs in Solana.toml"
        }, {
            name: "(n) No",
            short: "n",
            value: !1,
            description: "Do not run the 'clone' command now"
        } ]
    }).then((async answer => {
        if (!0 !== answer) return !1;
        await cloneCommand().parseAsync([]);
    })).catch((() => {
        console.log("Operation canceled."), process.exit();
    }));
}

function listLocalPrograms({labels: labels = {}, buildDir: buildDir = DEFAULT_BUILD_DIR, basePath: basePath, configPath: configPath, cluster: cluster = "localnet"} = {}) {
    let allFound = !1, locatedPrograms = {}, buildDirListing = new Map;
    if (!directoryExists(buildDir = resolve(join(basePath || (configPath ? dirname(configPath) : process.cwd()), buildDir)))) return warnMessage(`Unable to locate build output directory: ${buildDir}`), 
    {
        locatedPrograms: locatedPrograms,
        buildDirListing: buildDirListing,
        allFound: allFound
    };
    if (buildDirListing = loadFileNamesToMap(buildDir, ".so"), !Object.prototype.hasOwnProperty.call(labels, cluster)) return {
        locatedPrograms: locatedPrograms,
        buildDirListing: buildDirListing,
        allFound: allFound
    };
    let missingCounter = 0;
    return buildDirListing.forEach(((binaryName, programName) => {
        Object.prototype.hasOwnProperty.call(labels[cluster], programName) && !Object.hasOwn(locatedPrograms, programName) ? locatedPrograms[programName] = {
            address: labels[cluster][programName],
            filePath: join(buildDir, binaryName)
        } : (missingCounter++, Object.prototype.hasOwnProperty.call(labels[cluster], programName) ? warnMessage(`Unable to locate compiled program '${programName}' from config`) : warnMessage(`Compiled program '${programName}' was found with no config info`));
    })), 0 == missingCounter && (allFound = !0), {
        locatedPrograms: locatedPrograms,
        buildDirListing: buildDirListing,
        allFound: allFound
    };
}

function testValidatorCommand() {
    return new Command("test-validator").configureOutput(cliOutputConfig).description("run the Solana test-validator on your local machine").addOption(new Option("--reset", "reset the test-validator to genesis, reloading all preloaded fixtures")).addOption(new Option("--output", "output the generated test-validator command while executing it")).addOption(COMMON_OPTIONS.outputOnly).addOption(COMMON_OPTIONS.accountDir).addOption(COMMON_OPTIONS.config).addOption(COMMON_OPTIONS.keypair).addOption(COMMON_OPTIONS.url).action((async options => {
        options.outputOnly ? options.output = options.outputOnly : titleMessage("solana-test-validator"), 
        await checkCommand("solana-test-validator --version", {
            exit: !0,
            message: "Unable to detect the 'solana-test-validator'. Do you have it installed?"
        });
        let config = loadConfigToml(options.config, options);
        updateGitignore([ DEFAULT_CACHE_DIR, DEFAULT_TEST_LEDGER_DIR ]);
        let authorityAddress = null;
        config.settings.keypair && (doesFileExist(config.settings.keypair) ? authorityAddress = loadKeypairFromFile(config.settings.keypair)?.publicKey.toBase58() : (warnMessage(`Unable to locate keypair file: ${config.settings.keypair}`), 
        warnMessage("Skipping auto creation and setting authorities")));
        let locatedPrograms = {};
        const anchorToml = loadAnchorToml(config.configPath);
        anchorToml && (config = deconflictAnchorTomlWithConfig(anchorToml, config), config.programs = deepMerge$1(config.programs, anchorToml.programs)), 
        Object.assign(locatedPrograms, listLocalPrograms({
            configPath: config.configPath,
            labels: config.programs,
            cluster: "localnet"
        }).locatedPrograms), options.reset && await cloneCommand().parseAsync([]);
        const cloneCounts = validateExpectedCloneCounts(config.settings.accountDir, config.clone);
        cloneCounts.actual !== cloneCounts.expected && (warnMessage(`Expected ${cloneCounts.expected} fixtures, but only ${cloneCounts.actual} found.`), 
        options.outputOnly || await promptToAutoClone());
        const command = buildTestValidatorCommand({
            verbose: !options.output,
            reset: options.reset || !1,
            accountDir: config.settings.accountDir,
            authority: authorityAddress,
            localPrograms: locatedPrograms
        });
        options.output && console.log(`\n${command}\n`), options.outputOnly && process.exit(), 
        options.reset && (console.log("Loaded", loadFileNamesToMap(config.settings.accountDir, ".json").size, "accounts into the local validator"), 
        console.log("Loaded", loadFileNamesToMap(config.settings.accountDir, ".so").size, "programs into the local validator"));
        const explorerUrl = new URL("https://explorer.solana.com/?cluster=custom");
        explorerUrl.searchParams.set("customUrl", "http://localhost:8899"), console.log("\nSolana Explorer for your local test-validator:"), 
        console.log("(on Brave Browser, you may need to turn Shields down for the Explorer website)"), 
        console.log(explorerUrl.toString()), runTestValidator({
            command: command
        });
    }));
}

const DEFAULT_CARGO_TOML_FILE = "Cargo.toml";

function loadCargoToml(manifestPath = DEFAULT_CARGO_TOML_FILE, settings = {}, isManifestRequired = !1) {
    return directoryExists(manifestPath) && (manifestPath = join(manifestPath, DEFAULT_CARGO_TOML_FILE)), 
    !!doesFileExist(manifestPath, !0) && loadTomlFile(manifestPath);
}

function findAllCargoToml(startDir, whitelist = [], blacklist = [ "node_modules", "dist", "target" ], maxDepth = 3) {
    const cargoTomlPaths = [], whitelistPatterns = whitelist.map((pattern => new RegExp("^" + pattern.replace(/\*/g, ".*") + "$")));
    function isWhitelisted(relativeDir) {
        return 0 === whitelistPatterns.length || whitelistPatterns.some((regex => regex.test(relativeDir)));
    }
    return function searchDir(dir, depth) {
        if (depth > maxDepth) return;
        const items = readdirSync(dir);
        for (const item of items) {
            const itemPath = join(dir, item), stats = statSync(itemPath);
            if (stats.isFile() && "Cargo.toml" === item && cargoTomlPaths.push(itemPath), stats.isDirectory()) {
                const relativeDir = relative(startDir, itemPath);
                if (blacklist.includes(relativeDir) && !isWhitelisted(relativeDir)) continue;
                searchDir(itemPath, depth + 1);
            }
        }
    }(startDir, 0), cargoTomlPaths;
}

function getProgramPathsInWorkspace(startDir, workspaceDirs) {
    const programPaths = new Map;
    let tempToml = !1;
    doesFileExist(startDir) && (startDir = dirname(startDir));
    return findAllCargoToml(startDir, workspaceDirs).map((progPath => {
        if (!doesFileExist(progPath)) return;
        if (tempToml = loadCargoToml(progPath), !tempToml || tempToml.workspace) return;
        const name = tempToml?.lib?.name || tempToml?.package?.name;
        name && programPaths.set(name, tempToml.configPath);
    })), programPaths;
}

function autoLocateProgramsInWorkspace(manifestPath = join(process.cwd(), "Cargo.toml"), workspaceDirs = [ "temp", "programs/*", "program" ]) {
    let cargoToml = loadCargoToml(manifestPath);
    cargoToml || workspaceDirs.some((workspace => {
        const filePath = join(process.cwd(), workspace.replace(/\*+$/, ""), "Cargo.toml");
        !doesFileExist(filePath) || (cargoToml = loadCargoToml(filePath));
    }));
    let programs = new Map;
    return cargoToml && (cargoToml.configPath && (manifestPath = cargoToml.configPath), 
    cargoToml.workspace?.members && (workspaceDirs = cargoToml.workspace.members), programs = getProgramPathsInWorkspace(manifestPath, workspaceDirs)), 
    {
        programs: programs,
        cargoToml: cargoToml
    };
}

function buildProgramCommand({verbose: verbose = !1, manifestPath: manifestPath, workspace: workspace = !1, toolsVersion: toolsVersion}) {
    const command = [ "cargo build-sbf" ];
    return manifestPath && command.push(`--manifest-path ${manifestPath}`), workspace && command.push("--workspace"), 
    toolsVersion && (toolsVersion.startsWith("v") || (toolsVersion = `v${toolsVersion}`), 
    command.push(`--tools-version ${toolsVersion}`)), command.join(" ");
}

function buildCommand() {
    return new Command("build").configureOutput(cliOutputConfig).description("build your Solana programs").usage("[options] [-- <CARGO_ARGS>...]").addOption(new Option("-- <CARGO_ARGS>", "arguments to pass to the underlying 'cargo build-sbf' command")).addOption(new Option("-p --program-name <PROGRAM_NAME>", "name of the program to build")).addOption(COMMON_OPTIONS.manifestPath).addOption(COMMON_OPTIONS.config).addOption(COMMON_OPTIONS.outputOnly).action((async (options, {args: passThroughArgs}) => {
        options.outputOnly || titleMessage("Build your Solana programs"), await checkCommand("cargo build-sbf --help", {
            exit: !0,
            message: "Unable to detect the 'cargo build-sbf' command. Do you have it installed?"
        });
        let {programs: programs, cargoToml: cargoToml} = autoLocateProgramsInWorkspace(options.manifestPath);
        if (options.programName && (programs.has(options.programName) && doesFileExist(programs.get(options.programName)) ? cargoToml = loadCargoToml(programs.get(options.programName)) : (warnMessage(`Unable to locate program '${options.programName}' in this workspace`), 
        console.log("The following programs were located:"), programs.forEach(((_programPath, programName) => console.log(" -", programName))), 
        process.exit())), !cargoToml) return warningOutro("Unable to locate Cargo.toml file. Operation canceled.");
        let buildCommand = null, toolsVersion = null;
        const solanaVersion = await installedToolVersion("solana"), {platformTools: platformTools} = await getPlatformToolsVersions();
        if (checkVersion(solanaVersion, "2.0") && !checkVersion(platformTools, "1.43") && (warnMessage("cargo build-sbf versions >=2.X requires building with platform tools version >=1.43"), 
        toolsVersion = "1.43", warnMessage(`Auto setting platform tools to ${toolsVersion} for this build`)), 
        cargoToml.workspace) console.log("Building all programs in the workspace"), buildCommand = buildProgramCommand({
            manifestPath: cargoToml.configPath,
            workspace: !0,
            toolsVersion: toolsVersion
        }); else {
            if (!cargoToml.package || !cargoToml.lib["crate-type"].includes("lib")) return warningOutro("Unable to locate any program's Cargo.toml file");
            console.log(`Building program '${cargoToml.lib.name || cargoToml.package.name || "[unknown]"}' only`), 
            buildCommand = buildProgramCommand({
                manifestPath: cargoToml.configPath,
                toolsVersion: toolsVersion
            });
        }
        if (!buildCommand) return warningOutro("Unable to create build command");
        shellExecInSession({
            command: buildCommand,
            args: passThroughArgs,
            outputOnly: options.outputOnly
        });
    }));
}

async function promptToInstall(toolName) {
    return select({
        message: `Would you like to install '${toolName}' now?`,
        default: "y",
        choices: [ {
            name: "(y) Yes",
            short: "y",
            value: !0
        }, {
            name: "(n) No",
            short: "n",
            value: !1
        } ]
    }).then((async answer => !0 === answer)).catch((() => {
        console.log("Operation canceled."), process.exit();
    }));
}

const command = "zest coverage";

function coverageCommand() {
    return new Command("coverage").configureOutput(cliOutputConfig).description("run code coverage on a Solana program").usage("[options] [-- <ZEST_ARGS>...]").addOption(new Option("-- <ZEST_ARGS>", `arguments to pass to the underlying ${command} command`)).addOption(COMMON_OPTIONS.outputOnly).action((async (options, {args: passThroughArgs}) => {
        options.outputOnly || titleMessage("Zest code coverage"), await checkCommand("zest --help", {
            exit: !0,
            onError: async () => {
                warnMessage("Unable to detect the 'zest' command.");
                await promptToInstall("zest") && await installZest();
            },
            doubleCheck: !0
        }), shellExecInSession({
            command: command,
            args: passThroughArgs,
            outputOnly: options.outputOnly
        });
    }));
}

function buildDeployProgramCommand({programPath: programPath, programId: programId, verbose: verbose = !1, manifestPath: manifestPath, workspace: workspace = !1, url: url, keypair: keypair, upgradeAuthority: upgradeAuthority}) {
    const command = [ "solana program deploy" ];
    return url && command.push(`--url ${parseRpcUrlOrMoniker(url, !0)}`), keypair && command.push(`--keypair ${keypair}`), 
    upgradeAuthority && command.push(`--upgrade-authority ${upgradeAuthority}`), programId && command.push(`--program-id ${programId}`), 
    command.push(programPath), command.join(" ");
}

async function getDeployedProgramInfo(programId, cluster) {
    const command = [ "solana program show", "--output json", `--url ${parseRpcUrlOrMoniker(cluster, !0)}`, programId ];
    let {stderr: stderr, stdout: stdout} = await src_default(command.join(" "));
    if (stderr) return stderr.trim().split("\n"), !1;
    if (!stdout.trim()) return !1;
    const programInfo = parseJson(stdout);
    return "none" == programInfo.authority && (programInfo.authority = !1), programInfo;
}

async function promptToSelectCluster(message = "Select a cluster?", defaultValue = "mainnet") {
    return console.log(), select({
        message: message,
        theme: {},
        default: defaultValue,
        choices: [ {
            short: "m",
            name: "m) mainnet",
            value: "mainnet"
        }, {
            short: "d",
            name: "d) devnet",
            value: "devnet"
        }, {
            short: "t",
            name: "t) testnet",
            value: "testnet"
        }, {
            short: "l",
            name: "l) localnet",
            value: "localnet"
        } ]
    }).then((async answer => (answer.startsWith("m") && (answer = "mainnet"), answer))).catch((() => (console.log("Operation canceled."), 
    process.exit(), defaultValue)));
}

function deployCommand() {
    return new Command("deploy").configureOutput(cliOutputConfig).description("deploy a Solana program").usage("[options] [-- <DEPLOY_ARGS>...]").addOption(new Option("-- <DEPLOY_ARGS>", "arguments to pass to the underlying 'solana program' command")).addOption(new Option("-p --program-name <PROGRAM_NAME>", "name of the program to deploy")).addOption(COMMON_OPTIONS.url).addOption(COMMON_OPTIONS.manifestPath).addOption(COMMON_OPTIONS.keypair).addOption(COMMON_OPTIONS.config).addOption(COMMON_OPTIONS.outputOnly).action((async (options, {args: passThroughArgs}) => {
        options.outputOnly || titleMessage("Deploy a Solana program"), await checkCommand("solana program --help", {
            exit: !0,
            message: "Unable to detect the 'solana program' command"
        });
        const {programs: programs, cargoToml: cargoToml} = autoLocateProgramsInWorkspace(options.manifestPath);
        if (options.programName || 1 != programs.size || (options.programName = programs.entries().next().value[0]), 
        !cargoToml) return warnMessage("Unable to locate Cargo.toml");
        if (programs.has(options.programName) && options.programName || (options.programName ? programs.has(options.programName) || warnMessage(`Unable to locate program '${options.programName}' in this workspace`) : warnMessage("You must select a program to deploy. See --help."), 
        console.log("The following programs were located:"), programs.forEach(((_programPath, programName) => console.log(" -", programName))), 
        process.exit()), !options.url) {
            const cluster = await promptToSelectCluster("Select the cluster to deploy your program on?", getSafeClusterMoniker(cliConfig?.json_rpc_url) || void 0);
            options.url = parseRpcUrlOrMoniker(cluster);
        }
        if (!options.url) return warnMessage("You must select cluster to deploy to. See --help");
        let selectedCluster = getSafeClusterMoniker(options.url);
        if (!selectedCluster) {
            if (selectedCluster = getSafeClusterMoniker(await promptToSelectCluster("Unable to auto detect the cluster to deploy too. Select a cluster?")), 
            !selectedCluster) return warnMessage("Unable to detect cluster to deploy to. Operation canceled.");
        }
        let config = loadConfigToml(options.config, options, !1);
        const buildDir = path.join(path.dirname(cargoToml.configPath), "target", "deploy");
        if (!directoryExists(buildDir)) return warnMessage(`Unable to locate your build dir: ${buildDir}`), 
        warnMessage("Have you built your programs?");
        const binaryPath = path.join(buildDir, `${options.programName}.so`);
        if (!doesFileExist(binaryPath)) return warnMessage(`Unable to locate program binary:\n${binaryPath}`), 
        warnMessage("Have you built your programs?");
        let programId = null, programIdPath = path.join(buildDir, `${options.programName}-keypair.json`);
        const programKeypair = loadKeypairFromFile(programIdPath);
        if (config?.programs ? (getSafeClusterMoniker(selectedCluster, config.programs) || (warnMessage(`Unable to locate '${selectedCluster}' programs in your Solana.toml`), 
        console.log("The following programs are declared:"), Object.keys(config.programs).forEach((cl => {
            console.log(` - ${cl}:`), Object.keys(config.programs[cl]).forEach((name => {
                console.log(`    - ${name}`);
            }));
        })), process.exit()), config?.programs?.[selectedCluster] && Object.hasOwn(config.programs[selectedCluster], options.programName) || (warnMessage(`Program '${options.programName}' not found in 'programs.${selectedCluster}'`), 
        process.exit()), programId = config.programs[selectedCluster][options.programName]) : programKeypair ? (programId = programKeypair.publicKey.toBase58(), 
        warnMessage("Auto detected default program keypair file:"), console.log(` - keypair path: ${programIdPath}`), 
        console.log(` - program id: ${programId}`)) : (warnMessage("Unable to locate any program id or program keypair."), 
        process.exit()), !programId) return warnMessage(`Unable to locate program id for '${options.programName}'. Do you have it declared?`);
        let programInfo = await getDeployedProgramInfo(programId, options.url);
        if (!programInfo) {
            if (!programKeypair) return warnMessage(`Unable to locate program keypair: ${programIdPath}`);
            const programIdFromKeypair = programKeypair.publicKey.toBase58();
            programIdFromKeypair !== programId && (warnMessage("The loaded program keypair does NOT match the configured program id"), 
            console.log(` - program keypair: ${programIdFromKeypair}`), console.log(` - declared program id: ${programId}`), 
            warnMessage("Unable to perform initial program deployment. Operation cancelled."), 
            process.exit()), programId = programIdFromKeypair, programInfo = await getDeployedProgramInfo(programId, options.url);
        }
        const authorityKeypair = loadKeypairFromFile(config.settings.keypair);
        if (programInfo) {
            if (!programInfo.authority) return cancelMessage(`Program ${programInfo.programId} is no longer upgradeable`);
            if (programInfo.authority !== authorityKeypair.publicKey.toBase58()) return cancelMessage(`Your keypair (${authorityKeypair.publicKey.toBase58()}) is not the upgrade authority for program ${programId}`);
            programId = programInfo.programId;
        }
        const command = buildDeployProgramCommand({
            programPath: binaryPath,
            programId: programIdPath || programId,
            url: options.url,
            keypair: options.keypair
        });
        console.log(""), shellExecInSession({
            command: command,
            args: passThroughArgs,
            outputOnly: options.outputOnly
        });
    }));
}

async function main() {
    try {
        const program = cliProgramRoot();
        program.addCommand(installCommand()).addCommand(doctorCommand()).addCommand(cloneCommand()).addCommand(deployCommand()).addCommand(buildCommand()).addCommand(coverageCommand()).addCommand(testValidatorCommand()), 
        2 === process.argv.length && process.argv.push("--help"), await program.parseAsync();
    } catch (err) {
        errorMessage(err.toString());
    }
}

assertRuntimeVersion(), main();
